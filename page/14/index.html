<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/14/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">444</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/10/30/password-tech-note/" class="post-title-link" itemprop="url">《图解密码技术》总结整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-10-30 00:07:43 / 修改时间：01:05:35" itemprop="dateCreated datePublished" datetime="2018-10-30T00:07:43+08:00">2018-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/30/password-tech-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/30/password-tech-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26265544/">《图解密码技术》</a>一书</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>信源、信宿、信道</li>
<li>加密、解密、密钥</li>
<li>对称密码、公钥密码、混合密码</li>
<li>单向散列（hash）函数、信息认证</li>
<li>数字签名 &#x2F; 篡改和否认</li>
<li>伪随机数</li>
</ul>
<p>信息传递时面临的风险：</p>
<ul>
<li>窃听 -&gt; 对称、公钥密码</li>
<li>篡改 -&gt; 散列函数、消息认证、数字签名</li>
<li>伪装 -&gt; 消息认证、数字签名</li>
<li>否认 -&gt; 数字签名</li>
</ul>
<p>有悖常识的几点：</p>
<ul>
<li>不要使用保密的加密算法</li>
<li>使用低强度密码不如不用</li>
<li>任何密码都有可能被破解</li>
<li>密码只是安全的一部分（社工）</li>
</ul>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>凯撒密码 &#x2F; 平移 &#x2F; 暴力破解</li>
<li>简单替换密码 &#x2F; 替换 &#x2F; 频率分析</li>
<li>Enigma &#x2F; 加密密码的密码 &#x2F; 针对每日密钥的破解</li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><ul>
<li>编码和异或</li>
<li>一次性密码和它的问题</li>
<li><strong>使用对称密码时，我们通常默认密钥配送问题已解决</strong></li>
</ul>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>全称Data Encryption Standard。于1977年在美国发明并使用。目前可以被暴力破解，因此不应再使用了。</p>
<ul>
<li>DES以<strong>64bit</strong>为一个单位，使用和明文等长的密钥。</li>
<li>密钥每8位包含1位纠错码</li>
<li>基本结构使用Feistel网络<ul>
<li>加密&#x2F;解密步骤以轮为单位，DES有16轮</li>
<li>每轮运算不加密右半侧，同时右半侧比特和该轮密钥通过轮函数得到本轮加密左侧的密钥，和左侧做异或得到左侧密文</li>
<li>每轮加密后，进行左右对调，保证右侧的保密</li>
<li><strong>解密时用相同结构</strong>，反向使用子密钥和轮函数即可</li>
<li>轮函数可以任意复杂</li>
</ul>
</li>
<li>差分分析和线性分析衡量分组密码强度</li>
</ul>
<p><strong>三重DES</strong></p>
<p>由IBM开发，步骤为DES加密 -&gt; DES解密 -&gt; DES加密。密钥长度是原来三倍，即168比特。</p>
<ul>
<li>三步使用同一密钥，即向下兼容DES</li>
<li>根据1、3步是否使用同一密钥，分为DES-EDE2和DES-EDE3</li>
<li>处理速度慢</li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>全称Advanced Encrytion Standard，用来取代DES。由NIST开于1997年开始募集，将作为国家标准。算法要求开源免费，并在社群里公开评审，最终于2000年确定为Rijndael。</p>
<ul>
<li>基本结构为SPN结构</li>
<li>明文分组长度固定为<strong>128bit</strong>、密钥长度可以是128、192、256比特三种</li>
<li>每轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey四步<ul>
<li>SubBytes，将4字节 * 4字节的矩阵与一个转换矩阵相乘，得到替换后的矩阵</li>
<li>ShiftRows，逐行做平移</li>
<li>MixColumns，逐列做矩阵运算</li>
<li>AddRoundKey，和轮密钥矩阵做对应位上的异或运算</li>
</ul>
</li>
<li>解密时，除了AddRoundKey一步，其余均需要做逆运算</li>
<li>目前还没有针对Rijndael的有效攻击</li>
<li><strong>避免使用DES，选择AES</strong></li>
</ul>
<h2 id="分组密码的迭代模式"><a href="#分组密码的迭代模式" class="headerlink" title="分组密码的迭代模式"></a>分组密码的迭代模式</h2><p>分组密码只能加密<strong>固定长度</strong>的密码。因此，需要有<strong>模式</strong>来迭代加密任意长度的明文。与分组密码相对的是流密码，对数据进行连续处理。</p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>全称为Electronic CodeBook。是最简单直接的分组方式。将明文分组加密后直接得到对应位置的密文。不足的位用特定数据<strong>填充</strong>。</p>
<ul>
<li>问题很明显，<strong>不要使用</strong></li>
<li>相同的明文分组会得到相同的密文分组</li>
<li>攻击者无需破译密码也可通过修改密文操纵明文，比如替换或删除分组</li>
</ul>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>全称Cipher Block Chaining。和ECB的最大不同在于明文分组加密前会和上一个密文分组做一次异或运算。开头的明文分组会和一个随机序列做XOR。</p>
<ul>
<li>一个密文分组的损坏会影响关联的两个分组的解密</li>
<li>比特的缺失将会影响整个密文的解密</li>
<li>操纵初始化向量反转某一位比特可以反转第一个密文分组的某一位</li>
<li>填充提示攻击，攻击padding部分</li>
<li>SSL&#x2F;TLS使用CBC模式保证通信机密</li>
<li><strong>CTS</strong>使用最后一个密文填充不足的明文部分</li>
</ul>
<h3 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h3><p>全程Cipher FeedBack模式。和CBC模式的区别在密文分组先加密，再和下一个明文做异或运算。实际上明文分组和密文分组间只相差了一个异或运算。很类似一次性密码本的模式。</p>
<ul>
<li>解密时，需要对密文分组和初始向量做<strong>加密</strong>操作</li>
<li><strong>重放</strong>攻击，替换密文分组为原有分组，可使得解密出的明文为原有明文</li>
</ul>
<h3 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h3><p>全称Output-FeedBack模式。和CFB很像，区别在于OFB每次做XOR的密钥流仅来自于上一次的密钥，<strong>和密文分组无关</strong>。因为密钥流可以提前准备好，分组加密过程可以是并行的。</p>
<ul>
<li>第一次的密钥来自初始化向量</li>
<li>速度快</li>
<li>如果碰巧密钥加密后和加密前一样，那么之后的密钥就会是同一个值</li>
</ul>
<h3 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h3><p>全称CounTeR。CTR和OFB类似，区别在于它的密钥流来自于累加的计数器。密文分组来自于密钥流和明文分组的XOR运算。</p>
<ul>
<li>计数器由nonce和序号两部分各8字节组成，nonce是随机生成的，序号是从1累加的。</li>
<li>和OFB一样，加密解密速度快，结构简单</li>
<li>CTR的密钥流在选定nonce后就确定了，因此可以以<strong>任意顺序并行</strong>加密、解密</li>
</ul>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>解决了对称密码的密钥配送问题。</p>
<h3 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h3><ul>
<li><strong>事先共享</strong>，在现实生活中传送</li>
<li><strong>密钥配送中心</strong>，集中式管理用户密钥，用其加密临时的会话密钥</li>
<li><strong>使用Diffie-Hellman密钥交换</strong></li>
<li><strong>使用公钥密码</strong></li>
</ul>
<h3 id="公钥密码-1"><a href="#公钥密码-1" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>使用加密密钥（公钥）加密，使用解密密钥（私钥）解密，避免密钥的泄露。</p>
<ul>
<li>发送者使用加密密钥</li>
<li>接收者使用解密密钥</li>
<li>加密密钥可以公开</li>
<li>解密密钥一定要保密</li>
</ul>
<p>目前所使用的公钥密码RSA来自于1978年的发明。流程上，</p>
<ul>
<li><strong>接收者</strong>生成公私钥对，发送公钥给发送者</li>
<li>发送者使用公钥加密明文</li>
<li>接收者使用私钥解密密文</li>
</ul>
<p>公钥密码有两个问题：</p>
<ul>
<li>认证公钥的合法性</li>
<li>处理速度慢</li>
</ul>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>利用了数论中求解离散对数困难且耗时的特点。</p>
<ul>
<li><strong>加密</strong>，使用<code>密文=明文 ^ E mod N</code>。E和N组合成公钥。</li>
<li><strong>解密</strong>，使用<code>明文=密文 ^ D mod N</code>。D和N组合成密钥。</li>
</ul>
<p>生成N、E、D和顺序如下：</p>
<ol>
<li>寻找互质的两个大数p和q，N为二者的乘积</li>
<li>p-1和q-1的最小公倍数记为L</li>
<li>寻找比L小的和L互质的数，即为E</li>
<li>寻找比L小的和E乘积取模L为1的数，即为D</li>
</ol>
<p>因为解密时有对N取模操作，因此加密的明文不能大于N。</p>
<p><strong>攻击方式</strong></p>
<ul>
<li>破解密文 -&gt; 求解离散对数很难</li>
<li>暴力破解D -&gt; 比特位太长，很难破解</li>
<li>通过E求解D，只要知道p和q就能算出D -&gt; 不知道p和q的组合 -&gt; <strong>对N质因数分解很难</strong></li>
</ul>
<p><strong>中间人攻击</strong>里，攻击者可以替换掉原本的公钥，发送给接收者，使用自己的私钥解密，从而实现攻击。这时需要<strong>证书</strong>保证公钥的权威性。</p>
<p><strong>选择密文攻击</strong>里，攻击者可以利用服务端返回的错误消息收集加密算法信息。RSA-OAEP会在明文开头加上明文散列值和填充位，解密时发现散列值和内容对不上时，会隐藏错误信息。</p>
<p>除了RSA外，还有ElGamal方式、Robin方式、ECC（椭圆曲线密码）等公钥密码。它们分别利用了mod N下求离散对数，mod N下求平方根，和椭圆曲线上做乘法运算逆运算在数学上很难求解的特点。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q: 和对称密码的强度对比<br>A: 达到同等强度，RSA大致需要密钥是AES长度的20倍</p>
<p>Q: RSA使用的质数会用完么<br>A: 512bit的质数数目大约是10 ^ 150。足够使用。</p>
<p>Q: RSA破解难度如何？<br>A: 和大整数质因数分解一样难度</p>
<p>Q: 要保证RSA强度，N的长度要达到多少位<br>A: 2048bit，4096bit更好</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><ul>
<li>用对称密码加密明文</li>
<li>用公钥密码加密上述对称密码的密钥（通常用随机数生成器得到，只用于此次会话）</li>
<li>公钥密码的密钥由外部赋予（证书）</li>
</ul>
<p>密码软件PGP、HTTPS中使用的SSL&#x2F;TLS就使用了混合密码系统。当然它们还包含数字签名、认证、私钥管理等更多处理。</p>
<p>类似混合密码系统，后面要介绍的数字签名、证书、消息认证、伪随机数生成也都是<strong>基础密码技术的组合</strong>。</p>
<h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><ul>
<li>将任意长度的消息转换到<strong>固定长度</strong>散列</li>
<li>具有抗碰撞性，即找到具有相同散列函数的消息很困难</li>
<li>单向性，即无法从三列中还原原信息</li>
</ul>
<h3 id="MD4、MD5"><a href="#MD4、MD5" class="headerlink" title="MD4、MD5"></a>MD4、MD5</h3><p>全称Message Digest。由Rivest设计于1990和1991年。能够产生<strong>128bit</strong>的散列值。它们的强抗碰撞性已被攻破，<strong>不建议使用</strong>。</p>
<h3 id="RIPEMD-160"><a href="#RIPEMD-160" class="headerlink" title="RIPEMD-160"></a>RIPEMD-160</h3><p>1996年设计，是欧盟RIPE项目的修订版，能产生160bit长度的散列值。比特币中使用的散列函数就是RIPEMD-160。</p>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p>SHA于1993年由NIST设计，在1995年发布了SHA-1修订版，能够产生<strong>160bit</strong>的散列值。它的强抗碰撞性已被攻破，<strong>也不建议使用</strong>。</p>
<p>SHA-2于2002年发布，它是包括SHA-256，SHA-384和SHA-512的集合，分别产生<strong>256、384和512bit</strong>的散列值。目前未被攻破。SHA-2的几种散列长度来自SHA-256和SHA-512的组合。</p>
<p>SHA-3作为SHA-1的升级替代算法，和AES一样，由NIST公开选拔，并在2012年确定为一个叫<strong>Keccak</strong>的算法。之后会和SHA-2并存一段时间。</p>
<h3 id="Keccak"><a href="#Keccak" class="headerlink" title="Keccak"></a>Keccak</h3><p>Keccak可以输入<strong>任意长度</strong>的数据，产生<strong>任意长度</strong>的散列值。实现上，Keccak采用海绵结构，有<strong>吸收</strong>和<strong>挤出</strong>两阶段。</p>
<ul>
<li>吸收阶段，按分组长度r逐段读入消息内容，和内部状态做异或运算，之后和长度为c的内部状态一起交给函数f做“搅拌”。完成一轮处理，输出作为内部状态继读入输入的消息分组。</li>
<li>挤出阶段，内部消息r和c逐段和函数f做运算，一段段输出散列值。</li>
</ul>
<p>Keccak的双工结构下，输入和输出可以同时进行。Keccak内部状态由5 * 5 * z的一个三维比特数组组成，共有b个bit。Keccak的本质就是实现一个充分搅拌上述数组的函数f。SHA-3中使用的是Keccak-f[1600]函数。其中b就是内部状态的bit数。函数的每一轮包含θ、ρ、π、χ、ι5步。循环轮数为12 + 2 * log2(b &#x2F; 25)。</p>
<ul>
<li>θ，将不同两个column的各5个bit通过异或运算加起来，再和当前位做异或替换</li>
<li>ρ，各比特沿z轴方向进行平移</li>
<li>π，对一个slice上的5 * 5个比特做旋转、轮换操作</li>
<li>χ，对一个row上的各位做某个逻辑运算</li>
<li>ι，用某个轮常数对所有比特做异或运算，避免对称性</li>
</ul>
<p>Keccak采用的海绵结构和此前各散列算法使用的MD结构（循环执行压缩函数）方法截然不同，这也是它最后成为标准的一个原因。目前还未出现针对Keccak的有效攻击手段。</p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>利用文件的冗余性，构造<strong>一大堆</strong>和想要内容一样的数据，找到和原内容散列值一样的结果。</p>
<ul>
<li>原像攻击，给定散列值，找到具有该散列值的任意消息</li>
<li>第二原像攻击，给定消息1，找到和消息1有相同散列值的消息2</li>
<li>生日攻击，攻击散列算法的“强抗碰撞性”（寻找两个具有相同散列值的消息），利用了从有N个元素的集合中依次取并放回M个元素，两次取到同一元素的概率约为根号N的特点。大大减少暴力破解需要的次数。</li>
</ul>
<h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><p>可以同时防止消息的伪装和篡改。消息认证码简称MAC（Message Authentication Code）。可以简单理解成<strong>需要密钥参与的单向散列过程</strong>。在使用时：</p>
<ul>
<li>发送者伴随消息发送计算出的MAC</li>
<li>接受者对消息通过共享密钥计算出MAC值，进行对比，一致则表示认证成功</li>
<li><strong>这个密钥不能被中间人获取！</strong></li>
</ul>
<p>使用消息认证码（MAC）机制的场景有：</p>
<ul>
<li>SWIFT</li>
<li>IPSec</li>
<li>SSL&#x2F;TLS</li>
</ul>
<p>在认证加密时，Encrypt-then-MAC表示对密文计算MAC值，从而能判断密文是由知道明文和密钥的人生成的。除了Encrypt-then-MAC外，还有Encrypt-and-MAC和MAC-then-Encrypt两种方式。</p>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC即Hash MAC，是使用单向散列函数构造认证码的方法。分为下面几步：</p>
<ol>
<li>在密钥后填充0到长度达到单向散列函数的分组长度</li>
<li>填充后的密钥和ipad序列做XOR运算，ipad序列是00110110为单位循环的比特序列</li>
<li>组合在消息<strong>头部</strong>，并计算出散列值</li>
<li>填充后的密钥和opad做XOR运算，opad是01011100位单位循环的比特序列</li>
<li>结果拼在散列值<strong>后面</strong></li>
<li>根据5的结果计算最终的散列值</li>
</ol>
<h3 id="应对攻击方式"><a href="#应对攻击方式" class="headerlink" title="应对攻击方式"></a>应对攻击方式</h3><ul>
<li>消息认证需要解决<strong>重放攻击</strong>的问题，即再次发送相同的消息和MAC值。可以在消息中额外带上序号、时间戳，或先发送一个nonce一次性随机数保证相同的消息也会有完全不同的MAC值。</li>
<li><strong>密钥推测攻击</strong>，应保证不能根据MAC值推测出双方使用的密钥，必须使用安全、高强度的伪随机数生成器。</li>
</ul>
<p>另外，消息认证无法解决下面的问题：</p>
<ul>
<li>向第三方证明，密钥的共享只在通信的双方，无法证明给第三方</li>
<li>同样的，不能防止通信的一方<strong>否认</strong>消息</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>和公钥密码<strong>相反</strong>的使用方式：</p>
<ul>
<li>发布者使用私钥加密消息，私钥保密</li>
<li>使用发布者的公钥可以解密消息，公钥公开</li>
</ul>
<p>签名有两种方式：<strong>对消息签名</strong>和<strong>对消息的散列值签名</strong>。它们主要区别在签名的对象不同。基本过程是：</p>
<ol>
<li>生成公、私钥对，发送公钥给接收者</li>
<li>使用私钥加密消息&#x2F;消息的hash值，得到签名</li>
<li>发送消息和签名给接收者</li>
<li>接收者使用公钥解密，对比消息&#x2F;消息hash值，验证发送者身份</li>
</ol>
<p>在签名中，密钥只是起着“保证消息发送者的可靠来源目的的”，被复制并不影响它发挥作用。同时，由于不知道私钥，修改消息后无法伪造消息的签名。</p>
<p>实际应用数字签名的地方有很多：</p>
<ul>
<li>安全信息公告</li>
<li>软件下载</li>
<li>公钥证书，确保公钥的合法来源</li>
<li>SSL&#x2F;TLS，交换公钥的过程</li>
</ul>
<p>数字签名基于公钥密码，因此数字签名的实现方式因采用的公钥密码而异，如RSA、ElGamal、ECDSA（椭圆曲线密码）。对数字签名的攻击可以基于单向散列函数或是公钥密码。</p>
<ul>
<li><strong>不要对不清楚来源的数据做数字签名</strong></li>
<li><strong>对消息的散列值函数做数字签名</strong></li>
</ul>
<p>数字签名无法解决<strong>验证签名正确性的公钥被伪造</strong>的问题，因为公钥正确性也依赖于数字签名技术。这里需要<strong>证书</strong>以及<strong>公钥基础设施PKI</strong>这种社会学的基础设施辅助。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书即<strong>公钥证书</strong>，用来验证公钥密码和数字签名的公钥，由认证机构（CA）发布，认证机构可以是政府机关、一般企业或个人。证书的发布过程包括：</p>
<ol>
<li>申请人生成一对密钥，并把公钥发送给CA</li>
<li>CA验证申请人身份</li>
<li>通过验证后，CA使用自己的私钥对公钥施加数字签名并生成证书</li>
<li>使用申请人证书的使用者通过CA的公钥验证申请人的公钥是否合法</li>
<li>验证通过后，使用公钥完成公钥密码或数字签名</li>
</ol>
<p>PKI是为了能够更有效运用公钥制定的一系列规范的总称。PKI组成要素有3个：使用PKI的用户、认证机构、仓库。</p>
<ul>
<li>用户，分为注册公钥的用户和使用注册公钥的用户</li>
<li>CA，包括生成密钥、验证本人身份、验证公钥合法性、作废证书</li>
<li>仓库，是保存证书的数据库</li>
</ul>
<p>其中认证机构做了以下事情：</p>
<ul>
<li><strong>生成密钥对</strong>，可以由用户或是CA生成，若是CA生成，需要根据规范发送私钥给用户</li>
<li><strong>注册证书</strong>，用户根据规范申请证书，认证机构根据业务准则生成符合X.509规范的证书</li>
<li><strong>作废证书</strong>，因为私钥丢失等原因需要作废证书时，需要认证机构制作CRL（Certificate Revocation List，证书作废清单），PKI用户总需要从CA获取最新的CRL，以确认自己拿到的公钥证书是否有效。</li>
</ul>
<p><strong>认证机构的证书认证</strong></p>
<p>认证机构的公钥证书可以由其他的认证机构施加数字签名。这个关系可以嵌套很多层，比如部门认证机构、分公司认证机构、总公司认证机构。一直往上直到根CA，可以对自己的公钥做自签名。</p>
<p>从而，在验证证书合法性上，也会出现<strong>从上至下</strong>的验证过程。</p>
<h3 id="证书的攻击"><a href="#证书的攻击" class="headerlink" title="证书的攻击"></a>证书的攻击</h3><p>对证书的攻击即对数字签名的攻击。</p>
<ul>
<li>对施加数字签名前的公钥攻击</li>
<li>注册相似人名进行攻击</li>
<li>窃取CA的私钥</li>
<li>伪装成CA发放证书进行攻击，认证机构本身的可信度也很重要</li>
<li>利用发送CRL的时间间隔，窃取了使用者的私钥，当使用者联系CA发布CRL时，有一定的时间间隔</li>
<li>同样利用CRL，使用合法私钥发送消息后，发送CRL作废自己的公钥，<strong>否认</strong>自己之前发送的消息</li>
</ul>
<p><strong>不可能在完全不可信的状态下创建出信任关系，除非以已经存在的信任关系为基础。</strong></p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><ul>
<li><p>密钥长度（DES：56bit，三重DES：112bit或168bit，AES：128、192、256bit</p>
</li>
<li><p>对称密码和公钥密码<strong>用于确保机密性</strong>，消息认证码和数字签名使用的密码<strong>用于认证，防止篡改内容和伪装身份</strong></p>
</li>
<li><p>只使用一次的密钥称为<strong>会话密钥</strong>，重复使用的密钥称为<strong>主密钥</strong>。</p>
</li>
<li><p><strong>密码学用途的随机数生成器必须为密码学用途专门设计</strong></p>
</li>
<li><p>定期改变会话密钥可以减少密钥泄露的损失</p>
</li>
<li><p>保存密钥时，使用KEK（Key Encrypting Key）方式保存密钥可以减少管理密钥的数目。</p>
</li>
</ul>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换里，通信的双方通过交换一些可以公开的消息，就能够生成共享的密钥。</p>
<ol>
<li>确定一个非常大的质数P，寻找P的生成元（原根）G</li>
<li>通信双方各自找1个1 ~ P-2的随机数A、B，生成G ^ A mod P与G ^ B mod P，发送给对方</li>
<li>对方用收到的数字根据自己选的随机数做乘方运算，得到相等的值作为密钥</li>
</ol>
<p>它同样利用了离散对数问题难以快速求解的特点。这种交换方法可以做中间人攻击，可以用数字签名、证书等方式应对。</p>
<h3 id="基于口令的密码（PBE）"><a href="#基于口令的密码（PBE）" class="headerlink" title="基于口令的密码（PBE）"></a>基于口令的密码（PBE）</h3><p>基于口令的密码避免了：记忆CEK -&gt; 记忆KEK -&gt; 记忆KEK的KEK的死循环。使用好记忆的口令配合盐生成CEK。使用过程如下：</p>
<ol>
<li>使用随机数生成器生成盐（随机数），加上用户口令，使用单向散列函数得到KEK</li>
<li>使用KEK加密会话使用的CEK</li>
<li>保存好盐以及使用KEK加密的会话秘钥</li>
</ol>
<ul>
<li>盐的目的是避免字典攻击</li>
<li>口令虽然便于生成，但是强度不高，因此需要格外地小心保管</li>
<li>可以对KEK迭代使用单向散列函数得到最后的KEK（拉伸），这将加大攻击者的攻击负担</li>
</ul>
<h3 id="生成安全的口令"><a href="#生成安全的口令" class="headerlink" title="生成安全的口令"></a>生成安全的口令</h3><ul>
<li>使用<strong>只有自己</strong>知道的信息<ul>
<li>不包括别人见过的信息</li>
<li>不包括可以很容易推测的信息</li>
</ul>
</li>
<li>不应该重复使用口令，容易受牵连影响</li>
<li>物理保存是可以的，但要注意安全</li>
<li>可以使用口令生成和管理工具（比如1Password）</li>
</ul>
<h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>随机数生成在密码学中很常用：</p>
<ul>
<li>生成密钥</li>
<li>生成分组密码的初始化向量</li>
<li>生成CTR模式的nonce</li>
<li>生成盐</li>
</ul>
<p>随机数至少需要具有下面的属性：</p>
<ul>
<li>随机等概性</li>
<li>无状态，即无法从上一个推测下一个，生成序列无法重现</li>
</ul>
<p>由于计算机构成的抽象世界是<strong>离散的</strong>，内部状态有限，不能满足无状态的特点，因此只能称作<strong>伪随机数生成器</strong>。基于计算机硬件的随机数生成器可以认为是“真”随机数，它通常提前储存在一个随机数池中，在需要的时候直接从池中取用。伪随机数生成器根据随机的种子（seed）通过算法将内部状态转化为最终的随机数。</p>
<ul>
<li><strong>线性同余法</strong>，以当前随机数为内部状态（初始值为种子），(A x Rn + C) mod M，计算下一个值。其中A、C、M都需要事先选好，线性同余法生成的随机数数列具有可预测性，即不需要知道种子也可以推测下随机数值</li>
<li><strong>单向散列函数</strong>，利用单向散列函数保护内部状态，以种子为初始值，逐次递加得到新的内部状态，再通过单向散列函数输出为随机数</li>
<li><strong>密码法</strong>，类似单向散列函数，使用密钥加密内部状态输出也可以作为随机数，此时保护内部状态的加密算法和密钥</li>
<li><strong>ANSI X9.17</strong>中，使用AES和三重DES作为密码算法<ol>
<li>初始化内部状态</li>
<li>使用当前时间生成掩码</li>
<li>掩码和内部状态做XOR</li>
<li>加密3的输出，作为随机数输出</li>
<li>对加密后的输出与掩码做XOR</li>
<li>加密5的结果作为新的内部状态</li>
</ol>
</li>
</ul>
<h2 id="PGP介绍"><a href="#PGP介绍" class="headerlink" title="PGP介绍"></a>PGP介绍</h2><p>PGP全程Pretty Good Privacy，编写于1990年，具备现代密码软件所需的几乎所有功能。OpenPGP是一对密文和数字签名进行定义的标准规格。</p>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><p>加密时，使用混合密码系统的流程：</p>
<ol>
<li>用伪随机数生成会话密钥</li>
<li>用<strong>接收者</strong>的公钥加密会话密钥</li>
<li>压缩消息，并使用对称密码加密，密钥为上面生成的会话密钥</li>
<li>将加密后的密钥和密文拼接在一起</li>
<li>将4的结果转换为文本数据，即为报文数据</li>
</ol>
<p>解密时，PGP的私钥通过用户口令加密保存。在收到密文时：</p>
<ol>
<li>输入接收者的口令</li>
<li>求口令的散列值，生成用户解密私钥的秘钥</li>
<li>解密得到私钥</li>
<li>将报文数据转换为二进制，并拆解成加密的会话密钥和压缩的密文</li>
<li>用自己的私钥解密得到会话密钥</li>
<li>用会话密钥解密密文</li>
<li>解压缩明文得到原始消息</li>
</ol>
<h3 id="生成数字签名"><a href="#生成数字签名" class="headerlink" title="生成数字签名"></a>生成数字签名</h3><p>同样，生成数字签名时：</p>
<ol>
<li>输入接收者的口令</li>
<li>求口令的散列值，生成用户解密私钥的秘钥</li>
<li>解密得到私钥</li>
<li>使用单向散列函数计算消息散列值</li>
<li>对散列值签名，即使用私钥加密</li>
<li>拼合签名和消息，进行压缩</li>
<li><em>（可选）</em>转换二进制为文本数据，即最后的报文数据</li>
</ol>
<p>类似地，验证时：</p>
<ol>
<li>转换为二进制文件，解压缩数据</li>
<li>分解出签名和消息两部分</li>
<li>使用公钥解密签名，得到散列值</li>
<li>使用单向散列函数计算消息散列值，对比3中的散列值</li>
<li>相等即验证成功</li>
</ol>
<h3 id="生成数字签名并加密"><a href="#生成数字签名并加密" class="headerlink" title="生成数字签名并加密"></a>生成数字签名并加密</h3><p>实际情况下，我们往往需要使用加密算法加密数字签名中的原消息。实现步骤是上两节的组合。即先进行数字签名，再对签名结果加密。</p>
<p>验证过程是相反的，先解密密文得到签名结果，再验证数字签名。</p>
<h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3><p>PGP确认公钥合法性的方法不依赖于认证机构颁发证书，而是采用所有者信任级别构成信任网（也叫信任圈、朋友圈）的方式，让用户自己决定该信任谁。建立信任有三种方式：</p>
<ul>
<li>通过自己的签名来确认。用户在通过其他方式（比如线下）确认公钥可信任后，对该公钥加上自己的数字签名。由于PGP中，使用者本人的公钥是绝对信任，被施加签名的公钥因此可信任。<em>注意：这并不代表被施加签名的公钥所有者被<strong>完全</strong>信任</em></li>
<li>通过自己完全信任的数字签名进行确认。即<strong>完全信任</strong>某个公钥进行的数字签名，用户可对当前信任的每个公钥所有者设置信任级别，级别为<strong>完全信任</strong>时，所有者公钥施加签名的公钥也会被信任。</li>
<li>通过有限信任的多个数字签名进行确认。在设置信任级别为<strong>有限信任</strong>时，有限信任的公钥<strong>都</strong>施加数字签名后，新的公钥才会被信任。</li>
</ul>
<p>通过上面三种方式，PGP使用者可以构建起自己的信任网，从而根据自己的决定信任某个公钥。</p>
<h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>TLS是SSL的后续版本，但在大多数情况下，可以统一写成SSL&#x2F;TLS。<strong>SSL&#x2F;TLS可以承载应用层协议，保证应用层传输的安全性，HTTP就是其中一种</strong>。其余SSL&#x2F;TLS可以承载的应用层协议还包括SMTP、POP3等等。</p>
<p>SSL于1994年在网景公司开发，在1995年发布了SSL3.0版本，后被发现会导致POODLE攻击。TLS是IETF在1999年作为SSL3.1发布。2006年发布TLS1.1，之后又发布了TLS1.2。</p>
<p>HTTPS中SSL&#x2F;TLS要保证以下三点：</p>
<ul>
<li>保证消息传输中<strong>不被窃听</strong> -&gt; <strong>对称密码</strong>加密消息，<strong>公钥密码</strong>加密对称密码的密钥</li>
<li>保证消息传输中<strong>不被篡改</strong> -&gt; <strong>消息认证</strong>码</li>
<li>保证消息传输<strong>双方的合法性</strong> -&gt; <strong>数字签名</strong>生成证书</li>
</ul>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>下面的流程以TLS1.2为例。TLS协议分为两层：</p>
<ul>
<li><strong>TLS握手协议</strong>，位于上层，处理除加密的部分。可以进一步分为：<ul>
<li><strong>握手协议</strong>，负责在客户端和服务器间协商密码算法和共享密钥</li>
<li><strong>密码规格变更协议</strong>，向通信对象传达变更密码方式</li>
<li><strong>警告协议</strong>，在发生错误时将错误传达给对方</li>
<li><strong>应用数据协议</strong>，将TLS上承载的应用数据传达给通信对象</li>
</ul>
</li>
<li><strong>TLS记录协议</strong>，位于底层，处理加密的部分。使用了对称密码和消息认证码，但具体的算法和密钥需要通信双方具体协商</li>
</ul>
<h3 id="TLS记录协议"><a href="#TLS记录协议" class="headerlink" title="TLS记录协议"></a>TLS记录协议</h3><p>记录协议负责数据的压缩、加密、数据认证，工作方式如下：</p>
<ol>
<li>分割消息为较小的片段，再分段压缩，<strong>压缩方式需要协商决定</strong></li>
<li>对压缩过的消息进行消息认证，加上MAC值。为了避免重放攻击，在计算MAC值时，加上了片段的编号。其中的<strong>单向散列函数的算法、使用的密钥都需要协商确定</strong></li>
<li>把MAC值和压缩过的消息片段组合在一起，使用对称密码加密。迭代模式使用CBC模式，CBC模式的初始化向量通过主密码生成。<strong>对称密码的算法、密钥则需要协商决定</strong></li>
<li>上述经过加密的数据，再加上<strong>数据类型、版本号、压缩后的长度</strong>，构成最终的报文数据。数据类型就是之前提到的TLS握手协议的4类子协议</li>
</ol>
<h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>握手协议负责生成对称密码中的共享密钥以及交换证书。因为握手的整个过程都是明文进行的，因此需要使用公钥密码或是Diffie-Hellman密钥交换。整个握手协议有下面几步：</p>
<ol>
<li><strong>ClientHello</strong>，客户端发送一些信息给服务器，便于协商算法和密钥</li>
</ol>
<ul>
<li>可用版本号，即支持的SSL&#x2F;TLS版本号</li>
<li>客户端生成的随机数，在后面的步骤会用到</li>
<li>会话ID，在需要重新使用以前的会话时用到</li>
<li>客户端可用的密码套件清单</li>
<li>客户端可用的压缩方式清单</li>
<li>当前时间</li>
</ul>
<ol start="2">
<li><strong>ServerHello</strong>，服务器根据客户端传来的信息，选择合适的算法和密码套件，返回的消息中带有下面几条</li>
</ol>
<ul>
<li>使用的版本号</li>
<li>服务端生成的随机数，后面步骤会用到</li>
<li>会话ID，作用同上</li>
<li>使用的密码套件</li>
<li>使用的压缩方式</li>
<li>当前时间</li>
</ul>
<ol start="3">
<li><strong>Certificate</strong>，<strong>非匿名通信</strong>时，服务器发送自己的证书，以及对服务器证书签名的CA的证书</li>
<li><strong>ServerKeyExchange</strong>，当Certificate消息不足时，服务器通过此消息传递额外信息</li>
<li><strong>CertificateRequest</strong>，需要进行<strong>客户端认证</strong>时，服务端发送此消息，并带上服务器能理解的证书类型、CA名称清单。</li>
<li><strong>ServerHelloDone</strong>，服务器发送此消息结束服务器的返回</li>
<li><strong>Certificate</strong>，作为CertificateRequest的回应，客户端发送自己的证书，交给服务器验证</li>
<li><strong>ClientKeyExchange</strong>，密码套件包含RSA时，会发送<strong>经过服务器公钥加密的预备主密码</strong>；密码套件包含Diffie-Hellman密钥交换时，会发送Diffie-Hellman密钥交换中的公开值。<strong>预备主密码（pre-master secret）</strong>是客户端生成的随机数，之后会用做生成主密码的种子。根据预备主密码，通信双方计算出<strong>相同的主密码</strong>。主密码会用做以下用途：</li>
</ol>
<ul>
<li>对称密码的密钥</li>
<li>消息认证码的密钥</li>
<li>CBC模式中的初始化向量</li>
</ul>
<ol start="9">
<li><strong>CertificateVerify</strong>，在服务器发送CertificateRequest时，通过此消息发送客户端使用自己私钥签名的主密码和握手协议传输消息的散列值。证明自己是客户端证书的持有人。</li>
<li><strong>ChangeCipherSpec</strong>，客户端发送，表示切换密码开始，实际上是密码规格变更协议的一类报文</li>
<li><strong>Finished</strong>，握手结束，此时已使用切换后的密码套件来加密发送。</li>
<li><strong>ChangeCipherSpec</strong>，<strong>Finished</strong>。来自服务器，作用同上。</li>
</ol>
<p>通过上面的步骤，双方达成了下面的目标：</p>
<ul>
<li>客户端获得了服务器的公钥，完成了服务器认证</li>
<li>服务器获得了客户端公钥，完成了客户端认证（如果需要的话）</li>
<li>生成了对称密码的密钥</li>
<li>生成了消息认证码中的共享密钥</li>
</ul>
<h3 id="密码规格变更协议"><a href="#密码规格变更协议" class="headerlink" title="密码规格变更协议"></a>密码规格变更协议</h3><p>用于在一开始从明文通信切换到使用密码套件沟通。</p>
<h3 id="警告协议"><a href="#警告协议" class="headerlink" title="警告协议"></a>警告协议</h3><p>用在握手协议异常、消息认证码错误、无法解压数据等异常情况。</p>
<h3 id="应用数据协议"><a href="#应用数据协议" class="headerlink" title="应用数据协议"></a>应用数据协议</h3><p>通信对象间传递应用数据。</p>
<h3 id="主密码"><a href="#主密码" class="headerlink" title="主密码"></a>主密码</h3><p>主密码根据预备主密码（pre-master secret）或Diffie-Hellman密钥交换的公开值生成。生成的主密码用于生成<strong>对称密码的密钥、消息认证码的密钥、CBC模式的初始化向量</strong>。</p>
<h3 id="对SSL-x2F-TLS的攻击"><a href="#对SSL-x2F-TLS的攻击" class="headerlink" title="对SSL&#x2F;TLS的攻击"></a>对SSL&#x2F;TLS的攻击</h3><ul>
<li>SSL&#x2F;TLS框架性的特点让它不依赖于某个特定的密码技术，因此对特定密码技术的攻击对SSL&#x2F;TLS本身影响不大</li>
<li>心脏出血漏洞，发现于2014年，利用TLS心跳拓展对请求的数据大小没有检查，可以获取内存中与请求无关的信息。是OpenSSL实现的漏洞。</li>
<li>POODLE攻击，利用CBC中的填充提示攻击，发现于2014年SSL3.0中。</li>
<li>FREAK攻击，可以在密码套件协商时，利用中间人攻击，强制使用强度很低的RSA Export Suites。从而在加密后，暴力破解明文。</li>
<li>对伪随机数生成器的攻击</li>
<li>利用之前提过的CRL</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>密码技术因为人类的不完美而必定不会完美。</p>
<ul>
<li><strong>对称密码</strong>，使用相同密钥加密、解密，保证消息<strong>机密性</strong>。目前主要使用AES。</li>
<li><strong>公钥密码</strong>，使用不同密钥加密、解密，作用同上。使用最广泛的是RSA，还有相关的Diffie-Hellman密钥交换</li>
<li><strong>单向散列函数</strong>，将消息转为固定长度散列值的技术，保证消息<strong>完整性</strong>，目前使用SHA2和SHA3（Keccak）</li>
<li><strong>消息认证码</strong>，结合单向散列函数和对称密码，保证消息<strong>完整性</strong>并<strong>认证消息</strong>，但无法防御<strong>否认</strong>。目前主要使用HMAC</li>
<li><strong>数字签名</strong>，结合单向散列函数和公钥秘钥，保证<strong>完整性</strong>，<strong>不可否认性</strong>和<strong>认证消息</strong>。是公钥证书采用的技术</li>
<li><strong>伪随机数生成器</strong>，配合上述技术使用，需要保证<strong>不可预测性</strong>和<strong>不可重现性</strong></li>
</ul>
<p>密码技术从某种角度看是一种压缩技术：</p>
<ul>
<li>密钥是机密性的压缩</li>
<li>散列值是消息完整性的压缩</li>
<li>认证值时认证的压缩</li>
<li>随机数种子是不可预测性的压缩</li>
</ul>
<h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>比特币来自于Satoshi Nakamoto（中本聪，化名）的一篇论文，并于2009年开始实际运用。比特币是一种<strong>基于P2P网络的支付结算系统</strong>。用户通过它进行进行价值转移。</p>
<ul>
<li><strong>地址</strong>，将公钥使用散列函数求散列值得到，地址都以1开头，剩下内容 不包含O，0,1和I。</li>
<li><strong>钱包</strong>，即比特币客户端，可以生成密钥对，公钥用于收款，密钥用于付款</li>
<li><strong>区块链</strong>，保存了比特币所有交易记录的账簿，若干交易组成一个区块，在区块头有所有交易的散列值，以及上一个区块的散列值，有交易添加时会触发区块头的散列值变化，并链式传递下去</li>
<li><strong>交易</strong>，收、付款方各自生成密钥对，付款方创建交易“地址A向地址B转账x BTC”，<strong>并用自己的私钥签署数字签名</strong>，之后广播至P2P网络中，完成交易。比特币使用的数字签名基于椭圆曲线DSA，方程为x^2 &#x3D; y^3 + 7</li>
<li><strong>挖矿</strong>，向区块链中添加新区块的行为被称为挖矿，第一个挖矿成功的矿工会获得挖矿奖励和区块所有交易的手续费。为了证明自己确实完成了规定工作，矿工需要进行<strong>工作量证明</strong>（PoW），即生成的区块头中，前一区块头的散列值必须以若干位的0开头，这个工作需要投入大量的计算资源。区块大约每10分钟添加一个，为了避免通货膨胀，所需的0的个数会不断调整。<ul>
<li>根据协议规定，挖矿奖励每4年减少一半</li>
<li>当区块链上同时出现分支时，P2P网络会选择计算量大的分支进行工作</li>
</ul>
</li>
<li>比特币的匿名性只限于交易地址</li>
</ul>
<h2 id="附录：椭圆曲线"><a href="#附录：椭圆曲线" class="headerlink" title="附录：椭圆曲线"></a>附录：椭圆曲线</h2><ul>
<li>椭圆曲线（EC）源自于求椭圆弧长的椭圆积分的反函数。</li>
<li>定义椭圆曲线上的加法运算</li>
<li>椭圆曲线上的离散对数（ECDLP） - 已知点G和点xG，求整数x</li>
<li>有限域上的离散对数，对点进行模运算</li>
<li>椭圆曲线Diffie-Hellman密钥交换</li>
<li>椭圆曲线ElGamal密码</li>
<li>椭圆曲线DSA（ECDSA）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/10/01/some-tips-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/10/01/some-tips-4/" class="post-title-link" itemprop="url">工作中的遇到的一些小知识 4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-10-01 19:18:38 / 修改时间：19:20:04" itemprop="dateCreated datePublished" datetime="2018-10-01T19:18:38+08:00">2018-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/01/some-tips-4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/01/some-tips-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="lottie-production环境下bug修复总结"><a href="#lottie-production环境下bug修复总结" class="headerlink" title="lottie production环境下bug修复总结"></a>lottie production环境下bug修复总结</h2><p>现象：<br>前段时间，用lottie-web做动画的时候，发现在有个别动画在本地测试时可以正常播放，打包上线后会报库代码内的错误</p>
<p>猜测原因：<br>打包过程中的uglify有损压缩了lottie-web的代码，导致部分特性的bug</p>
<p>修复方式：</p>
<ol>
<li>在webpack配置中，为lottie-web专门指定一个chunk</li>
<li>在optimization中，指定一个lottie的cacheGroup，保证一个专门的chunk</li>
<li>minimizer中uglifyJSConfig指定exclude为lottie的chunk名，避免被uglify</li>
<li>resolve中，指定lottie-web resolve到’..&#x2F;node_modules&#x2F;lottie-web&#x2F;build&#x2F;player&#x2F;lottie.min.js’，使用压缩过的版本</li>
</ol>
<p>大致像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="attr">lottie</span>: [<span class="string">&#x27;lottie-web&#x27;</span>],</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="string">&#x27;lottie-web&#x27;</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../node_modules/lottie-web/build/player/lottie.min.js&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">lottie</span>: &#123;</span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;lottie&#x27;</span>,</span><br><span class="line">                    <span class="attr">test</span>: <span class="string">&#x27;lottie&#x27;</span>,</span><br><span class="line">                    <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/lottie/</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：<br>问题解决。</p>
<h2 id="Android机型下rem适配不准的问题"><a href="#Android机型下rem适配不准的问题" class="headerlink" title="Android机型下rem适配不准的问题"></a>Android机型下rem适配不准的问题</h2><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/14f6ce51a75f">https://www.jianshu.com/p/14f6ce51a75f</a></p>
</blockquote>
<p>通过比较<code>document.documentElement.style.fontSize</code>和<code>window.getComputedStyle(document.documentElement)[&#39;font-size&#39;]</code>，假设前者是a，后者是b，<code>a * a / b</code>计算得到和设计一致的尺寸。</p>
<h2 id="3D旋转效果"><a href="#3D旋转效果" class="headerlink" title="3D旋转效果"></a>3D旋转效果</h2><p>利用CSS中的<code>backface-visibility: hidden;</code>属性，实现在<code>transform: rotateY(180deg)</code>时，页面翻转到不可见区域。</p>
<h2 id="egret学习"><a href="#egret学习" class="headerlink" title="egret学习"></a>egret学习</h2><p>场景：H5小游戏开发</p>
<p>投放场景：各种小游戏平台，也可以打包为Android、iOS、Windows Phone应用发布，甚至直接web访问H5页面</p>
<p>开发语言：TypeScript</p>
<p>开发方式：</p>
<ul>
<li>类Java的代码组织方式，MVC分离项目代码，M和C开发体验类似“用JavaScript写Java项目”。在View部分开发体验类似于用<code>canvas API写页面结构</code></li>
<li>类Android的resource管理方式（定义json文件描述资源组和路径对应），在代码中用API动态分组或逐个load资源</li>
<li>单一入口，流程上在stage加载完成后，load资源（同时给出loading页面），之后执行游戏逻辑</li>
<li>使用dispatchEvent实现组件间的信息交流</li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>入口文件为index.html。在其中引入manifest.json。读入所需的库文件后，根据DOM容器的<code>data-*</code>属性确定项目配置，以及项目入口<code>*.ts</code>（一般是<code>Main.ts</code>）。之后打包编译到<code>bin-debug</code>。</p>
<p>业务逻辑放在<code>/src</code>下，资源文件放在<code>/resources</code>中，资源文件用类似于Android的形式进行存取管理。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>Displayable元素可以添加到容器中显示。包含下面基类。</p>
<ul>
<li>displayableContainer 视图元素容器<ul>
<li>stage</li>
<li>scrollView</li>
<li>sprite</li>
</ul>
</li>
<li>bitmap</li>
<li>bitmapText</li>
<li>textField</li>
<li>movieClip</li>
<li>shape</li>
</ul>
<p>movieClip表示逐帧动画。生成方法如下：</p>
<ol>
<li><code>RES.getRes</code>获取资源</li>
<li>使用factory方法构造movieClipData</li>
<li>使用movieClipData构造movieClip</li>
</ol>
<p>简单动画用tween来实现。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ul>
<li><code>egret publish</code>或run build。发布H5，runtime版本</li>
<li>对应平台support工具，如Android、iOS、微信小程序</li>
</ul>
<p>不过在最新的egret launcher下，项目本身已经提供的发布到原生的快捷入口，参考<a target="_blank" rel="noopener" href="http://developer.egret.com/cn/github/egret-docs/Native/native/projectsetting/index.html">官方解释</a>。</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>和React如何结合开发？</strong></p>
<p>View层通过canvas、WebGL实现，不适合和React结合。</p>
<p><strong>部署方式如何结合在App里</strong></p>
<p>小游戏可以发布到HTML5平台，之后类似老的webview页面开发方式，部署到离线包平台或在线页面即可。</p>
<h2 id="SSO实现方案"><a href="#SSO实现方案" class="headerlink" title="SSO实现方案"></a>SSO实现方案</h2><p>SSO - Single Sign On 单一站点登录。由一个站点的登录状态实现关联网站免登录。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由sso.xxx.com记录用户登录态，其他需要使用同一登录态的网站需要同步该域名下的登录态cookie到自己的独立域名下。</p>
<h3 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h3><p>一般公司内部的网站或ToC的集团网页间都有SSO控制，任意访问一个清除了所有cookie网页，观察network中开头的302报文即可发现实现SSO过程中的各跳转逻辑。</p>
<p>实际步骤因实现而异：</p>
<ol>
<li>（转让控制权）访问目标网页，302到SSO的跳转特定页面，如jump.sso.xxx.com</li>
<li>（写入cookie）302回目标网页的特定页面，如sso.mysite.com。该域名CNAME到sso.xxx.com的服务器</li>
<li>（写入cookie）sso.mysite.com写入cookie到自己的同域名下，再次302到目标网页，完成SSO过程</li>
</ol>
<p>或者</p>
<ol>
<li>同上</li>
<li>（写入cookie）jump.sso.xxx.com做cookie的检查确认，通过url的方式写入回调的user session，再302回mysite.com。</li>
<li>（写入cookie）mysite.com的后台对应路由根据URL里的回调写入cookie，302到目标页面</li>
</ol>
<p>在写入cookie到新域名过程中，可以有不同的实现方式。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>第一步302到sso.xxx.com的时候已经可以带上xxx.com的cookie了，但是由于浏览器安全限制，并不能直接set cookie到独立域名下。需要再次302回原始域名，CNAME到sso的服务器，实现set cookie到独立域名。</p>
<p>为了保证安全性，CNAME到sso的sso.mysite.com所传递的参数需要有安全机制保证。如时间戳、秘钥等保证请求的完整性。避免中间人伪造域名下的请求。同时，链接本身也应有<strong>时效性</strong>，在超过时间范围失效，避免拦截链接，实现钓鱼网站获取sso.xxx.com的登录态。</p>
<p>具体步骤：</p>
<ol>
<li>302到jump.sso.xxx.com后，进行权限检查判断域名是否允许同步，匹配SSO的cookie域名下的cookie取交集，得到需要同步的cookie。</li>
<li>通过以上两步后，302到sso.mysite.com，url中带上cookie和安全相关的参数</li>
<li>根据安全参数校验、target是否允许同步，决定返回403还是302。</li>
<li>通过校验后，同步登录态cookie，302到目标网页</li>
</ol>
<p>清除登录态时，如何做到相关域名的同时清除，还需要额外设计。</p>
<p>当然，如果sso只在内网使用，在jump.sso.xxx.com做完安全验证后，通过url将结果交由sso.mysite.com设置登录态Cookie，要更为简洁。</p>
<h2 id="git-branch-rename"><a href="#git-branch-rename" class="headerlink" title="git branch rename"></a>git branch rename</h2><p>如果分支在远端也有的话，工作需要分为本地和远端两部分。</p>
<ol>
<li>重命名本地分支</li>
</ol>
<ul>
<li>如果就在该分支  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m new-name</span><br></pre></td></tr></table></figure></li>
<li>如果在其他分支  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old-name new-name</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>删除原分支，推送新分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :old-name new-name</span><br></pre></td></tr></table></figure></li>
<li>重置upstream设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -u new-name</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="webpack无痛mock方案"><a href="#webpack无痛mock方案" class="headerlink" title="webpack无痛mock方案"></a>webpack无痛mock方案</h2><p>使用webpack-api-mocker实现，对比axios-mock-adapter和其余方案有几个优势：</p>
<ul>
<li>mock部分代码和业务代码分离开，让网络请求部分代码（&#x2F;apis）有清晰的逻辑，不混杂业务无关内容</li>
<li>热更新，保存即生效</li>
<li>本地dev环境无痛切换到production环境，无需修改任何代码</li>
<li>基于webpack-dev-server，和整个项目耦合，无需本地起服务<br>本地开发时，配置webpack.dev.config.js，在devServer部分的配置中加入apiMocker即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apiMocker = <span class="built_in">require</span>(<span class="string">&quot;webpack-api-mocker&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="title function_">before</span>(<span class="params">app</span>) &#123;</span><br><span class="line">            <span class="title function_">apiMocker</span>(app, path.<span class="title function_">resolve</span>(<span class="string">&#x27;./mock/index.js&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 对应的路径下，写入mock数据和路径即可，可以灵活组织各模块的mock数据：</span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;GET /user/info&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">            <span class="comment">// your mock data</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;POST /user/update&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = proxy;</span><br></pre></td></tr></table></figure>

<p>更多使用，参考webpack-api-mocker文档。</p>
<h2 id="webpack配置使用es6语法"><a href="#webpack配置使用es6语法" class="headerlink" title="webpack配置使用es6语法"></a>webpack配置使用es6语法</h2><p>如今现代的前端开发早已采用全es6的语法书写，然而webpack的配置文件需要通过node解析执行，一般还使用es5的语法书写。在需要使用<code>import</code>，<code>export</code>，数组、对象解构等最新特性时就很蛋疼。</p>
<p>比如在最近的开发中，使用<code>webpack-api-mocker</code>时，希望拆分不同领域的接口到不同文件，最后通过对象结构的方式聚合在mocker的入口文件中。使用es5的语法就很麻烦。</p>
<p>实际上，让webpack使用babel解析配置文件分两步即可：</p>
<ol>
<li><code>yarn add -D babel-register</code>，让webpack能够使用babel-loader转译配置文件</li>
<li>修改配置文件后缀为，<code>webpack.config.babel.js</code>，webpack会使用<code>.js</code>前的字符串作为loader</li>
</ol>
<p>之后就可以愉快地使用es6语法写配置文件了。</p>
<h2 id="autoprefixer-remove-webkit-box-orient解决方案"><a href="#autoprefixer-remove-webkit-box-orient解决方案" class="headerlink" title="autoprefixer remove -webkit-box-orient解决方案"></a>autoprefixer remove <code>-webkit-box-orient</code>解决方案</h2><p>autoprefixer是postcss的插件，会根据browser list，删除一些autodated的样式，其中就包括<code>-webkit-box-orient</code>这个用于hack实现多行省略号的CSS样式。</p>
<p>几种方法：</p>
<ul>
<li>设置autoprefixer，<code>&#123;remove: false&#125;</code>，保留autodated的样式规则</li>
<li>添加flexbox 2009老旧浏览器到broswer list中</li>
<li>如下，通过注释临时disable autoprefixer</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* autoprefixer: ignore next */</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/09/13/http-intro-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/09/13/http-intro-note/" class="post-title-link" itemprop="url">《图解HTTP》整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-13 23:35:11" itemprop="dateCreated datePublished" datetime="2018-09-13T23:35:11+08:00">2018-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-09-25 00:35:18" itemprop="dateModified" datetime="2018-09-25T00:35:18+08:00">2018-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/09/13/http-intro-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/13/http-intro-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>读完了《图解HTTP》，就算是对计算机网络和HTTP部分内容做了个温习吧。同步做了整理，以便加强记忆和后面回顾。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>请求报文构成：</p>
<ul>
<li>方法</li>
<li>URI（绝对或是相对）</li>
<li>HTTP版本</li>
<li>请求首部</li>
<li>内容实体</li>
</ul>
<p>响应报文构成：</p>
<ul>
<li>HTTP版本号</li>
<li>状态码</li>
<li>状态码原语</li>
<li>响应头部</li>
<li>响应主体</li>
</ul>
<p>请求URI是服务器本身时，可以用<code>*</code>代替URI。</p>
<p>可用的方法列表：</p>
<ul>
<li>GET 获取资源</li>
<li>POST 传输信息</li>
<li>PUT 传输文件，<strong>没有用户验证机制</strong>，很少用到</li>
<li>DELETE 删除文件，同上，很少用到</li>
<li>HEAD 获得响应头部，不返回主体</li>
<li>OPTIONS 询问支持方法</li>
<li>CONNECT 用来建立HTTPS连接的隧道</li>
<li>TRACE 追踪路径上的所有服务器节点，很少用到</li>
</ul>
<p>其中后面三个是HTTP1.1才开始支持的。</p>
<p><strong>持久化</strong></p>
<p>在HTTP1.1后，HTTP建立的TCP连接默认是长连接（<code>keep-alive</code>），避免不必要的多次TCP握手和挥手。在此基础上，客户端可以同时向服务端发起多个资源请求。</p>
<p><strong>状态化</strong></p>
<p>HTTP本身是无状态的。通过cookie实现状态化，cookie通过服务端在响应头部的<code>set-cookie</code>字段下发，设置信息、使用范围、过期时间等内容。客户端在使用范围内的请求默认会携带上cookie信息。</p>
<h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><ul>
<li>请求首部和主体通过CR+LF分割开来</li>
<li>报文编码<ul>
<li>编码压缩<ul>
<li>gzip （GNU zip）</li>
<li>compress（UNIX compress）</li>
<li>deflate（zlib）</li>
<li>indentity（不压缩）</li>
</ul>
</li>
<li>分块发送</li>
<li>多部分发送（multipart）<ul>
<li>multipart&#x2F;form-data 表单文件上传，用boundary字符<code>--</code>表示新的part的开始</li>
<li>multipart&#x2F;byterange 配合206响应只包含了部分数据时使用</li>
</ul>
</li>
<li>部分发送<ul>
<li>Range指定字节范围</li>
<li>206响应状态码</li>
</ul>
</li>
</ul>
</li>
<li>内容协商<ul>
<li>双方就合适的语言、字符集、编码方式、过期时间进行协商</li>
</ul>
</li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><ul>
<li>1xx 这一类型的状态码，代表请求已被接受，需要继续处理<ul>
<li>100 Continue：客户端应当继续发送请求。</li>
<li>101 Switching Protocals：将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。</li>
</ul>
</li>
<li>2xx 成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<ul>
<li>200 OK：请求已成功，在方法时HEAD时不返回响应主体</li>
<li>204 No Content：服务器成功处理了请求，但不需要返回任何实体内容，<strong>用户浏览器应保留发送了该请求的页面</strong></li>
<li>205 Reset Content：和204的唯一不同是返回此状态码的响应要求请求者重置文档视图</li>
<li>206 Partial Content：服务器已经成功处理了部分GET请求。请求必须包含Range头信息来指示客户端希望得到的内容范围，返回使用<code>Content-Range</code>多用于下载工具</li>
</ul>
</li>
<li>3xx 重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址在本次响应的Location域中指明。<ul>
<li>300 Multiple Choices：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</li>
<li>301 Moved Permanently：被请求的资源已永久移动到新位置，建议使用Location中的新地址</li>
<li>302 Found：请求的资源现在临时从不同的URI响应请求</li>
<li>303 See Other：和302的区别是，客户端<strong>应当采用GET的方式</strong>访问新的资源</li>
<li>304 Not Modified：如果客户端发送了一个带条件（包括缓存相关的请求头部）的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变</li>
<li>305 Use Proxy：被请求的资源必须通过指定的代理才能被访问</li>
</ul>
</li>
<li>4xx 客户端错误：客户端发生了错误<ul>
<li>400 Bad Request：由于包含语法错误，当前请求无法被服务器理解</li>
<li>401 Unauthorized：当前请求需要用户验证，或用户未通过验证。</li>
<li>403 Forbidden：服务器已经理解请求，但是拒绝执行它</li>
<li>404 Not Found：资源未被在服务器上发现</li>
<li>405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源，响应中必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表</li>
<li>406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件</li>
<li>413 Request Entity Too Large</li>
<li>414 Request-URI Too Long</li>
</ul>
</li>
<li>5xx 服务器错误：服务器在处理请求的过程中有错误发生<ul>
<li>500 Internal Server Error：这个问题会在服务器的代码出错时出现</li>
<li>501 Not Implemented：服务器不支持当前请求所需要的某个功能</li>
<li>502 Bad GateWay：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</li>
<li>503 Service Unavailable：临时的服务器维护或者过载。这个状况是临时的，并且将在一段时间以后恢复。</li>
<li>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应</li>
</ul>
</li>
</ul>
<h2 id="协作机制"><a href="#协作机制" class="headerlink" title="协作机制"></a>协作机制</h2><ul>
<li>代理（Proxy），单纯转发HTTP请求，会在响应头部的<code>Via</code>字段留下痕迹</li>
<li>网关（Gateway），隔绝服务器和客户端，有安全、计费等逻辑</li>
<li>隧道（tunnel），基于协议搭建，保证传输安全，对用户侧透明</li>
<li>缓存（Cache），本地、服务端二级缓存，加快响应时间，有过期时间</li>
</ul>
<h2 id="报文头部"><a href="#报文头部" class="headerlink" title="报文头部"></a>报文头部</h2><ul>
<li>首部用来进行连接的各种信息描述。每个首部的字段用字段名和值组成，两者用<code>:</code>隔开。</li>
<li>首部分为端到端和逐跳两类，前者在报文转发的整个过程都保留，后者在转发后就会丢弃。典型的逐条首部有<code>Connection</code>, <code>Keep-Alive</code>, <code>Transfer-Encoding</code>, <code>Upgrade</code>等</li>
</ul>
<h3 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>客户端和服务端协商缓存机制。配合下面一些首部字段使用：</p>
<ul>
<li><code>Etag</code></li>
<li><code>Last-Modified</code></li>
<li><code>Expires</code>（HTTP1.0）</li>
<li><code>Pragma</code>（HTTP1.0）</li>
<li><code>Age</code>（HTTP1.0）</li>
<li><code>If-None-Match</code></li>
<li><code>If-Not-Modified-Since</code></li>
</ul>
<p><code>Cache-Control</code>有下面一些可配置项。</p>
<p>缓冲能力上，</p>
<ul>
<li>private，缓存只针对当前用户而言</li>
<li>public，缓存对所有用户生效</li>
<li>no-cache，始终对缓存进行过期验证</li>
<li>no-store，不允许缓存</li>
</ul>
<p>过期时间上，</p>
<ul>
<li>min-fresh，返回指定时间范围内的非过期资源</li>
<li>max-stale，返回指定时间范围内过期、非过期资源</li>
<li>max-age，单位：秒，最大缓存时间</li>
<li>s-max-age，同上，只用于CDN缓存</li>
</ul>
<p>二次验证上，</p>
<ul>
<li>only-if-cached，强制从缓存服务器中获取内容</li>
<li>immutable，一旦缓存不可更改</li>
<li>must-revalidate，即使本地已缓存，仍要求检查CDN缓存</li>
<li>proxy-revalidate，缓存服务器必须检查源内容是否改变</li>
</ul>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>管理连接，主要有两个用途。</p>
<ul>
<li>指定不希望转发给代理的字段</li>
<li>管理持久连接。使用<code>Connection: Keep-Alive</code>建立连接（HTTP1.1默认行为），使用<code>Connection: Close</code>终止连接</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>报文创建时间。行如“Date: Tue, 03 Jul 2012 04:31:12 GMT”</p>
<h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>历史遗留字段。<code>Pragma: no-cache</code>等同于<code>Cache-Control: no-cache</code>。</p>
<p>除此外还有：</p>
<ul>
<li>Trailer，说明报文主体中记录的首部字段</li>
<li>Transfer-Encoding，分段传输的主体编码</li>
<li>Upgrade，切换协议，<strong>配合<code>Connection: Upgrade</code>使用</strong></li>
<li>Via，标明沿途的整条路径</li>
<li>Warning，缓存相关警告</li>
</ul>
<h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><ul>
<li>Accept 接受文件的类型，类型间可以指定<code>q=x</code>表示权重值，x的取值在0到1之间。下同</li>
<li>Accept-Charset 可以接受的文件字符集</li>
<li>Accept-Encoding 可以接受的文件编码，有gzip，compress，deflate，indentity几种</li>
<li>Accept-Language 可接受的语言</li>
<li>Authorization 服务端需要的用户验证信息</li>
<li>Age 从缓存实体产生到现在经历的时间</li>
<li>Expect 期望的服务端返回状态码，服务端无法满足时返回417状态码，客户端等待服务端100响应时发送的请求都要带上该字段</li>
<li>Host 服务器的主机名，通常是请求资源的URL</li>
<li>If-Match 需要匹配的Etag，不满足时返回412，表示不满足条件</li>
<li>If-Modified-Since 返回指定日期后的新内容，否则返回304</li>
<li>If-Unmodified-Since 类似上</li>
<li>If-Range 类似If-Match不过是范围匹配</li>
<li>Max-Forwards 报文最多转发次数，通常配合TRACE方法使用</li>
<li>Proxy-Authorization 代理服务端需要的用户验证信息</li>
<li>Range 请求资源的部分内容，一般用在多线程下载（客户端发起）</li>
<li>Referer 当前请求从哪个地址发起</li>
<li>User-Agent 请求发起终端信息</li>
</ul>
<h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><ul>
<li>Accept-Ranges，表示服务器是否支持Range请求，支持时值为bytes，否则是none</li>
<li>Age，表示缓存到目前为止过了多久（HTTP1.0）</li>
<li>Etag，资源的唯一标识，分为强Etag和弱Etag</li>
<li>Location，用在3xx的请求中，表示客户端需要重定向到的新地址</li>
<li>WWW-Authentication&#x2F;Proxy-Authentication，服务器、代理使用的认证类型</li>
<li>Server，服务器信息</li>
<li>Vary，与Vary指定首部字段同名的请求才会命中缓存</li>
</ul>
<h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><ul>
<li>Allow 允许的访问方法</li>
<li>Content-Encoding&#x2F;Content-Language&#x2F;Content-Length&#x2F; 内容的编码、语言、长度、类型</li>
<li>Content-Location 内容的位置，通常在和访问URI时会用到</li>
<li>Content-MD5 内容MD5编码，便于和客户端编码后进行对比，防止内容篡改</li>
<li>Content-Range 用于部分请求</li>
<li>Content-Type 文件类型，包括MIME type和字符集</li>
<li>Expires&#x2F;Last-Modified 文件的过期时间和上次修改时间，用户判断缓存是否过期</li>
</ul>
<p>除此之外，还有和Cookie相关的两个头部，它们来自网景公司对于Cookie的设计。</p>
<ul>
<li>Set-Cookie，服务端下发设置Cookie信息。包含下列信息<ul>
<li>expires，过期时间</li>
<li>path，适用路径</li>
<li>domain，适用域名</li>
<li>secure，限制https才会携带Cookie</li>
<li>HttpOnly，限制JS脚本访问Cookie</li>
<li>下发的cookie内容</li>
</ul>
</li>
<li>Cookie，客户端期望的cookie内容</li>
</ul>
<p>另外还有一些常用的首部字段：</p>
<ul>
<li>X-Frame-Options，规定页面在iframe中的呈现方式<ul>
<li>DENY 禁止访问</li>
<li>SAMEORIGIN 仅允许同源访问</li>
</ul>
</li>
<li>X-XSS-Protection，为1时开启XSS防御</li>
</ul>
<p><strong>不建议使用”X-“开头的方式拓展非标准首部</strong>。 </p>
<h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><p>HTTP缺点：</p>
<ul>
<li>使用明文 -&gt; 通信内容可以被窃听 –HTTPS–&gt; 加密通信内容</li>
<li>不能验证身份 -&gt; DDoS攻击和伪装服务器、客户端身份 –HTTPS–&gt; 证书证明身份</li>
<li>不能验证内容完整性 -&gt; 中间人攻击 –HTTPS–&gt; HTTPS保证完整性</li>
</ul>
<p>HTTPS特征：</p>
<ul>
<li>加密内容</li>
<li>证书</li>
<li>完整性保护</li>
</ul>
<p>HTTPS建立在SSL连接之上，SSL建立在TCP连接上。SSL使用共享秘钥和公开秘钥加密两种方式混合加密。在秘钥确保安全的情况下，使用共享秘钥对称加密，优化速度；否则使用公开秘钥确保安全性。</p>
<ul>
<li>共享秘钥，双方使用同一秘钥加密和解密，秘钥被监听后加密就失去了意义</li>
<li>公开秘钥，使用公开秘钥加密，使用私有秘钥解密</li>
</ul>
<p>然而公开密钥本身并不能确保完整性，需要证书机构（CA）颁发证书认证，确保秘钥和端的有效以及合法性。服务端也可以使用OpenSSL为自己颁发自认证证书，但是一般会在浏览器上弹出警告。</p>
<p>HTTPS建立连接的过程包括：</p>
<ol>
<li>协商决定秘钥组件</li>
<li>服务端发送公开密钥、证书</li>
<li>客户端检查证书合法性，以确认服务端身份，并拿到公钥</li>
<li>客户端发送pre-master secret随机字符串</li>
<li>服务端使用私钥加密pre-master secret hash值，返回加密的hash值（避免黑客尝试破解私钥）</li>
<li>客户端使用公钥解密hash，对比自己之前生成的pre-master secret字符串hash，若一致，及证明服务端身份的合法性</li>
<li>客户端生成一个对称加密算法和秘钥master-secret，使用公钥加密，发送给服务端</li>
<li>双方使用master-secret进行通信</li>
</ol>
<p>通信的完整性可以通过将报文内容生成hash交由客户端验证来实现。</p>
<p>SSL最初由网景开发，1.0和2.0版本被发现存在问题已被废弃。3.0后由IETF接手。目前可用的协议版本有SSL3.0和TLS1.0、TLS1.1、TLS1.2，其中最常用的是SSL3.0和TLS1.0。</p>
<p><strong>证书</strong></p>
<p>证书包含：</p>
<ul>
<li>发布机构（CA）</li>
<li>有效期</li>
<li>持有者（由CA担保证明持有者身份）</li>
<li>公钥</li>
<li>数字签名算法</li>
<li>指纹算法</li>
</ul>
<p>为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会用自己的私钥加密后再和证书放到一起发布。使用者在打开证书时，根据加密算法，系统使用自带的公钥解密指纹和指纹算法，使用指纹算法计算证书的hash值和指纹对比，如果对的上就代表证书没问题。系统使用的公钥和证书一般由证书发布机构自己生成，内嵌在操作系统中。</p>
<p>证书颁发机构（CA）通常会去做很多工作确保持有者的合法性，信任CA代表着信任CA颁发证书中的所有信息。所以一般系统只选择信誉较好的CA机构。公司内部使用或自生成的证书就只能被在指定范围内被信任。</p>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><ul>
<li>BASIC 使用用户名密码验证，明文传输</li>
<li>DIGEST 质询响应，防止密码被拦截，安全度和便利性都较差</li>
<li>SSL 客户端证书 + HTTPS传输，成本高</li>
<li>HTTP表单 + Cookie&#x2F;Session验证</li>
</ul>
<h2 id="功能追加协议"><a href="#功能追加协议" class="headerlink" title="功能追加协议"></a>功能追加协议</h2><p><strong>WebSocket</strong></p>
<p>全双工，解决Ajax，长短轮询的局限。握手过程很简单：</p>
<ul>
<li>请求方添加<code>Upgrade</code>首部字段，声明升级到websocket。包含Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Verison等必要字段</li>
<li>响应方回复101状态码，包含Sec-WebSocket-Accept（是根据Sec-WebSocket-Key生成的），Sec-WebSocket-Protocol</li>
</ul>
<p>连接建立后，双方使用WebSocket的方式进行通信</p>
<p><strong>WebDAV</strong></p>
<p>基于Web的文件属性管理。新增了一些方法和状态码，允许客户端远程修改服务器上的文件。</p>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><p><strong>RSS</strong></p>
<p>RDF Site Summary，简易内容聚合。和Atom一样，使用XML的形式发布信息，通过特定的RSS阅读器阅读。</p>
<h2 id="常见Web攻击方式"><a href="#常见Web攻击方式" class="headerlink" title="常见Web攻击方式"></a>常见Web攻击方式</h2><p>根本原因：HTTP本身没有必要的安全机制。</p>
<h3 id="输出值转义相关攻击方式"><a href="#输出值转义相关攻击方式" class="headerlink" title="输出值转义相关攻击方式"></a>输出值转义相关攻击方式</h3><ul>
<li>XSS，跨站脚本攻击，主要出现在<strong>动态拼接HTML</strong>的场景中，用户恶意注入的script代码段埋下陷阱，诱导用户误操作触发。盗取用户密码或Cookie信息</li>
<li>SQL注入，通过URL注入的方式，制造恶意SQL语句，出现在<strong>动态拼接SQL语句</strong>的场景下。可以绕过认证、甚至破坏整个数据库</li>
<li>OS命令注入，类似SQL注入，出现在<strong>动态拼接OS语句</strong>的场景下。</li>
<li>HTTP首部攻击，出现在服务端响应头部使用了用户侧输入场景下，比如302响应中的Location头部可能存在的query部分。攻击者可以通过添加换行符，恶意添加新的首部字段，甚至篡改原有的响应主体</li>
<li>邮箱首部注入攻击，类似HTTP首部攻击</li>
</ul>
<p>类似地还有目录遍历漏洞、远程文件引用漏洞。</p>
<p>通过上面几种攻击方式，可以看到，<strong>永远不要信任用户侧输入</strong>，<strong>使用白名单机制，禁止动态拼接用户输入的语句</strong>。</p>
<h3 id="设计缺陷相关攻击方式"><a href="#设计缺陷相关攻击方式" class="headerlink" title="设计缺陷相关攻击方式"></a>设计缺陷相关攻击方式</h3><ul>
<li>强制浏览，在服务器公开目录下，浏览开发者本非自愿公开的文件。</li>
<li>不正确的系统错误处理方式，数据库等内部系统抛出的错误，对用户毫无帮助，反倒能让攻击者看到服务背后的一些细节。包括，数据库错误、PHP等脚本错误、Web服务器的错误</li>
<li>开放重定向，网站有诸如<code>?redirect=xxx</code>的path可以重定向时，一定要对redirect后的网址进行白名单控制，防止成为钓鱼攻击的跳板</li>
</ul>
<h3 id="session相关"><a href="#session相关" class="headerlink" title="session相关"></a>session相关</h3><ul>
<li>XSS盗取cookie，伪装用户登录</li>
<li>发送恶意链接，强制用户使用攻击者指定的session ID</li>
<li>CSRF，跨站信息伪造，在带有用户信息的domain里留下恶意的网络请求，伪造用户发起请求，伪造请求可以通过<code>&lt;img src=&quot;xx&quot; /&gt;</code>, <code>&lt;video src=&quot;xxx&gt;&lt;/video&gt;</code>等多种形式</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>穷举法破解密码，暴力破解。使用图片验证码、手机验证码、机器检测等方式限制同IP的访问频率。<ul>
<li>彩虹表。使用salt，增加破解难度</li>
</ul>
</li>
<li>撞库。建议用户在不同域内使用不一样的密码</li>
<li>点击劫持，使用透明元素覆盖在目标网页上。在18+网页中最常出现（😂）。</li>
<li>DoS（Denial of Service）拒绝服务攻击，构造大量合法的网络请求，导致服务器超负荷。通常都是DDoS（Distributed Denial of Service）的形式。需要在IP层去过滤攻击的IP。</li>
<li>后门程序</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/09/02/dont-make-me-think-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/09/02/dont-make-me-think-note/" class="post-title-link" itemprop="url">《Don't make me think》 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-02 23:46:37" itemprop="dateCreated datePublished" datetime="2018-09-02T23:46:37+08:00">2018-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-09-13 01:00:18" itemprop="dateModified" datetime="2018-09-13T01:00:18+08:00">2018-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/09/02/dont-make-me-think-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/02/dont-make-me-think-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原版链接: <a target="_blank" rel="noopener" href="https://book.douban.com/subject/25820714/">https://book.douban.com/subject/25820714/</a></p>
</blockquote>
<h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><ul>
<li>减少用户思考</li>
<li>减少用户心理负担</li>
</ul>
<p>原因： 用户时间有限，界面必须易于理解</p>
<h2 id="用户的使用方法"><a href="#用户的使用方法" class="headerlink" title="用户的使用方法"></a>用户的使用方法</h2><ul>
<li>82原则，只扫描感兴趣的</li>
<li>用户只寻求一个可行而非最优的答案</li>
<li>用户并不关心产品如何运作，会按照某个可用的方式一直使用下去</li>
</ul>
<h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><ul>
<li>利用习惯性思维，包括页面位置、使用方法、元素外观这些被培养起来的习惯。如无必要，勿增实体。</li>
<li>层次分明，逻辑上的关联能从视觉上直接体现；能够划分区域</li>
<li>明确标识可交互元素；提高信噪比，减少不必要视觉干扰</li>
<li>标题更靠近关联的内容，突出关键词汇</li>
<li>减少冗余文本，包括欢迎语、指示文字</li>
</ul>
<h2 id="Web导航"><a href="#Web导航" class="headerlink" title="Web导航"></a>Web导航</h2><p>重要性：</p>
<ul>
<li>用户在web中感受不到方位</li>
<li>用户需要更快地达成目标</li>
</ul>
<p>习惯用法：</p>
<ul>
<li>导航部分（或是某些公用部分）固定出现在页面同样位置，会让用户能<strong>立即确认</strong>自己还处在这个网站里<ul>
<li>在<strong>市场类应用</strong>里，包括站点ID、栏目、实用工具、搜索</li>
</ul>
</li>
<li>站点ID需要有独特可区分的设计</li>
<li>一个返回首页的导航链接</li>
<li>简洁明了的搜索框<ul>
<li>简单的按钮文案</li>
<li>减少无用的提示文字</li>
<li>明确可能的搜索选项（如果有的话）</li>
</ul>
</li>
<li>每个页面需要有个名字（保留意见）<ul>
<li>合适位置</li>
<li>引人注目</li>
<li>和链接保持尽量一致</li>
</ul>
</li>
<li>明确告诉用户“我在哪儿”<ul>
<li>面包屑</li>
<li>tab</li>
</ul>
</li>
<li>上述元素主要的原因：<strong>现实生活中，用户并不会按照设计师规划好的路径访问网页，可能会来自分享链接、搜索引擎，并不能保证从入口进入。要能让用户在任意一个页面都可以清楚明白它要完成某项任务的话，应该如何使用当前这个网页。</strong></li>
</ul>
<h2 id="吸引用户时需要注意的地方"><a href="#吸引用户时需要注意的地方" class="headerlink" title="吸引用户时需要注意的地方"></a>吸引用户时需要注意的地方</h2><p>主页要能传达整体印象。必须能显而易见地直截了当地明白：</p>
<ul>
<li>这是什么网站</li>
<li>我能在里面做什么</li>
<li>网站里有什么</li>
<li>为什么选择这个网站</li>
</ul>
<p>在用户弄清楚这些问题的最初几秒甚至是最初几毫秒，是决定你能否留住他的关键（晕轮效应）。而且因为上面加粗字体的原因，你可能要在主页外的其他页面也保证这一点。</p>
<p>一些手段：</p>
<ul>
<li>靠近站点ID的简洁的slogan</li>
<li>一些推介语</li>
<li>以明确主张为目标占用空间</li>
<li>在描述使命时保证坦诚</li>
<li>ab test和数据说话</li>
</ul>
<p>好口号和好的站点ID一样，是非常重要的。它需要至少有下面几点特征：</p>
<ul>
<li>清晰简洁、言之有物</li>
<li>明确产品特色与优势，最好是只有你能适用，别的产品都用不了的那种</li>
<li>最好能再个性、俏皮一点</li>
</ul>
<p>当然你们公司足够出名的话，上面这些就当不存在就行。</p>
<p>接下来的任务就是，告诉用户该<strong>从哪里开始</strong>和避免滥用首页推介。</p>
<h2 id="怎样减少信仰讨论"><a href="#怎样减少信仰讨论" class="headerlink" title="怎样减少信仰讨论"></a>怎样减少信仰讨论</h2><ul>
<li>避免关于个人喜好的讨论（如：“我不喜欢下拉框”）</li>
<li>针对场景，根据经验选择（如：“我认为这种场景下不适合下拉框”）</li>
<li><strong>充分测试，数据说话反哺经验</strong></li>
</ul>
<h2 id="如何进行可用性测试"><a href="#如何进行可用性测试" class="headerlink" title="如何进行可用性测试"></a>如何进行可用性测试</h2><p><em>当下的互联网公司迭代速度之快，可能并没有时间做这方面的研究。</em></p>
<p>区分开焦点测试（类似于种子用户，听取他们的使用感受和反馈）和可用性测试。</p>
<ul>
<li>焦点测试在早期阶段</li>
<li>可用性测试持续进行</li>
<li>周期性（比如一个月）进行可行性测试</li>
<li>暴露严重问题，因为团队可能并没有资源解决所有问题</li>
<li>应该有个主持人</li>
</ul>
<p>最有可能的测试流程：</p>
<ul>
<li>介绍部分</li>
<li>简单的提问部分，了解测试者的背景</li>
<li>简单的主页浏览，询问感受</li>
<li>完成测试任务</li>
<li>问题询问</li>
</ul>
<p>典型的问题:</p>
<ul>
<li>用户不清楚概念</li>
<li>用户找不到想要的字眼</li>
<li>内容太多了</li>
</ul>
<h2 id="移动时代带来的挑战"><a href="#移动时代带来的挑战" class="headerlink" title="移动时代带来的挑战"></a>移动时代带来的挑战</h2><ul>
<li>狭小空间的约束<ul>
<li>用户需要立即完成或经常重复的工作应该一样就能看到</li>
<li>其他的事情应该轻点几下就能完成，而且有显而易见的路径到达</li>
</ul>
</li>
<li><strong>兼容多平台的UI解决银弹是很难的</strong></li>
<li>在UI上给用户足够的按钮，比如一个有着三维样式闪着光的按钮</li>
<li>意识到没有光标了</li>
<li>应用最好能“让人快乐”</li>
<li>移动应用尤其需要<strong>可学习</strong>，然后是<strong>可记忆</strong></li>
</ul>
<h2 id="用户的好感度"><a href="#用户的好感度" class="headerlink" title="用户的好感度"></a>用户的好感度</h2><p>降低好感度的几种方式</p>
<ul>
<li>隐藏用户想要的信息</li>
<li>对用户交互不宽容</li>
<li>询问用户过多信息</li>
<li>敷衍用户</li>
<li>看上去不专业</li>
</ul>
<p>如何提升好感度</p>
<ul>
<li>知道用户想要什么</li>
<li>简明易懂</li>
<li>看上去花了心思</li>
<li>知道用户的可能问题，并给予解释</li>
<li>提高鲁棒性</li>
</ul>
<h2 id="如何说服你的老板推进可用性"><a href="#如何说服你的老板推进可用性" class="headerlink" title="如何说服你的老板推进可用性"></a>如何说服你的老板推进可用性</h2><p>略</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/08/16/git-workflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/08/16/git-workflow/" class="post-title-link" itemprop="url">git工作流最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-08-16 23:28:34 / 修改时间：23:29:29" itemprop="dateCreated datePublished" datetime="2018-08-16T23:28:34+08:00">2018-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/08/16/git-workflow/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/08/16/git-workflow/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md">my-git&#x2F;git-workflow-tutorial.md at master · xirong&#x2F;my-git</a></p>
</blockquote>
<p>git工作流有多种使用方法，在实际工作中的不良工作习惯，会造成很让人头大的麻烦。下面距离一些常用的工作流。</p>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>类似SVN，集中式工作流以中央仓库作为项目所有修改的单点实体，只用到master这一个分支。<strong>开发者提交功能修改到中央库前，采用<code>rebase</code>的方式“在其基础上添加自己的修改”，得到完美的线性历史；遇到冲突时，通过<code>git status</code>和<code>git add</code>合并冲突</strong>。最后<code>git rebase --continue</code>即可。遇到困难无法进行下去时，<code>git rebase --abort</code>就可以撤回到rebase前的状态。</p>
<p>在这种工作流下，使用<code>rebase</code>参数比不使用的<code>git pull</code>好处在于，rebase后的提交记录会少一次累赘的“合并提交”。</p>
<h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>git相较SVN强大在分布式的特征。功能分支工作流主要针对新增功能集成到正式项目。功能分支工作流仍然以中央仓库为基础，但不是直接提交本地历史到各自的本地master分支，而是在开发新功能时<strong>创建新的分支，描述新功能</strong>。不同的功能分支相互隔离，同时也保证master分支的代码一定没有问题。一旦功能分支push到master，意味着功能与其他开发者共享。</p>
<p>合并到master分支的过程通过创建pull request进行，在pull request请求中，让其他开发者有机会先去review变更。Pull request被接受后，剩下的工作就和集中式很像了，拉取master分支代码，合并，提交。</p>
<p>工作流程上：</p>
<ol>
<li>先checkout功能分支</li>
<li>做本地开发提交，以及<code>push -u</code>推送到远端分支（<code>-u</code>是跟踪远端对应分支的意思）</li>
<li>完成开发后，提交pull request，请求合并远端功能分支到master，团队其他成员可以进行评论</li>
<li>在接受前，团队<strong>所有成员</strong>有需要，可以提交自己的修改到该功能分支，也会显示在pull request里</li>
<li>在pull-request被接受后，在本地master上可以用pull或者<code>pull -r</code>的方式合并功能分支，前者更像功能和原来代码的合并，后者更偏向线型的提交历史</li>
</ol>
<h3 id="gitflow"><a href="#gitflow" class="headerlink" title="gitflow"></a>gitflow</h3><p>Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。相较功能分支更复杂，但也更健壮。仍然用中央仓库作为所有开发者的交互中心。相对于使用仅有的一个master分支，Gitflow工作流使用两个分支来记录项目的历史。master分支存储了正式发布的历史，而<strong>develop分支作为功能的集成分支。</strong>从而可以在master的<strong>所有提交附上版本号</strong>。</p>
<p>每个新功能位于一个自己的分支，有着和功能分支一样的开发工作流，唯一不同的是，功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。每次合并都位于develop分支。</p>
<p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就<strong>从develop分支上checkout一个发布分支release</strong>。从这个时间点开始之后新的功能不能再加到这个分支上——这个分支只应该做Bug修复、文档生成和其它面向发布任务。在release工作完成后，合并release分支到master，并加上tag。同时，<strong>release上做的修改要合并会develop分支</strong>。最后删除release分支。</p>
<p>维护分支或说是热修复（hotfix）分支用于给产品发布版本（production releases）快速生成补丁，这是唯一可以直接从master分支fork出来的分支。修改完成后，修改应该立马合并回master和develop。master也应该为合并生成新的tag。</p>
<h3 id="forking"><a href="#forking" class="headerlink" title="forking"></a>forking</h3><p>Forking工作流是分布式工作流，可以安全可靠地管理大团队的开发者（developer）和不信任贡献者（contributor）的提交。这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。</p>
<p>新开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。这个仓库拷贝作为他个人公开仓库 —— 其它开发者不允许push到这个仓库，<strong>但可以pull下来修改</strong>。要提交本地修改时，push提交到自己公开仓库中 —— 而不是正式仓库中。 然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。为了集成功能到正式代码库，<strong>维护者pull贡献者的变更到自己的本地仓库中</strong>，检查变更以确保不会让项目出错， 合并变更到自己本地的master分支， 然后push master分支到服务器的正式仓库中。到此，贡献的提交成为了项目的一部分，其它的开发者应该执行pull操作与正式仓库同步自己本地仓库。</p>
<p>具体来说，大致有下面几步：</p>
<ol>
<li>开发者fork正式仓库</li>
<li>开发者clone自己的fork出来的仓库，与之前工作流不一样的是，<strong>Forking工作流需要2个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。</strong>，像下面这样  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://bitbucket.org/maintainer/repo</span><br></pre></td></tr></table></figure></li>
<li>开发者修改都是私有的，如果项目往前走了，可以用git pull获得新的提交</li>
<li>开发者准备分享新功能时，需要先push到自己的公开仓库中，然后发起pull request通知项目维护者，集成开发者的功能分支</li>
<li>项目维护者通过GUI岔开pull request或者pull代码到自己的本地仓库，再手动合并。</li>
<li>开发者通过<code>pull upstream master</code>的方式拉取项目最新进展</li>
</ol>
<h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><p>pull request用于合并不同分支或不同仓库的代码，并在合并前进行一些讨论和代码微调，在上面不同工作流的情况下具体功能体现也不同。</p>
<p>上面几种工作流范式只是几种标准的建议，正式的项目版本管理中，可以糅合上面的一些特点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/blog/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/30/">30</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:11</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/14/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">151</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">463</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/11/22/selfish-gene/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/11/22/selfish-gene/" class="post-title-link" itemprop="url">《自私的基因》——生命的必然性和偶然性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-22 23:36:28" itemprop="dateCreated datePublished" datetime="2018-11-22T23:36:28+08:00">2018-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-11-24 00:15:33" itemprop="dateModified" datetime="2018-11-24T00:15:33+08:00">2018-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/11/22/selfish-gene/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/22/selfish-gene/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《自私的基因》是道金斯在上世纪70年代写的一本关于生物学的经典著作。书中从“自私的”复制因子基因的角度出发，推导出生物学、社会学各个方面的规律猜想，乃至最后上升到对生命、人类产生的必然性和偶然性的大胆设想。全书从第5章起，开始引人入胜，内容渐入佳境，让人手不释卷。其中对于代际、两性出现、共生群居等方面的探讨，令我有三观再塑之感。尽管前几章对复制因子基因的“自私性”和生存机器铺垫甚多，有点拖沓，整体还是很值得一读的。另外，把《自私的基因》和《人类简史》连在一起思考，甚至有更奇妙更透彻的感觉。</p>
<h2 id="对“自私的基因”一词的解释"><a href="#对“自私的基因”一词的解释" class="headerlink" title="对“自私的基因”一词的解释"></a>对“自私的基因”一词的解释</h2><p><strong>生物的进化的最基本单位是基因而不是生物个体</strong>。因为基因有复制性，可以控制个体性状。生物的生存繁衍等一切行为的本质是基因带来的。成功基因的标志是可以在复制中不断战胜其余复制因子，<strong>这个过程是“盲目的”。基因是不会做选择的，做选择的是自然环境</strong>。经过自然选择留下来的成功基因，自然是生存能力最强，留下复制最多的，看上去也是最“自私的”。自私一词是有些感性，但是它是对成功基因最恰当的形容了。你可以把它和<strong>“不被淘汰”</strong>等同。</p>
<h2 id="复制因子"><a href="#复制因子" class="headerlink" title="复制因子"></a>复制因子</h2><p>基因作为自然界诞生的产物，更通用的说法可以叫<strong>复制因子</strong>。在复制因子出现之前，自然界一片混沌，各种大分子在“分子汤”内自由游荡，随意组合，我们很难把它们叫做“个体”。直到有一天（说得不大严谨）出现了第一个复制因子。它们不见得是分子汤里最大的，但是它有可贵的性质——能复制自身。这个偶然性虽然非常之小，但是<strong>一旦出现就会不可逆的扩张开来</strong>。以至于复制因子一旦出现就会占据整个分子汤的主要地位，它会必然地在海洋里疯狂复制自己的拷贝。</p>
<p>很有可能基因只不过是一种复制因子，在基因出现前甚至出现之初，可能甚至很可能有类似基因的其他复制因子。复制因子之间必定会有胜利和失败者，因为分子汤资源是有限的，不足以维持无限量的复制。现在看来，最终基因胜利了。在基因的竞争和演化中，逐渐出现了蛋白质的保护膜，更多的基因渐渐聚合起来，蛋白质分工逐渐明确，生存机器由此产生。<strong>人不过也是一种生存机器罢了</strong>，“操纵”这个机器的是背后的基因。</p>
<p>另外，复制过程当然不会是完美无缺的，因此产生的多样性，让生存机器间也出现了越来越大的形态差异。</p>
<h2 id="基因与染色体"><a href="#基因与染色体" class="headerlink" title="基因与染色体"></a>基因与染色体</h2><p>我们生物都是同一种复制因子——DNA的生存机器，基因在染色体中，它通过蛋白酶监督着蛋白质的生成，并通过蛋白质控制生物性状。基因对生物的控制是<strong>“单向”的</strong>，也即后天所学是无法改变基因并遗传给后代的。个体的存活时间可能很有限，但是基因不断复制和交叉会一代代传递下去。</p>
<p>基因的复制最好是完美无缺的，自然选择对失误的复制惩罚往往很严重，如染色体丢失、倒位很容易导致个体的死亡。但是也有些复制失误不会造成那么大问题，只是在个体的一生逐渐积累，这也就是衰老。成功基因的标志除了“自私”，即能传递自身，还要保证和其他基因的通力合作下，能让生存机器的死亡至少推迟在生殖以后。有种观点认为性“促进了在单个个体内积累以往出现在不同个体内的有利突变”。</p>
<p>所谓<strong>进化就是指基因库中某些基因变多了，而另外的变少了的过程</strong>。</p>
<h2 id="基因机器"><a href="#基因机器" class="headerlink" title="基因机器"></a>基因机器</h2><p>基因通过合成蛋白质，进而由神经控制和激素控制控制生物个体。控制下个体的每一次行为都是一次选择，在自然选择后留下的都是适于当前环境的。动物的行为无论是利己的还是利他的，都在基因控制之下，基因是主要的策略制定者，大脑则是执行者，并接管了很多决策职能。</p>
<p>一个生存机器对另外生存机器的行为或神经系统施加影响时，前者就是在和后者联络（communication）。这也让基因的影响力能辐射到另外的个体，产生相互的影响。即下章会提到的行为。</p>
<h2 id="博弈论下的动物行为"><a href="#博弈论下的动物行为" class="headerlink" title="博弈论下的动物行为"></a>博弈论下的动物行为</h2><p>动物间的搏斗是<strong>克制且按规则</strong>进行的，因为不分青红皂白地杀死对手并无明显的好处，在一个庞大复杂的竞争系统中，除掉一个对手不见得就是好事，但是把特定对手杀死或者至少搏斗一番是个好主意。在行为双方都可以做选择时，博弈论的理论告诉我们，在大量样本的情况下，会有进化上的稳定策略（ESS）。而偏离ESS的行为将会受到自然选择的惩罚。</p>
<p><em>（关于鹰和鸽子策略的探讨篇幅过长，建议网上查看，便于理解ESS）</em></p>
<p>进化中的稳定策略无处不在，且不止一种策略会留在最后的稳态中（稳定的多态性）。在行为双方能力不对称（这是常态）且行为双方有记忆时，开始个体的胜利或失败可能是完全偶然的，但是随着搏斗的进行，个体间会自动归类成等级，避免激烈的搏斗，从而产生了阶级。按照博弈论思路下的推导，一个种群内可能会从一个ESS跳到另一个ESS，伴随着环境不断进步。</p>
<p>不过，面对和自己有着很多共同基因的近亲，这种讨论就失效了。基因 + 自然选择必然会留下特地照顾自身复制的基因。这方面讨论见下一章。</p>
<h2 id="亲代行为与计划生育"><a href="#亲代行为与计划生育" class="headerlink" title="亲代行为与计划生育"></a>亲代行为与计划生育</h2><p>经过自然选择的基因必然具有一个特质：最大程度的复制自身。基因有没有一些比较合情理的“识别”自身复制的方法呢？有，其中一个就是<strong>个体的近亲</strong>。这显然是亲代对子代利他性行为普遍存在的原因。父母之爱是亲代之爱的一种特殊情况。亲代间基因的相似度显然是不同的，血缘关系越近，基因相似度越高，对应的 利他性行为也会越显著。很明显兄弟姐妹之爱不如父母之爱来得那么普遍（只从天生层面讲）。</p>
<p>然而父母对子代的关心不会一直持续。因为父母对一个个体的关怀可以分为两个阶段：<strong>生育幼儿</strong>，<strong>养育幼儿</strong>。从基因“自私”的一面来讲，亲代理应最大限度生育后代。但是事实却不是这样，一大原因是野生动物生存困难，几乎永远不可能因衰老死亡，疾病、饥饿、捕食者种种隐私很容易导致野生个体死亡。而且可以观察到，野生生物通常会控制自己生育后代的数目，即“计划生育”，这是因为，计划生育在资源和生存条件恶劣的情况下，反而能最大限度增加子代的存活数。节制的剩余数目反而是当前环境的最优解。过度生育的个体会被自然选择惩罚。</p>
<h2 id="代际的竞争"><a href="#代际的竞争" class="headerlink" title="代际的竞争"></a>代际的竞争</h2><p>亲代对子代的投资往往是不均等的，同时对某个子代的投入，必然是以牺牲对其他子代投入为代价的。子代为了保证自己的存活，往往会竭尽所能甚至是欺骗。同时，亲代在自身随着衰老养育能力下降后，通常会有生殖能力逐渐消失的现象（尤其是雌性），因为此时对子女的投入不如对孙子孙女的投入平均回报大。雄性往往是逐渐衰退的，原因可能是，父亲对子女的投资额比不上母亲。幼儿的哺乳期不宜过长，到尚未出生的弟弟妹妹因为他继续吃奶蒙受的损失超过从他那里得来好处的数倍时，他就不应再吃下去了。广义的断奶由此出现。</p>
<p>然而，子代为了自己利益的最大化，和亲代的目标必然有分歧，最终的结局是两方理想条件的某种妥协。我们不要指望子代个体本性里有利他主义的成分，<strong>道德准则和基因里的本性是两回事</strong>。</p>
<p>这里要再强调一下，从基因到个体的“自私”表现，都是经过自然选择的必然结果，不自私的基因和个体都在激烈的竞争中被淘汰了。</p>
<h2 id="两性"><a href="#两性" class="headerlink" title="两性"></a>两性</h2><p>生物大多有性别之分，尤其是有性生殖个体。在生殖上，可以说每个配偶的本性都应该会设法利用对方，迫使自己少投资，对方多投资。那两性是如何出现的呢？我们知道两种生殖细胞，一种细胞（卵细胞）较大，数量少，营养物质充足，不灵活；另外一种（精子）较小，数量巨大，身材瘦小，灵活。明显卵细胞一方投资较多，看起来是精子那一方占了便宜，为什么会这样呢？假设最开始两种生殖配子是差不多的性质，<strong>一旦这种配子间的分歧产生，性质偏向卵细胞的一方在诞生个体上就会更有优势，而偏向精子的一方在寻找对象上（量大，灵活）也会更有优势，而性质介于两者之间的生殖配子就会收到自然选择的惩罚</strong>。从而这种差异就像脱缰的野马，一发不可收拾，到两者的形态到达再继续变化就要被惩罚的稳态，即现在这个模样。</p>
<p>而精子代表的一方就成为了雄性，卵子一方成为了雌性。从上面的理论可以自然推测出，朝着尽量多诞生复制的目标下，雄性个体数目较之雌性个体会越来越少（因为雄性个体可以很轻易产生大量精子，对应到大范围的雌性）。但是现状很显然不是这样，男女比例是很接近的。原因是，生育一个儿子的基因较之生育女儿极有可能会复制自己出现在成为大量后代中。 在基因朝着多生育儿子的趋势前进时，自然地就平衡了之前男少女多的情况。<strong>生育相同数目的儿女的策略是进化上的稳定策略</strong>。</p>
<p>对生育个体而言，他或她在其中投资的越少，所能生育的子女就越多。但是雌性<strong>由于卵细胞的存在</strong>，个体往往从自己体内诞生，个体一旦死亡，自己比做父亲的要蒙受更大损失。顺便补充有趣的一点，在鱼类中情况是反过来的，有一种可能是，鱼类的交配过程是共同排出生殖细胞到水中完成交配，而不是在雌性个体内。这时情况就变了，谁先排出生殖细胞就更易把责任推给另一方（值得商榷），卵细胞相对较大，在水中不易散逸，精子则很容易散逸。所以雄鱼通常得等在雌性后面排出生殖细胞，而被迫承担养育责任。</p>
<p>说回来，在交配完成后，双方都要冒着被对方抛弃的危险（雌性可以遗弃还未诞生的个体，所以雄性也有风险）。在这种博弈情况下，有一些常见策略，如“家庭幸福”和“大丈夫”。前者指在交配前，双方仔细观察对方忠诚和眷恋家庭生活的可能迹象，“订婚期”长对雄性个体也有利，因为他有上当受骗，抚养其他雄性个体所生子女的风险。在雄性有忠诚、薄情两种决策，雌性有忸怩、放荡两种决策下，较多忠诚和较多忸怩以及较少薄情和较少放荡会达到一种稳态。大丈夫策略下，则是根据雄性个体素质进行选择，保证子代更加健壮，从而更容易拥有交配权。素质判断的过程随着雄性偶尔的欺骗出现，会向着<strong>雄性某些表征愈发明显和雌性观察力愈发敏锐发展</strong>。表征明显得有时甚至略显夸张，这一方面也是种“炫耀”，炫耀自己拥有一些<strong>累赘</strong>也依然能活的很好。</p>
<p>雌性因为卵子的自愿地位，不必像雄性个体那样，仅仅具有性吸引力就能保证自己的卵子有受精机会，所以在交配问题上更加挑剔（比如雌驴会避免和雄马交配，生育出没有生育能力的骡子），雄性则相反，需要具有更加吸引人（尤其是雌性）的种种性状。同时，凡是存在乱伦禁忌的地方，可以认为雌性会比雄性更严守此这种禁忌。</p>
<h2 id="共生和合作"><a href="#共生和合作" class="headerlink" title="共生和合作"></a>共生和合作</h2><p>生存机器间除了搏斗、亲代、有性参与的相互作用，还有共生和合作的存在。比如鸟群和鱼群的存在。有些群体个体会警告其余个体危险的存在等等。这些看似利他性行为实际都可以从有利自己生存的角度考虑。</p>
<p>蚂蚁、蜜蜂、裸鼹鼠等物种的<strong>职虫不育性</strong>是个很有趣的现象。它们的个体间营社会性生活。这其实是把生育和抚育策略结合在一起进化的结果。这个现象和雌虫的生殖特性密切相关。雌虫生育的个体都是<strong>单倍体</strong>，兄弟姐妹间基因的相似度甚至高于自己生育的后代的相似度。相比自己繁殖养育，不如“耕耘”有生殖力的母体，趋势母体提高繁殖力，复制自己的基因。同时，往往这种生物生存的环境资源有限，外出繁育ROI较低。</p>
<p>在共生现象中，双方都有骗子和傻瓜两种策略，但在斤斤计较策略存在的情况下，骗子策略会被渐渐战胜。有观点认为，人类细胞不过是共生微生物的结果，而我们本身也是不同基因共生的群体结果。</p>
<h2 id="推广到文化"><a href="#推广到文化" class="headerlink" title="推广到文化"></a>推广到文化</h2><p>正如《人类简史》里面所说，涉及到道德、规范、法律、文化的领域，就进入了人类的想象空间。复制因子的规律能否推广到“文化因子”（meme）中是个不错的尝试。不过meme本身是可以人为操纵，而不是“盲目的”。和基因不同，数学模型和概念在此很难有用武之地，试图对人类意识的探讨更易让类比有刻意引申之嫌。</p>
<h2 id="好人好报"><a href="#好人好报" class="headerlink" title="好人好报"></a>好人好报</h2><p>在个体合作时，基于合作和背叛两种基本元素，可以产生很多合作策略。当合作明确只能做一次时，双方会面临<strong>“囚徒困境”</strong>，即个体的最优解不是整体的最优解。但是，<strong>合作明确会持续进行，且看不到终点时</strong>（看不到终点很重要，因为有终点存在，整个信任就会从最后一次合作的倒推开始崩塌），这个“零和问题”变成了“<strong>非零和问题</strong>”。这种情况下，拥有<strong>宽容</strong>，<strong>善良</strong>，<strong>不嫉妒</strong>特质的合作策略会在各种策略中获胜，并最终达到稳态。</p>
<p><em>描述过程见书第十二章，写的很有意思</em></p>
<p>总结来说，<strong>未知的</strong>，<strong>长期的</strong>，<strong>非零和</strong>进化博弈下，好人会取得最终的胜利，并占据大多数。</p>
<h2 id="生命的必然和偶然"><a href="#生命的必然和偶然" class="headerlink" title="生命的必然和偶然"></a>生命的必然和偶然</h2><p>最后一章里，我们总结一下前面所有的结论，并试图给出更透彻、更明白的一些结论。首先，个体生物即载体以努力传播自己基因为任务，同时对基因有利对整个生命体也有利。基因所能影响的只有蛋白质合成，再操纵细胞乃至整个生存机器，并最终“从自身身体中逃逸出”，操作整个外部世界，如海狸的河坝。这里我们考虑一下“寄生”和“共生”的区别。通过一些例子来看，最终的区别是<strong>寄生个体将基因传递给后代的方式是否和宿主基因一样</strong>。享有共同命运的寄生生物基因，最终会享有共同利益，停止寄生行为。比如绿色水螅和水藻的基因，以及甲虫和细菌的基因，寄生基因只能通过宿主的生殖细胞拥有未来。</p>
<p>推广一下，<strong>我们自己的基因通力合作，不是因为它们共享同一个身体，而是它们共享同一条出路——精子和卵子</strong>。如果能找到一条另外的出路，一些基因自然就会表现得不再合作。比如，人体内流感病毒的基因通过飞沫传递，狂犬病病毒之于狗也是这样。基因对于个体的控制比你想象得要厉害，给一个男人看女人身体的图片，便可以唤起其性冲动，甚至勃起，而这个过程中，他并没有被欺骗，认为图片是个真实的女人。虽然他知道是打印机打出的图片，他的神经系统依然有和面对真实女性一样的反应。我们的身体不过是“寄生”基因的集合体。自然选择偏向控制他人的基因，动物行为倾向于最大化此基因的生存。</p>
<p>总结下，<strong>共生的基因共享离开当前基因载体的共同渠道</strong>，个体如果想成为有效的基因载体，必须保证<strong>对所有其中的基因提供等概率的、通往未来的共同通道</strong>。最后回答三个问题。</p>
<p><strong>为什么基因汇聚在一起，形成细胞？</strong>，单个基因操纵的化学反应通常不足以合成所需的最终产物，一种蛋白酶需要在其他基因存在的情况下才能生长繁荣。</p>
<p><strong>为什么细胞会汇聚在一起，形成多细胞？</strong>，一方面是体型的优势，另一方面是便于分工，让每一个部件处理特定任务时更有效率。</p>
<p>最后一个，也是最有意思的问题。<strong>为什么生命体循环总有瓶颈般的受精卵阶段？</strong>，不论大象、蚂蚁都是这样。原因是，从部分个体开始的繁殖只能获得很少一部分改变，彻底的改变，只能从“设计图纸”开始，<strong>保证每一个个体都拥有干净的起点</strong>。瓶颈保证了生命循环继承的是图纸而不是成品。另外，这种瓶颈的存在，<strong>让生命循环定型，更有规律的重复</strong>。<strong>基因这种精确的行为规划是胚胎得意进化形成复杂组织和器官的先决条件</strong>，鹰的眼睛，燕子的翅膀，这些精确和复杂的器官不可能在没有时间规划下出现。最后，也是最关键一点，<strong>瓶颈的存在自然地带来的基因间的共同利益</strong>，因为所有的基因都需要通过瓶颈传给下一代，别无选择。</p>
<p>总结一下，生命循环成为“瓶颈状”，有生命的材料会渐渐聚在一起，形成独立而统一的生命体。生命材料越多，就有更多的载体细胞凝结努力，作用于特殊种类的细胞，使他们可以承载其共同的基因，通过瓶颈走向下一代。所有生命的基本单位和最初动力都是复制因子，没有任何复制过程是完美的，一些编译失去复制能力而灰飞烟灭。互惠的复制因子间可以帮助对方更好的生存，这些复制因子聚合一处形成了细胞，与而后形成的多细胞生命，由“瓶颈”生命循环进化而成的载体繁荣发展，逐渐变成愈加独立的载体。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/11/21/some-tips-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/11/21/some-tips-5/" class="post-title-link" itemprop="url">工作中的遇到的一些小知识 5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-11-21 23:06:54 / 修改时间：23:11:29" itemprop="dateCreated datePublished" datetime="2018-11-21T23:06:54+08:00">2018-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/11/21/some-tips-5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/21/some-tips-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="smooth-scroll"><a href="#smooth-scroll" class="headerlink" title="smooth scroll"></a>smooth scroll</h2><p>使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll">window.scroll API </a>，从MDN的文档来看，各浏览器的支持情况还不错。</p>
<p>或者自己通过<code>setTimeout</code>加上ease function实现难度也不大。</p>
<h2 id="React在老版本浏览器或Webview下的支持问题"><a href="#React在老版本浏览器或Webview下的支持问题" class="headerlink" title="React在老版本浏览器或Webview下的支持问题"></a>React在老版本浏览器或Webview下的支持问题</h2><blockquote>
<p>[JavaScript Environment Requirements</p>
</blockquote>
<ul>
<li>React](<a target="_blank" rel="noopener" href="https://reactjs.org/docs/javascript-environment-requirements.html">https://reactjs.org/docs/javascript-environment-requirements.html</a>)</li>
</ul>
<p>React 16依赖于ES6中的Map和Set特性。如果需要React运行在老版本的不支持ES6的浏览器或Webview下，需要<a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-polyfill">babel-polyfill</a>或<a target="_blank" rel="noopener" href="https://github.com/zloirock/core-js">core-js</a>的支持。</p>
<p>类似于下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/es6/map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/es6/set&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;babel-polyfill&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>需要格外注意的是，不论是import core-js还是import babel-polyfill，<strong>都一定要写在第一次<code>import React from &#39;react&#39;</code>的前面</strong>。否则是起不到polyfill React中ES6特性的效果的。</p>
<h2 id="一些老版本Android的坑"><a href="#一些老版本Android的坑" class="headerlink" title="一些老版本Android的坑"></a>一些老版本Android的坑</h2><ul>
<li>在伪元素如<code>:before</code>和<code>:after</code>使用动画会导致crash，<a target="_blank" rel="noopener" href="https://caniuse.com/#search=%3Abefore">caniuse</a>的known issues上只是说在safari v6版本和以下会有不支持的情况。</li>
<li>不支持不带前缀的<code>transform</code>…</li>
<li>不支持在<code>&lt;line&gt;</code>上的<code>stroke-width</code>属性上使用rem</li>
<li>不支持Element.matches方法</li>
</ul>
<h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><blockquote>
<p>wiki: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FFmpeg">https://en.wikipedia.org/wiki/FFmpeg</a><br>官网: <a target="_blank" rel="noopener" href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></p>
</blockquote>
<p>主要包含三个命令行指令：</p>
<ul>
<li>ffmpeg，多媒体转码</li>
<li>ffplay，基于SDL和ffmpeg的极简播放器</li>
<li>ffprobe，多媒体分析</li>
</ul>
<p>ffmpeg部分支持参数：</p>
<ul>
<li><code>-i</code>指定输入文件</li>
<li><code>-t</code>处理时间</li>
<li><code>-ss</code>起始时间</li>
<li><code>-b:a</code>或<code>-b:v</code>指定音频、视频的输出码率。</li>
<li><code>-r</code>fps 帧率</li>
<li><code>-s 1920x1080</code>设置帧大小</li>
<li><code>-c:a</code>或<code>-c:v</code>设置音频、视频编码器</li>
<li><code>-ac</code>声道数</li>
<li><code>-ar</code>音频采样率</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.ffmpeg.org/ffmpeg.html#Options">更多</a></p>
<h2 id="React-Router使用History路由时，不识别带‘-’的路径"><a href="#React-Router使用History路由时，不识别带‘-’的路径" class="headerlink" title="React Router使用History路由时，不识别带‘.’的路径"></a>React Router使用History路由时，不识别带‘.’的路径</h2><p>webpack-dev-server的配置里，增加<code>disableDotRule</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">historyApiFallback: &#123;</span><br><span class="line">    disableDotRule: true</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注，这样做会使xxx.html的形式也重定向到默认的index.html，在多入口的项目下会有问题。</p>
<h2 id="React-Hooks和React-Hot-Loader默认配置相冲突"><a href="#React-Hooks和React-Hot-Loader默认配置相冲突" class="headerlink" title="React Hooks和React Hot Loader默认配置相冲突"></a>React Hooks和React Hot Loader默认配置相冲突</h2><p>设置RHL的<code>pureSFC</code>配置为true，详见<a target="_blank" rel="noopener" href="https://github.com/gaearon/react-hot-loader/issues/1088#issuecomment-434862175">讨论</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setConfig(&#123; pureSFC: true &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的rollup配置样例"><a href="#一个简单的rollup配置样例" class="headerlink" title="一个简单的rollup配置样例"></a>一个简单的rollup配置样例</h2><p>最近有一个开发前端录音库（严格来说是改进）的需求，目标是发布到npm管理平台上，在打包库上<a target="_blank" rel="noopener" href="https://rollupjs.org/guide/en">rollup</a>的发挥要优于webpack。刚好想用用试试，就用了rollup作为打包工具。因为场景比webpack更简单，配置上也比webpack好配很多，基本看看<a target="_blank" rel="noopener" href="https://rollupjs.org/guide/zh#tutorial">官方文档</a>就可以上手了。</p>
<p>不过，文档里用的babel版本还是6.x，使用新版本babel后，配置文件<code>rollup.config.js</code>和<code>.babelrc</code>有些改动，这里列在下面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// rollup.config.js</span><br><span class="line">import resolve from &#x27;rollup-plugin-node-resolve&#x27;;</span><br><span class="line">import commonjs from &#x27;rollup-plugin-commonjs&#x27;;</span><br><span class="line">import babel from &#x27;rollup-plugin-babel&#x27;;</span><br><span class="line">import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    input: &#x27;src/index.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: &#x27;index.js&#x27;,</span><br><span class="line">        format: &#x27;es&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        resolve(),</span><br><span class="line">        commonjs(),</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude: &#x27;node_modules/**&#x27;</span><br><span class="line">        &#125;),</span><br><span class="line">        terser()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    presets: [</span><br><span class="line">        [</span><br><span class="line">            &#x27;@babel/env&#x27;,</span><br><span class="line">            &#123;</span><br><span class="line">                loose: true,</span><br><span class="line">                modules: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [&#x27;@babel/proposal-object-rest-spread&#x27;, &#123; loose: true &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>–END–</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/11/21/audio-recorder-improvement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/11/21/audio-recorder-improvement/" class="post-title-link" itemprop="url">前端录音方案优化实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-11-21 23:04:53 / 修改时间：23:35:20" itemprop="dateCreated datePublished" datetime="2018-11-21T23:04:53+08:00">2018-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/11/21/audio-recorder-improvement/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/21/audio-recorder-improvement/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在视听类业务或重交互的业务场景下，有时需要在前端采集用户语音。前端实现录音功能可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder">MediaRecorder</a>，或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">getUserMedia</a>结合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext">AudioContext</a>。其中，前一种方法的支持度惨不忍睹，使用getUserMedia的方式是较为常用的选择。</p>
<p class="img-tip" data-str="MediaRecorder支持度"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/87e5a7855500447eb22349f29814bdf5~noop.png' height=465 width=1261/></p>

<h2 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h2><p>在实现前端录音上，<a target="_blank" rel="noopener" href="https://github.com/mattdiamond/Recorderjs">Recorder.js</a>实现了一个基础可用版，不过它支持的可配置项很少，音频采样率、声道数、采样的比特位数都使用的采集配置的默认值。但在大多场景下，录音文件体积较大，4s的录音可以达到700 ~ 800KB，不利于网络传输，需要录音采集参数可配置，以优化文件体积。</p>
<p class="img-tip" data-str="4s录音的文件体积"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/c2f3c40147a4447fad41d3bea41c4256~noop.png' height=94 width=1178/></p>

<p>另外，有些场景录制的语音需要交给算法组做语音识别，对语音有特定要求：</p>
<ul>
<li>采样率16000Hz</li>
<li>单声道</li>
<li>采样位数16bit</li>
</ul>
<p>这时就需要一个优化的前端录音方案，支持根据输入配置修改音频流数据。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这里将原有录音方案的几个关键代码流程整理如下：</p>
<p class="img-tip" data-str="原有录音方案"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/5379450a44474160b9fa09e7dc7ee31d~noop.png' height=490 width=871/></p>

<p>其中：</p>
<ul>
<li>先调用<code>getUserMedia</code>获取音频流，并初始化一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a>。使用<code>connect</code>连接到<code>ScriptProcessorNode</code>上，并连续触发<code>audioprocess</code>事件。</li>
<li>在<code>onaudioprocess</code>事件处理函数中，拿到录音数据。根据当前<code>recording</code>的值判断是否写入<code>recBuffers</code>中。<code>recording</code>状态可以通过<code>record</code>和<code>stop</code>方法控制。</li>
<li><code>exportWAV</code>方法会触发导出流程，导出步骤里<ul>
<li><code>mergeBuffers</code>将<code>recBuffers</code>数组扁平化</li>
<li><code>interleave</code>将各声道信息数组扁平化</li>
<li><code>encodeWAV</code>为即将生成的音频文件写入音频头</li>
<li>最后<code>floatTo16bitPCM</code>将音频设备采集的元素范围在[0,1]之间的Float32Array，转换成一个元素是16位有符号整数的Float32Array中</li>
</ul>
</li>
<li>最后拿到的Blob类型数据可以本地播放或通过FormData上传服务端使用。<br>下面分几方面介绍录音方案优化的设计和实现。</li>
</ul>
<h3 id="音频头拓展"><a href="#音频头拓展" class="headerlink" title="音频头拓展"></a>音频头拓展</h3><p>要支持可拓展的采样率、声道、采样比特数，wav音频头也要动态配置。</p>
<p>WAVE格式是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">Resource Interchange File Format</a>（RIFF）的一种，其基本块名称是“WAVE”，其中包含两个子块“fmt”和“data”。结构上由WAVE_HEADER、WAVE_FMT、WAVE_DATA、采样数据4个部分组成。可以看到实际上就是在PCM数据前面加了一个文件头。WAVE类型文件整体结构图如下：</p>
<p class="img-tip" data-str="WAVE文件头示例"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/e5c3f9bc6d3545308fb50fc10ce64790~noop.png' height=449 width=673/></p>

<p>其中和采样率、声道、采样位数相关的字段有：</p>
<ul>
<li>NumChannels</li>
<li>SampleRate</li>
<li>ByteRate，等于SampleRate * BlockAlign</li>
<li>BlockAlign，等于ChannelCount * BitsPerSample &#x2F; 8</li>
<li>BitsPerSample</li>
</ul>
<p>这几个字段根据输入的配置项设置即可实现音频头拓展部分。<br>另外，需要注意的是其中字段有Big Endian和Little Endian的区分，对应在代码里，通过<code>setUint16</code>和<code>setUIint32</code>的最后一个入参决定。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">encodeWAV</span>(<span class="params">samples</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">44</span> + samples.<span class="property">length</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RIFF identifier */</span></span><br><span class="line">    <span class="title function_">writeString</span>(view, <span class="number">0</span>, <span class="string">&#x27;RIFF&#x27;</span>);</span><br><span class="line">    <span class="comment">/* RIFF chunk length */</span></span><br><span class="line">    view.<span class="title function_">setUint32</span>(<span class="number">4</span>, <span class="number">36</span> + samples.<span class="property">length</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* RIFF type */</span></span><br><span class="line">    <span class="title function_">writeString</span>(view, <span class="number">8</span>, <span class="string">&#x27;WAVE&#x27;</span>);</span><br><span class="line">    <span class="comment">/* format chunk identifier */</span></span><br><span class="line">    <span class="title function_">writeString</span>(view, <span class="number">12</span>, <span class="string">&#x27;fmt &#x27;</span>);</span><br><span class="line">    <span class="comment">/* format chunk length, PCM use 16 */</span></span><br><span class="line">    view.<span class="title function_">setUint32</span>(<span class="number">16</span>, <span class="number">16</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* sample format (raw), PCM use 1 */</span></span><br><span class="line">    view.<span class="title function_">setUint16</span>(<span class="number">20</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* channel count */</span></span><br><span class="line">    view.<span class="title function_">setUint16</span>(<span class="number">22</span>, numChannels, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* sample rate */</span></span><br><span class="line">    view.<span class="title function_">setUint32</span>(<span class="number">24</span>, sampleRate, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* byte rate (sample rate * block align) */</span></span><br><span class="line">    view.<span class="title function_">setUint32</span>(<span class="number">28</span>, sampleRate * numChannels * sampleBit / <span class="number">8</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* block align (channel count * bytes per sample) */</span></span><br><span class="line">    view.<span class="title function_">setUint16</span>(<span class="number">32</span>, numChannels * sampleBit / <span class="number">8</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* bits per sample */</span></span><br><span class="line">    view.<span class="title function_">setUint16</span>(<span class="number">34</span>, sampleBit, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* data chunk identifier */</span></span><br><span class="line">    <span class="title function_">writeString</span>(view, <span class="number">36</span>, <span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    <span class="comment">/* data chunk length */</span></span><br><span class="line">    view.<span class="title function_">setUint32</span>(<span class="number">40</span>, samples.<span class="property">length</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>通常前端录音的音频采样率是音频设备默认使用的44.1kHz（或48kHz）。开发者需要默认以外的采样率时（比如16kHz），可以在录音数据交给<code>encodeWAV</code>封装前根据新的采样率做重采样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compress</span>(<span class="params">samples, ratio</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = samples.<span class="property">length</span> / ratio;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">        result[index] = samples[index * ratio];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重采样的原理上，程序根据重采样和原始采用率的比值，间隔采样音频原数据，丢弃掉其他采样点数据，从而模拟采样率的等比例下降。</p>
<p><em>注：间隔丢弃原数据在重采样率是原采样率的整数倍分之一时（即1、1&#x2F;2、1&#x2F;3…）才不会损失用户音色。另外，重采样率比原采样率高时，需要在采样点中间额外插值，这里未实现；</em></p>
<h3 id="声道数"><a href="#声道数" class="headerlink" title="声道数"></a>声道数</h3><p>在<code>audioprocess</code>事件中，需要根据配置项中的声道数，从inputBuffer取对应声道数据，一般的处理下，会丢弃多余的声道数据。类似地，在存储声道数据时，也要灵活考虑配置项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">onaudioprocess</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">recording</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> buffer = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; <span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">numChannels</span>; channel++) &#123;</span><br><span class="line">        buffer.<span class="title function_">push</span>(e.<span class="property">inputBuffer</span>.<span class="title function_">getChannelData</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">record</span>(<span class="params">inputBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; numChannels; channel++) &#123;</span><br><span class="line">        recBuffers[channel].<span class="title function_">push</span>(inputBuffer[channel]);</span><br><span class="line">    &#125;</span><br><span class="line">    recLength += inputBuffer[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后导出时，根据声道数判断是否需要interleave的步骤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (numChannels === <span class="number">2</span>) &#123;</span><br><span class="line">    interleaved = <span class="title function_">interleave</span>(buffers[<span class="number">0</span>], buffers[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [interleaved] = buffers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>默认的采样位数是16位，在对音质或位数没有明确要求时，可以转成8位。</p>
<p>PCM16LE格式的采样数据的取值范围是-32768到32767，而PCM8格式的采样数据的取值范围是0到255。因此PCM16LE转换到PCM8需要将-32768到32767的16bit有符号数值转换为0到255的8bit无符号数值。实现上，见下面的对比：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">floatTo16BitPCM</span>(<span class="params">output, offset, input</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> initOffset = offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.<span class="property">length</span>; i++, initOffset += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> s = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, input[i]));</span><br><span class="line">        output.<span class="title function_">setInt16</span>(initOffset, s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">floatTo8bitPCM</span>(<span class="params">output, offset, input</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> initOffset = offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.<span class="property">length</span>; i++, initOffset++) &#123;</span><br><span class="line">        <span class="keyword">const</span> s = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, input[i]));</span><br><span class="line">        <span class="keyword">const</span> val = s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>;</span><br><span class="line">        output.<span class="title function_">setInt8</span>(initOffset, <span class="built_in">parseInt</span>(val / <span class="number">256</span> + <span class="number">128</span>, <span class="number">10</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方的<code>floatTo16BitPCM</code>是转换音频采样数据到PCM数据的原始方法，下面的<code>floatTo8BitPCM</code>方法中<code>parseInt(val / 256 + 128, 10)</code>做了16位到8位的转换。最后在封装音频数据为Blob类型时，根据采样位数使用不同函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">encodeWAV</span>(<span class="params">samples</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    sampleBit === <span class="number">8</span></span><br><span class="line">        ? <span class="title function_">floatTo8bitPCM</span>(view, <span class="number">44</span>, samples)</span><br><span class="line">        : <span class="title function_">floatTo16BitPCM</span>(view, <span class="number">44</span>, samples);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后，由于前端录音场景下，音频流基本都来自<code>getUserMedia</code>，为了减少模板代码，库里封装了一个static方法，快捷地直接由<code>getUserMedia</code>构造一个recorder对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">createFromUserMedia</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line">        <span class="attr">audio</span>: &#123;</span><br><span class="line">            <span class="attr">mandatory</span>: &#123;</span><br><span class="line">                <span class="attr">googEchoCancellation</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">                <span class="attr">googAutoGainControl</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">                <span class="attr">googNoiseSuppression</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">                <span class="attr">googHighpassFilter</span>: <span class="string">&#x27;false&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">optional</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">video</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">AudioContext</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Recorder</span>(context.<span class="title function_">createMediaStreamSource</span>(stream, config));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在之前提到了需要算法组音频识别的场景下，只需要在构造时指定配置项即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Recorder</span> <span class="keyword">from</span> <span class="string">&#x27;./audio-recorder&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">recorder</span> = <span class="title class_">Recorder</span>.<span class="title function_">createFromUserMedia</span>(&#123;</span><br><span class="line">    <span class="attr">sampleBit</span>: <span class="number">16</span>, <span class="comment">// 可省略</span></span><br><span class="line">    <span class="attr">numChannels</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">sampleRate</span>: <span class="number">16000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时，一个500ms的录音大概15KB，换算下来4s大约120KB，比此前的体积小了很多。在不强调音质的场景下，表现要好许多。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面的录音方案优化实践主要包含下面几点：</p>
<ul>
<li>WAVE音频头修改</li>
<li>重采样音频数据</li>
<li>丢弃多余的声道数据</li>
<li>转换16位音频数据到8位</li>
</ul>
<p>源码在<a target="_blank" rel="noopener" href="https://github.com/shenlvmeng/audio-recorder">这里</a>，欢迎使用与拍砖。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mattdiamond/Recorderjs">mattdiamond&#x2F;Recorderjs A plugin for recording&#x2F;exporting the output of Web Audio API nodes</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/50534316">视音频数据处理入门：PCM音频采样数据处理</a></li>
<li><a target="_blank" rel="noopener" href="http://soundfile.sapp.org/doc/WaveFormat/">Microsoft WAVE soundfile format</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/10/31/react-hooks-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/10/31/react-hooks-intro/" class="post-title-link" itemprop="url">React Hooks简要介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-31 23:32:17" itemprop="dateCreated datePublished" datetime="2018-10-31T23:32:17+08:00">2018-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-30 22:29:46" itemprop="dateModified" datetime="2019-06-30T22:29:46+08:00">2019-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/31/react-hooks-intro/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/31/react-hooks-intro/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">Hooks</a>是<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react?activeTab=versions">React v16.7.0-alpha</a>中引入的新特性，目前（2018年10月底）还在<a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/pull/68">讨论之中</a>。</p>
<p>关于这次改动，官网里特地表明<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html#no-breaking-changes"><strong>这不是Breaking Changes</strong></a>，并且向前兼容，大家可以放心地使用。在动机上：</p>
<ul>
<li>使用Hooks将便于开发者拆分和复用state<strong>管理的逻辑</strong>（而不是state本身）</li>
<li>使用Hooks将把Class组件中的React生命周期方法抽象成effects，根据需要插入</li>
<li>除了state和生命周期方法，React还将class提供的更多features拆分出来作为额外功能，按需使用</li>
</ul>
<p>下面将从上面几点分别展开介绍，并给出一些使用须知。</p>
<h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><p>根据上面所述，用来拆分和复用state管理逻辑。通常情况下，class组件中的state更新逻辑比较简单。和<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-state.html">官网给的例子</a>本质上没什么差别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Declare a new state variable, which we&#x27;ll call &quot;count&quot;</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useState</code>是State Hook提供的API方法，它只需<strong>1个入参</strong>，表示状态的初始值。返回一个pair：</p>
<ul>
<li>第一个元素，状态本身，类似<code>this.state.xxx</code></li>
<li>第二个元素，设置状态方法，类似<code>this.setState(&#123; xxx: &#39;foo&#39; &#125;)</code></li>
</ul>
<p><strong>需要注意的是，第二个元素，设置状态的方法不是增量更新，而是直接替换</strong>，这点和<code>setState</code>有区别。</p>
<p>在下面的渲染部分，直接使用状态名即可。当然这里只声明了一个需要的状态变量，需要新的状态变量（比如：<code>[fruit, setFruit]</code>）时，需要用同样的方法获得返回，像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare multiple state variables!</span></span><br><span class="line"><span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> [fruit, setFruit] = <span class="title function_">useState</span>(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = <span class="title function_">useState</span>([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]);</span><br></pre></td></tr></table></figure>

<p>可以看到，使用State Hook时，如何<strong>拆分state</strong>到各useState中是需要考虑的事情。</p>
<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p>Effect Hook用来处理<strong>React每次渲染完成后的副作用</strong>。它等同于<code>componentDidMount</code>, <code>componentDidUpdate</code>, 再加上<code>componentWillUnmount</code>。副作用分两种，需要cleanup和不需要cleanup的。</p>
<p><strong>不需要Cleanup</strong></p>
<p>通常的副作用包括数据请求、DOM修改等等。这些操作不需要清理占用的资源。使用时类似下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>useEffect</code>方法，传入一个函数作为唯一入参。这样，在<strong>每次render完成后（包含第一次render）</strong>，都会执行这个函数，去完成副作用的部分。</p>
<p>你可能有些疑惑，如果我有某个副作用，只在componentDidMount使用一次，比如获取DOM ref这种呢？另外，每次重新渲染后，如果副作用依赖于当前的状态值，难道还需要写if语句判断状态有没有变化吗？接着，往下看。</p>
<p><code>userEffect</code>这个方法可以有第二个入参，这个入参是数组类型，表示这个effects所依赖的内部状态。（<strong>注意：这个状态必须是上面用<code>useState</code>声明的</strong>）只有数组内的状态变化时，React才会去执行第一个入参的函数。</p>
<p>另外，数组为空时，表示函数没有依赖，即只在componentDidMount时执行一次即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// Only re-run the effect if count changes</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This component has been rendered.&#x27;</span>);</span><br><span class="line">&#125;, []); <span class="comment">// Only re-run at the first rendering</span></span><br></pre></td></tr></table></figure>

<p>最后，<code>useEffect</code>是异步完成的，即不会block浏览器更新屏幕内容，以节省资源。在一些不常见的场景，如需要测量当前布局时，需要用同步的<code>useLayoutEffect</code>。</p>
<p><strong>需要Cleanup</strong></p>
<p>有的副作用以添加事件监听、设置定时器等等的subscription的形式进行，这些在组件销毁后需要释放掉占用的资源，避免内存泄漏。类似你之前在<code>componentWillUnmount</code>里写的逻辑。</p>
<p>React用<code>useEffect</code>表示这个副作用的清除操作。用法类似<code>setTimeout</code>，用返回值作为handler。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="comment">// Specify how to clean up after this effect:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在实际运行时，一个Effect在组件re-render时都会被重新销毁再重建，以便于在componentDidUpdate时，也能跟踪到副作用内使用的状态的最新值。上面那段代码可能会遇到下面这样的实际运行情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount with &#123; friend: &#123; id: 100 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">100</span>, handleStatusChange);     <span class="comment">// Run first effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with &#123; friend: &#123; id: 200 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">100</span>, handleStatusChange); <span class="comment">// Clean up previous effect</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">200</span>, handleStatusChange);     <span class="comment">// Run next effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with &#123; friend: &#123; id: 300 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">200</span>, handleStatusChange); <span class="comment">// Clean up previous effect</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">300</span>, handleStatusChange);     <span class="comment">// Run next effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmount</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">300</span>, handleStatusChange); <span class="comment">// Clean up last effect</span></span><br></pre></td></tr></table></figure>

<p>为了避免这样的频繁操作影响性能，可以通过上面介绍的传第二个参数的方式优化性能。<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects">官方文档</a>在最后还补充了一句：</p>
<blockquote>
<p>In the future, the second argument might get added automatically by a build-time transformation.</p>
</blockquote>
<h2 id="一些使用准则"><a href="#一些使用准则" class="headerlink" title="一些使用准则"></a>一些使用准则</h2><ul>
<li>在函数内部的最外层使用，<strong>别在块语句内使用</strong>，以保证正确的内部状态</li>
<li><strong>只在函数组件和自定义Hooks中使用Hooks API</strong>，以保证可读性</li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">这个eslint-plugin</a>能帮助你检查代码风格</li>
</ul>
<p>为什么会有看起来比较别扭的上面两条规则呢？</p>
<p>从<code>useState</code>和<code>useEffect</code>看到，API本身是没有状态的，并不知道API的返回赋值给了哪个变量名。所以，就像介绍里说的：</p>
<blockquote>
<p>React relies on the order in which Hooks are called.</p>
</blockquote>
<p>React依赖于Hooks的调用顺序，因此在每次render时，Hooks方法的调用顺序<strong>一定要保持一致</strong>。</p>
<p><em>（猜测内部用类似数组的结构保存了一个函数组件内的多个Hooks）</em></p>
<p>从而，所有导致Hooks可能不按一致顺序执行的写法都不建议使用。为了保证Hooks执行顺序所见即所得，又有了第二条准则。</p>
<h2 id="组合-自定义Hooks"><a href="#组合-自定义Hooks" class="headerlink" title="组合 - 自定义Hooks"></a>组合 - 自定义Hooks</h2><p>Hooks除了或多或少基于React提供的Hooks外，只是再普通不过的JavaScript function而已。可以将组件中共用的<strong>状态逻辑</strong>拆分出来作为自定义Hooks。类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFriendStatus</span>(<span class="params">friendID</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStatusChange</span>(<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="title function_">setIsOnline</span>(status.<span class="property">isOnline</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>强烈建议用户自定义的Hooks函数也以<code>use</code>开头</strong>。在使用时，就像使用正常的函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FriendStatus</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = <span class="title function_">useFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FriendListItem</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = <span class="title function_">useFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">isOnline</span> ? &#x27;<span class="attr">green</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">black</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.friend.name&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hooks共用的是状态逻辑，使用同一个自定义Hooks创建的状态是相互隔离的</strong>。</p>
<p>你可以发挥你的想象力，抽象共用的状态逻辑，使用组合的方式（在函数中组合，React并不建议在class组件中使用mixin）构建新组件，减少组件代码长度。</p>
<p>官网举了个非常简单却普遍的<code>useReducer</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useReducer</span>(<span class="params">reducer, initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextState = <span class="title function_">reducer</span>(state, action);</span><br><span class="line">    <span class="title function_">setState</span>(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Todos</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [todos, dispatch] = <span class="title function_">useReducer</span>(todosReducer, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAddClick</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span>, text &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="还有什么Hooks"><a href="#还有什么Hooks" class="headerlink" title="还有什么Hooks"></a>还有什么Hooks</h2><ul>
<li><code>useContext</code>，接受<code>React.createContext</code>作为入参，在每次provider更新后，自动用最新的context重渲染。</li>
<li><code>useReducer</code>，组件状态逻辑很复杂时，代替<code>useState</code>使用</li>
<li><code>useCallback</code>，保存一个和当前状态相关的函数，只有状态变化时，函数才会更新，避免重复创建函数。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><code>useMemo</code>，保存一个和当前状态相关的值，只有状态变化时，值才会重新计算。不提供数组代表每次渲染都会更新。</li>
<li><code>useRef</code>，获取DOM ref  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextInputWithFocusButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// `current` points to the mounted text input element</span></span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>useImperativeMethods</code>，暴露当前组件Ref给父组件</li>
<li><code>useMutationEffect</code>和<code>useLayoutEffect</code>，类似<code>useEffect</code>只是同步执行，而且执行时机有区别</li>
</ul>
<p>更多参考<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html">文档介绍</a></p>
<h2 id="还有问题？"><a href="#还有问题？" class="headerlink" title="还有问题？"></a>还有问题？</h2><ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#do-hooks-cover-all-use-cases-for-classes">不常见的方法如<code>componentDidCatch</code>未来会支持</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components">范式上，Hooks是高阶组件的更简单形式</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate">借助<code>useMemo</code>，<code>shouldComponentUpdate</code>可以有更好的写法</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables"><code>this.foo</code>这种写法可以用<code>useRef</code>实现</a> - 个人感觉有点不符合直觉</li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables">state split准则：将一起改变的state split到一起</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state"><code>useEffect</code>需要用到prevState，prevProps时需要hack</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">使用Hooks不会更慢，反而会更快</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#under-the-hood">idea来源</a></li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>刚好最近在某管理后台需要有用户列表页的展示，除了获取数据的副作用，只有渲染的功能，用Hooks实现起来就很自然，而在原来的范式下，因为一个额外的网络请求，就需要把functional组件转成class，随之而来的又是一系列的模板代码和声明周期函数。</p>
<p>使用Hooks之后的代码像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UserList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [users, setUsers] = <span class="title function_">useState</span>([]);</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getUsers</span>();</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="title function_">setUsers</span>(res.<span class="property">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fetchData</span>();</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;admin-users&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">dataSource</span>=<span class="string">&#123;users&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">pagination</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原来的模式时，大概像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">users</span>: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getUsers</span>();</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">users</span>: res.<span class="property">data</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;admin-users&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">dataSource</span>=<span class="string">&#123;this.state.users&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">pagination</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然代码行数类似，但是代码信噪比和可拓展性明显上面更优。</p>
<h2 id="感受与展望"><a href="#感受与展望" class="headerlink" title="感受与展望"></a>感受与展望</h2><p>我理解Hooks的目的并不是强行把class组件里的功能硬塞到functional组件里（虽然从用法上确实有这种感觉），推荐使用funcational组件的形式。而是一次<strong>新的复用组件逻辑方式的尝试</strong>。毕竟组合函数比组合class简单多了（React并不建议mixin）。同时通过上面的简单实践可以发现，使用Hooks之后，少了许多<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti code</a>，看上去清爽了许多，可读性也随着提高。</p>
<p>不过另一方面，Hooks的API初看上去挺美，挺简洁好用，那是因为最开始举例的场景简单，不需要hack。由于使用Hooks就意味着用全盘用function的形式写组件，原来用class写法写的复杂的业务组件，如果都用Hooks的方式写，也需要开发者具有一定的设计模式意识。同时在有些场景（比如上面说的prevState，prevProps）要使用比较反直觉的操作才能完成。期待后面Hooks API不断优化后的结果。</p>
<p>在逐渐使用Hooks的方式写组件后，业务中会有一些共用的Hooks抽象出来，整个项目目录结构也会发生变化，Hooks文件的管理方式还要再实践。期待Hooks能让每个模块代码都能小于200行的一天更早到来😌。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2018/10/30/password-tech-note/" class="post-title-link" itemprop="url">《图解密码技术》总结整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-10-30 00:07:43 / 修改时间：01:05:35" itemprop="dateCreated datePublished" datetime="2018-10-30T00:07:43+08:00">2018-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/30/password-tech-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/30/password-tech-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26265544/">《图解密码技术》</a>一书</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>信源、信宿、信道</li>
<li>加密、解密、密钥</li>
<li>对称密码、公钥密码、混合密码</li>
<li>单向散列（hash）函数、信息认证</li>
<li>数字签名 &#x2F; 篡改和否认</li>
<li>伪随机数</li>
</ul>
<p>信息传递时面临的风险：</p>
<ul>
<li>窃听 -&gt; 对称、公钥密码</li>
<li>篡改 -&gt; 散列函数、消息认证、数字签名</li>
<li>伪装 -&gt; 消息认证、数字签名</li>
<li>否认 -&gt; 数字签名</li>
</ul>
<p>有悖常识的几点：</p>
<ul>
<li>不要使用保密的加密算法</li>
<li>使用低强度密码不如不用</li>
<li>任何密码都有可能被破解</li>
<li>密码只是安全的一部分（社工）</li>
</ul>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>凯撒密码 &#x2F; 平移 &#x2F; 暴力破解</li>
<li>简单替换密码 &#x2F; 替换 &#x2F; 频率分析</li>
<li>Enigma &#x2F; 加密密码的密码 &#x2F; 针对每日密钥的破解</li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><ul>
<li>编码和异或</li>
<li>一次性密码和它的问题</li>
<li><strong>使用对称密码时，我们通常默认密钥配送问题已解决</strong></li>
</ul>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>全称Data Encryption Standard。于1977年在美国发明并使用。目前可以被暴力破解，因此不应再使用了。</p>
<ul>
<li>DES以<strong>64bit</strong>为一个单位，使用和明文等长的密钥。</li>
<li>密钥每8位包含1位纠错码</li>
<li>基本结构使用Feistel网络<ul>
<li>加密&#x2F;解密步骤以轮为单位，DES有16轮</li>
<li>每轮运算不加密右半侧，同时右半侧比特和该轮密钥通过轮函数得到本轮加密左侧的密钥，和左侧做异或得到左侧密文</li>
<li>每轮加密后，进行左右对调，保证右侧的保密</li>
<li><strong>解密时用相同结构</strong>，反向使用子密钥和轮函数即可</li>
<li>轮函数可以任意复杂</li>
</ul>
</li>
<li>差分分析和线性分析衡量分组密码强度</li>
</ul>
<p><strong>三重DES</strong></p>
<p>由IBM开发，步骤为DES加密 -&gt; DES解密 -&gt; DES加密。密钥长度是原来三倍，即168比特。</p>
<ul>
<li>三步使用同一密钥，即向下兼容DES</li>
<li>根据1、3步是否使用同一密钥，分为DES-EDE2和DES-EDE3</li>
<li>处理速度慢</li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>全称Advanced Encrytion Standard，用来取代DES。由NIST开于1997年开始募集，将作为国家标准。算法要求开源免费，并在社群里公开评审，最终于2000年确定为Rijndael。</p>
<ul>
<li>基本结构为SPN结构</li>
<li>明文分组长度固定为<strong>128bit</strong>、密钥长度可以是128、192、256比特三种</li>
<li>每轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey四步<ul>
<li>SubBytes，将4字节 * 4字节的矩阵与一个转换矩阵相乘，得到替换后的矩阵</li>
<li>ShiftRows，逐行做平移</li>
<li>MixColumns，逐列做矩阵运算</li>
<li>AddRoundKey，和轮密钥矩阵做对应位上的异或运算</li>
</ul>
</li>
<li>解密时，除了AddRoundKey一步，其余均需要做逆运算</li>
<li>目前还没有针对Rijndael的有效攻击</li>
<li><strong>避免使用DES，选择AES</strong></li>
</ul>
<h2 id="分组密码的迭代模式"><a href="#分组密码的迭代模式" class="headerlink" title="分组密码的迭代模式"></a>分组密码的迭代模式</h2><p>分组密码只能加密<strong>固定长度</strong>的密码。因此，需要有<strong>模式</strong>来迭代加密任意长度的明文。与分组密码相对的是流密码，对数据进行连续处理。</p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>全称为Electronic CodeBook。是最简单直接的分组方式。将明文分组加密后直接得到对应位置的密文。不足的位用特定数据<strong>填充</strong>。</p>
<ul>
<li>问题很明显，<strong>不要使用</strong></li>
<li>相同的明文分组会得到相同的密文分组</li>
<li>攻击者无需破译密码也可通过修改密文操纵明文，比如替换或删除分组</li>
</ul>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>全称Cipher Block Chaining。和ECB的最大不同在于明文分组加密前会和上一个密文分组做一次异或运算。开头的明文分组会和一个随机序列做XOR。</p>
<ul>
<li>一个密文分组的损坏会影响关联的两个分组的解密</li>
<li>比特的缺失将会影响整个密文的解密</li>
<li>操纵初始化向量反转某一位比特可以反转第一个密文分组的某一位</li>
<li>填充提示攻击，攻击padding部分</li>
<li>SSL&#x2F;TLS使用CBC模式保证通信机密</li>
<li><strong>CTS</strong>使用最后一个密文填充不足的明文部分</li>
</ul>
<h3 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h3><p>全程Cipher FeedBack模式。和CBC模式的区别在密文分组先加密，再和下一个明文做异或运算。实际上明文分组和密文分组间只相差了一个异或运算。很类似一次性密码本的模式。</p>
<ul>
<li>解密时，需要对密文分组和初始向量做<strong>加密</strong>操作</li>
<li><strong>重放</strong>攻击，替换密文分组为原有分组，可使得解密出的明文为原有明文</li>
</ul>
<h3 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h3><p>全称Output-FeedBack模式。和CFB很像，区别在于OFB每次做XOR的密钥流仅来自于上一次的密钥，<strong>和密文分组无关</strong>。因为密钥流可以提前准备好，分组加密过程可以是并行的。</p>
<ul>
<li>第一次的密钥来自初始化向量</li>
<li>速度快</li>
<li>如果碰巧密钥加密后和加密前一样，那么之后的密钥就会是同一个值</li>
</ul>
<h3 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h3><p>全称CounTeR。CTR和OFB类似，区别在于它的密钥流来自于累加的计数器。密文分组来自于密钥流和明文分组的XOR运算。</p>
<ul>
<li>计数器由nonce和序号两部分各8字节组成，nonce是随机生成的，序号是从1累加的。</li>
<li>和OFB一样，加密解密速度快，结构简单</li>
<li>CTR的密钥流在选定nonce后就确定了，因此可以以<strong>任意顺序并行</strong>加密、解密</li>
</ul>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>解决了对称密码的密钥配送问题。</p>
<h3 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h3><ul>
<li><strong>事先共享</strong>，在现实生活中传送</li>
<li><strong>密钥配送中心</strong>，集中式管理用户密钥，用其加密临时的会话密钥</li>
<li><strong>使用Diffie-Hellman密钥交换</strong></li>
<li><strong>使用公钥密码</strong></li>
</ul>
<h3 id="公钥密码-1"><a href="#公钥密码-1" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>使用加密密钥（公钥）加密，使用解密密钥（私钥）解密，避免密钥的泄露。</p>
<ul>
<li>发送者使用加密密钥</li>
<li>接收者使用解密密钥</li>
<li>加密密钥可以公开</li>
<li>解密密钥一定要保密</li>
</ul>
<p>目前所使用的公钥密码RSA来自于1978年的发明。流程上，</p>
<ul>
<li><strong>接收者</strong>生成公私钥对，发送公钥给发送者</li>
<li>发送者使用公钥加密明文</li>
<li>接收者使用私钥解密密文</li>
</ul>
<p>公钥密码有两个问题：</p>
<ul>
<li>认证公钥的合法性</li>
<li>处理速度慢</li>
</ul>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>利用了数论中求解离散对数困难且耗时的特点。</p>
<ul>
<li><strong>加密</strong>，使用<code>密文=明文 ^ E mod N</code>。E和N组合成公钥。</li>
<li><strong>解密</strong>，使用<code>明文=密文 ^ D mod N</code>。D和N组合成密钥。</li>
</ul>
<p>生成N、E、D和顺序如下：</p>
<ol>
<li>寻找互质的两个大数p和q，N为二者的乘积</li>
<li>p-1和q-1的最小公倍数记为L</li>
<li>寻找比L小的和L互质的数，即为E</li>
<li>寻找比L小的和E乘积取模L为1的数，即为D</li>
</ol>
<p>因为解密时有对N取模操作，因此加密的明文不能大于N。</p>
<p><strong>攻击方式</strong></p>
<ul>
<li>破解密文 -&gt; 求解离散对数很难</li>
<li>暴力破解D -&gt; 比特位太长，很难破解</li>
<li>通过E求解D，只要知道p和q就能算出D -&gt; 不知道p和q的组合 -&gt; <strong>对N质因数分解很难</strong></li>
</ul>
<p><strong>中间人攻击</strong>里，攻击者可以替换掉原本的公钥，发送给接收者，使用自己的私钥解密，从而实现攻击。这时需要<strong>证书</strong>保证公钥的权威性。</p>
<p><strong>选择密文攻击</strong>里，攻击者可以利用服务端返回的错误消息收集加密算法信息。RSA-OAEP会在明文开头加上明文散列值和填充位，解密时发现散列值和内容对不上时，会隐藏错误信息。</p>
<p>除了RSA外，还有ElGamal方式、Robin方式、ECC（椭圆曲线密码）等公钥密码。它们分别利用了mod N下求离散对数，mod N下求平方根，和椭圆曲线上做乘法运算逆运算在数学上很难求解的特点。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q: 和对称密码的强度对比<br>A: 达到同等强度，RSA大致需要密钥是AES长度的20倍</p>
<p>Q: RSA使用的质数会用完么<br>A: 512bit的质数数目大约是10 ^ 150。足够使用。</p>
<p>Q: RSA破解难度如何？<br>A: 和大整数质因数分解一样难度</p>
<p>Q: 要保证RSA强度，N的长度要达到多少位<br>A: 2048bit，4096bit更好</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><ul>
<li>用对称密码加密明文</li>
<li>用公钥密码加密上述对称密码的密钥（通常用随机数生成器得到，只用于此次会话）</li>
<li>公钥密码的密钥由外部赋予（证书）</li>
</ul>
<p>密码软件PGP、HTTPS中使用的SSL&#x2F;TLS就使用了混合密码系统。当然它们还包含数字签名、认证、私钥管理等更多处理。</p>
<p>类似混合密码系统，后面要介绍的数字签名、证书、消息认证、伪随机数生成也都是<strong>基础密码技术的组合</strong>。</p>
<h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><ul>
<li>将任意长度的消息转换到<strong>固定长度</strong>散列</li>
<li>具有抗碰撞性，即找到具有相同散列函数的消息很困难</li>
<li>单向性，即无法从三列中还原原信息</li>
</ul>
<h3 id="MD4、MD5"><a href="#MD4、MD5" class="headerlink" title="MD4、MD5"></a>MD4、MD5</h3><p>全称Message Digest。由Rivest设计于1990和1991年。能够产生<strong>128bit</strong>的散列值。它们的强抗碰撞性已被攻破，<strong>不建议使用</strong>。</p>
<h3 id="RIPEMD-160"><a href="#RIPEMD-160" class="headerlink" title="RIPEMD-160"></a>RIPEMD-160</h3><p>1996年设计，是欧盟RIPE项目的修订版，能产生160bit长度的散列值。比特币中使用的散列函数就是RIPEMD-160。</p>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p>SHA于1993年由NIST设计，在1995年发布了SHA-1修订版，能够产生<strong>160bit</strong>的散列值。它的强抗碰撞性已被攻破，<strong>也不建议使用</strong>。</p>
<p>SHA-2于2002年发布，它是包括SHA-256，SHA-384和SHA-512的集合，分别产生<strong>256、384和512bit</strong>的散列值。目前未被攻破。SHA-2的几种散列长度来自SHA-256和SHA-512的组合。</p>
<p>SHA-3作为SHA-1的升级替代算法，和AES一样，由NIST公开选拔，并在2012年确定为一个叫<strong>Keccak</strong>的算法。之后会和SHA-2并存一段时间。</p>
<h3 id="Keccak"><a href="#Keccak" class="headerlink" title="Keccak"></a>Keccak</h3><p>Keccak可以输入<strong>任意长度</strong>的数据，产生<strong>任意长度</strong>的散列值。实现上，Keccak采用海绵结构，有<strong>吸收</strong>和<strong>挤出</strong>两阶段。</p>
<ul>
<li>吸收阶段，按分组长度r逐段读入消息内容，和内部状态做异或运算，之后和长度为c的内部状态一起交给函数f做“搅拌”。完成一轮处理，输出作为内部状态继读入输入的消息分组。</li>
<li>挤出阶段，内部消息r和c逐段和函数f做运算，一段段输出散列值。</li>
</ul>
<p>Keccak的双工结构下，输入和输出可以同时进行。Keccak内部状态由5 * 5 * z的一个三维比特数组组成，共有b个bit。Keccak的本质就是实现一个充分搅拌上述数组的函数f。SHA-3中使用的是Keccak-f[1600]函数。其中b就是内部状态的bit数。函数的每一轮包含θ、ρ、π、χ、ι5步。循环轮数为12 + 2 * log2(b &#x2F; 25)。</p>
<ul>
<li>θ，将不同两个column的各5个bit通过异或运算加起来，再和当前位做异或替换</li>
<li>ρ，各比特沿z轴方向进行平移</li>
<li>π，对一个slice上的5 * 5个比特做旋转、轮换操作</li>
<li>χ，对一个row上的各位做某个逻辑运算</li>
<li>ι，用某个轮常数对所有比特做异或运算，避免对称性</li>
</ul>
<p>Keccak采用的海绵结构和此前各散列算法使用的MD结构（循环执行压缩函数）方法截然不同，这也是它最后成为标准的一个原因。目前还未出现针对Keccak的有效攻击手段。</p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>利用文件的冗余性，构造<strong>一大堆</strong>和想要内容一样的数据，找到和原内容散列值一样的结果。</p>
<ul>
<li>原像攻击，给定散列值，找到具有该散列值的任意消息</li>
<li>第二原像攻击，给定消息1，找到和消息1有相同散列值的消息2</li>
<li>生日攻击，攻击散列算法的“强抗碰撞性”（寻找两个具有相同散列值的消息），利用了从有N个元素的集合中依次取并放回M个元素，两次取到同一元素的概率约为根号N的特点。大大减少暴力破解需要的次数。</li>
</ul>
<h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><p>可以同时防止消息的伪装和篡改。消息认证码简称MAC（Message Authentication Code）。可以简单理解成<strong>需要密钥参与的单向散列过程</strong>。在使用时：</p>
<ul>
<li>发送者伴随消息发送计算出的MAC</li>
<li>接受者对消息通过共享密钥计算出MAC值，进行对比，一致则表示认证成功</li>
<li><strong>这个密钥不能被中间人获取！</strong></li>
</ul>
<p>使用消息认证码（MAC）机制的场景有：</p>
<ul>
<li>SWIFT</li>
<li>IPSec</li>
<li>SSL&#x2F;TLS</li>
</ul>
<p>在认证加密时，Encrypt-then-MAC表示对密文计算MAC值，从而能判断密文是由知道明文和密钥的人生成的。除了Encrypt-then-MAC外，还有Encrypt-and-MAC和MAC-then-Encrypt两种方式。</p>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC即Hash MAC，是使用单向散列函数构造认证码的方法。分为下面几步：</p>
<ol>
<li>在密钥后填充0到长度达到单向散列函数的分组长度</li>
<li>填充后的密钥和ipad序列做XOR运算，ipad序列是00110110为单位循环的比特序列</li>
<li>组合在消息<strong>头部</strong>，并计算出散列值</li>
<li>填充后的密钥和opad做XOR运算，opad是01011100位单位循环的比特序列</li>
<li>结果拼在散列值<strong>后面</strong></li>
<li>根据5的结果计算最终的散列值</li>
</ol>
<h3 id="应对攻击方式"><a href="#应对攻击方式" class="headerlink" title="应对攻击方式"></a>应对攻击方式</h3><ul>
<li>消息认证需要解决<strong>重放攻击</strong>的问题，即再次发送相同的消息和MAC值。可以在消息中额外带上序号、时间戳，或先发送一个nonce一次性随机数保证相同的消息也会有完全不同的MAC值。</li>
<li><strong>密钥推测攻击</strong>，应保证不能根据MAC值推测出双方使用的密钥，必须使用安全、高强度的伪随机数生成器。</li>
</ul>
<p>另外，消息认证无法解决下面的问题：</p>
<ul>
<li>向第三方证明，密钥的共享只在通信的双方，无法证明给第三方</li>
<li>同样的，不能防止通信的一方<strong>否认</strong>消息</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>和公钥密码<strong>相反</strong>的使用方式：</p>
<ul>
<li>发布者使用私钥加密消息，私钥保密</li>
<li>使用发布者的公钥可以解密消息，公钥公开</li>
</ul>
<p>签名有两种方式：<strong>对消息签名</strong>和<strong>对消息的散列值签名</strong>。它们主要区别在签名的对象不同。基本过程是：</p>
<ol>
<li>生成公、私钥对，发送公钥给接收者</li>
<li>使用私钥加密消息&#x2F;消息的hash值，得到签名</li>
<li>发送消息和签名给接收者</li>
<li>接收者使用公钥解密，对比消息&#x2F;消息hash值，验证发送者身份</li>
</ol>
<p>在签名中，密钥只是起着“保证消息发送者的可靠来源目的的”，被复制并不影响它发挥作用。同时，由于不知道私钥，修改消息后无法伪造消息的签名。</p>
<p>实际应用数字签名的地方有很多：</p>
<ul>
<li>安全信息公告</li>
<li>软件下载</li>
<li>公钥证书，确保公钥的合法来源</li>
<li>SSL&#x2F;TLS，交换公钥的过程</li>
</ul>
<p>数字签名基于公钥密码，因此数字签名的实现方式因采用的公钥密码而异，如RSA、ElGamal、ECDSA（椭圆曲线密码）。对数字签名的攻击可以基于单向散列函数或是公钥密码。</p>
<ul>
<li><strong>不要对不清楚来源的数据做数字签名</strong></li>
<li><strong>对消息的散列值函数做数字签名</strong></li>
</ul>
<p>数字签名无法解决<strong>验证签名正确性的公钥被伪造</strong>的问题，因为公钥正确性也依赖于数字签名技术。这里需要<strong>证书</strong>以及<strong>公钥基础设施PKI</strong>这种社会学的基础设施辅助。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书即<strong>公钥证书</strong>，用来验证公钥密码和数字签名的公钥，由认证机构（CA）发布，认证机构可以是政府机关、一般企业或个人。证书的发布过程包括：</p>
<ol>
<li>申请人生成一对密钥，并把公钥发送给CA</li>
<li>CA验证申请人身份</li>
<li>通过验证后，CA使用自己的私钥对公钥施加数字签名并生成证书</li>
<li>使用申请人证书的使用者通过CA的公钥验证申请人的公钥是否合法</li>
<li>验证通过后，使用公钥完成公钥密码或数字签名</li>
</ol>
<p>PKI是为了能够更有效运用公钥制定的一系列规范的总称。PKI组成要素有3个：使用PKI的用户、认证机构、仓库。</p>
<ul>
<li>用户，分为注册公钥的用户和使用注册公钥的用户</li>
<li>CA，包括生成密钥、验证本人身份、验证公钥合法性、作废证书</li>
<li>仓库，是保存证书的数据库</li>
</ul>
<p>其中认证机构做了以下事情：</p>
<ul>
<li><strong>生成密钥对</strong>，可以由用户或是CA生成，若是CA生成，需要根据规范发送私钥给用户</li>
<li><strong>注册证书</strong>，用户根据规范申请证书，认证机构根据业务准则生成符合X.509规范的证书</li>
<li><strong>作废证书</strong>，因为私钥丢失等原因需要作废证书时，需要认证机构制作CRL（Certificate Revocation List，证书作废清单），PKI用户总需要从CA获取最新的CRL，以确认自己拿到的公钥证书是否有效。</li>
</ul>
<p><strong>认证机构的证书认证</strong></p>
<p>认证机构的公钥证书可以由其他的认证机构施加数字签名。这个关系可以嵌套很多层，比如部门认证机构、分公司认证机构、总公司认证机构。一直往上直到根CA，可以对自己的公钥做自签名。</p>
<p>从而，在验证证书合法性上，也会出现<strong>从上至下</strong>的验证过程。</p>
<h3 id="证书的攻击"><a href="#证书的攻击" class="headerlink" title="证书的攻击"></a>证书的攻击</h3><p>对证书的攻击即对数字签名的攻击。</p>
<ul>
<li>对施加数字签名前的公钥攻击</li>
<li>注册相似人名进行攻击</li>
<li>窃取CA的私钥</li>
<li>伪装成CA发放证书进行攻击，认证机构本身的可信度也很重要</li>
<li>利用发送CRL的时间间隔，窃取了使用者的私钥，当使用者联系CA发布CRL时，有一定的时间间隔</li>
<li>同样利用CRL，使用合法私钥发送消息后，发送CRL作废自己的公钥，<strong>否认</strong>自己之前发送的消息</li>
</ul>
<p><strong>不可能在完全不可信的状态下创建出信任关系，除非以已经存在的信任关系为基础。</strong></p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><ul>
<li><p>密钥长度（DES：56bit，三重DES：112bit或168bit，AES：128、192、256bit</p>
</li>
<li><p>对称密码和公钥密码<strong>用于确保机密性</strong>，消息认证码和数字签名使用的密码<strong>用于认证，防止篡改内容和伪装身份</strong></p>
</li>
<li><p>只使用一次的密钥称为<strong>会话密钥</strong>，重复使用的密钥称为<strong>主密钥</strong>。</p>
</li>
<li><p><strong>密码学用途的随机数生成器必须为密码学用途专门设计</strong></p>
</li>
<li><p>定期改变会话密钥可以减少密钥泄露的损失</p>
</li>
<li><p>保存密钥时，使用KEK（Key Encrypting Key）方式保存密钥可以减少管理密钥的数目。</p>
</li>
</ul>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换里，通信的双方通过交换一些可以公开的消息，就能够生成共享的密钥。</p>
<ol>
<li>确定一个非常大的质数P，寻找P的生成元（原根）G</li>
<li>通信双方各自找1个1 ~ P-2的随机数A、B，生成G ^ A mod P与G ^ B mod P，发送给对方</li>
<li>对方用收到的数字根据自己选的随机数做乘方运算，得到相等的值作为密钥</li>
</ol>
<p>它同样利用了离散对数问题难以快速求解的特点。这种交换方法可以做中间人攻击，可以用数字签名、证书等方式应对。</p>
<h3 id="基于口令的密码（PBE）"><a href="#基于口令的密码（PBE）" class="headerlink" title="基于口令的密码（PBE）"></a>基于口令的密码（PBE）</h3><p>基于口令的密码避免了：记忆CEK -&gt; 记忆KEK -&gt; 记忆KEK的KEK的死循环。使用好记忆的口令配合盐生成CEK。使用过程如下：</p>
<ol>
<li>使用随机数生成器生成盐（随机数），加上用户口令，使用单向散列函数得到KEK</li>
<li>使用KEK加密会话使用的CEK</li>
<li>保存好盐以及使用KEK加密的会话秘钥</li>
</ol>
<ul>
<li>盐的目的是避免字典攻击</li>
<li>口令虽然便于生成，但是强度不高，因此需要格外地小心保管</li>
<li>可以对KEK迭代使用单向散列函数得到最后的KEK（拉伸），这将加大攻击者的攻击负担</li>
</ul>
<h3 id="生成安全的口令"><a href="#生成安全的口令" class="headerlink" title="生成安全的口令"></a>生成安全的口令</h3><ul>
<li>使用<strong>只有自己</strong>知道的信息<ul>
<li>不包括别人见过的信息</li>
<li>不包括可以很容易推测的信息</li>
</ul>
</li>
<li>不应该重复使用口令，容易受牵连影响</li>
<li>物理保存是可以的，但要注意安全</li>
<li>可以使用口令生成和管理工具（比如1Password）</li>
</ul>
<h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>随机数生成在密码学中很常用：</p>
<ul>
<li>生成密钥</li>
<li>生成分组密码的初始化向量</li>
<li>生成CTR模式的nonce</li>
<li>生成盐</li>
</ul>
<p>随机数至少需要具有下面的属性：</p>
<ul>
<li>随机等概性</li>
<li>无状态，即无法从上一个推测下一个，生成序列无法重现</li>
</ul>
<p>由于计算机构成的抽象世界是<strong>离散的</strong>，内部状态有限，不能满足无状态的特点，因此只能称作<strong>伪随机数生成器</strong>。基于计算机硬件的随机数生成器可以认为是“真”随机数，它通常提前储存在一个随机数池中，在需要的时候直接从池中取用。伪随机数生成器根据随机的种子（seed）通过算法将内部状态转化为最终的随机数。</p>
<ul>
<li><strong>线性同余法</strong>，以当前随机数为内部状态（初始值为种子），(A x Rn + C) mod M，计算下一个值。其中A、C、M都需要事先选好，线性同余法生成的随机数数列具有可预测性，即不需要知道种子也可以推测下随机数值</li>
<li><strong>单向散列函数</strong>，利用单向散列函数保护内部状态，以种子为初始值，逐次递加得到新的内部状态，再通过单向散列函数输出为随机数</li>
<li><strong>密码法</strong>，类似单向散列函数，使用密钥加密内部状态输出也可以作为随机数，此时保护内部状态的加密算法和密钥</li>
<li><strong>ANSI X9.17</strong>中，使用AES和三重DES作为密码算法<ol>
<li>初始化内部状态</li>
<li>使用当前时间生成掩码</li>
<li>掩码和内部状态做XOR</li>
<li>加密3的输出，作为随机数输出</li>
<li>对加密后的输出与掩码做XOR</li>
<li>加密5的结果作为新的内部状态</li>
</ol>
</li>
</ul>
<h2 id="PGP介绍"><a href="#PGP介绍" class="headerlink" title="PGP介绍"></a>PGP介绍</h2><p>PGP全程Pretty Good Privacy，编写于1990年，具备现代密码软件所需的几乎所有功能。OpenPGP是一对密文和数字签名进行定义的标准规格。</p>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><p>加密时，使用混合密码系统的流程：</p>
<ol>
<li>用伪随机数生成会话密钥</li>
<li>用<strong>接收者</strong>的公钥加密会话密钥</li>
<li>压缩消息，并使用对称密码加密，密钥为上面生成的会话密钥</li>
<li>将加密后的密钥和密文拼接在一起</li>
<li>将4的结果转换为文本数据，即为报文数据</li>
</ol>
<p>解密时，PGP的私钥通过用户口令加密保存。在收到密文时：</p>
<ol>
<li>输入接收者的口令</li>
<li>求口令的散列值，生成用户解密私钥的秘钥</li>
<li>解密得到私钥</li>
<li>将报文数据转换为二进制，并拆解成加密的会话密钥和压缩的密文</li>
<li>用自己的私钥解密得到会话密钥</li>
<li>用会话密钥解密密文</li>
<li>解压缩明文得到原始消息</li>
</ol>
<h3 id="生成数字签名"><a href="#生成数字签名" class="headerlink" title="生成数字签名"></a>生成数字签名</h3><p>同样，生成数字签名时：</p>
<ol>
<li>输入接收者的口令</li>
<li>求口令的散列值，生成用户解密私钥的秘钥</li>
<li>解密得到私钥</li>
<li>使用单向散列函数计算消息散列值</li>
<li>对散列值签名，即使用私钥加密</li>
<li>拼合签名和消息，进行压缩</li>
<li><em>（可选）</em>转换二进制为文本数据，即最后的报文数据</li>
</ol>
<p>类似地，验证时：</p>
<ol>
<li>转换为二进制文件，解压缩数据</li>
<li>分解出签名和消息两部分</li>
<li>使用公钥解密签名，得到散列值</li>
<li>使用单向散列函数计算消息散列值，对比3中的散列值</li>
<li>相等即验证成功</li>
</ol>
<h3 id="生成数字签名并加密"><a href="#生成数字签名并加密" class="headerlink" title="生成数字签名并加密"></a>生成数字签名并加密</h3><p>实际情况下，我们往往需要使用加密算法加密数字签名中的原消息。实现步骤是上两节的组合。即先进行数字签名，再对签名结果加密。</p>
<p>验证过程是相反的，先解密密文得到签名结果，再验证数字签名。</p>
<h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3><p>PGP确认公钥合法性的方法不依赖于认证机构颁发证书，而是采用所有者信任级别构成信任网（也叫信任圈、朋友圈）的方式，让用户自己决定该信任谁。建立信任有三种方式：</p>
<ul>
<li>通过自己的签名来确认。用户在通过其他方式（比如线下）确认公钥可信任后，对该公钥加上自己的数字签名。由于PGP中，使用者本人的公钥是绝对信任，被施加签名的公钥因此可信任。<em>注意：这并不代表被施加签名的公钥所有者被<strong>完全</strong>信任</em></li>
<li>通过自己完全信任的数字签名进行确认。即<strong>完全信任</strong>某个公钥进行的数字签名，用户可对当前信任的每个公钥所有者设置信任级别，级别为<strong>完全信任</strong>时，所有者公钥施加签名的公钥也会被信任。</li>
<li>通过有限信任的多个数字签名进行确认。在设置信任级别为<strong>有限信任</strong>时，有限信任的公钥<strong>都</strong>施加数字签名后，新的公钥才会被信任。</li>
</ul>
<p>通过上面三种方式，PGP使用者可以构建起自己的信任网，从而根据自己的决定信任某个公钥。</p>
<h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>TLS是SSL的后续版本，但在大多数情况下，可以统一写成SSL&#x2F;TLS。<strong>SSL&#x2F;TLS可以承载应用层协议，保证应用层传输的安全性，HTTP就是其中一种</strong>。其余SSL&#x2F;TLS可以承载的应用层协议还包括SMTP、POP3等等。</p>
<p>SSL于1994年在网景公司开发，在1995年发布了SSL3.0版本，后被发现会导致POODLE攻击。TLS是IETF在1999年作为SSL3.1发布。2006年发布TLS1.1，之后又发布了TLS1.2。</p>
<p>HTTPS中SSL&#x2F;TLS要保证以下三点：</p>
<ul>
<li>保证消息传输中<strong>不被窃听</strong> -&gt; <strong>对称密码</strong>加密消息，<strong>公钥密码</strong>加密对称密码的密钥</li>
<li>保证消息传输中<strong>不被篡改</strong> -&gt; <strong>消息认证</strong>码</li>
<li>保证消息传输<strong>双方的合法性</strong> -&gt; <strong>数字签名</strong>生成证书</li>
</ul>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>下面的流程以TLS1.2为例。TLS协议分为两层：</p>
<ul>
<li><strong>TLS握手协议</strong>，位于上层，处理除加密的部分。可以进一步分为：<ul>
<li><strong>握手协议</strong>，负责在客户端和服务器间协商密码算法和共享密钥</li>
<li><strong>密码规格变更协议</strong>，向通信对象传达变更密码方式</li>
<li><strong>警告协议</strong>，在发生错误时将错误传达给对方</li>
<li><strong>应用数据协议</strong>，将TLS上承载的应用数据传达给通信对象</li>
</ul>
</li>
<li><strong>TLS记录协议</strong>，位于底层，处理加密的部分。使用了对称密码和消息认证码，但具体的算法和密钥需要通信双方具体协商</li>
</ul>
<h3 id="TLS记录协议"><a href="#TLS记录协议" class="headerlink" title="TLS记录协议"></a>TLS记录协议</h3><p>记录协议负责数据的压缩、加密、数据认证，工作方式如下：</p>
<ol>
<li>分割消息为较小的片段，再分段压缩，<strong>压缩方式需要协商决定</strong></li>
<li>对压缩过的消息进行消息认证，加上MAC值。为了避免重放攻击，在计算MAC值时，加上了片段的编号。其中的<strong>单向散列函数的算法、使用的密钥都需要协商确定</strong></li>
<li>把MAC值和压缩过的消息片段组合在一起，使用对称密码加密。迭代模式使用CBC模式，CBC模式的初始化向量通过主密码生成。<strong>对称密码的算法、密钥则需要协商决定</strong></li>
<li>上述经过加密的数据，再加上<strong>数据类型、版本号、压缩后的长度</strong>，构成最终的报文数据。数据类型就是之前提到的TLS握手协议的4类子协议</li>
</ol>
<h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>握手协议负责生成对称密码中的共享密钥以及交换证书。因为握手的整个过程都是明文进行的，因此需要使用公钥密码或是Diffie-Hellman密钥交换。整个握手协议有下面几步：</p>
<ol>
<li><strong>ClientHello</strong>，客户端发送一些信息给服务器，便于协商算法和密钥</li>
</ol>
<ul>
<li>可用版本号，即支持的SSL&#x2F;TLS版本号</li>
<li>客户端生成的随机数，在后面的步骤会用到</li>
<li>会话ID，在需要重新使用以前的会话时用到</li>
<li>客户端可用的密码套件清单</li>
<li>客户端可用的压缩方式清单</li>
<li>当前时间</li>
</ul>
<ol start="2">
<li><strong>ServerHello</strong>，服务器根据客户端传来的信息，选择合适的算法和密码套件，返回的消息中带有下面几条</li>
</ol>
<ul>
<li>使用的版本号</li>
<li>服务端生成的随机数，后面步骤会用到</li>
<li>会话ID，作用同上</li>
<li>使用的密码套件</li>
<li>使用的压缩方式</li>
<li>当前时间</li>
</ul>
<ol start="3">
<li><strong>Certificate</strong>，<strong>非匿名通信</strong>时，服务器发送自己的证书，以及对服务器证书签名的CA的证书</li>
<li><strong>ServerKeyExchange</strong>，当Certificate消息不足时，服务器通过此消息传递额外信息</li>
<li><strong>CertificateRequest</strong>，需要进行<strong>客户端认证</strong>时，服务端发送此消息，并带上服务器能理解的证书类型、CA名称清单。</li>
<li><strong>ServerHelloDone</strong>，服务器发送此消息结束服务器的返回</li>
<li><strong>Certificate</strong>，作为CertificateRequest的回应，客户端发送自己的证书，交给服务器验证</li>
<li><strong>ClientKeyExchange</strong>，密码套件包含RSA时，会发送<strong>经过服务器公钥加密的预备主密码</strong>；密码套件包含Diffie-Hellman密钥交换时，会发送Diffie-Hellman密钥交换中的公开值。<strong>预备主密码（pre-master secret）</strong>是客户端生成的随机数，之后会用做生成主密码的种子。根据预备主密码，通信双方计算出<strong>相同的主密码</strong>。主密码会用做以下用途：</li>
</ol>
<ul>
<li>对称密码的密钥</li>
<li>消息认证码的密钥</li>
<li>CBC模式中的初始化向量</li>
</ul>
<ol start="9">
<li><strong>CertificateVerify</strong>，在服务器发送CertificateRequest时，通过此消息发送客户端使用自己私钥签名的主密码和握手协议传输消息的散列值。证明自己是客户端证书的持有人。</li>
<li><strong>ChangeCipherSpec</strong>，客户端发送，表示切换密码开始，实际上是密码规格变更协议的一类报文</li>
<li><strong>Finished</strong>，握手结束，此时已使用切换后的密码套件来加密发送。</li>
<li><strong>ChangeCipherSpec</strong>，<strong>Finished</strong>。来自服务器，作用同上。</li>
</ol>
<p>通过上面的步骤，双方达成了下面的目标：</p>
<ul>
<li>客户端获得了服务器的公钥，完成了服务器认证</li>
<li>服务器获得了客户端公钥，完成了客户端认证（如果需要的话）</li>
<li>生成了对称密码的密钥</li>
<li>生成了消息认证码中的共享密钥</li>
</ul>
<h3 id="密码规格变更协议"><a href="#密码规格变更协议" class="headerlink" title="密码规格变更协议"></a>密码规格变更协议</h3><p>用于在一开始从明文通信切换到使用密码套件沟通。</p>
<h3 id="警告协议"><a href="#警告协议" class="headerlink" title="警告协议"></a>警告协议</h3><p>用在握手协议异常、消息认证码错误、无法解压数据等异常情况。</p>
<h3 id="应用数据协议"><a href="#应用数据协议" class="headerlink" title="应用数据协议"></a>应用数据协议</h3><p>通信对象间传递应用数据。</p>
<h3 id="主密码"><a href="#主密码" class="headerlink" title="主密码"></a>主密码</h3><p>主密码根据预备主密码（pre-master secret）或Diffie-Hellman密钥交换的公开值生成。生成的主密码用于生成<strong>对称密码的密钥、消息认证码的密钥、CBC模式的初始化向量</strong>。</p>
<h3 id="对SSL-x2F-TLS的攻击"><a href="#对SSL-x2F-TLS的攻击" class="headerlink" title="对SSL&#x2F;TLS的攻击"></a>对SSL&#x2F;TLS的攻击</h3><ul>
<li>SSL&#x2F;TLS框架性的特点让它不依赖于某个特定的密码技术，因此对特定密码技术的攻击对SSL&#x2F;TLS本身影响不大</li>
<li>心脏出血漏洞，发现于2014年，利用TLS心跳拓展对请求的数据大小没有检查，可以获取内存中与请求无关的信息。是OpenSSL实现的漏洞。</li>
<li>POODLE攻击，利用CBC中的填充提示攻击，发现于2014年SSL3.0中。</li>
<li>FREAK攻击，可以在密码套件协商时，利用中间人攻击，强制使用强度很低的RSA Export Suites。从而在加密后，暴力破解明文。</li>
<li>对伪随机数生成器的攻击</li>
<li>利用之前提过的CRL</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>密码技术因为人类的不完美而必定不会完美。</p>
<ul>
<li><strong>对称密码</strong>，使用相同密钥加密、解密，保证消息<strong>机密性</strong>。目前主要使用AES。</li>
<li><strong>公钥密码</strong>，使用不同密钥加密、解密，作用同上。使用最广泛的是RSA，还有相关的Diffie-Hellman密钥交换</li>
<li><strong>单向散列函数</strong>，将消息转为固定长度散列值的技术，保证消息<strong>完整性</strong>，目前使用SHA2和SHA3（Keccak）</li>
<li><strong>消息认证码</strong>，结合单向散列函数和对称密码，保证消息<strong>完整性</strong>并<strong>认证消息</strong>，但无法防御<strong>否认</strong>。目前主要使用HMAC</li>
<li><strong>数字签名</strong>，结合单向散列函数和公钥秘钥，保证<strong>完整性</strong>，<strong>不可否认性</strong>和<strong>认证消息</strong>。是公钥证书采用的技术</li>
<li><strong>伪随机数生成器</strong>，配合上述技术使用，需要保证<strong>不可预测性</strong>和<strong>不可重现性</strong></li>
</ul>
<p>密码技术从某种角度看是一种压缩技术：</p>
<ul>
<li>密钥是机密性的压缩</li>
<li>散列值是消息完整性的压缩</li>
<li>认证值时认证的压缩</li>
<li>随机数种子是不可预测性的压缩</li>
</ul>
<h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>比特币来自于Satoshi Nakamoto（中本聪，化名）的一篇论文，并于2009年开始实际运用。比特币是一种<strong>基于P2P网络的支付结算系统</strong>。用户通过它进行进行价值转移。</p>
<ul>
<li><strong>地址</strong>，将公钥使用散列函数求散列值得到，地址都以1开头，剩下内容 不包含O，0,1和I。</li>
<li><strong>钱包</strong>，即比特币客户端，可以生成密钥对，公钥用于收款，密钥用于付款</li>
<li><strong>区块链</strong>，保存了比特币所有交易记录的账簿，若干交易组成一个区块，在区块头有所有交易的散列值，以及上一个区块的散列值，有交易添加时会触发区块头的散列值变化，并链式传递下去</li>
<li><strong>交易</strong>，收、付款方各自生成密钥对，付款方创建交易“地址A向地址B转账x BTC”，<strong>并用自己的私钥签署数字签名</strong>，之后广播至P2P网络中，完成交易。比特币使用的数字签名基于椭圆曲线DSA，方程为x^2 &#x3D; y^3 + 7</li>
<li><strong>挖矿</strong>，向区块链中添加新区块的行为被称为挖矿，第一个挖矿成功的矿工会获得挖矿奖励和区块所有交易的手续费。为了证明自己确实完成了规定工作，矿工需要进行<strong>工作量证明</strong>（PoW），即生成的区块头中，前一区块头的散列值必须以若干位的0开头，这个工作需要投入大量的计算资源。区块大约每10分钟添加一个，为了避免通货膨胀，所需的0的个数会不断调整。<ul>
<li>根据协议规定，挖矿奖励每4年减少一半</li>
<li>当区块链上同时出现分支时，P2P网络会选择计算量大的分支进行工作</li>
</ul>
</li>
<li>比特币的匿名性只限于交易地址</li>
</ul>
<h2 id="附录：椭圆曲线"><a href="#附录：椭圆曲线" class="headerlink" title="附录：椭圆曲线"></a>附录：椭圆曲线</h2><ul>
<li>椭圆曲线（EC）源自于求椭圆弧长的椭圆积分的反函数。</li>
<li>定义椭圆曲线上的加法运算</li>
<li>椭圆曲线上的离散对数（ECDLP） - 已知点G和点xG，求整数x</li>
<li>有限域上的离散对数，对点进行模运算</li>
<li>椭圆曲线Diffie-Hellman密钥交换</li>
<li>椭圆曲线ElGamal密码</li>
<li>椭圆曲线DSA（ECDSA）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/blog/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:27</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

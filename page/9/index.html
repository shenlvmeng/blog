<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/9/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">473</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/24/golang-learning/" class="post-title-link" itemprop="url">go语言入门学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 23:03:54" itemprop="dateCreated datePublished" datetime="2019-12-24T23:03:54+08:00">2019-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-05-12 22:34:39" itemprop="dateModified" datetime="2020-05-12T22:34:39+08:00">2020-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/12/24/golang-learning/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/24/golang-learning/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>66k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:50</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>更多：<a target="_blank" rel="noopener" href="https://golang.org/">go官网</a></p>
</blockquote>
<blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://github.com/shenlvmeng/go-learning-exercise">https://github.com/shenlvmeng/go-learning-exercise</a></p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Go语言构想与2007年9月，于2009年11月发布。主要思想来自3种语言：</p>
<ul>
<li>C，基础语法和编译</li>
<li>Pascal，包概念</li>
<li>CSP（Communication Sequential Process），并发思想</li>
</ul>
<p>Go项目诞生是为了解决Google中系统复杂性太高的问题。因此，简单性是Go思想的重要部分。设计上，Go</p>
<ul>
<li>没有隐式类型转换</li>
<li>没有构造和析构函数</li>
<li>没有运算符重载</li>
<li>没有形参默认值</li>
<li>没有继承</li>
<li>没有泛型</li>
<li>没有异常</li>
<li>没有宏（macro）</li>
<li>没有函数注记</li>
<li>没有线程局部存储</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="范例1：Hello-world"><a href="#范例1：Hello-world" class="headerlink" title="范例1：Hello world"></a>范例1：Hello world</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在诸多语言中，C对Go的影响是最深的。<code>.go</code>文件需要经过编译成二进制文件才可以运行。</p>
<ul>
<li><code>go run</code>可以直接运行<code>.go</code>文件</li>
<li><code>go build</code>可以编译生成二进制文件，并在之后直接执行</li>
</ul>
<p>在代码结构上，</p>
<ul>
<li>先声明当前包名，其中命名为<code>main</code>的包名代表代码是可执行程序，而非一个库文件</li>
<li>再<code>import</code>依赖包，go自带100+内置包。在编译时，编译器会抛弃未被使用的包，减少体积</li>
<li>接下来是程序代码，命名为<code>main</code>的函数是执行的入口</li>
</ul>
<p>Go代码有着标准的代码格式，并可以通过<code>gofmt</code>格式化代码。<strong>代码中不需要在行尾写分号</strong>，后面紧跟特定token的换行符会自动转成分号。因此，Go代码中换行会影响代码编译。</p>
<h3 id="范例2：命令行参数"><a href="#范例2：命令行参数" class="headerlink" title="范例2：命令行参数"></a>范例2：命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 1</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s, sep <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">        s += setp + os.Args[i]</span><br><span class="line">        setp = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>切片（slice）是序列数组元素的表示方式，可以用<code>s[i]</code>或<code>s[m:n]</code>（m或n缺失是表示头和尾元素位置）获取1或n-m个元素。使用<code>len(s)</code>获取长度。</li>
<li>注释以<code>//</code>开头</li>
<li>import多个库时，可以用<code>()</code>包裹列表的形式声明，这种写法更为常见</li>
<li>使用<code>var</code>开头表示变量声明，未指定初始值的变量会隐式初始化为当前类型的“零值”（0或’’等）</li>
<li><code>:=</code>式的声明可以省去<code>var</code>更快地为一组变量初始化</li>
<li>go中的<strong>for循环是唯一的循环语句</strong>，分为以下三部分。缺失initialization和condition时可以表示while循环</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// zero or more statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 2</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s, sep := <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, arg := os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        s += sep + arg</span><br><span class="line">        sep = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环中，<code>range</code>可以生产一对值，index和value</li>
<li><code>_</code>专门用来替代不需要使用的变量名，否则go会报错</li>
<li>另外也可以直接用<code>strings.Join</code>方法实现效果</li>
</ul>
<h3 id="范例3：寻找重复行"><a href="#范例3：寻找重复行" class="headerlink" title="范例3：寻找重复行"></a>范例3：寻找重复行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    input = bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同<code>for</code>循环一样，<code>if</code>语句也不需要<code>()</code>包裹</li>
<li>内置的<code>make</code>函数可以创建一个新的map。map也可以被<code>for</code>循环遍历，每次循环的pair分别是key和value</li>
<li><code>counts[input.Text()]</code>中当key不存在时，会返回零值0</li>
<li>bufio库可以更方便地帮忙处理程序的输入（input）和输出（output）<ul>
<li><code>input.Scan()</code>获取下一行，并自动去掉末尾换行符，在没有内容时返回<code>false</code></li>
<li><code>input.Text()</code>获取当前位置的文本</li>
</ul>
</li>
<li><code>Printf</code>和C语言风格类似，里面行如<code>%s</code>，<code>%v</code>的特殊符号称为<em>verbs</em></li>
</ul>
<p>从文件中寻找代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    files := os.Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">        countlines(os.Stdin, counts)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">            f, err := os.Open(file)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">&quot;dup: %v\n&quot;</span>, err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            countLines(f, counts)</span><br><span class="line">            f.Close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, lines)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countlines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(f)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的流模式读取文件外，还可以直接把整个文件直接读进内存，再将二进制数据string化并处理。此处可以使用<code>io/ioutil</code>中的<code>ReadFile</code>方法。转换过程用<code>string(data)</code>完成。</p>
<p>日常使用时，通常借助bufio，ioutil等高层级API就可以完成任务，而不需要深入实现内部。</p>
<h3 id="范例4：Gif"><a href="#范例4：Gif" class="headerlink" title="范例4：Gif"></a>范例4：Gif</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;image&quot;</span></span><br><span class="line">	<span class="string">&quot;image/color&quot;</span></span><br><span class="line">	<span class="string">&quot;image/gif&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	whiteIndex = <span class="number">0</span></span><br><span class="line">	blackIndex = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lissajous(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		cycles  = <span class="number">5</span></span><br><span class="line">		res     = <span class="number">0.001</span></span><br><span class="line">		size    = <span class="number">100</span></span><br><span class="line">		nframes = <span class="number">64</span></span><br><span class="line">		delay   = <span class="number">8</span></span><br><span class="line">	)</span><br><span class="line">	freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">	phase := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">		img := image.NewPaletted(rect, palette)</span><br><span class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">			x := math.Sin(t)</span><br><span class="line">			y := math.Sin(t*freq + phase)</span><br><span class="line">			img.SetColorIndex(size+<span class="type">int</span>(x*size+<span class="number">0.5</span>), size+<span class="type">int</span>(y*size+<span class="number">0.5</span>), blackIndex)</span><br><span class="line">		&#125;</span><br><span class="line">		phase += <span class="number">0.1</span></span><br><span class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">	&#125;</span><br><span class="line">	gif.EncodeAll(out, &amp;anim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>const</code>声明常量，常量的值只能是number，string或boolean</li>
<li><code>gif.GIF&#123;...&#125;</code>是合成字面量的写法，其类型是struct，可以字面量声明其field，未声明fields均为零值（zero value）</li>
<li>image库API可以操作图像</li>
</ul>
<h3 id="范例5：fetch"><a href="#范例5：fetch" class="headerlink" title="范例5：fetch"></a>范例5：fetch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;http://&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.HasPrefix(url, prefix) &#123;</span><br><span class="line">			url = prefix + url</span><br><span class="line">		&#125;</span><br><span class="line">		resp, err := http.Get(url)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: %v\n&quot;</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		_, err = io.Copy(os.Stdout, resp.Body)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和网络相关的API都位于net库中，如<code>http.Get(url)</code></li>
<li><code>os.Exit(1)</code>代表异常退出</li>
</ul>
<h3 id="范例6：并行fetch"><a href="#范例6：并行fetch" class="headerlink" title="范例6：并行fetch"></a>范例6：并行fetch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">go</span> fetch(url, ch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2fs elapse\n&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	res, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprint(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	nbytes, err := io.Copy(ioutil.Discard, res.Body)</span><br><span class="line">	res.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprintf(<span class="string">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	secs := time.Since(start).Seconds()</span><br><span class="line">	ch &lt;- fmt.Sprintf(<span class="string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>goroutine是go中并行执行函数的表示，channel是goroutine间相互沟通的方式，传递特定类型数据。<strong>goroutine相互沟通时，沟通的两者会对其他goroutine block</strong>，保证没有冲突<ul>
<li>goroutine使用<code>go</code>创建，channel使用<code>chan</code>创建，<code>ch &lt;-</code>表示向channel发送，<code>&lt;- ch</code>表示从channel接收</li>
</ul>
</li>
<li><code>ioutil.Discard</code>输出流会直接丢弃流内容</li>
</ul>
<h3 id="范例7：web-server"><a href="#范例7：web-server" class="headerlink" title="范例7：web server"></a>范例7：web server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>http</code>库的<code>HandleFunc</code>和<code>ListenAndServer</code>可以便捷地启动一个服务器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handle)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/count&quot;</span>, counter)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;count %d\n&quot;</span>, count)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>server会为每个请求创建一个新的goroutine处理，为了避免并发读写count时的bug，使用了mutex锁保证读写是都是串行的</li>
<li><code>os.Stdout</code>,<code>ioutil.Discard</code>, <code>http.ResponseWriter</code>都实现了<code>io.Writer</code>接口，因此可以用在任何需要输出流的地方</li>
<li>if语句前可以增加前置语句，如<code>if err:=xxx; err != nil</code></li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li>go中的<code>switch</code>没有fall through机制，若需要，需要显示声明<code>fallthrough</code>。<code>case</code>支持表达式，<code>switch</code>后支持没有操作数，此时的switch称为tagless switch。<code>break</code>, <code>continue</code>, <code>goto</code>命令如常</li>
<li>go中有命名类型，类似ts中的<code>interface</code>，行如<code>type Point struct &#123; X, Y int &#125;</code></li>
<li>go中有指针，<code>*</code>表示去指针对应的值，<code>&amp;</code>表示取变量的指针，另外<strong>不支持指针上的算术运算</strong></li>
<li>go中的方法指命名类型上的函数，interface意义如常</li>
<li>可以去<a target="_blank" rel="noopener" href="https://golang.org/pkg">这里</a>寻找标准库的包，或去<a target="_blank" rel="noopener" href="https://godoc.org/">这里</a>寻找社区贡献的包</li>
<li>注释风格同其他语言，<code>//</code>表示单行注释，<code>/* */</code>表示多行注释。不支持嵌套注释</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>和JS类似</p>
<ul>
<li>以**Unicode字母或下划线<code>_</code>**开头</li>
<li>后跟<strong>Unicode字母或数字或下划线</strong></li>
<li><strong>大小写敏感</strong></li>
</ul>
<p>go目前（2020&#x2F;01&#x2F;01）有25个不允许用来命名的<strong>关键字</strong>，其中几个可能是对前端较难想到的是</p>
<ul>
<li><code>select</code></li>
<li><code>defer</code></li>
<li><code>chan</code></li>
<li><code>range</code></li>
<li><code>fallthrough</code></li>
</ul>
<p>另外，还有一些预定义常量、类型、函数<strong>可以用来命名</strong>，但很容易造成误解，下面举些例子：</p>
<ul>
<li>常量：<code>true</code> <code>iota</code> <code>nil</code></li>
<li>类型：<code>int</code> <code>complex128</code> <code>uintptr</code> <code>rune</code> <code>error</code></li>
<li>函数：<code>make</code> <code>len</code> <code>imag</code> <code>panic</code> <code>close</code></li>
</ul>
<p><strong>包名始终小写</strong>，在函数域内命名的函数只在函数域内可见，否则<strong>在整个包域内可见</strong>。整个包内声明的变量用首字母区分可见性：</p>
<ul>
<li><strong>首字母大写的可以被其他包访问</strong>，如<code>fmt.FPrintf</code></li>
<li>反之则只在包内可见</li>
</ul>
<p>命名长度没有限制，但建议<em>scope越大的变量命名越长</em>。Go使用驼峰风格的变量命名，首字母缩略词和首字母<strong>同大写或同小写</strong>。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明有4钟：</p>
<ul>
<li><code>var</code> 变量</li>
<li><code>const</code> 常量</li>
<li><code>type</code> 类型</li>
<li><code>func</code> 函数</li>
</ul>
<p>声明在函数域内可见，或在整个包域内可见。函数返回可以是一组变量。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = expression</span><br></pre></td></tr></table></figure>

<p>Go中的变量声明如上所示，其中的<code>type</code>部分或<code>expression</code>部分可以省略，<strong>但是不能同时省略</strong>。</p>
<ul>
<li>type缺失时，name的类型由expression字面量或返回值决定</li>
<li>expression缺失时，name的值<strong>自动设置为type类型的“零值”（zero value）</strong><ul>
<li>数值零值为0，字符串零值为<code>&quot;&quot;</code>，布尔类型零值为<code>false</code></li>
<li>其余接口或引用类型零值为<code>nil</code>，如指针、map、切片、函数、channel</li>
<li>聚合类型的零值即其所有组成元素的零值</li>
</ul>
</li>
</ul>
<p>所以，<strong>Go中不存在未初始化的变量</strong>。包级别变量在<code>main</code>函数开始前初始化，局部变量在声明过程中初始化。一组变量可以同时被初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">1.3</span>, <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">var</span> f, err = os.Open(name)</span><br></pre></td></tr></table></figure>

<h4 id="简写式"><a href="#简写式" class="headerlink" title="简写式"></a>简写式</h4><p>在<strong>函数域</strong>内的<strong>局部变量声明</strong>可以使用简写式，即<code>:=</code>。在已知变量初始值时可以省去写<code>var</code>。在初始值并不重要或最好显式写明类型时，还是使用<code>var foo type</code>的形式比较好。和<code>var</code>声明一样，也可以同时用简写式声明多个局部变量。但要注意，不要把这种写法和<em>元组赋值（tuple assignment）</em>搞混了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiple initialzier expression</span></span><br><span class="line">i, j := <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple assignment</span></span><br><span class="line">i, j = j, i</span><br></pre></td></tr></table></figure>

<p>另外，简写式声明里可以写<strong>部分</strong>已经声明的局部变量，在这里会当做赋值处理。但是简写式声明中要<strong>至少包含一个未声明变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.OpenFile(infile)</span><br><span class="line">out, err := os.OpenFile(outfile)</span><br></pre></td></tr></table></figure>

<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>Go中的指针和C中类似，用<code>&amp;</code>表示取一个<strong>变量</strong>的地址，用<code>*</code>表示访问某个地址所在的位置。指针的零值为<code>nil</code>，因此可以用<code>p != nil</code>来判断指针是否指向变量。</p>
<h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><code>new</code>函数</h4><p>可以通过<code>new</code>函数，声明类型<code>T</code>创建新的<strong>匿名</strong>变量，函数返回变量的指针即<code>*T</code>类型。这在不需要变量名时很好用。每次调用<code>new</code>函数新建变量时，返回的地址<strong>不同</strong>，<strong>除非类型不附加任何信息</strong>，如<code>struct &#123;&#125;</code>或<code>[0]int</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">*p = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>另外，由于<code>new</code>只是预定义函数，所以可以用来做变量名。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期即变量从创建到被回收的时间。包级别的变量会在整个程序执行过程中存在。局部变量则会在<em>未被引用（unreachable）</em>时释放内存。Go中的垃圾回收机制会自动帮你完成这件事。但是如果有下面这种情况出现，则会阻止垃圾回收释放内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	x = <span class="number">1</span></span><br><span class="line">	global = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，<code>x</code>局部变量从<code>f</code>函数中<strong>逃逸</strong>，并不会在<code>f</code>函数返回时被回收，持久存储在堆（heap）中。应尽量避免这种情况带来的额外内存损耗。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>和其余语言赋值没什么太大区别。</p>
<p>不同的是，额外增加了<strong>元组赋值</strong>。<code>=</code>右侧的一组变量会先求值，再赋给左侧变量。建议在不需要复杂运算时使用。同时，有些表达式和函数也会返回一组值，此时需要用元组赋值的方式接收。在不需要某个变量时，可以使用<code>_</code>占位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, y= y, x</span><br><span class="line"></span><br><span class="line">f, err = os.Open(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line">v, ok = m[key]</span><br><span class="line">v, ok = x.(T)</span><br><span class="line">v, ok = &lt;- ch</span><br></pre></td></tr></table></figure>

<h4 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h4><p>除了一些显式的赋值外，还有函数返回、字面量声明等。Go中的赋值<strong>当且仅当</strong><code>=</code>左右的值和变量<strong>类型相同</strong>才可进行（对于<code>==</code>和<code>!=</code>的判断也是这样）。<code>nil</code>可以赋值给任何复杂类型或引用类型。</p>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p>Go中可以定义类型。Go中的类型定义储存值的符号、它们的大小、固有操作以及方法，使用<code>type name underlying-name</code>声明。它通常出现在包级别，有些也会通过首字母大写的形式export出去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CTOF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123;</span><br><span class="line">	<span class="keyword">return</span> Fahrenheit(c * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FTOC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123;</span><br><span class="line">	<span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个有着相同底层类型的命名类型并不是同一种类型</strong>，也不能直接相互赋值和比较。但是可以使用<strong>强制类型转换</strong>转换到想同类型来比较。所有的类型<code>T</code>都有对应的强制类型转换操作<code>T(x)</code>。两个有相同类层类型或指向相同底层类型的未命名指针可以相互强制转换。另外，Go中的强制类型转换从不会在运行时出错。</p>
<p>比较特别的是，类型上还可以声明方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h3><p>Go中的包即其他语言中的库、模块。以实现模块化、封装、分发和重用。和Java类似，一个包的代码<strong>可以存放在多个文件内</strong>，通常位于同一个文件夹下。每个包都有相互隔离的命名空间，需要用·<code>image.Decode</code>的形式使用。需要<code>export</code>的变量、类型、函数使用<strong>首字母大写</strong>的形式。</p>
<p>建议在每个export出去的变量、类型、函数前使用注释说明。另外，建议在包开头留下<em>doc comment</em>，或将更多注释放在<code>doc.go</code>中。</p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;shenlvmeng/learning/tempconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		t, err := strconv.ParseFloat(arg, <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Strerr, <span class="string">&quot;convert error: %v\n&quot;</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		f := temconv.Fahrenheit(t)</span><br><span class="line">		c := tempconv.Celsius(c)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s = %s, %s = %s\n&quot;</span>, f, tempconv.FTOC(f), c, tempconv.CTOF(c))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个包都有自己的import路径，Go语言标准并不定义如何解释import路径，这一步交给解释工具完成。每个包的包名通常和路径的最后一段同名。为避免包名冲突，import可以指定包的别名。</p>
<p>在引用了未被使用的包时会报错。，借助<code>goimports</code>等工具和正确的IDE配置，可以在保存代码时自动标准化代码格式。</p>
<h4 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a>包初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">//third</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// first</span></span><br></pre></td></tr></table></figure>

<p>初始化时，先按照依赖的顺序初始化包级别变量。而<code>.go</code>文件的处理顺序则按照传给go编译器的顺序。初始化的过程是自底向上的，即当所有依赖包都初始化完成后，才会初始化<code>main</code>包，再执行<code>main</code>函数。对于初始化过程复杂的变量，可以在<code>init</code>函数中声明，而<code>init</code>是在程序启动时，按照声明的顺序一个一个执行的。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是编译时的，和运行时的生命周期概念相对应。作用域描述一个声明的可见范围。和C系列语言类似，用大括号<code>&#123;&#125;</code>包裹会形成<strong>词法块作用域</strong>。Go在<strong>全局作用域</strong>下预定义了一些常量、函数、类型等。在函数外声明的作用域是包级别的，<code>import</code>进来的包作用域是文件级别的。局部声明只在块作用域内。内部作用域会覆盖外部作用域的同名声明。</p>
<p>另外，Go中还有一些<strong>隐式</strong>的作用域，比如<code>for</code>，<code>if</code>，<code>switch</code>表达式中的作用域。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x := x[i]</span><br><span class="line">		<span class="keyword">if</span> x != <span class="string">&quot;o&quot;</span> &#123;</span><br><span class="line">			x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> <span class="comment">// 类似upperCase</span></span><br><span class="line">			fmt.Prinf(<span class="string">&quot;%c&quot;</span>, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>for</code>和<code>if</code>内部的x是一个单独的作用域。另外注意，简写式中会声明局部变量，会覆盖外部的同名变量，可能会带来意料之外的结果。可以通过<code>var xxx type</code>的形式声明变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cwd, err := os.Getwd() <span class="comment">// compile error: unused cwd</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><p>Go有4大类数据类型：</p>
<ul>
<li><strong>基础类型</strong>，即数字、字符串、布尔值</li>
<li><strong>聚合类型</strong>，即数组、struct</li>
<li><strong>引用类型</strong>，包括函数、指针、slice、map、channel</li>
<li><strong>接口类型</strong></li>
</ul>
<p>这一部分先说基础类型</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Go的数字类型包含了不同size的整型、浮点数和复数，以及它们的有无符号性。</p>
<p>整型有8、16、32、64四种长度，以及对应的signed和unsigned。组合一下即下面8种：</p>
<ul>
<li><code>int8</code></li>
<li><code>int16</code></li>
<li><code>int32</code></li>
<li><code>int64</code></li>
<li><code>uint8</code></li>
<li><code>uint16</code></li>
<li><code>uint32</code></li>
<li><code>uint64</code></li>
</ul>
<p>另外，<code>rune</code>是<code>int32</code>的别称，通常用来表示1个Unicode字符，<code>byte</code>是<code>unit8</code>的别称。<code>uintptr</code>用来表示一个可以承载任意指针值的无符号整型。</p>
<p>Go中对整型的处理和C风格很像。</p>
<ul>
<li>用首位表示符号位（signed int中）</li>
<li>类型承载范围和C一样，如int8表示-128到127</li>
<li>和C一样的操作符以及优先级，唯一区别是<code>&amp;^</code>表示位清除，<code>x &amp;^ y</code>表示根据y各位将x各位清0</li>
<li><code>&lt;&lt;</code>左移位，空位取0，<code>&gt;&gt;</code>右移位，无符号数补零，<strong>有符号数补符号位</strong></li>
<li>整型间除法会清除小数部分</li>
<li>取余<code>%</code>运算结果符号和被除数有关</li>
<li>超过位数的会溢出</li>
<li><code>0</code>开头表示八进制（通常用来表示POSIX系统中文件权限设置），<code>0x</code>表示十六进制</li>
</ul>
<p>不一样的是：</p>
<ul>
<li>相同类型才可比较大小，否则需要用<code>int()</code>强制转换为1种类型再比较。某些类型转换只改变值的使用方式，有些则会改变值，如<code>int</code>和<code>float</code>之间的转换</li>
<li>用<code>%d</code>, <code>%o</code>, <code>%x</code>分别表示整型、八进制和十六进制数</li>
<li>用<code>%c</code>表示显示对应的Unicode字符，<code>%q</code>显示带引号版本</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数有<code>float32</code>和<code>float64</code>两种类型，服从IEEE754标准。为保证精确性，通常使用<code>flaot64</code>。另外，还有以下特点</p>
<ul>
<li><code>.</code>前后的0可以省略</li>
<li><code>%g</code>, <code>%e</code>和<code>%f</code>分别打印最合适展示精确度版本、指数版本和原始版本</li>
<li>有<code>+Inf</code>, <code>-Inf</code>和<code>NaN</code>特殊值，表现类似JS</li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>Go有两种复数类型：<code>complex64</code>和<code>complex128</code>，它们其实是由<code>float32</code>和<code>float64</code>组成的。复数可以通过<code>complex</code>内置函数初始化，或者直接使用字面量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1 + 2i</span></span><br><span class="line">y := <span class="number">3</span> - <span class="number">4i</span></span><br></pre></td></tr></table></figure>

<p>复数间可以判断相等性，无法判断大小。<code>math/cmplx</code>包里包含一些复数的数学运算。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>即type <code>bool</code>，和其他语言类似，有短路行为，<code>&amp;&amp;</code>比<code>||</code>优先级更高。<code>bool</code>类型和整型之间不能相互隐式转换。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串表示<strong>一组不可修改的比特位序列</strong>，但通常用来承载可读的Unicode编码点。<code>len</code>返回字符串长度，<code>[i]</code>返回第<code>i</code>个<strong>字节</strong>处的值。越界读取会导致panic。</p>
<ul>
<li><code>s[i:j]</code>表示自带的substring操作，其中<code>i</code>和<code>j</code>均可省略</li>
<li>字符串间可以比较大小和相等性，其中大小通过逐字节子母序比较</li>
<li><code>+</code>可表示字符串拼接</li>
<li>不可变性：不允许修改字符串的值（如<code>s[0] = &#39;L&#39;</code>），这使得Go可以在底层复用字符串，节省内存</li>
</ul>
<h4 id="字面量字符串"><a href="#字面量字符串" class="headerlink" title="字面量字符串"></a>字面量字符串</h4><p>用双引号<code>&quot;</code>包裹，UTF-8编码。双引号中的反斜线<code>\</code>有特殊含义。如</p>
<ul>
<li><code>\n</code>表示换行</li>
<li><code>\t</code>表示制表符</li>
<li><code>\x</code>表示后接十六进制的高低位</li>
<li><code>\ooo</code>表示三个八进制位</li>
</ul>
<p>由反引号&#96;&#96; &#96;包裹的表示纯文本字面量，其中的换行和格式也会被跨平台保留。可以用来书写多行字符串。</p>
<h4 id="Unicode表示"><a href="#Unicode表示" class="headerlink" title="Unicode表示"></a>Unicode表示</h4><p>Go中使用UTF-8变长编码：</p>
<ul>
<li><code>0xxxxxxx</code>表示ASCII码</li>
<li><code>11xxxxxx 10xxxxxx</code> 表示两字节长度</li>
<li><code>110xxxxx 10xxxxxx 10xxxxxx</code>表示三字节长度</li>
<li><code>1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx</code> 表示四字节长度</li>
</ul>
<p>可以由<code>\uhhhh</code>表示16比特或<code>\U</code>表示32比特，如世界：<code>\u4e16\u754c</code>。<code>unicode</code>包和<code>unicode/utf8</code>包提供了编解码工具。<code>utf6.DecodeRuneInString</code>可以读取一个自然字符的数据，而非一个字节一个字节读取，<code>utf8.RuneCountInString</code>返回字符串的自然字符长度。幸运的是，<code>range</code>循环会自动调用utf8解码其中的自然字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode/uft8&quot;</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 13</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s) <span class="comment">// 9)</span></span><br></pre></td></tr></table></figure>

<p>当Go Unicode解析失败时，会使用特殊的Unicode占位符<code>\ufffd</code>，显示为带有问号的特殊字符。另外，<code>rune[]</code>可以直接将字符串转成编码后的每个Unicode编码点。这个rune数组进行<code>string()</code>强制类型转换后即原始字符串。当然你也可以直接<code>string()</code>装换一个整型数，不合规的整形数会得到上面提到的特殊字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;世界&quot;</span></span><br><span class="line">r := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="type">string</span>(r))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(<span class="number">65</span>))</span><br><span class="line">fmt.Printlf(<span class="type">string</span>(<span class="number">12341234</span>))</span><br></pre></td></tr></table></figure>

<h4 id="字符串和Byte-Slices"><a href="#字符串和Byte-Slices" class="headerlink" title="字符串和Byte Slices"></a>字符串和Byte Slices</h4><p><code>bytes</code>, <code>strings</code>, <code>strconv</code>, <code>unicode</code>是和string相关的几个包。<code>strings</code>提供基本的字符串搜索、比较、修改等操作，<code>bytes</code>提供修改字节数组的一些操作。有时，使用<code>byte.Buffer</code>类型，在操作字符串字节时会更有效率。<code>strconv</code>提供了将其他类型转成字符串和修饰字符串的操作函数。<code>unicode</code>提供了一些以rune为中心的函数，如<code>IsDigit</code>, <code>IsLetter</code>, <code>isUpper</code>等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basename removes directory and filename suffix</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basename</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	slash := strings.LastIndex(s, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">	s = s[slash+<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> dot := strings.LastIndex(s, <span class="string">&quot;.&quot;</span>); dot &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		s = s[:dot]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path</code>和<code>path/filepath</code>包提供了更多文件夹和目录的操作函数。</p>
<p>尽管字符串中的字节序列是不可更改的。<strong>其对应的字节序列数组则是可以自由修改的</strong>。<code>[]byte(s)</code>会分配一个字符串<code>s</code>的字节序列拷贝，也可以对应用<code>string(b)</code>还原。<code>bytes</code>包提供的<code>Buffer</code>类型可以很方便地承载<code>[]byte</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中，<code>WriteString</code>和<code>WriteByte</code>用于向Buffer中写入字节或字节序列，该类型还有许多其他应用场景。</p>
<h4 id="字符串和整型间的转换"><a href="#字符串和整型间的转换" class="headerlink" title="字符串和整型间的转换"></a>字符串和整型间的转换</h4><ul>
<li><strong>字符串 -&gt; 整型</strong>，<code>fmt.Sprintf</code>或<code>strconv.Itoa</code></li>
<li><strong>整型 -&gt; 字符串</strong>，<code>strconv.FormatInt</code>或<code>strconv.FormatUint</code>或<code>strconv.ParseInt</code>或<code>Atoi</code></li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量有以下几个基本特点:</p>
<ul>
<li>编译时即对编译器可知</li>
<li>必须是基础类型：boolean，string或number</li>
</ul>
<p>常量使用<code>const</code>声明，形式看起来和使用<code>var</code>类似，不过值是常量。对常量进行的所有操作，如数学运算、逻辑运算、比较、内置函数求值，都是在编译期就确定了。</p>
<p>常量可以组声明，声明时可以不显式声明类型，此时将使用右侧操作数推断常量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	noDelay time.Duration = <span class="number">0</span></span><br><span class="line">	timeout = <span class="number">5</span> * time.Minute</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, noDelay) <span class="comment">// &quot;time.Duration 0&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, timeout) <span class="comment">// &quot;time.Duration 5m0s&quot;</span></span><br></pre></td></tr></table></figure>

<p>还有个不常用的点：组声明时，<strong>除了第一个常量，剩下的常量可以不写右侧操作数</strong>，此时会使用<strong>上一个常量</strong>来初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b</span><br><span class="line">	c = <span class="number">2</span></span><br><span class="line">	d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="常量生成器iota"><a href="#常量生成器iota" class="headerlink" title="常量生成器iota"></a>常量生成器<code>iota</code></h4><p><code>iota</code>即常量生成器，它从0开始，每次常量声明后加一。利用这个规律可以方便地生成一组常量枚举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">	Monday</span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Saturday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="keyword">const</span> _ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * itoa)</span><br><span class="line">	KB</span><br><span class="line">	MB</span><br><span class="line">	GB</span><br><span class="line">	TB</span><br><span class="line">	PB</span><br><span class="line">	EB</span><br><span class="line">	ZB</span><br><span class="line">	YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h4><p>常量和变量不一样的点在，<strong>常量是可以不声明类型的</strong>，根据常量限定的类型，有下面一些类型：</p>
<ul>
<li>无类型整型</li>
<li>无类型Boolean</li>
<li>无类型rune</li>
<li>无类型浮点数</li>
<li>无类型复数</li>
<li>无类型字符串</li>
</ul>
<p>常量在使用时，会<strong>隐式</strong>转换成需要的类型，并在无法转换时抛出错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + i <span class="comment">// complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span> <span class="comment">// integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span> <span class="comment">// float -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span> <span class="comment">// rune -&gt; float64</span></span><br></pre></td></tr></table></figure>

<p>实际上，这些无类型常量有一个隐含类型，如:</p>
<ul>
<li>无类型整型 -&gt; <code>int</code></li>
<li>无类型浮点数 -&gt; <code>float64</code></li>
<li>无类型复数 -&gt; <code>complex128</code></li>
<li>无类型rune -&gt; <code>int32</code>（<code>rune</code>）</li>
</ul>
<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><p>基本类型是数据结构的组成“原子”。原子的组合就构成了“分子”——聚合类型：</p>
<ul>
<li>array</li>
<li>slices</li>
<li>maps</li>
<li>structs</li>
</ul>
<p>其中array和structs是聚合类型的基础，它们都有着<strong>固定大小</strong>。而slice和map则是动态大小。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])</span><br><span class="line">fmt.Println(f[<span class="built_in">len</span>(a)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<p>类似C风格，array表示由0或多个同一类型元素组成的<strong>定长序列</strong>。声明数组时，需要使用<strong>常量表达式</strong>作为数组长度。当数组元素全部列出时，可以用<code>...</code>代替长度。元素未声明初始值时，按零值（zero value）处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="number">1</span>[<span class="number">2</span>]) <span class="comment">// 0</span></span><br><span class="line">q = [...]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当元素较多时，还可以用index到value的键值对形式声明，未声明的值为零值。下面的例子中，<code>r</code>长度100，除了最后一个元素为-1之外，其余都为0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>若数组数组具有可比性，则数组也具有<strong>可比性</strong>。另外，不同长度的数组是不同类型。<code>[4]int</code>和<code>[3]int</code>不是同一类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := sha256.Sum256(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	c2 := sha256.Sum256(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\t\n&quot;</span>, c1 == c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go中将数组作为参数传递时，<strong>传递的是复制的新数组，而不是传入数组的引用</strong>，这是Go和其他语言不大一样的地方。当然可以通过传入数组指针的方式，实现在函数内修改数组内容。由于数组是定长的，在更多时候，函数参数使用slice类型传入。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice和array类型紧密相关，使用<code>[]T</code>声明。每个slice的底层都基于一个array。slice只是一个指针指向array中的某一个元素作为开始，除此之外，它还有<code>len</code>和<code>cap</code>函数分别用来表示切片长度，和切片最大容量（从切片开始到底层array结尾）。</p>
<p>因此不同slice可以共享同一个array，它们之间可以相互重叠。<code>s[i:j]</code>是从创建slice的方式，遵从左闭右开原则，<code>i</code>和<code>j</code>均可省略，省略时分别表示0和数组最末尾元素。<strong>创建可以基于一个array变量或一个array指针或其他slice</strong>。创建超过array范围会引起panic，只超过<code>len(s)</code>则会拓展这个slice。因为string实际上是<code>[]byte</code>切片，所以<code>s[i:j]</code>和<code>substring</code>是一个意思。</p>
<p>从上面可以看到，slice即一个指向数组元素的指针，所以传递一个slice时，可以修改底层array的值。下面这个反转数组的函数不限数组长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		s[i], s[j] := s[j], s[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>&#125;</span><br><span class="line">reverse(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// [5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>s</code>是一个切片字面量，和array的区别在于没有声明长度。这种写法实际上会生成以后面值为全部元素的数组，并把切片指向这个数组。类似地，还可以使用<code>make</code>创建一个切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>由于切片只是引用，从效率和可理解性上考虑，<strong>切片间不具有可比性</strong>。不过切片可以和<code>nil</code>比较，<code>nil</code>表示空切片，而非“没有元素”的切片。不过Go中slice相关的函数对待这两种切片行为一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> <span class="comment">// s == nil</span></span><br><span class="line">S = <span class="literal">nil</span> <span class="comment">// s == nil</span></span><br><span class="line">s = []<span class="type">int</span>(<span class="literal">nil</span>) <span class="comment">// s == nil</span></span><br><span class="line">s = []<span class="type">int</span>&#123;&#125; <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>

<h4 id="append和copy"><a href="#append和copy" class="headerlink" title="append和copy"></a><code>append</code>和<code>copy</code></h4><p><code>append</code>函数可以操作slice。如果append之后，slice长度超过了底层array的长度，<code>append</code>会自动拓展底层array长度。另外，append不仅可以追加单个元素，还可以追加任意个元素，或解构后的slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">	runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes)</span><br><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...)</span><br></pre></td></tr></table></figure>

<p>在不借助<code>append</code>实现类似<code>append</code>功能时，就需要自己借助<code>cap(x)</code>和<code>make</code>完成底层array的长度扩充。如同下面的一段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="type">int</span>, y ...<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="type">int</span></span><br><span class="line">	zlen := <span class="built_in">len</span>(x) + <span class="built_in">len</span>(y)</span><br><span class="line">	<span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">		z = x[:zlen]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		zcap := zlen</span><br><span class="line">		<span class="keyword">if</span> zcap &lt; <span class="number">2</span> * <span class="built_in">len</span>(x) &#123;</span><br><span class="line">			zcap := <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">		z = <span class="built_in">make</span>([]<span class="type">int</span>, zlen, zcap)</span><br><span class="line">		<span class="built_in">copy</span>(z, x)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(z[<span class="built_in">len</span>(x)], y)</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>...</code>表示剩余参数，</p>
<p>借助<code>copy</code>还能实现一些slice的原址操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="built_in">copy</span>(slice[i:], slice[i+<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map即键值对，其中<strong>key要求具有可比较性</strong>。map有两种构造方式：<code>make</code>或字面量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="string">&quot;Alice&quot;</span>: <span class="number">18</span>,</span><br><span class="line">	<span class="string">&quot;Bob&quot;</span>: <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map使用<strong>下标访问</strong>，使用<code>delete</code>删除键。另外，<strong>访问不存在的key时，值是<code>value</code>类型的零值</strong>。因此可以免去一些多余的初始化步骤。由于map的值并不是变量，所以不能用<code>&amp;</code>获取地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;Cindy&quot;</span>] = <span class="number">23</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;bob&quot;</span>)</span><br><span class="line"><span class="comment">// 新的key</span></span><br><span class="line">ages[<span class="string">&quot;Dred&quot;</span>] += <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">_ := &amp;ages[<span class="string">&quot;Cindy&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>map在遍历时，顺序是随机的。因此如果需要确定顺序，需要事先手动排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">	names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, names := <span class="keyword">range</span> names &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的<code>delete</code>，<code>len</code>，<code>range</code>和取值操作都可以对零值<code>nil</code>进行，但是存储到<code>nil</code>map时会报错。由于访问map不存在的key会返回默认的零值，所以下标操作用第二个参数返回是否对应的key，*且参数通常命名<code>ok</code>*。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;Ed&quot;</span>]; !ok &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go中没有<code>set</code>类型，可以用<code>map[string]bool</code>等价。当key可能不可比较时（如用slice做key），可以用额外的序列化使用。</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>struct类似ts中的<code>interface</code>。由<strong>零</strong>或多个fields组成，每个field使用<strong>点</strong>来访问。struct和field都是变量，所以可以用<code>&amp;</code>获取地址。对地址也可以使用点来访问field。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">	DoB time.Time</span><br><span class="line">	Position <span class="type">string</span></span><br><span class="line">	Salary <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e Employee</span><br><span class="line">e.Salary = <span class="number">1000</span></span><br><span class="line">pos := &amp;e.Position</span><br><span class="line">*pos = <span class="string">&quot;Senior &quot;</span> + *pos</span><br></pre></td></tr></table></figure>

<p>相同类型的两个key可以<strong>在一起声明</strong>。在Go的struct中，<strong>field的组合和排序都意味着不同的type</strong>。和包一样，大写的field被导出可被访问，这也是Go的一种通用的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Name, Address <span class="type">string</span></span><br><span class="line">	DoB time.Time</span><br><span class="line">	Position <span class="type">string</span></span><br><span class="line">	Salary <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct类型的field不能自指，但是允许包含自己类型的<strong>指针</strong>，比如最经典的二叉树场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left, right *tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct的零值由各field零值组成，不是nil，没有field的空struct写作<code>struct&#123;&#125;</code>。不携带信息，但可能在有些地方会有用。</p>
<h4 id="字面量struct"><a href="#字面量struct" class="headerlink" title="字面量struct"></a>字面量struct</h4><p>两种声明方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">int</span> &#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">anim := git.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有fields<strong>按顺序</strong>声明，struct的fields有任何改动都需要修改，所以通常只在小规模struct以及包内部使用</li>
<li>使用键值对方式声明，可以省略field，且对顺序不敏感</li>
</ul>
<p>另外，在Go中，所有的函数参数传递都是<strong>传值</strong>。因此，如果函数内部需要修改struct时，不能传递struct类型，而需要传递指针。由于struct传递指针的场景比较多，所以提供了类似<code>p := &amp;Point&#123;1, 1&#125;</code>的简写语法糖。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualPrize</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">	e.Salary = e.Salary * <span class="number">2</span> + <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果struct的所有field都具有可比性，则struct也具有可比性，可以比较是否相等。因此，struct在有些情况可以用来作为map的key。</p>
<h4 id="struct嵌入与匿名域"><a href="#struct嵌入与匿名域" class="headerlink" title="struct嵌入与匿名域"></a>struct嵌入与匿名域</h4><p>匿名域用于struct之间的组合，可以达到<em>类似</em>类继承的效果。在struct声明中，如果field类型是有名称的，则可以忽略掉field名，得到一个匿名域。匿名域类型或类型内的各field对应用struct可见。有点类似TS中<code>interface</code>的<code>extends</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point</span><br><span class="line">	Radius: <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">	Circle</span><br><span class="line">	Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span></span><br><span class="line">w.Y = <span class="number">10</span></span><br><span class="line">w.Radius = <span class="number">5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>换种说法，匿名域就是向下访问时可以省去不写的中间域。即使中间域类型是首字母小写不对外可见的，只要剩下域对外可见也可以访问。struct这种<strong>组合</strong>思想是Go在面向对象上的核心。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>编解码JSON数据的方法都位于<code>encoding/json</code>，其中编解码整块数据的函数分别为<code>json.Marshal</code>和<code>json.Unmarshal</code>，前者传入Go数据结构，返回压缩后的JSON字符串，使用<code>json.MarshalIndent</code>可以返回美化后的JSON字符串。编码时，<strong>只有被导出的域才会出现在JSON字符串中</strong>。且field之后的<em>field tag</em>可以作为metadata修改JSON行为，如指定被JSON字符串化之后的key名。或用下面的<code>omitempty</code>忽略掉零值的key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	Year <span class="type">int</span> <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">	Color <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">	Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相反，在解码JSON数据时，需要显式声明struct结构来接收JSON数据。<code>json.Unmarshal</code>方法的第二个入参即struct的指针。在解析JSON时，对key是不区分大小写的，因此只需要对<code>a_b</code>类型的JSON key指定<em>field tag</em>。</p>
<p>对于stream格式的JSON数据，使用<code>json.Encode</code>和<code>json.Decode</code>编解码。</p>
<h3 id="HTML和文本模板"><a href="#HTML和文本模板" class="headerlink" title="HTML和文本模板"></a>HTML和文本模板</h3><p><code>text/template</code>和<code>html/template</code>用于文本模板和HTML模板。它们都使用双花括号包裹带有逻辑的简单语句。其中，<code>html/template</code>还会默认对文本做escape脱敏处理（对<code>template.HTML</code>不会escape）。</p>
<ul>
<li>使用<code>template.New</code>创建模板</li>
<li><code>template.Funcs</code>向模板内插入函数</li>
<li><code>template.Must</code>保证模板有内容</li>
<li><code>template.Parse</code>解析模板</li>
<li>使用模板的<code>Execute</code>方法生成解析后内容</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = template.Must(template.New(<span class="string">&quot;issueList&quot;</span>)).Funcs(</span><br><span class="line">	template.FuncMap(<span class="string">&quot;daysAgo&quot;</span>: daysAgo)</span><br><span class="line">).Parse(templ)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result, err := github.SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相同类型入参可以聚合<code>x, y int</code></li>
<li>返回值为多个时，需要用<code>()</code>包裹</li>
<li>返回值也可以给予变量名，这种情况下，相当于提前为返回值声明变量</li>
<li>入参是<strong>传值</strong>，即入参会复制一份传递给函数内部，只有像slice、map、function、channel这种引用实现的类型在函数内改变会影响外部值</li>
<li>只有函数声明，没有函数体的函数表示函数由其他语言实现，如<code>func Sin(x float64) float64</code></li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Go的递归和其他语言无异。不同的是，传统语言的函数递归借助<strong>定长的栈</strong>实现，大小从64KB到2MB不等，而Go使用<strong>变长栈</strong>实现，避免的栈溢出的情况。</p>
<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>Go支持同时返回多个返回值。同类型返回值可以压缩，还可以声明有名称的返回值。在多返回值时，还可以直接传递给需要多个入参的函数，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.Println(findLinks(url))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">links, err := findLinks(url)</span><br><span class="line">log.Println(links, err)</span><br></pre></td></tr></table></figure>

<p>返回值有名称时，会<strong>作为函数体内最外层变量出现</strong>。因此，不需要显示<code>return</code>返回值，这种现象也称为“裸返回”（<em>bare return</em>）。由于裸返回时，<code>return</code>后不会跟随返回值，不利于代码可读性，所以只在需要的时候使用它。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>函数<em>返回</em>错误在Go中是普遍现象。有时，错误类型只需要有1种，这时通常用<code>bool</code>类型的<code>ok</code>表示。如对<code>map</code>类型的变量的访问。但大多数时候，错误原因可能要有比较多种，这时可以用<code>error</code>类型的<code>err</code>表示。</p>
<p>在Go中较少使用exception表示失败（尽管Go也有exception机制），Go只在真正的bug处，才使用异常打印stack trace信息。在Go中较常出现的是普通的error类型，它只作为普通控制流的一部分。</p>
<h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><p>error处理由调用方负责，有5种策略：</p>
<ul>
<li><strong>向上传递</strong>，在没有error时，可以用<code>fmt.Errorf</code>制造一个自定义错误信息的错误。Go建议仔细设计错误信息内容，<strong>不使用大写字母，不使用换行</strong>。建议函数的每一层补充上更多信息。</li>
<li><strong>重试</strong>，在有些场景下，如测试服务端连接</li>
<li><strong>退出</strong>，严重问题时，可以用<code>os.Exit(1)</code>退出，或者用<code>log.Fatalf</code>打印错误信息后退出</li>
<li><strong>打印日志后继续</strong>，对于简单问题，可以打印日志后继续流程</li>
<li><strong>忽略</strong>，在特殊情况下，可以直接忽略，如错误确实不会影响功能实现</li>
</ul>
<p>Go建议是使用函数时考虑错误处理的场景。</p>
<h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>EOF（End Of File）是一种特殊的错误类型，<code>io.EOF</code>表示输入流没有更多内容了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := is.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><blockquote>
<p>这一章很类似JS或TS</p>
</blockquote>
<p>Go中函数是<em>一级成员</em>。这意味着，它可以作为一种类型，传递给变量、入参或者返回，就像其他值的类型一样。函数是一种引用类型，所以可以为<code>nil</code>，但是<strong>执行<code>nil</code>会导致panic</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="literal">nil</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// call of nil panic</span></span><br></pre></td></tr></table></figure>

<p>再次基础上，就可以对函数做更灵活而精准的设计，拆分函数关注点和抽象层次。构造出更灵活的程序。以<code>strings.Map</code>为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;Admin&quot;</span>)) <span class="comment">// Benjo</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Go中只能在包级别声明有名函数，而匿名函数可以在块作用域、函数作用域内声明。因此，<strong>高阶函数</strong>、<strong>闭包</strong>等概念Go中也有。由于这些概念JS中也有，这里就不再赘述。</p>
<h3 id="循环变量捕获"><a href="#循环变量捕获" class="headerlink" title="循环变量捕获"></a>循环变量捕获</h3><blockquote>
<p>JS也有类似问题，不过原因不同</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一段会有问题的代码</span></span><br><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的for循环中，循环变量<code>dir</code>在<code>append</code>的回调中有使用，我们回忆一下，for循环中循环变量位于for语句块外，在整个for循环后才销毁。所以这会导致每一个回调执行时，dir都被更新为最新的值。将dir在循环体内再次赋值即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    <span class="comment">// 可以运行</span></span><br><span class="line">    dir := dir</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似JS中的剩余参数，Go中也使用<code>rest ...type</code>表示函数的剩余入参。rest需要声明类型，rest为slice类型。要注意的是，这种函数和直接传入一个slice参数的函数类型并不一样。另外，在剩余参数类型不明确时，可以用<code>interface&#123;&#125;</code>表示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在变量后使用`...`表示解构</span></span><br><span class="line">val := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(sum(values...))</span><br></pre></td></tr></table></figure>

<h3 id="延迟函数调用（Deferred-Function-Calls）"><a href="#延迟函数调用（Deferred-Function-Calls）" class="headerlink" title="延迟函数调用（Deferred Function Calls）"></a>延迟函数调用（Deferred Function Calls）</h3><p>在语句前加上<code>defer</code>标识符，会让<code>defer</code>后的<strong>函数调用</strong>推迟到所在函数的**<code>return</code>之后**执行。<code>defer</code>后的函数和表达式会立即求值。<code>defer</code>的函数调用在函数panic后仍然会被调用。可以用来执行一些释放资源的操作，如以下场景：</p>
<ul>
<li>open和close</li>
<li>connect和disconnect</li>
<li>lock和unlock</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最合适的使用时机是在刚刚获得资源之后</strong>。还可以利用defer完成<em>进入</em>和<em>离开</em>函数的成对操作做一些调试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> trace(<span class="string">&quot;bigSlowOperation&quot;</span>)()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    log.Printf(<span class="string">&quot;enter %s&quot;</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于defer在函数最后执行的特点，甚至可以在defer中<strong>获取和修改函数返回值</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时也由于defer的这个特点，在for循环中使用defer一定要谨慎。</p>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>Go中的panic类似于其他语言的exception，它一般代表程序中存在bug和不应该出现的情况。panic后，正常程序执行停止，<strong>defer的函数被倒序执行</strong>，然后函数崩溃并带有错误信息。</p>
<p>除了系统触发的panic，还可以直接通过<code>panic(&quot;certain message&quot;)</code>手动触发一个panic。一些包中以<strong>Must</strong>开头的API通常表示，在不符合规范的时候API会panic。<strong>建议只在内部可信任环境下使用这种API</strong>。</p>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>就像其他语言中的try catch一样，Go中的panic同样有机制去妥善处理。Go有内置的<code>recover</code>函数，可以用于在panic中恢复。</p>
<ul>
<li><code>recover</code>需要在defer的函数中使用</li>
<li><code>recover</code>函数会返回panic的value，在没有panic的情况下，该函数返回<code>nil</code></li>
</ul>
<p>下面是一些使用<code>recover</code>的建议：</p>
<ul>
<li>不要毫无条件地从panic中recover，这可能会掩盖一些潜在的bug或资源泄露</li>
<li>在panic后，可以使用<code>runtime.Stack</code>这样的方法打印一下错误的详细信息，再recover</li>
<li>可以定义一些外部不可见的类型，在调用panic时传入，在recover返回时判断类型，从而做到针对特定情况panic执行recover，其余情况仍旧panic</li>
<li>对于预期中的error不使用panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span></span> (title <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            <span class="comment">// no panic</span></span><br><span class="line">        <span class="keyword">case</span> bailout&#123;&#125;:</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;multiple titles&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">panic</span>(p) <span class="comment">// resume panic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go也有OOP的特性，即<em>对象</em>上具有<em>方法</em>，方法需要关联在一个特定类型上。</p>
<h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明里，在普通声明的函数名前，增加函数绑定的类型receiver，即完成了方法的声明。Go中没有<code>this</code>和<code>self</code>这样的保留字。类型receiver中的变量，即方法可以访问的类型变量。变量名由于会比较常用，所以通常取类型首字母。</p>
<p>其他方法的行为类似其他OOP语言：诸如方法名和函数名不在一个命名空间，所以可以重名；方法名之间不能重名；<strong>方法名不能和属性名相同</strong>。由于Go中声明命名类型比较自由，而方法可以很方便绑定在命名类型上，所以可以给基础类型，如数字、字符串等，增加新方法。</p>
<h3 id="指针receiver"><a href="#指针receiver" class="headerlink" title="指针receiver"></a>指针receiver</h3><p>上面提到，访问方法需要一个receiver。除了变量本身，指针也可以作为receiver。在Go中函数入参都是传值的，也就是传入值的复制。所以除了map、slice这种引用类型，其余类型的值在方法内改变并不会影响到外部。如果需要方法改变receiver本身的话，可以指定将方法绑定在指针类型上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r)</span><br></pre></td></tr></table></figure>

<p>通常会规定，如果类型上有方法是指针类型的receiver，所有的方法都需要有一个指针类型receiver。类似struct一节介绍的，如果变量具有类型<code>T</code>，而方法的receiver是<code>*T</code>，我们可以直接使用简写的<code>p.ScaleBy(2)</code>而不需要写成<code>(&amp;p).ScaleBy(2)</code>。相反地，receiver要求类型<code>T</code>，变量传入<code>*T</code>也是可以的。</p>
<p>但是，直接将字面量传入给指针类型的receiver是不允许的，如<code>Point&#123;1, 2&#125;.ScaleBy(2)</code>。</p>
<h3 id="Nil是合法的Receiver"><a href="#Nil是合法的Receiver" class="headerlink" title="Nil是合法的Receiver"></a>Nil是合法的Receiver</h3><p>Go中，<code>nil</code>在很多时候是合法的零值。同样也可以作为receiver。当然在你的命名类型中，最好对合法的<code>nil</code>类型加以说明。Go的内置类型和操作，如slice，map、struct、append、make等也可以正常地处理<code>nil</code>。</p>
<h3 id="组合和struct-embedding"><a href="#组合和struct-embedding" class="headerlink" title="组合和struct embedding"></a>组合和struct embedding</h3><p>在此前的struct一节中，已经介绍了Go的struct embedding设计。这里结合方法继续讨论一下。首先我们先回忆下struct embedding是啥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">cp.X = <span class="number">1</span></span><br><span class="line">fmt.Println(cp.Point.X)</span><br><span class="line">cp.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Print;n(cp.Y)</span><br></pre></td></tr></table></figure>

<p>匿名的field会直接将field类型中的<strong>成员和方法</strong>都<strong>组合</strong>（composite）进当前类型中（和TS中的extends有点像）。如上面的<code>ColoredPoint</code>就直接拥有了<code>Point</code>的<code>Distance</code>和<code>ScaleBy</code>功能（当然也可以访问Point）。Go更希望用<strong>组合</strong>（composition）而非<strong>派生</strong>（derivation）构造更复杂的类型。比如，上面的<code>ColoredPoint</code>并不是一个<code>Point</code>，并不能当做一个Point访问和使用。</p>
<p>匿名field如果是指针类型，除了上面的特性，还能实现让两个变量共享一个底层的结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line">p := ColoredPoint&#123;&amp;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line">q := ColoredPoint&#123;&amp;Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">p.Point = q.Point</span><br></pre></td></tr></table></figure>

<p>在访问receiver上的方法时，Go首先会去直接声明的field中寻找，然后再去embedded的field中寻找，再向下寻找。方法只能在命名类型和其指针类型上定义，但是借助struct embedding也可以实现，将<strong>功能聚合</strong>在一起。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    v := mapping[key]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面重写之后的代码表现力明显更好了。</p>
<h3 id="方法值（method-value）和方法表达式（method-expression）"><a href="#方法值（method-value）和方法表达式（method-expression）" class="headerlink" title="方法值（method value）和方法表达式（method expression）"></a>方法值（method value）和方法表达式（method expression）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">distanceFromP := p.Distance</span><br><span class="line">fmt.Println(distanceFromP(q))</span><br><span class="line"></span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second(), r.Launch)</span><br></pre></td></tr></table></figure>

<p><code>p.Distance</code>会得到一个method value，它是一个绑定到了特定receiver上的一个方法，本身也是一个函数。可以当做函数类型的值用作入参或返回值。这个和JS还比较像。</p>
<p>类似的，Go中还有method expression的概念。即直接用类型名加点（<code>.</code>）访问方法得到一个method expression。它也是一个函数，可以<strong>看做是一个没有绑定receiver的方法</strong>。调用函数时，传入的第一个入参会当做receiver，后续的作为方法入参。这个特性在需要根据情况灵活选择方法时很好用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Add(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Sub(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> path []Point</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> TranslateBy(offset Point, add <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span></span> Point</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        op = Point.Add</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = Point.Sub</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        path[i] = op(path[i], offset)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个实例：bitset"><a href="#一个实例：bitset" class="headerlink" title="一个实例：bitset"></a>一个实例：bitset</h3><ul>
<li><code>bytes.Buffer</code>经常用来拼接字符串</li>
<li><code>fmt</code>的print打印字符串时会调用变量的<code>String</code>方法</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>首先，Go的封装细粒度只到package一层，package内不控制可见性</strong>。所以当你想要控制可见性时，需要用拆分package实现。</p>
<p>封装用来掩盖不需要像使用者展示的信息和细节。Go中唯一用来控制可见性的手段是一个<strong>大小写约定</strong>：大写表示从包中导出，小写表示包内可见，对于struct中的field以及类型的method也是如此（包外访问不了，包内随便访问）。通常来讲，<strong>当需要封装对象时，我们都会使用struct</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    words []<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不建议</span></span><br><span class="line"><span class="keyword">type</span> IntSet []<span class="type">uint64</span></span><br></pre></td></tr></table></figure>

<p>使用struct封装本来就很简单的类型有以下几个原因：</p>
<ul>
<li>使用方无法修改对象值，这样只用查阅更少的声明，就能得到对象值大致的可能范围</li>
<li>对使用方掩盖实现细节，可以避免让使用方依赖那些可能改变的内容，也给开发者重构空间，开发者可以在不改变API兼容性的情况下灵活调整内部实现</li>
<li>避免使用方任意修改对象值，造成更多边缘情况，提高程序编写难度和程序不稳定性</li>
</ul>
<p>有时，封装也会暴露出一些<strong>getter</strong>和<strong>setter</strong>。通常命名上，会直接使用field的首字母大写形式，省去不必要的<code>Get</code>，<code>Fetch</code>，<code>Lookup</code>前缀。实际上，Go并不禁止导出field，只是在有些情况下，导出field会影响代码可靠性。</p>
<p>封装并不总是必要的。有时，底层数据结构是目标数据结构的<strong>充要表示</strong>，不多不少，场景变数不多，这时可以不用struct封装。但是，像IntSet这种，实现细节变数多，程序实现稳定性低，需要被保护起来，避免影响使用者。从而要采取封装的方式，把那些变数变得“不透明”。</p>
<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><p>如其他OOP语言一样，Go中也有用于标识抽象类型的接口描述。不同的是，Go中的接口都是<strong>隐式</strong>满足的，松耦合。</p>
<h3 id="作为约定的接口"><a href="#作为约定的接口" class="headerlink" title="作为约定的接口"></a>作为约定的接口</h3><p>之前介绍过的所有类型都是<strong>具体类型</strong>（concrete type），具体类型指数据表示和行为实现在类型确定后，就已一清二楚。为了保证语言灵活性，Go中还有<strong>接口类型</strong>（interface type）。这种类型不暴露内在结构和实现细节，而是给出接口输入输出，作为一种<strong>约定</strong>交由具体实现方完成，从而实现依赖反转（DI）。这一概念的设计上和其他OOP语言无二。不过在使用上，Go并不要求实现方明确依赖关系，只需实现约定即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span> &#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ...comments</span></span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，实现<code>String</code>方法也让类型隐式满足了<code>fmt.Stringer</code>的定义。Go中单方法interface的命名，通常以动词的名词形态为主。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中也有类似struct embedding的<strong>嵌入式写法</strong>，简化interface的组合成本。另外，interface中方法的顺序不影响interface类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的满足"><a href="#接口的满足" class="headerlink" title="接口的满足"></a>接口的满足</h3><p>Go中变量可以是接口类型，在给接口类型变量赋值时，需要检查值的方法是否满足了接口的类型定义，这一点和其他OOP语言相似。要注意，尽管Go有将变量<code>T</code>转成<code>*T</code>的隐式转换，但是类型<code>T</code>的方法和<code>*T</code>的方法receiver并不同。而通常具体类型中会在接口声明的方法中做一些写操作，因而指定receiver为指针类型，这有可能会导致无法满足接口定义。</p>
<p>接口覆盖了其包裹的内部类型，所以，<strong>即使内部类型满足其他方法，赋值给接口类型后，也只能方法接口拥有的方法</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK</span></span><br><span class="line">w.Close() <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>Go中还有一个通用的不可或缺的类型<code>interface&#123;&#125;</code>它表示对类型没有任何要求，同时也意味着该类型变量上无法执行任何操作，类似ts中的<code>Unknown</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>Go中具体类型对接口类型的满足都是隐式的，无需显式声明。所以一个具体类型可能会同时满足很多接口类型。可以把接口类型认为是将一些具体类型中公共的部分抽象出来的共同行为，将之作为<strong>grouping</strong>出来的共性。</p>
<h4 id="使用flag-Value解析命令行参数"><a href="#使用flag-Value解析命令行参数" class="headerlink" title="使用flag.Value解析命令行参数"></a>使用<code>flag.Value</code>解析命令行参数</h4><ul>
<li><code>fmt.Sscanf</code>可以从输入中按格式解析出特定类型参数</li>
</ul>
<h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>Go中，接口类型可以作为变量的合法类型。接口类型值因此具有<strong>动态类型</strong>和<strong>动态值</strong>。在Go中可以近似用类型描述符（type descriptor）表示，其中type表示具体类型，value表示具体值。在初始化时，type和value都是<code>nil</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        +-----------+</span><br><span class="line">type    |    nil    |</span><br><span class="line">        +-----------+</span><br><span class="line">value   |    nil    |</span><br><span class="line">        +-----------+</span><br></pre></td></tr></table></figure>

<p>而在第二和第三行，为w赋值为<code>os.Stdout</code>以及<code>*bytes.Buffer</code>类型时，type分别会变成<code>os.Stdout</code>和<code>*bytes.Buffer</code>，同时value也会被设置为对应初始值的指针。这个过程会完成类似于<code>io.Writer(os.Stdout)</code>的隐式类型转换。此时访问<code>w</code>的方法，会被动态分配到value上实现。而在最后又将<code>w</code>还原为初始值<code>nil</code>。</p>
<p>接口类型之间<strong>不一定</strong>可以比较，当接口值都为<code>nil</code>或接口值对应的具体类型相同以及具体值相同时，接口值相同。然而，如果具体类型不可比较时（如slice，function等），接口类型也不可比较。Go的<code>fmt</code>中，可以用<code>%T</code>打印变量类型。</p>
<h4 id="陷阱：nil值可以存在于非nil的接口值中"><a href="#陷阱：nil值可以存在于非nil的接口值中" class="headerlink" title="陷阱：nil值可以存在于非nil的接口值中"></a>陷阱：nil值可以存在于非nil的接口值中</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;</span><br><span class="line">    f(buf)</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;woops!\n&quot;</span>)) <span class="comment">// panic: nil pointer derefence</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的判断中，<code>out</code>已经有了具体的类型，因此接口类型的<code>out</code>不等于<code>nil</code>，然而<code>out</code>的具体值却是<code>nil</code>，这使得<code>Write</code>行为无法保证。解决办法是，在一开始为<code>buf</code>声明为<code>io.Writer</code>类型即可。</p>
<h3 id="sort-Interface"><a href="#sort-Interface" class="headerlink" title="sort.Interface"></a><code>sort.Interface</code></h3><p>Go使用sort包中的<code>sort.Interface</code>实现排序功能。同时对于常见类型string、int等也有事先封装好的<code>sort.Strings()</code>，<code>sort.Int()</code>。对于自定义类型，在实现<code>sort.Interface</code>接口后，也可使用<code>sort.Sort</code>排序。接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个方法分别用来<strong>返回长度</strong>、<strong>比较大小</strong>和<strong>交换顺序</strong>。这也是排序的几个基本操作。下面给出了字符串排序的内部实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在排序struct等复杂类型slice时，建议定义指针类型数组，这样可以让swap时速度更快</strong>。</p>
<p>sort还有一个方便的反向排序方法<code>sort.Reverse</code>，它借助了struct embedding，用一个内部类型<code>reverse</code>封装了外部实现接口的类型，另外，直接在<code>reverse</code>上定义了Less，覆盖了<code>Interface</code>的实现，从而实现了反向排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123; Interface &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less (i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> r.Interface.Less(j, i) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(i Interface)</span></span> Interface &#123; <span class="keyword">return</span> reverse&#123;i&#125; &#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(sort.Reverse(byArtist(tracks)))</span><br></pre></td></tr></table></figure>

<p>除了slice类型外，其他实现了<code>sort.Interface</code>接口的类型一样可以排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    t []*Track</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.t) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Swap(i, j <span class="type">int</span>) &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><code>http.Handler</code>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="type">string</span>, h Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>实现了这个接口的可以传递给<code>ListenAndServe</code>。但通常用不到这种原始的方式。Go的http包提供的<code>ServeMux</code>类型可以给请求分路，聚合一堆<code>http.Handlers</code>。写起来像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoe&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>http.HandlerFunc</code>将传入的函数包裹成了满足<code>Handler</code>接口的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的使用还是要写一些模板代码，对此可以将<code>mux.Handler</code>简写成<code>mux.HandlerFunc(&quot;list&quot;, db.list)</code>。可以再减少一点代码。实际上，http还提供了一个全局的<code>ServeMux</code>对象实例<code>DefaultServeMux</code>，不需要手动创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    http.HandlerFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">    http.HandlerFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>go中每一个handler都在一个单独的goroutine上，要妥善处理好并发的情况。</strong></p>
<h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><code>error</code>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code>类型实现了<code>error</code>接口。整个<code>errors</code>包都围绕这个接口设计，除了<code>errors.New()</code>方法，还可以直接通过<code>fmt.Errorf</code>返回一个格式化后的error值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="type">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.text &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, arags ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单的数学表达式求值器"><a href="#简单的数学表达式求值器" class="headerlink" title="简单的数学表达式求值器"></a>简单的数学表达式求值器</h3><p>递归的AST解析</p>
<p>略。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（type assertion），写作<code>x.(T)</code>，通常用来将动态类型限定到更严格的类型。</p>
<ul>
<li><code>T</code>是具体类型时，会判断<code>x</code>类型是否和<code>T</code><strong>一致</strong>，是则将<code>x</code>类型设置为<code>T</code>，否则<code>panic</code></li>
<li><code>T</code>是抽象类型interface时，会判断<code>x</code>是否<strong>满足</strong><code>T</code>接口，是则将<code>x</code>类型设置为接口<code>T</code>，否则panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)</span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// panic</span></span><br></pre></td></tr></table></figure>

<p><strong>当对<code>nil</code>进行类型断言时时，断言一定失败</strong>。另外，类型断言可以支持第二个返回参数<code>ok</code>表示是否成功，此时不会panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use w...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用：错误类型区分"><a href="#应用：错误类型区分" class="headerlink" title="应用：错误类型区分"></a>应用：错误类型区分</h4><p>借助类型断言，可以将判断抛出的具体错误类型，<code>os</code>包提供了<code>IsExist</code>，<code>isNotExist</code>，<code>isPermission</code>用来区分文件已存在，文件不存在，不允许几种错误。我们以文件不存在为例，此时抛出的<code>PathError</code>类型错误包含了具体的错误类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 满足Error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/path&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, err)</span><br><span class="line"><span class="comment">// Output: &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/path&quot;, Err:0x2&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用断言后，就可以从<code>err</code>中拿到具体错误类型，从而判断是否是文件不存在导致的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class="line">        err = pe.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，建议在错误抛出时就进行检测，在聚合后，原始错误的数据结构可能会丢失从而无法判断。</p>
<h4 id="方法查询"><a href="#方法查询" class="headerlink" title="方法查询"></a>方法查询</h4><p>抽象类型如<code>io.Writer</code>可能缺少使用者需要的方法如<code>io.WriteString</code>（尽管满足<code>io.Writer</code>的大多数具体类型除了必须满足的<code>Write</code>方法外，都对写入字符串支持了<code>WriteString</code>方法）。</p>
<p>可以定义一个临时接口类型，判断满足抽象类型的变量是否具有指定方法。因为Go中接口的满足是隐式的（类似鸭子类型），不像许多强类型语言一样，需要显式声明。之前使用弱类型语言的可能能很好接受。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w io.Writer, s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteString(<span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sw.WriteString(s) <span class="comment">// 更有效率的方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w.Write([]<span class="type">byte</span>(s))  <span class="comment">// 兜底方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，<code>fmt.Sprintf</code>打印不同类型的变量时，也借助了类型断言，对于特定类型调用特定方法，最后再使用<strong>反射</strong>处理其他类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatOnValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err, ok := x.(<span class="type">error</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> err.Error()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> str, ok := x.(Stringer); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> str.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h3><p>interface除了之前说的<strong>让多个具体类型有一致表现</strong>的用法外，还可以作为<strong>可区分具体类型的合集</strong>来使用。这种时候需要结合type switch的用法。如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在确定了<code>x</code>的类型后，还需要直接使用<code>x</code>。此时可以写作<code>switch x:= x.(type)</code>。</p>
<p>这种用法和之前的用法不同在于：这里接口不作为有<strong>一致表现</strong>而存在，它只是用来暂存将要区分开的具体类型，而这些具体类型往往时有<strong>不同表现</strong>的。所以这种用法里的接口<strong>几乎没有方法</strong>。换一种说法，之前的用法里，接口背后的具体类型细节需要被掩盖来使用，而这里需要使用具体类型的细节。</p>
<h3 id="一些忠告"><a href="#一些忠告" class="headerlink" title="一些忠告"></a>一些忠告</h3><p>和上一章方法类似，接口是一种很好使用的面向对象的特性。但<strong>不建议上来就从定义一堆接口</strong>开始，这样通常会产生一大堆只有一个具体类型实现的接口。接口是抽象类型，是通过具体类型抽象得来的。通常是在<strong>需要用统一的方式处理不同类型</strong>时，拿来使用。</p>
<p>同时，大多数Go程序中，接口往往小且包含比较少的方法。像是<code>io.Writer</code>或<code>fmt.Stringer</code>。和方法一章一样，它们虽然是面向对象的特性，但是不是Go中一定要使用的语言特性。只在需要的时候使用。大多数时候，直接使用函数就足够了。在书中，方法如<code>input.Write</code>的使用就远不如函数如<code>fmt.Printf</code>来得频繁。</p>
<h2 id="goroutine和信道"><a href="#goroutine和信道" class="headerlink" title="goroutine和信道"></a>goroutine和信道</h2><p>Go支持两种并发编程的风格，第一种在本章介绍，通过goroutines和channels支持<strong>通信顺序进程（Communicating sequential processes，CSP）</strong>，这种情况下，值会在goroutine间来回传递，而变量在多数情况下被限制自单个活动中。下一章介绍的共享变量风格的并发编程更接近传统的并发风格。</p>
<h3 id="认识goroutine"><a href="#认识goroutine" class="headerlink" title="认识goroutine"></a>认识goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">    fibN := fib(n) <span class="comment">// slow</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, r = <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>goroutine类似线程，有着定量而非定性的差异</li>
<li><code>main</code>函数也会启动一个<em>main goroutine</em></li>
<li>goroutine通过<code>go</code>启动一个函数或方法调用，并在声明后立即返回</li>
<li>除了<code>main</code>函数返回或程序结束（<code>os.Exit</code>）外，一个goroutine没有办法直接停止另一个，但可以通过传值的方式间接实现。</li>
</ul>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>服务器处理请求是最典型的并发场景。</p>
<h4 id="1-Clock-Server"><a href="#1-Clock-Server" class="headerlink" title="1. Clock Server"></a>1. Clock Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleConn(conn) <span class="comment">// go handleConn(conn)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := io.WriteString(c, time.Now().Format(<span class="string">&quot;15:04:05\n&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// e.g. client disconnect</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>listener.Accept</code>会在接收到TCP连接请求前一直阻塞</li>
<li><code>time.Format</code>方法通过一个<strong>特殊的样例</strong>（15:04:05）表示要格式化的格式，<code>time.Parse</code>也是如此</li>
<li>client端可以用<code>net.Dial</code>发起一个TCP连接请求</li>
</ul>
<p>上述的服务端是<strong>串行</strong>处理client的请求，并每秒打印当前时间，在<code>handleConn(conn)</code>前加上<code>go</code>关键字后，即可让服务端<strong>并行</strong>处理client的请求。</p>
<h4 id="2-Echo-Server"><a href="#2-Echo-Server" class="headerlink" title="2. Echo Server"></a>2. Echo Server</h4><p>上面的例子是在一个连接中使用一个goroutine，当然每个连接也可以创建多个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="type">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToUpper(shout))</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, shout)</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(c)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        echo(c, input.Text(), <span class="number">1</span>*time.Second) <span class="comment">// go echo(...)</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">go</span> mustCopy(os.Stdout, conn)</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>echo</code>前加上<code>go</code>即可让服务器同时相应多个请求，返回“回声”。同理，在client端打印服务端返回的代码前加上<code>go</code>即可让使用者输入的同时打印返回的“回声”。</p>
<h3 id="信道（channel）"><a href="#信道（channel）" class="headerlink" title="信道（channel）"></a>信道（channel）</h3><p><code>go</code>启动并行的活动，信道作为活动间通信的通道，借助它可以发送和接收消息。信道通过<code>make</code>构造，需要指定传输消息的类型，作为信道类型。可以使用<code>close</code>关闭信道。后续的<strong>发送</strong>操作会panic，<strong>接收</strong>操作会得所有到已发送的值，而再之后的后续<strong>接收</strong>操作只能得到信道类型对应的<em>零值</em>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- x</span><br><span class="line">x = &lt;-ch</span><br><span class="line"><span class="comment">// 直接丢弃channel来的值</span></span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>信道还分为有缓冲区和无缓冲区两种类型，上述的<code>make</code>构造的都是无缓冲区的信道，指定第二个参数可以构造有缓冲区的信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 有缓冲区</span></span><br></pre></td></tr></table></figure>

<h4 id="无缓冲信道（Unbuffered-Channels）"><a href="#无缓冲信道（Unbuffered-Channels）" class="headerlink" title="无缓冲信道（Unbuffered Channels）"></a>无缓冲信道（Unbuffered Channels）</h4><p>向无缓冲区<strong>发送消息</strong>会<strong>阻塞发送所在的goroutine</strong>，直到对应的goroutine在同一个信道上执行接收操作。相反地，<strong>接收消息</strong>在先的话，也会阻塞直到同一个信道上执行了发送操作。这种机制会<strong>同步</strong>两个goroutine的执行进度。如果发送信息在先，则接收信息会在发送所在的goroutine之前发生。从而，我们可以基于这个假设的前提保证一些事实。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(os.Stdout, conn)</span><br><span class="line">        log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// signal the main goroutine</span></span><br><span class="line">    &#125;()</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">    conn.Close()</span><br><span class="line">    &lt;-done <span class="comment">// wait for background goroutine to finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序里，会在接收完服务端返回后，才会关闭客户端。这里需要的是一个<strong>事件</strong>，使用的信道类型其实并不重要，所以使用了<code>struct&#123;&#125;</code>。实际应用中会使用<code>bool</code>或是<code>int</code>这样的简单类型。</p>
<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>借助上面提到的无缓冲区信道，可以实现多个goroutine之间的接续传递，也可以叫做<em>流水线</em>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------+         +-----------+         +-----------+</span><br><span class="line">|  Counter  |   --&gt;   |  Squarer  |   --&gt;   |  Printer  |</span><br><span class="line">+-----------+         +-----------+         +-----------+</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span> ;x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := &lt;-naturals</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的流水线中，Counter在打印100个自然数后，会关闭信道。会有之前所说的一些特性：</p>
<ul>
<li>向关闭信道写入消息会panic</li>
<li>从关闭信道读取信息会得到所有未发送的消息，再之后只能得到零值</li>
<li>关闭信道不会影响其他goroutine执行</li>
</ul>
<p>所以在上面的程序中，Printer会继续打印0，只有Counter正常退出。Go中没有<em>直接</em>的获取信道是否关闭的方法，但是对于从信道中读取消息有第二个<code>ok</code>参数，为<code>false</code>时表示信道已关闭且<strong>读取完所有消息</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, ok := naturals</span><br><span class="line"><span class="keyword">if</span> !ok &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的模板代码，go用<code>range</code>已封装好，不必重复书写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">        squares &lt;- x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不是所有信道在不用后都要显式关闭</strong>，只在需要传达信道关闭信息时再手动<code>close</code>关闭。其余的信道会在gc过程中回收。但这不意味着文件读取也可以不显式关闭：文件的读写操作后一定要执行关闭操作。关闭一个已关闭的信道会panic，关闭<code>nil</code>的信道也是一样。</p>
<h4 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h4><p>以上一小节为例，有三个goroutine，函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out, in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中的信道入参分别用来<strong>接收</strong><em>或</em><strong>发送</strong>消息（绝大多数信道也是如此）。因此对于这两种信道的细分，go类型系统提供了<strong>单向信道类型</strong>，即只读或只写。同时提供了类型助记符：</p>
<ul>
<li><code>chan&lt;-</code>表示只读，只可读取消息，不可关闭</li>
<li><code>&lt;-chan</code>表示只写，只可发送消息<strong>和关闭</strong></li>
</ul>
<p>违背只读只写上述规则，会在编译期间抛出错误。同时，<strong>双向信道可以隐式covert到单向信道，反之不可以</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲信道（Buffered-Channel）"><a href="#缓冲信道（Buffered-Channel）" class="headerlink" title="缓冲信道（Buffered Channel）"></a>缓冲信道（Buffered Channel）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>可以用队列类别缓冲信道，不同的是缓冲信道和goroutine是紧密相连的。</p>
<ul>
<li>写操作会在<strong>队列充满</strong>时阻塞</li>
<li>读操作会在<strong>队列为空</strong>时阻塞</li>
</ul>
<p>通过<code>cap</code>和<code>len</code>可以查看缓冲信道的实时容量和长度。虽然缓冲信道可以按队列去理解，但是不要把它拿去当队列来用。那么和无缓冲信道相比，缓冲信道应用场景有什么不同呢？</p>
<p>我们用流水线举例，流水线上的各道工序复杂程度有难有易，如果工作空间有限，每一道工序后都需要在下一道工序空闲时才能交付，一些简单工序就需要等待。这时就像<strong>无缓冲信道</strong>。假设工作空间宽裕，每道工序完成后，如果下游还未就绪，可以先放在空闲空间下，直接继续工作。这就是<strong>缓冲信道</strong>，多出来的工作空间即<strong>缓冲区</strong>，工序即<strong>goroutine</strong>。缓冲区可以弥补上下游工序工作效率的<em>些微差异</em>，缓冲区越大，可以容忍的效率差异就越大。如果工序间有明显差异，比如始终更快或更慢，此时增加缓冲区无法提供帮助，可以采用增加工序工人来提高工作效率，即<strong>在同一信道上使用更多goroutine</strong>。</p>
<p>从上面的比喻，可以得出两种信道的区别：</p>
<ul>
<li>无缓冲信道重点在<strong>同步</strong>，它可以确保上下游goroutine的同步性</li>
<li>缓冲信道则使用了队列来<strong>解耦</strong>上下游goroutine，使之不因为阻塞影响工作效率</li>
</ul>
<p>所以，我们假设有多个网站<em>镜像</em>来为网络请求提供服务，就可以使用缓冲信道，优先响应的可以直接提供服务，且在响应后可以继续工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirroredQuery</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    responses := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;asia.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;europe.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;america.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">return</span> &lt;-responses</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(hostname <span class="type">string</span>)</span></span> (res <span class="type">string</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行循环"><a href="#并行循环" class="headerlink" title="并行循环"></a>并行循环</h3><p>有些任务可以拆分成等效的<strong>相互独立</strong>的小任务，这种情况也被称为“令人尴尬的并行”，是最简单的并行工作场景，它的工作量和并行数呈线性关系。我们假设有一个并行处理图片缩小的程序，能返回缩小后的文件总体积，并在合适的时候停止。在程序编写过程中，会遇到一些问题：</p>
<ul>
<li>有错误出现时，未关闭剩余信道，导致goroutine泄露，并造成程序不响应或内存耗尽</li>
<li>for循环结合延迟执行代码时，循环描述体中的变量陷阱</li>
<li>要支持任意长度的图片列表，不能写死缓存信道的容量</li>
<li>无从直接得知goroutine是否执行完成</li>
</ul>
<p>最终得到下面的最终版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails</span><span class="params">(filenames &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    sizes := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// worker</span></span><br><span class="line">        <span class="comment">// avoid loop variable pitfall</span></span><br><span class="line">        <span class="keyword">go</span> runc(f <span class="type">string</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录任务完成</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumb, err := thumbnail.ImageFile(f)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            info, _ = os.Stat(thumb)</span><br><span class="line">            sizes &lt;- info.Size()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// closer</span></span><br><span class="line">    <span class="comment">// 必须写成goroutine的形式</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(sizes)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> size := <span class="keyword">range</span> sizes &#123;</span><br><span class="line">        total += size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序里面有几点需要特别说明：</p>
<ul>
<li>第一个for循环会将信道输入的图片文件列表转成任务的列表，然后再启动一个goroutine负责关闭信道，最后从信道中拿出所有的大小加总返回</li>
<li>关闭函数必须写成goroutine的形式。因为<code>sizes</code>的range结束依赖于<code>sizes</code>信道的关闭，同时<code>sizes</code>信道又必须<strong>等待</strong>所有图片处理任务执行完之后再关闭。等待和加总图片大小需要并行，所以需要一个新的goroutine去做</li>
<li>任务完成借助<code>sync.WaitGroup</code>完成，<code>wg.Wait()</code>会阻塞直到<code>wg.Done()</code>将所有任务清零</li>
</ul>
<h3 id="样例：并发web爬虫"><a href="#样例：并发web爬虫" class="headerlink" title="样例：并发web爬虫"></a>样例：并发web爬虫</h3><p>将第5章中的<code>worklist</code>由<code>slice</code>改为<code>channel</code>，让爬取网页内容的过程并发执行即可得到一个并发的web爬虫。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 无缓冲信道，也可以使用缓冲信道</span></span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">    <span class="comment">// 初始化channel</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line"></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 从channel中读取</span></span><br><span class="line">    <span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序在执行了一段时间后，会因为客观限制出现报错信息。这是因为程序<strong>过于并发</strong>了。由于硬件资源的限制，当并发数超过一定界限后，程序性能反而不如以前甚至会无法运行。因此需要手动限制并发量。这里有两种思路：</p>
<ul>
<li>通过限制发放许可证（token）的方式限制爬取goroutine是否执行，许可证数量有限，许可证用完后，阻止goroutine执行。当然作为信道的token，是在多个爬取goroutine间共享的。</li>
<li>限制爬取goroutine总数，只创建固定个数的goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量，占有表示被使用中</span></span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    token &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    &lt;-tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面代码<code>main</code>函数中的<code>worklist</code>延迟在for循环内赋值，使用<code>n</code>记录当前任务中的正在执行的任务数，可以实现在所有任务执行完成后退出程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    n++</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> ; n &lt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select实现多工"><a href="#select实现多工" class="headerlink" title="select实现多工"></a><code>select</code>实现多工</h3><p>在之前的例子里，从信道中读取&#x2F;写入值，会阻塞当前goroutine进度。如果需要同时接收两个信道的值，需要<code>select</code>语句块。<code>select</code>语句块使用类似<code>switch</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;- ch2</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个<code>case</code>可以是接收或是发送消息的语句，<code>select</code>语句在其中一个case发生后，才会继续（<code>select&#123;&#125;</code>会一直等待程序执行）。<code>default</code>可以指定没有任何一个case发生时的处理方式。</p>
<p>原文中给出的<code>time.Tick</code>例子会返回一个channel，并以设定的时间间隔发送消息。但是，再不从channel读取信息后，会造成goroutine泄露。因此只在整个生命周期都需要时才会使用。倒计时这种场景下建议使用更复杂的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">&lt;- ticker.C</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>

<p>对于一个nil信道的发送和接收会一直阻塞，select中的case也不会被选中。利用这个特性可以实现取消等功能。</p>
<h3 id="并发目录遍历"><a href="#并发目录遍历" class="headerlink" title="并发目录遍历"></a>并发目录遍历</h3><p>借助<code>ioutil.ReadDir</code>可以实现遍历根文件夹下所有文件体积的功能。下面是一个纯单线程版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkDir</span><span class="params">(dir <span class="type">string</span>, fileSizes <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> dirents(dir) &#123;</span><br><span class="line">        <span class="keyword">if</span> entry.IsDir() &#123;</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileSIzes &lt;- entry.Size()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;du1: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的版本可以实现功能，但是速度很慢，而且不能实时显示进度。这里我们用<code>time.Ticker</code>定时打印进度，同时通过命令行参数<code>p</code>控制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = flag.Bool(<span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;show progress&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> tick &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">    <span class="keyword">if</span> *progress &#123;</span><br><span class="line">        tick = time.Tick(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nFiles, nBytes <span class="type">int64</span></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> size, ok := fileSizes:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            nFiles++</span><br><span class="line">            nBytes += size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            printDiskUsage(nFiles, nBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    printDiskUsage(nFiles, nBytes) <span class="comment">// final print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>if *progress</code>语句在没有传递<code>-p</code>参数时，不会为tick赋值，而nil的tick值会让select中永远不会进入这个case，从而不打印进度。</p>
<p>在遍历根目录下的递归调用<code>walkDir</code>中，也可以使用goroutine，并通过<code>sync.WaitGroup</code>保证执行完成后关闭<code>fileSizes</code>信道。当然，无限制的创建goroutine会出现和上上小节一样的问题，所以也需要<em>信号量（semaphore）</em>，保证不至于创建过多goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取token</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sema &#125;() <span class="comment">// 释放token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>一样的，一个goroutine没有直接关闭另一个goroutine的办法。按照之前提到的<strong>通过信道传递消息</strong>的思路，但是一个信道只会被消费一次，我们这里的场景需要<strong>广播</strong>更合适。</p>
<p>之前提到，一个被关闭的信道在传递完信道内的消息后，后续再从这个信道获取值，会立即返回一个零值。可以利用这个特性，在执行取消操作后，将信道关闭即可，可以写出下面这样的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span> <span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在程序的<strong>瓶颈处</strong>，检查这个函数的返回值，一旦返回<code>true</code>则立即中止程序。比如，之前提到获取token的函数里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// acquire token</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sema &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按上面这种方式退出程序后，有可能出现goroutine还没有妥善关闭的情况，可以在调试时，程序的最后用<code>panic</code>打印系统信息，查看具体情况。</p>
<h3 id="样例：聊天服务器"><a href="#样例：聊天服务器" class="headerlink" title="样例：聊天服务器"></a>样例：聊天服务器</h3><p>聊天服务器也是并发和各种信道常用的场景，它包括：</p>
<ul>
<li>用户的接入、退出</li>
<li>用户信息的广播</li>
<li>用户session的维护</li>
</ul>
<p>我们可以用一个信道表示一个接入的用户，在一个全局的文件中处理用户登入、登出，即信道的信息维护，这里可以用map表示，对于接收到的消息，像注册的所有信道逐个发送，即广播。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> client <span class="keyword">chan</span>&lt;- <span class="type">string</span> <span class="comment">// 只写信道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    entering = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">    messages = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    leaving = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcaster</span><span class="params">()</span></span> &#123;</span><br><span class="line">    clients := <span class="built_in">make</span>(<span class="keyword">map</span>[client]<span class="type">bool</span>) <span class="comment">// 用户session维护</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-entering:</span><br><span class="line">            clients[cli] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-leaving:</span><br><span class="line">            <span class="built_in">delete</span>(clients, cli)</span><br><span class="line">            <span class="built_in">close</span>(cli)</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">            <span class="keyword">for</span> cli := <span class="keyword">range</span> clients &#123;</span><br><span class="line">                cli &lt;- msg</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，启动一个tcp服务器，单独启动一个goroutine负责上面的信道管理，另外对于每一个接入的连接，启动一个独立的goroutine处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> broadcaster()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理tcp连接的函数里，负责接入客户端，同时将连接中的内容写入到<code>messages</code>信道中，以便广播给其他客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> clientWriter(conn, ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一标识生成，也可以使用其他规则</span></span><br><span class="line">    who := conn.RemoteAddr().String()</span><br><span class="line">    ch &lt;- <span class="string">&quot;You are &quot;</span> + who</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has arrived&quot;</span></span><br><span class="line">    entering &lt;- ch</span><br><span class="line"></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        messages &lt;- who + <span class="string">&quot;: &quot;</span> + input.Text()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    leaving &lt;- ch</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has left&quot;</span></span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientWriter</span><span class="params">(conn net.Conn, ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Fprintln(conn, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的map没有使用lock操作，是因为它的读写都限制在了一个goroutine内，因此是<strong>并发安全</strong>的，其他并发使用的信道和<code>net.Conn</code>也是并发安全的。</p>
<h2 id="并发和共享变量"><a href="#并发和共享变量" class="headerlink" title="并发和共享变量"></a>并发和共享变量</h2><p>使用信道在goroutine间沟通是一种并发的范式，其中也略过了一些关键而细小的问题，这些在后面这种并发编程模式中会经常讨论。</p>
<h3 id="竞险（race-conditions）"><a href="#竞险（race-conditions）" class="headerlink" title="竞险（race conditions）"></a>竞险（race conditions）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    balance += amount</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> balance &#125;</span><br></pre></td></tr></table></figure>

<p>上面以银行为例，实际上给出了一个可以读写的变量。在串行执行场景下，不会有问题。在并发场景下，对<code>balance</code>读写的同时进行，就会造成一些问题。这种情况也叫<strong>数据争用（data race）</strong>，即<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。这种数据争用有时候还会带来未定义的行为。</p>
<p>在使用共享变量的模式并发编程时，如果不小心处理，很容易遇到数据争用的情况。然而，绝大多数的数据争用都“来者不善”，以至于我们要留心发生数据争用的场景：<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。下面有三种方式去避免：</p>
<ul>
<li><strong>不要写变量</strong>，比如将变量初始化好之后，使之只读或不可变</li>
<li><strong>避免在多个goroutine上操作变量</strong>，将操作限制在一个goroutine上，就像前一章中的broadcaster，这样的goroutine也叫做<em>调度者goroutine</em>。Go中有句箴言总结的很好：<strong>不要通过共享变量传递消息，通过传递消息来共享变量</strong>。这里的传递消息就是指通过信道发送和接收。当实在无法限制多个goroutine访问一个变量，也尽量限制访问，通过信道传递给其他goroutine，达到<strong>串行限制（serial confinement）</strong>的效果。</li>
<li><strong>在同一时间仅允许一个goroutine访问变量</strong>，即后面会提到的<strong>互斥锁</strong></li>
</ul>
<h3 id="互斥锁（sync-Mutex）"><a href="#互斥锁（sync-Mutex）" class="headerlink" title="互斥锁（sync.Mutex）"></a>互斥锁（<code>sync.Mutex</code>）</h3><p>互斥锁和之前提到的信号量（counting semaphore）很类似，更像是一个容量为1的信号量，即<em>二进制信号量（binary semaphore）</em>。每次执行后续操作前，都需要从一个全局信道中获取token，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用token</span></span><br><span class="line">    balance = balance + amount</span><br><span class="line">    &lt;-sema <span class="comment">// 释放token</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用token</span></span><br><span class="line">    b := balance</span><br><span class="line">    &lt;-sema <span class="comment">// 释放token</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的信号量表示使用<code>sync.Mutex</code>替代就是互斥锁的使用方式：</p>
<ul>
<li><code>var sema = make(chan struct&#123;&#125;, 1)</code> &#x3D;&gt; <code>var mu sync.Mutex</code></li>
<li><code>sema &lt;- struct&#123;&#125;&#123;&#125;</code> &#x3D;&gt; <code>mu.Lock()</code></li>
<li><code>&lt;-sema</code> &#x3D;&gt; <code>mu.Unlock()</code></li>
</ul>
<p>通常来说，互斥锁使用的范围很小，这一区域也叫临界区（critical section），被mutex守护的共享变量会紧跟在<code>Lock</code>之后。在程序较长时，为了避免在所有返回处显式<code>Unlock</code>可以使用<code>defer</code>，这会稍微增加一些显式<code>Unlock</code>的成本，但会让代码更简洁。</p>
<p>另外，互斥锁是不可重入的，即不能对一个已经上锁的共享变量上锁，这会导致死锁，因此确保互斥锁和其守护的变量不被导出。</p>
<h3 id="读-x2F-写互斥锁（sync-RWMutex）"><a href="#读-x2F-写互斥锁（sync-RWMutex）" class="headerlink" title="读&#x2F;写互斥锁（sync.RWMutex）"></a>读&#x2F;写互斥锁（<code>sync.RWMutex</code>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sync.RWMutex</code>可以限制写操作，而允许多个读操作同时进行。<code>RLock</code>方法开启，<code>RUnlock</code>关闭互斥锁。注意，只在确定没有对共享变量写操作发生的时候使用<code>RLock</code>方法，我们不能简单的假设一个<strong>逻辑</strong>读操作，在背后没有注入写入缓存或更新计数器等行为。如果不确定，请使用完整的互斥锁。</p>
<p>同时，<code>sync.RWMutex</code>只在大多数读操作在争用锁时会比较合适。其更复杂的实现，让它在其他场景下工作慢于普通的互斥锁。</p>
<h3 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h3><p>上面提到的对于<code>Balance</code>这个只读的函数也使用的互斥锁或者信道来限制多个goroutine访问共享变量，其中一个明显的原因是：读取操作发生在写操作如<code>Withdraw</code>或<code>Deposit</code>中间时，也会造成问题。另一个不那么明显的原因是，类似互斥锁、信道这种同步操作也会同步内存。</p>
<p>简单点说，在现代CPU架构中，多个处理器内很可能有缓存，每个goroutine对共享变量的修改很可能在多个缓存中，而对其他goroutine不可见，直到同步操作把缓存中的修改同步到主内存中，保证对所有goroutine可见且一致。</p>
<p>同一个goroutine内部是串行稳定的，但goroutine之间无法保证顺序。还有一种<strong>错误</strong>认识，goroutine的代码会<strong>逐行交错</strong>（interleaving）执行。但在现代的CPU架构和编译器中，并不是这么实现的。总而言之，把对变量的使用限制在同一个goroutine内，对其他变量使用互斥锁。</p>
<h3 id="懒初始化（sync-Once）"><a href="#懒初始化（sync-Once）" class="headerlink" title="懒初始化（sync.Once）"></a>懒初始化（<code>sync.Once</code>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化写操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，我们会推迟一个计算量比较大的初始化操作到使用时才进行，如上面<code>Icon</code>函数做的那样。很显然<code>Icon</code>函数不是并发安全的。在其中混有读写操作，且和外界共享icons变量。这时我们需要在初始化的时候对<code>loadIcons</code>函数加锁。加锁时要区分<code>icons</code>的是否初始化状态，可以对只读操作使用读&#x2F;写锁，再对写入操作使用互斥锁。像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        icon := icons[name]</span><br><span class="line">        mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> icon</span><br><span class="line">    &#125;</span><br><span class="line">    mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">// 因为在Lock前，有短暂的Unlock的时间段，有可能会被其他goroutine初始化，因此需要再次判断</span></span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    icon := icons[name]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面就是一个只做一次的操作（通常是初始化操作），为了维护一个是否完成的bool值，额外增加了一些操作，较容易出错。go对这种情况提供了<code>sync.Once</code>支持，在<code>Do</code>方法中传入只执行的函数，这个互斥锁会在第一次执行时上锁并将对变量的改动同步到其他goroutine中，同时维护一个bool值，在后续的执行中，直接跳过这一步。重写之后的<code>Icon</code>变得简单了很多。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="竞险检测器"><a href="#竞险检测器" class="headerlink" title="竞险检测器"></a>竞险检测器</h3><p>很多时候goroutine访问共享变量导致的竞险并不那么容易发现和避免。Go的配套工具链提供了<code>-race</code>标志位用来检查程序中可能存在的竞险情况，在<code>go run</code>, <code>go build</code>, <code>go test</code>后添加都可以。它可以记录对共享变量所做的所有读写操作以及对应的goroutine，还有程序中由<code>sync</code>和信道触发的同步操作。竞险检测器在分析这些事件流的时候可以给出包含共享变量和对其读写goroutine报告。在绝大多数情况下已经足够你查问题了。</p>
<p>竞险检测器只能报告程序覆盖到代码的竞险情况，所以尽量让测试覆盖到所有代码。竞险检查会稍微占用更多时间和内存，但是是可以接受的。</p>
<h3 id="样例：并发无阻塞缓存"><a href="#样例：并发无阻塞缓存" class="headerlink" title="样例：并发无阻塞缓存"></a>样例：并发无阻塞缓存</h3><p>实现这么一个并发数据结构，大抵有两种构建思路：</p>
<ul>
<li>使用有锁的共享变量</li>
<li>借助信道和通信实现串行化</li>
</ul>
<p>不同场景下，他们实现的复杂度可能会稍有不同。</p>
<h3 id="goroutine和线程"><a href="#goroutine和线程" class="headerlink" title="goroutine和线程"></a>goroutine和线程</h3><p>goroutine和线程有些很多小地方上的区别，这些区别让goroutine和线程有着较大区别。</p>
<ul>
<li>线程的栈一般是固定的（通常是2MB），goroutine的栈是灵活的，从较少的大小开始（通常是2KB），可以扩大和缩小</li>
<li>goroutine有自己的调度机制（m:n调度），把m个goroutine复用或调度到n的操作系统的线程</li>
<li><code>GOMAXPROCS</code>环境变量决定了Go代码可以使用多少个操作系统线程</li>
</ul>
<p>最后，goroutine没有其他操作系统或编程语言中用来支持多线程的为每个线程添加一个唯一标识的设计。这个是特别设计的，用来避免线程池的滥用。Go更推荐只由入参显式决定函数表现的风格，避免让函数收到执行线程的影响。</p>
<h2 id="包和Go工具"><a href="#包和Go工具" class="headerlink" title="包和Go工具"></a>包和Go工具</h2><p>如今中小型的程序可能会包含10000个函数，其中绝大多数来自其他人的包。包可以将程序中相互关联的特性整理到独立的单元中，进而在组织或社区中重用、分享。包名和导出的类型、变量、函数名都应简短清晰，Go使用首字母大小写控制可见性，从而掩盖实现细节，保证稳定性或实现互斥锁。</p>
<p>Go的构建速度算是比较快的。主要有3个原因：</p>
<ul>
<li>Go在每个文件开头都显式列出了引入的文件，无需读取整个文件</li>
<li>Go中没有引入是一个有向无环图，因此可以并行编译</li>
<li>编译好的Go包的目标文件会包含自身和<strong>自身的依赖</strong>，每一次的import只需读取一遍目标文件即可</li>
</ul>
<h3 id="import路径"><a href="#import路径" class="headerlink" title="import路径"></a>import路径</h3><p>Go的语言规范并没有规定import路径，路径的实现是由相关工具决定的。但是为了避免冲突，除了标准包以外的包，都需要以域名或组织名开头，如<code>encoding/json</code>，<code>golang.org/x/net/html</code>。</p>
<h3 id="声明和import"><a href="#声明和import" class="headerlink" title="声明和import"></a>声明和import</h3><p>每一个Go文件的开头，都需要以<code>package xxx</code>的形式标识包名。通常，包名是import路径的最后一段。但是有3个例外情况：</p>
<ul>
<li><code>main</code>包名表示告诉<code>go build</code>需要构建一个可执行文件</li>
<li>目录下包含<code>_test</code>后缀文件名的，在执行<code>go test</code>时会额外被构建用于测试的包</li>
<li>有的报名后面会跟版本号，这个时候以没有版本号的作为包名</li>
</ul>
<p>在import时，如果引入包较多时，可以用圆括号列表形式引入。列表间可以用空行隔开，通常用来分组域名，这个在按照字母顺序排序import时有用——排序会在每组内进行。如果不同域内的包名一样，如<code>math/rand</code>和<code>crypto/rand</code>，可以用重命名引入（renaming import）。像下面这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">    mrand <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这种重命名只在当前文件内有效。重命名通常可以避免包名冲突，或者简化一些复杂的包名，在简化时，注意对同样的原名，使用同样的缩写名。<code>go build</code>会报告编译中循环依赖。</p>
<h3 id="空导入"><a href="#空导入" class="headerlink" title="空导入"></a>空导入</h3><p>有的时候，我们的引入的<strong>目的在包的副作用</strong>，如其中全局变量的初始化或<code>init</code>函数的执行。这个时候可以用空白标识符<code>_</code>进行重命名即可，如<code>import _ &quot;image/png&quot;</code>。这种即空导入。</p>
<p>在书中例子里，对<code>image/png</code>的空导入，实现了png解码相关配置的全局注册（<code>image.RegisterFormat</code>），从而可以解码png图片。类似的思路在<code>database/sql</code>包中也有用到。</p>
<h3 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h3><p>对于包名，有下面一些建议的命名规范：</p>
<ul>
<li>使用简短明了的包名</li>
<li>使用有描述性且没有歧义的名字，且最好不要使用经常会用来命名局部变量的包名，如<code>path</code></li>
<li>包名通常使用单数形式，需要和其他情况区分开时，如<code>strings</code>，<code>bytes</code></li>
<li>避免使用具有隐藏含义的名称，如<code>temp</code></li>
</ul>
<p>对于包中的成员名：</p>
<ul>
<li>考虑和包名一起构成完整的含义，不需要包含包名，如<code>flat.Int</code>，<code>http.Get</code></li>
<li>有的包名表示一种类型，在内部会有对应的类型定义和<code>New</code>操作</li>
<li>即使对于有着很多成员的包，其最关键的几个方法仍然是最简单的</li>
</ul>
<h3 id="Go工具"><a href="#Go工具" class="headerlink" title="Go工具"></a>Go工具</h3><p>Go工具像一个瑞士军刀，它的各个子命令提供了诸如包管理器（<code>go get</code>）、构建系统（<code>go build</code>, <code>go run</code>, <code>go install</code>）、测试驱动（<code>go test</code>）等等。</p>
<h4 id="工作区组织"><a href="#工作区组织" class="headerlink" title="工作区组织"></a>工作区组织</h4><p>日常经常使用的是<code>GOPATH</code>环境变量，用于说明当前工作区的根路径。<code>GOROOT</code>表示go源码的根路径，<code>GOOS</code>表示操作系统，<code>GOARCH</code>表示处理器架构。更多配置可以执行<code>go env</code>查看。</p>
<h4 id="包下载"><a href="#包下载" class="headerlink" title="包下载"></a>包下载</h4><p>执行<code>go get</code>下载，下载时不仅包含源码的拷贝，还包含源码的版本控制信息。Go工具会自动判断流行的代码托管方式。对于不那么有名的托管网站，需要自己显式说明保本控制的协议，可以通过<code>go help importpath</code>查看细节。</p>
<p>Go工具在访问包的导入路径域名如<code>golang.org</code>时，会试图从网页的<code>&lt;meta&gt;</code>标签中寻找类似下面这样指示目标路径的信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;go-import&quot;</span> <span class="attr">content</span>=<span class="string">&quot;golang.org/x/net git https://go.googlesource.com/net&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，执行<code>go get -u</code>时会获取所有包的最新版本，在需要锁定版本时比较麻烦，可以借助<em>vendor</em>解决，在<code>go help gopath</code>中有介绍。</p>
<h4 id="包构建"><a href="#包构建" class="headerlink" title="包构建"></a>包构建</h4><ul>
<li>使用<code>go build</code>构建时，对于库类型代码只会检查错误，对于main包，则会构建可执行文件</li>
<li><strong>一个目录包含一个包</strong>，因此导入时，要么指定导入路径，要么指定相对路径，否则会以当前目录为基础构建。构建得到的可执行文件名称是go文件的前缀。</li>
<li><code>go build</code>构建时，会丢弃已编译的代码，只保留可执行文件。</li>
<li><code>go install</code>构建时，会保留已编译的代码，编译好的包位于<code>$GOPATH/pkg</code>下，编译得到的执行文件位于<code>$GOPATH/bin</code>下。再之后，<code>go build</code>和<code>go install</code>不会编译未被改变的包或命令，从而让执行过程更快。<code>go build -i</code>可以安装项目的所有依赖</li>
<li>修改<code>GOOS</code>和<code>GOARCH</code>可以改变包目标的平台和架构，默认只会针对当前平台和架构打包。</li>
<li>文件末尾以诸如<code>_linux.go</code>，<code>axm_amd64.s</code>结尾时，只会在打对应平台包的时候才会编译此文件。另外还可以以<code>// +build linux darwin</code>的注释形式做到更好的细粒度。<code>// +build ignore</code>表示编译时跳过该文件。</li>
</ul>
<p><code>go doc go/build</code>下有更多介绍。</p>
<h4 id="包文档"><a href="#包文档" class="headerlink" title="包文档"></a>包文档</h4><p>Go建议在导出的包成员和包声明前使用描述用途和用法的注释。注释宜简单且清晰，对于大段的注释，使用同名的文档文件（通常名为<code>doc.go</code>）进行说明。如果行为本身就足够明显，就不需要写注释。</p>
<p><code>go doc</code>命令可以查看包、包成员、包方法的文档。还有个很相似的命令<code>godoc</code>，它可以托管一个能够查看当前工作目录下文档的服务器。</p>
<h4 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h4><p>有些包可能希望导出只对个别信任的包可见，对于这种包，导入路径中需要包含<code>internal</code>。这些内部包只对<code>internal</code>的父目录下文件可见，如<code>net/http/internal/chunked</code>对<code>net/http/httputil</code>可见，但对<code>net/url</code>不可见。</p>
<h4 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h4><p><code>go list</code>工具可以查询包的导入路径。使用<code>...</code>通配符可以查到更多内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go list github.com/go-sql-driver/mysql</span><br><span class="line">go list ...</span><br><span class="line">go list gopl.io/ch3/...</span><br><span class="line">go list ...xml...</span><br></pre></td></tr></table></figure>

<p>结合<code>-json</code>可以打印json格式的包详情，或者结合<code>-f</code>加上<code>text/template</code>语法打印特定格式的字符串。</p>
<p>更多使用方式查看<code>go help list</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>同行评审和测试是两种避免代码错误的方式。Go尽量让写自动化测试代码不是一件很困难的事。在Go中进行测试，你需要了解的只不过是普通的Go语法规范和一些约定而已。</p>
<h3 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a><code>go test</code>工具</h3><p>Go的测试都借助<code>go test</code>完成。所有和测试相关的文件必须以<code>_test.go</code>结尾，这些文件不会在打包时包括进去，只会在运行测试时运行。在文件中有三类函数会被特殊处理：</p>
<ul>
<li>测试函数：必须以<code>Test</code>开头，表示检测一些逻辑的正确性，运行后会给出<code>PASS</code>或<code>FAIL</code></li>
<li>基准测试函数：必须以<code>Benchmark</code>开头，表示测量一些操作的性能，运行后会给出运行时间</li>
<li>样例函数：必须以<code>Example</code>开头，表示提供一些格式化的文档</li>
</ul>
<p><code>go test</code>运行完成时，会生成一个临时的<code>main</code>包，构建并运行，最后给出结果并清理现场</p>
<h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><p>测试函数均以<code>Test</code>开头，函数入参是test包提供的用来打印错误或其他日志的工具集。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSin</span><span class="params">(t *test.T)</span></span> &#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接着就像写普通Go代码一样去执行case就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">&quot;kayak&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;kayak&quot;) = false`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时，结合<code>-v</code>标记可以打印详细信息，结合<code>-run</code>标识可以只运行符合指定模式的case。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run=<span class="string">&quot;French|Canal&quot;</span> </span><br></pre></td></tr></table></figure>

<p>case之间的代码相似性很高，建议用配置的方式批量运行case，减少模板代码书写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPalindrome</span><span class="params">(t *tesing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="type">string</span></span><br><span class="line">        want <span class="type">bool</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ab&quot;</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="keyword">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;IsPalindrome(%q) = %v&quot;</span>, test.input, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>go test</code>在运行测试时，每个case的错误不会中断其他case的执行，也不会panic，来保证一次运行能获得所有case的执行结果。对于需要中断的情况，可以使用<code>t.Fatal</code>或者<code>t.Fatalf</code>。</p>
<h4 id="随机化测试"><a href="#随机化测试" class="headerlink" title="随机化测试"></a>随机化测试</h4><p>不同于上面提到的选择特定case进行测试。随机化测试可以覆盖更广的范围。在验证随机化测试是否符合预期上，有两种思路：</p>
<ul>
<li>使用另外一种方式给出结果，对比两种方式的结果是否相同</li>
<li>使用固定的模式生成随机化case，使其预期结果可以事先推导出来</li>
</ul>
<p>另外，在随机化测试时还要考虑能否再次复现问题case的情况。</p>
<h4 id="测试一个命令"><a href="#测试一个命令" class="headerlink" title="测试一个命令"></a>测试一个命令</h4><p>对于<code>go test</code>而言，<code>main</code>包只是一个库，可以将<code>main</code>函数中需要测试的逻辑抽离成函数，在<code>*_test.go</code>中测试即可。最好将<code>log.Fatal</code>或者<code>os.Exit</code>这种中断程序执行的语句放在<code>main</code>函数中，避免中断测试流程。</p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试即在对测试对象有清楚认识的情形下进行测试；黑盒测试则相反，更站在客户端的角度去测试包。在白盒测试下，我们可以修改原先包的一些实现方式，使之更易被测试。比如，可以将其中会有副作用的部分，如发邮件、写数据库、发短信的函数覆盖。（类似mock的思路）</p>
<p>但是，在覆盖后，别忘了还原回去，避免影响后续测试。类似下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckQuotaNotificationUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    saved := notifyUser</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; notifyUser = saved &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    notifyUser = <span class="function"><span class="keyword">func</span><span class="params">(user, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        notifiedUser, notifiedMsg = user, msg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种覆盖方式正常情况下不会有风险，因为<code>go test</code>通常不会并行运行多个测试。</p>
<h4 id="外部测试包"><a href="#外部测试包" class="headerlink" title="外部测试包"></a>外部测试包</h4><p>上面提到的都是直接在包下新建<code>*_test.go</code>文件的方式进行测试。有些情况下，如果测试文件内需要引用更高层包，会产生循环引用，这是上一章提到不允许的。这时可以定义为外部包。如：</p>
<p><code>net/url</code>下的测试文件导入了<code>net/http</code>包，而<code>net/http</code>包中又导入了<code>net/url</code>。这个时候在<code>net/url</code>下的测试文件使用<code>package url_test</code>声明，表示是另一个包<code>net/url_test</code>。然后，通过导入<code>net/url</code>和<code>net/http</code>的方式进行测试。就可以避免循环引用。</p>
<p>可以通过<code>go list -f</code>指定<code>.GoFiles</code>，<code>.TestGoFiles</code>和<code>.XTestGoFiles</code>分别查看包中的源文件、测试文件和外部测试包文件。</p>
<p>然而，外部测试包并不能访问到包内对外不可见的变量或函数。这个时候，可以在包内创建一个后门测试文件，用于导出一些内部变量或函数对外部包测试可见，通常命名为<code>export_test.go</code>。这类文件内不包含实际的测试。如<code>fmt</code>包下的<code>export_test.go</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IsSpace = isSpace</span><br></pre></td></tr></table></figure>

<h4 id="写高效的测试"><a href="#写高效的测试" class="headerlink" title="写高效的测试"></a>写高效的测试</h4><p>Go在设计上和其他很多语言不同，并不包含一个大而全的测试框架，也没有创建、清除操作，和常用的断言、判断方法等。Go认为写case是作者自己的事，而且就像写普通的程序一样，不要有死记硬背和长篇大论，只需简明扼要地表达测试意图。</p>
<p>在写测试代码时，避免过早抽象，先想着把功能实现，然后再想怎么通过抽象减少重复和复杂度。</p>
<h4 id="避免“脆弱”的测试"><a href="#避免“脆弱”的测试" class="headerlink" title="避免“脆弱”的测试"></a>避免“脆弱”的测试</h4><p>有两种应用：一种是真正bug很多的（buggy），另一种是合理改动也过不了case的（brittle）。而这里过不了case可能只是因为判断逻辑写的不够宽容，死抠细节导致很容易过时。避免这种情况一个很直接的办法是只检查你关心的特性，使用更简单和时间稳定的方式检查，如不要依赖字符串匹配。去检查本质。</p>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><blockquote>
<p>Testing shows the presence, not the absence of bugs —— Edsger Dijkstra</p>
</blockquote>
<p>覆盖率一定程度上能对测试的覆盖程度有启发性的指示作用。使用<code>go test -coverprofile</code>可以指定覆盖率数据输出，如果不需要输出，只看摘要，可以只用<code>go test -cover</code>。使用<code>go tool cover</code>可以显示覆盖率使用介绍。</p>
<p>最后要说明的是，被覆盖到的代码并不是没有bug，测试是一种<strong>务实</strong>的努力。它是在写测试代价和失败代价的中间的一个折中。</p>
<h3 id="性能测试函数"><a href="#性能测试函数" class="headerlink" title="性能测试函数"></a>性能测试函数</h3><p>这类函数都以<code>Benchmark</code>开头，和测试函数类似，函数入参是<code>*testing.B</code>类型的变量。默认情况下，不会执行任何性能测试，需要指定<code>-bench</code>值，去匹配对应函数执行，“<code>.</code>”表示匹配所有。如<code>go test -bench=.</code>性能测试函数写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsPalindrome</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以需要自己在基准测试函数中写循环，而不集成在测试驱动中，是避免一些一次性操作影响执行时间测量。<code>-benchmem</code>标识会显示内存分配的使用情况。性能测试函数可以用来对比两种策略或算法的相对时间优劣，以及通过调整循环次数，整体上考察代码设计。</p>
<h3 id="性能侧写（Profilling）"><a href="#性能侧写（Profilling）" class="headerlink" title="性能侧写（Profilling）"></a>性能侧写（Profilling）</h3><p>性能测试函数能帮你发现整体的性能好坏，但不能告诉你哪里做得不够好。</p>
<p>Knuth曾说过“不要过早优化”，然而结合上下文的原话的意思则是，寻找性能优化点并不那么容易，程序员们在写需求前浪费了大量时间在寻找优化点上，先把事情做出来，不要杞人忧天过早优化。但是优秀的程序员会努力找到优化点并改善之。</p>
<p>寻找关键点的方式就叫<em>profiling</em>。profile通过采样的方式给出占用时间、资源最多的对象，从而可以对应去优化。Go提供3种profile</p>
<ul>
<li>CPU profile，标记占用CPU时间最长的函数</li>
<li>heap profile，标记分配内存最多的声明</li>
<li>blocking profile，标记阻塞goroutine时间最久的操作</li>
</ul>
<p>对应在<code>go test</code>上的标识为<code>-cpuprofile</code>，<code>-memprofile</code>，<code>-blockprofile</code>。借助<code>go tool pprof</code>可以打印侧写数据，以及可视化数据。</p>
<h3 id="样例函数"><a href="#样例函数" class="headerlink" title="样例函数"></a>样例函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleIsPalindrome</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>))</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;palindrome&quot;</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一种会被<code>go test</code>特殊处理的是样例函数，这类函数以<code>Example</code>开头，并没有入参，也没有返回。它的作用主要有以下3点：</p>
<ul>
<li>文档记录，且更能传达意图，同时由于样例函数是实际的Go代码，对比文档，随着代码演化，不会有过期风险。命名单纯叫<code>Example</code>的函数作为整个包的样例函数。</li>
<li>函数最火包含<code>// Output:</code>注释的话，<code>go test</code>会检查标准输出是否能匹配注释中的输出</li>
<li>在<code>godoc</code>中可以作为playground，提供给用户动态编辑、运行的功能</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射能在<strong>运行时</strong>不知道变量类型情况下去修改和查询变量值。反射还能让我们将类型作为第一成员的值来使用。类似<code>fmt.Sprintf</code>和<code>text/template</code>中就有用到这个特性</p>
<h3 id="reflect-Type和reflect-Value"><a href="#reflect-Type和reflect-Value" class="headerlink" title="reflect.Type和reflect.Value"></a><code>reflect.Type</code>和<code>reflect.Value</code></h3><p><code>reflect.Type</code>和<code>reflect.Value</code>分别表示变量的类型和值。其中类型通过<code>reflect.TypeOf</code>得到，得到的<code>reflect.Type</code>可以保存任何类型值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(<span class="number">3</span>) <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Println(t) <span class="comment">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<p>返回的类型总是interface的动态类型，所以总是确切类型。</p>
<p><code>reflect.ValueOf</code>可以得到任意类型的变量值。返回的<code>reflect.Value</code>满足<code>fmt.Stringer</code>接口，不过打印出来的是变量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">3</span>) <span class="comment">// a reflect.Value</span></span><br><span class="line">fmt.Println(v) <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, v) <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(v.String()) <span class="comment">// &quot;&lt;int Value&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>reflect.Value.Interface</code>方法返回一个保存相同值的<code>interface&#123;&#125;</code>类型。它和<code>reflect.Value</code>不同在于，一个<code>interface&#123;&#125;</code>类型的变量掩盖了外部表现和内部实现细节，因此无从对其操作。&#96;&#96;reflect.Value<code>的</code>Kind&#96;方法可以返回类型的底层表示方法，因此使用时，可以只关心Go中定义的类型。</p>
<h3 id="递归值输出函数Display"><a href="#递归值输出函数Display" class="headerlink" title="递归值输出函数Display"></a>递归值输出函数<code>Display</code></h3><p>利用上面提到的<code>Kind</code>方法，可以实现递归打印任意类型值的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="type">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind()&#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = invalid\n&quot;</span>, path)</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fieldPath := fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)</span><br><span class="line">            display(fieldPath, v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%s]&quot;</span>, path, formatAtom(key), v.MapIndex(key)))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;(*%s)&quot;</span>, path), v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Interface:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s.type = %s\n&quot;</span>, path, v.Elem().Type())</span><br><span class="line">            display(path+<span class="string">&quot;.value&quot;</span>, v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 基础类型、信道、函数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = %s\n&quot;</span>, path, formatAtom(v))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到了许多<code>reflect.Value</code>的方法，不是所有的都安全：</p>
<ul>
<li><code>v.Index()</code>和<code>v.Len()</code>类似<code>len()</code>和<code>[i]</code>下标取值</li>
<li><code>v.NumbField()</code>返回结构体中的字段数目，<code>v.Field(i)</code>则返回第i位的<code>reflect.Value</code>类型值</li>
<li><code>v.MapKeys()</code>返回无序的map key</li>
<li><code>v.IsNil()</code>和<code>v.Elem()</code>分别判断是否为空和获取值</li>
</ul>
<p>上述方法在遇到有环的数据结构时，会无限打印，可以借助下一章里的<code>unsafe</code>包解决。</p>
<h3 id="使用reflect-Value设置变量"><a href="#使用reflect-Value设置变量" class="headerlink" title="使用reflect.Value设置变量"></a>使用<code>reflect.Value</code>设置变量</h3><p>Go中的变量都是有地址的，可以通过这个地址去修改变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">a := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">b := reflect.ValueOf(x)</span><br><span class="line">c := reflect.ValueOf(&amp;x)</span><br><span class="line">d := c.Elem() <span class="comment">// variable</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>d</code>即变量<code>x</code>。借助这个方式我们可以用<code>Addr()</code>获取地址，用<code>Interface()</code>获取<code>interface&#123;&#125;</code>类型的值，再使用类型断言转成具体的变量类型。像下面这样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">px := d.Addr().Interface().(*<span class="type">int</span>)</span><br><span class="line">*px = <span class="number">3</span></span><br><span class="line">fmt.Println(x) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>又或者，可以通过<code>Set</code>方法设置一个<code>reflect.Value</code>。针对特定类型，还有<code>SetInt</code>、<code>SetUint</code>、<code>SetString</code>这样的方法。注意，这些方法只使用在特定类型上，对于<code>interface&#123;&#125;</code>或其他类型使用，会引起panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d.Set(reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ry := reflect.ValueOf(&amp;y).Elem()</span><br><span class="line">ry.SetInt(<span class="number">2</span>) <span class="comment">// panic: SetInt called on interface Value</span></span><br><span class="line">ry.SetInt(reflect.Value(<span class="number">3</span>)) <span class="comment">// OK, y = int(3)</span></span><br></pre></td></tr></table></figure>

<p>另外，反射不能更新那些没有对外导出的结构体字段，尽管这些字段可以在发射中读取到。<code>CanSet()</code>可以判断一个<code>reflect.Value</code>是否可以修改，类似的，<code>CanAddr()</code>可以判断一个<code>reflect.Value</code>是否可以获取到地址。</p>
<p>利用上面的特性，可以实现encoding&#x2F;json中类似的解析JSON字符串的效果。</p>
<h3 id="访问结构体的field-tag"><a href="#访问结构体的field-tag" class="headerlink" title="访问结构体的field tag"></a>访问结构体的field tag</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    Labels []<span class="type">string</span> <span class="string">`http:&quot;l&quot;`</span></span><br><span class="line">    MaxResults <span class="type">int</span> <span class="string">`http:&quot;max&quot;`</span></span><br><span class="line">    Exact <span class="type">bool</span> <span class="string">`http:&quot;x&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在JSON一节提到，可以在结构体后使用<em>field tag</em>作为JSON解析过程中的metadata。实际上，除了<code>json</code>还可以设置其他tag。这个tag也可以通过反射特性拿到。</p>
<p><code>reflect.Type</code>的<code>Field()</code>方法可以返回一个<code>reflect.StructField</code>类型，其中包含了字段名、字段类型以及可选的标签。其中<code>Tag</code>字段即field tag对应的字符串，它的<code>Get</code>方法可以返回特定标识后的标签值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpack</span><span class="params">(req *http.Request, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := req.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]reflect.Value)</span><br><span class="line">    v := reflect.ValueOf(ptr).Elem()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">        fieldInfo := v.Type().Field(i) <span class="comment">// reflect.StructField类型</span></span><br><span class="line">        tag := fieldInfo.Tag <span class="comment">// reflect.StructTag类型</span></span><br><span class="line">        name := tag.Get(<span class="string">&quot;http&quot;</span>) <span class="comment">// 获取http标识</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            name = strings.ToLower(fieldInfo.Name)</span><br><span class="line">        &#125;</span><br><span class="line">        field[name] = v.Field(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展示类型的方法"><a href="#展示类型的方法" class="headerlink" title="展示类型的方法"></a>展示类型的方法</h3><p><code>reflect.Type</code>和<code>reflect.Value</code>都有一个<code>Method()</code>方法。<code>reflect.Type</code>中的方法返回<code>reflect.Method</code>实例，结构体中包含方法名和方法类型。<code>reflect.Value</code>中的<code>Method()</code>方法则返回一个<code>reflect.Value</code>类型，即一个绑定到receiver上的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    t := v.Type()</span><br><span class="line">    fmt.Println(<span class="string">&quot;type %s\n&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;func (%s) %s%s\n&quot;</span>, t, t.Method(i).Name, strings.TrimPrefix(methType.String(), <span class="string">&quot;func&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些忠告-1"><a href="#一些忠告-1" class="headerlink" title="一些忠告"></a>一些忠告</h3><p>反射在规范的类型系统外，引入了更高自由度和编程的灵活性，但同时也带来了弱类型解释型语言（没错，JS就是你）的弊病：编译期问题会变成运行时问题、代码可读性变差、性能更差。</p>
<p>反射虽然提供了很强大的功能，但是失去了类型的保护，需要额外处理类型的边界case，否则很容易在运行时出现panic。而这些在使用特定类型时会在编译期就被发现。因此，在使用时，建议将包中使用反射的部分完全封装在内，不对外暴露，同时做一些额外的动态检查。同时，在出错时，给出类型上更友好的提示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%d %s\n&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">42</span>) <span class="comment">// &quot;%!d(string=hello) %!s(int=42)&quot;</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>interface&#123;&#125;</code>类型和大量出现的反射代码会让代码安逸理解，需要辅以更加完善的文档和注释来解释。</p>
<p>最后，基于反射的函数执行速度比普通基于特定类型的函数慢至少一两个级别。因此，尽量不要在代码执行的关键路径上使用反射实现，类似测试代码这种小数据量和执行覆盖频率的代码就可以使用。</p>
<h2 id="低阶特性"><a href="#低阶特性" class="headerlink" title="低阶特性"></a>低阶特性</h2><p>Go已经尽量掩盖了它在底层的实现，用来避免出现难以调试的神秘问题。但在有些时候，比如为了追求性能，或者希望和操作系统底层交互，可能希望绕开这个限制。这一章的内容介绍的<code>unsafe</code>包提供了这么一个窗口，<code>cgo</code>工具可以将创建C库和Go的绑定关系。</p>
<h3 id="unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof"><a href="#unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof" class="headerlink" title="unsafe.Sizeof，unsafe.Alignof和unsafe.Offsetof"></a><code>unsafe.Sizeof</code>，<code>unsafe.Alignof</code>和<code>unsafe.Offsetof</code></h3><p>这三个API能让你了解一些Go在内存结构上的一些细节。其中</p>
<ul>
<li><code>Sizeof</code>返回操作数在内存中占用的大小</li>
<li><code>Alignof</code>返回操作数“对齐”需要的内存大小</li>
<li><code>Offsetof</code>返回结构体中字段在结构体内存的偏移量</li>
</ul>
<p>这几个API并不像它们名字里写的不安全，对于了解底层的内存表示是有帮助的，比如在需要优化内存性能时。</p>
<h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a><code>unsafe.Pointer</code></h3><p><code>unsafe.Pointer</code>是一个可以指向任意类型变量的指针，同时<strong>也可以把<code>unsafe.Pointer</code>类型指针转换回特定类型指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123; <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f)) &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#016x\n&quot;</span>, Float64bits(<span class="number">1.0</span>)) <span class="comment">// &quot;03xff00000000000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时<code>unsafe.Pointer</code>可以转换为<code>uintptr</code>类型，这个类型用整数表示了地址。这个整数类型足够大，足以表示任何类型的指针。但在使用时要多加注意，因为Go的垃圾回收机制使得一个变量的地址很可能会在运行过程中改变，从而使之前的<code>uintptr</code>类型变量失去意义。建议尽可能减少<code>unsafe.Pointer</code>到<code>uintptr</code>和对<code>uintptr</code>的使用。如果有包返回了一个<code>uintptr</code>类型，建议立即将其转换为<code>unsafe.Pointer</code>类型，确保指针能指向同一个变量。</p>
<h3 id="cgo"><a href="#cgo" class="headerlink" title="cgo"></a>cgo</h3><p>使用cgo可以在go中使用C语言，反之亦然，这里从略，具体参考<a target="_blank" rel="noopener" href="https://golang.org/cmd/cgo%E3%80%82">https://golang.org/cmd/cgo。</a></p>
<h3 id="再一些忠告"><a href="#再一些忠告" class="headerlink" title="再一些忠告"></a>再一些忠告</h3><p><code>unsafe</code>包和<code>reflect</code>包很像，提供了一些高级特性，但是更甚。它绕开了语言对不可控因素的隔离，会带来一些风险。所以，在特殊场景下，经过仔细考量和验证证实，使用<code>unsafe</code>确实会带来关键性能提升时，再在代码的关键位置使用<code>unsafe</code>，同时，尽量保证对代码其他地方透明。</p>
<p>最后，忘掉最后两章吧，先去踏踏实实写一些Go程序，在能用上<code>reflect</code>和<code>unsafe</code>的时候，你自然回想起来的。</p>
<p>祝，happy Go programming。</p>
<p><em>-END-</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/12/02/clean-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/02/clean-code/" class="post-title-link" itemprop="url">《代码整洁之道》——有一个好的代码品味</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-02 23:08:32" itemprop="dateCreated datePublished" datetime="2019-12-02T23:08:32+08:00">2019-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-12-28 17:50:49" itemprop="dateModified" datetime="2019-12-28T17:50:49+08:00">2019-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/12/02/clean-code/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/02/clean-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>The only valid measurement of code quality: WTFs&#x2F;minute</p>
</blockquote>
<p>在成为一个程序员的初期，实现功能还需磕磕绊绊的阶段，我们大抵没有精力操心代码风格的问题；而在能够搞定环境和API使用的时间段，大部分人又会沉湎于使用一门语言让想象实现的成就感，而没有发现暗藏在迭代后的危机。往往迭代了一段时间后，才发现之前埋下的巨坑已经让自己无从下手。这时一部分人醒悟过来，意识到一个优良的代码风格对于项目推进的长远意义。这也是《Clean Code》这本书的宗旨。它较之《程序员修炼之道》更为具体，较之《重构》更为宏观。对于工作一段时间后的程序员来说，是一个很好的提醒和反思归纳的建议。让代码work的方式是千万种，而让代码可持续，可扩展，长久work的方式也许需要前辈指引些方法。</p>
<h2 id="观念"><a href="#观念" class="headerlink" title="观念"></a>观念</h2><blockquote>
<p>Later equals never —— Leblanc Law</p>
</blockquote>
<p>糟糕的代码会让人难以下手，拖慢进度，若无人着手改善，混乱会持续增加，进而降低团队生产力，降低人效，然后搞砸整个项目。为什么不一开始就打好基础，写出整洁代码呢？</p>
<p>下面是一些大师对“整洁代码”的界定</p>
<ul>
<li>“代码逻辑直截了当，缺陷难以隐藏；减少依赖关系，从而便于维护；性能调优，省得引人做出没规矩的优化，干出蠢事；整洁的代码只干一件事” —— Bjarne Stroustrup</li>
<li>“代码简单直接，如同优美的散文；从不隐藏设计者的意图，充满干净利落的抽象和直截了当的控制语句” —— Grady Booch</li>
<li>“可由作者外的人阅读和扩展，应该有单元测试和验收测试；只使用有意义的命名；提供尽量正交的使用方法（一种而非多种做一件事的方法）；尽量少的API；尽量少的依赖关系，且要明确定义和清晰提供；代码应从字面意义上表达其含义” —— Dave Thomas</li>
<li>“整洁的代码总是看起来像某位特别在意的人写的，几乎没有改进的余地，所有的改进都会回到原点” —— Michael Feather</li>
<li>“能通过所有测试；没有重复代码，表达力强大；体现系统中的全部设计理念；包括尽量少的实体，如类、方法、函数。” —— Ron Jeffries</li>
<li>“整洁代码让每个例程都深合己意；漂亮代码让语言看起来像是专门为解决那个问题而存在” —— Ward Cunningham</li>
</ul>
<p>编写代码的难度，取决于读周边代码的难度，要想干得快，就先让代码易读。</p>
<blockquote>
<p>让营地比你来时更干净 —— 童子军军规</p>
</blockquote>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>好的命名，可以让人一眼就明白代码的逻辑。看下面两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="type">int</span>[]&gt; getThem() &#123;</span><br><span class="line">  List&lt;<span class="type">int</span>[]&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span>[] x : theList)</span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">0</span>] == <span class="number">4</span>)</span><br><span class="line">      list1.add(x)</span><br><span class="line">  <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Cell&gt; <span class="title function_">getFlaggedCells</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;Cell&gt; flaggedCells = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Cell&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Cell cell : gameBoard)</span><br><span class="line">    <span class="keyword">if</span> (cell.isFlagged)</span><br><span class="line">      flaggedCells.add(cell);</span><br><span class="line">  <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些准则：</p>
<ul>
<li>名副其实，一旦发现更好的，就替换掉旧的。<strong>如果名称还需要注释补充，那就不算名副其实</strong></li>
<li>避免误导，提防使用不同之处较小的名称，比如<code>UsernameListEmptyFilter</code>和<code>UsernameListNullFilter</code>，不要混用1和l，以及0和O</li>
<li>做有意义的区分，少废话，反例是<code>a1</code>和<code>a2</code>，<code>nameString</code>和<code>name</code></li>
<li>使用<strong>能读出来</strong>的名称，方便程序员的沟通</li>
<li>使用<strong>可搜索</strong>的名称，仅在块作用域或短函数内使用单字母名称</li>
<li>不把类型信息放在名称中</li>
<li>减少不必要的前缀和后缀</li>
<li>类名应该是名词，方法名应该是动词或动词短语</li>
<li>别玩梗</li>
<li>标准化语素，为每一个抽象概念选择一个统一的词</li>
<li>别用有多重含义的词汇，这会增加使用者顾虑和理解成本</li>
<li>只在没有明确定义的场景下使用语境（类，前缀……）</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>下面是一些准则：</p>
<ul>
<li><strong>短小，更短小</strong></li>
<li><strong>只做一件事，只做一件事，只做一件事</strong>，重要的事情说三遍<ul>
<li>还有一种方式可以帮助判断函数是不是只做了一件事：<strong>函数语句是否在一个抽象层级上</strong></li>
<li>只做一件事的函数无法被继续合理拆分成多段</li>
</ul>
</li>
<li>让代码拥有从上到下的自然的阅读顺序，尽量避免跳来跳去的阅读顺序</li>
<li>为函数使用<strong>描述性</strong>的名称</li>
<li>函数<strong>最多3个入参</strong>，最理想是没有参数，其次是1个，再其次是2个，要避免3个参数<ul>
<li><strong>布尔类型的参数会让你的函数难以理解</strong></li>
<li>使用二元参数时，最好保证前后顺序不敏感</li>
<li>对于复杂的入参，可以用对象封装起来</li>
</ul>
</li>
<li>函数要么只做副作用（<em>做什么事</em>），要么没有副作用（<em>回答什么事</em>），而且能从名称中一目了然地看到</li>
<li>用异常代替错误码，错误处理也是一件事</li>
<li><strong>别重复自己（Don’t repeat yourself, DRY）</strong>。重复是软件中一切邪恶的根源，软件开发领域的所有创新都在不断尝试从源代码中消灭重复</li>
</ul>
<p>函数是语言的动词，类是名词。大师级的程序员把系统当做故事来讲，而不是程序来写。他们使用特定编程语言提供的工具构建一种<strong>更丰富和更具表达力的语言</strong>。好的函数必须干净利落的组合在一起，形成清晰明确的语言，帮你<strong>讲好故事</strong>。这个过程不是一蹴而就的，你可以现象什么就写什么，然后一点点打磨它。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><blockquote>
<p>使用注释 &#x3D; 承认自己无法用代码表达清楚意图</p>
</blockquote>
<p>列举注释的准则前，必须摆正观念。<strong>注释是一种必须的恶，如果编程语言足够有表达力，或你长于用语言表达自己的意图，那么就不需要注释。注释的恰当用法是弥补我们用代码表达意图时遭遇的失败。</strong>注释存在的时间越久，具体所描述的事实就越远。原因很简单，程序员不可能坚持维护注释。</p>
<p>的确，程序员应该让注释保持可维护而精准，但最好能直接写清楚代码，保证无须编写注释。<strong>真实只在一处：代码</strong>，只有代码能忠实告诉你它做的事。</p>
<ul>
<li><strong>注释无法挽救糟糕的代码</strong>，与其为糟糕代码补充大量注释，不如花时间写出整洁有表达力的代码</li>
<li><strong>用代码代替注释</strong></li>
<li>有些无法避免且合理存在的注释<ul>
<li>法律信息</li>
<li>对函数名的补充</li>
<li>对稍微反常规意图的解释，避免误解</li>
<li>糟糕的代码来自外部库或外部API</li>
<li>敏感代码的警告</li>
<li>TODO、FIXME</li>
<li>Javadoc</li>
</ul>
</li>
<li>下面则是一些很常见的糟糕注释，它们只是糟糕代码的借口<ul>
<li>只有自己看得懂的注释</li>
<li>对函数名的复述</li>
<li>误导性注释</li>
<li>日志型注释，如Milestone记录</li>
<li>废话</li>
<li>位置标记，如<code>====================</code></li>
<li>代码署名</li>
<li><em>大多数</em>注释掉的代码</li>
<li>百科式的介绍</li>
<li>私有代码的Javadoc</li>
</ul>
</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>格式即代码风格，可以利用lint这样的自动化工具完成，需要在团队内保持一致。</p>
<h3 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h3><p>在从上到下的组织上，</p>
<ul>
<li>可以向报纸一样，先大纲，再粗线条概述，再给出细节，越往下细节越多</li>
<li>用<strong>空行</strong>分隔概念</li>
<li>靠近的代码行暗示了代码间的紧密关系</li>
<li>应避免迫使读者在源文件和类之间跳来跳去<ul>
<li>变量声明应尽量靠近使用位置</li>
<li>循环中的控制变量总在循环语句中声明</li>
<li>类成员在类顶部声明</li>
<li>如果某个函数调用了另一个，就应该把它们放一起</li>
<li>概念相关的代码应该放在一起，如<code>getHour</code>和<code>getMinute</code></li>
<li>如果可以，最好把被调用的函数放在执行调用的函数下面</li>
</ul>
</li>
</ul>
<h3 id="横向格式"><a href="#横向格式" class="headerlink" title="横向格式"></a>横向格式</h3><ul>
<li>水平字符的上限，100或120</li>
<li>使用<strong>空格</strong>分隔概念</li>
<li><strong>不需要水平对齐</strong>，以为从左到右的阅读顺序优先于从上到下</li>
<li>学会用<strong>缩进</strong>表现层级</li>
</ul>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ul>
<li><strong>对象</strong>把数据隐藏于抽象的后面，暴露操作数据的函数，<strong>数据结构</strong>暴露数据，不提供有意义的函数。</li>
<li>过程式代码难以添加新的数据结构，因为必须修改所有函数；面向对象代码难以添加新函数，因为必须修改所有类</li>
<li>得墨忒尔律：类C的方法f只应该调用以下对象的方法：<strong>C、f创建的对象、作为参数传给f的对象、C的成员所持有的对象</strong></li>
<li><strong>数据结构</strong>只简单地拥有公有变量，没有函数；而<strong>对象</strong>则只拥有私有变量和函数。一半是对象一半是数据结构的混淆会增加添加新函数和数据结构的难度</li>
<li>DTO（Data Transfer Objects，数据传输对象）就是只有公有变量，没有函数的类，Active Record就是DTO的一种</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理很重要，但要是它搞乱了代码逻辑，那就是错误的用法。</p>
<ul>
<li>返回异常而不是错误码</li>
<li>try-catch-finally语句块就像事务，可以帮你定义用户应该期待些什么</li>
<li>在Java中，可控异常违反开闭原则带来的成本要高于收益</li>
<li>打包第三方API，一方面降低了依赖的覆盖面，另一方面也有助于模拟第三方调用</li>
<li>可以把抛出错误封装成特定的函数</li>
<li>别返回和传递null值</li>
</ul>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>边界即我们代码和第三方代码的连接处。</p>
<ul>
<li>通过编写测试来概览和理解第三方代码的形式叫做<strong>学习性测试（learning tests）</strong>。它可以帮助我们快速试错和反馈，从而对第三方API快速上手。</li>
<li>在第三方代码尚未就绪时，<strong>编写我们想要的接口</strong>，可以使我们能保持代码在自己控制中，并在未来通过编写adapter的形式无痛迁移</li>
<li>应尽量避免过多依赖第三方的特定信息，更多依靠你能控制的东西，好过依靠你控制不了的东西，免得日后受其控制</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>TDD（Test-Driven Development）三定律<ul>
<li>在编写不能通过的单元测试前，不编写生产代码</li>
<li>只编写刚好无法通过的单元测试，不能编译也算</li>
<li>只编写刚好足已通过失败测试的生产代码</li>
</ul>
</li>
<li><strong>测试代码和生产代码一样重要</strong>。正是单元测试让你的代码可扩展、可维护、可复用</li>
<li>整洁的测试代码一样要求<strong>可读性</strong>。大多数测试代码可以总结为构造-操作-检验（Build-Operate-Check）模式。第一个环节构造测试数据，第二个环节操作数据，第三个环节验证是否得到期望的结果</li>
<li>每个测试中的断言数量应该尽量少，且只测试一个概念</li>
<li>FIRST原则<ul>
<li>Fast，测试应该能够快速运行</li>
<li>Independent，测试间应该相互独立</li>
<li>Repeatable，测试应该在任何环境下可重复通过</li>
<li>Self-Validating，测试应该有布尔值输出</li>
<li>Timely，测试应及时编写</li>
</ul>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>类应该由一组成员开始，从静态到普通，从共有到私有。且很少会有公有成员。</li>
<li>类应该短小，<strong>类的名称应该能描述其权责</strong>。类名无法精确明明时，类大概就太长了。类名越含糊，类越有可能拥有过多权责。类名应该控制在25个字母内，且不应该包含连词。</li>
<li>单一权责原则（Single Responsibility Principle，SRP）认为，类和模块应有且仅有<strong>一条加以修改的原因</strong>。这个原则可以帮助创造更好的抽象。它也是OO设计中最重要的概念之一。</li>
<li>内聚：类应该只有少量实体变量，且所有方法都应该操作其中一些。当类的每个变量都被每个方法使用时，我们认为该类具有最大的内聚性。当发现类逐渐丧失内聚性时，尽早拆分它！让它变成多个短小的类。这个拆分的过程也是权责的拆分过程。</li>
<li>通过基类和子类，可以在不修改类的同时，保持类对新功能的开放。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。可以通过抽象类和接口隔离细节修改带来的影响。</li>
<li>降低类之间的连接耦合，可以采用依赖倒置原则（Dependency Inversion Principle，DIP），让类依赖于抽象（接口）而不是具体细节（自行构造类）</li>
</ul>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p><em>这一章的Java概念较多</em></p>
<ul>
<li>分开系统的构造和使用</li>
<li><strong>依赖注入</strong>是控制反转的一种思路，它将第二权责从对象中拿出来，转移到专门的对象中去，从而遵循<strong>单一权责原则</strong></li>
<li>我们应该专注于今天的用户故事，并且<strong>持续适当切分</strong>我们的关注面。书中举了Java AOP、AspectJ框架的例子</li>
<li>实现时，使用<em>大致可工作的最简单方案</em>。只要软件构架有效切分了关注面，就比较好做根本性改动</li>
</ul>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>Kent Beck关于测试的4个原则：</p>
<ul>
<li>运行所有测试，全面测试并持续通过所有测试的系统，就是可测试的系统。测试也能减少重构时可能破坏代码的顾虑。</li>
<li>不可重复，使用模板生成或继承等高级概念</li>
<li>表达程序员的意图。代码应当清晰表达作者的意图。使用好名称、保持类和函数的短小，以及之前章节提到的各种方法</li>
<li>尽可能减少类和方法的数目，避免前两条规范的矫枉过正</li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>并发是一种解耦策略，帮助我们分解开<strong>做什么（目的）</strong>和<strong>何时（时机）</strong>。</p>
<ul>
<li>并发<strong>有时</strong>能改善性能，会在编写额外代码上带来额外开销</li>
<li>正确的并发是复杂的</li>
<li>并发会带来系统结构的变化</li>
</ul>
<p>有些防御并发代码问题的原则：</p>
<ul>
<li>单一权责：分离并发代码和其他代码</li>
<li>限制对可能共享的数据的访问</li>
<li>线程应尽可能独立</li>
</ul>
<p>并发执行模式：</p>
<ul>
<li>生产者-消费者模式：数据通过队列传递，队列本身是一种限定资源</li>
<li>读者-作者模式</li>
<li>宴席哲学家问题</li>
</ul>
<p>还有一些需要注意的事情：</p>
<ul>
<li>警惕同步方法间的依赖</li>
<li>尽可能减小sychronized区域</li>
<li>尽早考虑程序关闭问题</li>
<li>测试线程代码</li>
</ul>
<h2 id="3个实例"><a href="#3个实例" class="headerlink" title="3个实例"></a>3个实例</h2><p>书中以三个实例的重构过程向我们表现了一些将之前思路应用于优化代码的方式。</p>
<h3 id="命令行参数解析：args"><a href="#命令行参数解析：args" class="headerlink" title="命令行参数解析：args"></a>命令行参数解析：args</h3><blockquote>
<p>编程是一种技术甚于科学的东西，要编写整洁代码，必须先写肮脏代码，然后再<strong>清理它</strong></p>
</blockquote>
<p>在你的初稿，当代码糟糕透顶时甚至是前几稿中，很可能还是会存在烂摊子：成员多得吓人，奇怪命名的魔法字符串，一大堆的try-catch-finally代码。程序员们不都是蠢人，这堆糟糕透顶的代码其实是从最初看起来很合理但是<strong>扩展性差</strong>的代码一步步演化来的。</p>
<p>需要使用一些总结和抽象，来简明地表达你的目的。另外，在重构前，“我”（其实是作者）要不厌其烦地强调TDD的必要性，它能保证你重构的每一步，系统都可以工作。在重构过程中，放进拿出是常见的事，小步幅、保持测试通过，你可能会不断移动各种东西。</p>
<p>优秀的代码设计，大都关乎<strong>分隔</strong>——创建合适的空间防止不同种类的代码。对关注面的分隔让代码更易于理解和维护（减少理解所需要的大脑缓存）</p>
<h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><ul>
<li>不必要的编码前缀（<code>f_</code>）</li>
<li>未封装的条件判断</li>
<li>建议使用肯定式代替否定式判断</li>
<li>奇怪的不直观的函数名</li>
<li>易造成理解困难的变量名</li>
<li>拆分违反SRP原则的函数</li>
<li>避免隐式时序耦合的函数，用hardcode的形式显示表现时序耦合</li>
</ul>
<h3 id="SerialDate重构"><a href="#SerialDate重构" class="headerlink" title="SerialDate重构"></a>SerialDate重构</h3><p>再强调一遍，<strong>重构前要有一个完整的验证可行性的测试</strong>。然后开始重构：</p>
<ul>
<li>没有描述力的类名和术语名</li>
<li>使用枚举代替常量类</li>
<li>抽象类中不应知道实现细节</li>
<li>基类不宜知道子类的情况</li>
<li>多余的注释</li>
<li>变量声明应该放在尽量靠近使用的地方</li>
<li>如果有专业术语，就不要自己命名了</li>
<li>不要写无用的模板代码</li>
<li>如果函数对成员进行操作，它就不应该是静态的</li>
<li>用<strong>解释临时变量</strong>的方式，让大段的代码更为简化和有表达力</li>
<li>消除魔术数</li>
</ul>
<h2 id="味道和启发"><a href="#味道和启发" class="headerlink" title="味道和启发"></a>味道和启发</h2><p>作者在这里对《重构：既有代码设计的改善》里提到的味道做了自己的一些扩充，也可以作为对上面章节的回顾。</p>
<p><em>“味道”，即那些看起来不大对劲的代码</em></p>
<h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><ul>
<li>不恰当的信息，如修改记录</li>
<li>过时的注释</li>
<li>多余的废话</li>
<li>错误的有误导性的注释</li>
<li>注释掉的代码</li>
</ul>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>多步才能完成的构建</li>
<li>多步才能完成的测试</li>
</ul>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><ul>
<li>过多的入参</li>
<li>布尔类型参数</li>
<li>从未被调用的函数</li>
<li>用于返回的参数</li>
</ul>
<h3 id="一般性问题"><a href="#一般性问题" class="headerlink" title="一般性问题"></a>一般性问题</h3><ul>
<li>源文件中有多种语言</li>
<li>明显违背字面意义的直觉</li>
<li>不考虑边界情况</li>
<li>忽视安全问题</li>
<li><strong>重复</strong>，这也是最常见的问题。每次看到重复代码都代表遗漏了抽象。有一些常见的设计模式可以帮助你。</li>
<li>代码的抽象层级有问题，或混杂。抽象类用来容纳高层级概念，子类用来容纳低层级概念。不同层级概念放在不同容器中。</li>
<li>基类依赖于子类。通常来说，基类对子类应该一无所知</li>
<li>信息过多，违背SRP</li>
<li>从未使用的代码</li>
<li>不恰当的垂直分隔</li>
<li>语素前后不一致</li>
<li>基于巧合、预设假设的耦合。异或是两个没有直接目的之间的模块的耦合。</li>
<li><strong>特性依恋</strong>，类的方法只应对自身的成员和方法感兴趣，不应关注其他类的成员和方法</li>
<li>使用boolean或枚举参数让一个函数表现多态。使用多个函数通常由于向单个函数传递代码来选择函数行为</li>
<li>晦涩的意图，如魔术数、魔术字符串、过度简写的表达式</li>
<li>位置错误的权责</li>
<li>不恰当的静态方法，如完全不需要多态的函数</li>
<li>使用自解释的变量名</li>
<li>使用自解释的函数名</li>
<li>理解算法</li>
<li>把逻辑依赖（脑海中的限制&#x2F;已知条件）改为物理依赖</li>
<li>使用if&#x2F;else、switch前想想有没有多态的实现方法</li>
<li>遵循团队lint规则</li>
<li>足够准确</li>
<li>未封装的条件判断</li>
<li>未封装的边界条件检测</li>
<li>避免否定性条件</li>
<li><strong>函数应该只做一件事</strong></li>
<li><strong>函数应该只在一个抽象层级上</strong></li>
<li>隐蔽的时序性耦合</li>
<li>别随意，先好好思考再下手</li>
<li>应该在较高层级放置可配置数据</li>
<li>避免传递浏览，即遵守德墨忒尔律</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul>
<li>使用通配符避免过长的导入清单</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">package</span>.*</span><br></pre></td></tr></table></figure>

<ul>
<li>不要继承<em>常量</em>，使用静态导入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> EmployeeConstants.*</span><br></pre></td></tr></table></figure>
<ul>
<li>在可以的情况下，用枚举代替常量</li>
</ul>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><ul>
<li>使用描述性名称</li>
<li>名称应该与抽象层级相符</li>
<li>使用标准化语素</li>
<li>使用无歧义的名称</li>
<li>在较大作用范围使用较长名称，较小作用范围<em>可以</em>使用较短名称</li>
<li>名称应该明确说明有副作用存在</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>要有足够的测试</li>
<li>使用覆盖率工具</li>
<li>别放过小测试</li>
<li>被忽略的测试是对不确定事物的疑问</li>
<li>测试边界条件</li>
<li>测试失败的模式（pattern）会有启发性</li>
<li>测试覆盖率的模式会有启发性</li>
<li>测试应该快速</li>
</ul>
<h2 id="并发编程示例"><a href="#并发编程示例" class="headerlink" title="并发编程示例"></a>并发编程示例</h2><h3 id="客户端-x2F-服务端"><a href="#客户端-x2F-服务端" class="headerlink" title="客户端&#x2F;服务端"></a>客户端&#x2F;服务端</h3><ul>
<li>如果吞吐量与I&#x2F;O有关，则并发编程可以提升运行效率</li>
<li>保持并发系统整洁，把线程管理隔离到一个位置</li>
</ul>
<h3 id="可能的执行路径"><a href="#可能的执行路径" class="headerlink" title="可能的执行路径"></a>可能的执行路径</h3><p>深入到字节码和汇编语句的执行上，有些并非线程安全的操作中，不同的执行路径会带来不同结果。</p>
<h3 id="了解类库"><a href="#了解类库" class="headerlink" title="了解类库"></a>了解类库</h3><ul>
<li>Executor框架</li>
<li>非锁定方案：AtomicBoolean，AtomicInteger和AtomicReference</li>
<li>数据库连接、java.util中的容器、Servlet天生不是线程安全的</li>
</ul>
<h3 id="提升吞吐量"><a href="#提升吞吐量" class="headerlink" title="提升吞吐量"></a>提升吞吐量</h3><ul>
<li>synchronized代码块最好能限制在小范围内</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁需要满足4个条件：</p>
<ul>
<li><strong>互斥</strong>，即资源数量有限，或无法在同一时间为多个线程公用</li>
<li><strong>上锁及等待</strong>，从线程获取资源到完成工作前，不会释放这个资源</li>
<li><strong>无抢先机制</strong>，线程无法从其他线程处夺取资源</li>
<li><strong>循环等待</strong></li>
</ul>
<p>相反地，有4种避免死锁的方式：</p>
<ul>
<li><strong>不互斥</strong>，使用允许同时使用的资源，或增加资源数目</li>
<li><strong>不上锁及等待</strong>，如果有等待情况就释放所有资源从新来过</li>
<li><strong>满足抢先机制</strong></li>
<li><strong>不做循环等待</strong></li>
</ul>
<h3 id="测试多线程代码"><a href="#测试多线程代码" class="headerlink" title="测试多线程代码"></a>测试多线程代码</h3><ul>
<li>复现问题可能很难，可以借助工具（如ConTest）帮助</li>
</ul>
<p><em>–END–</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/11/15/degit-improvement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/15/degit-improvement/" class="post-title-link" itemprop="url">degit认识和改造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-11-15 21:51:58 / 修改时间：22:17:53" itemprop="dateCreated datePublished" datetime="2019-11-15T21:51:58+08:00">2019-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/11/15/degit-improvement/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/15/degit-improvement/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近日写了一个chrome插件的starter-boilerplate。但这类boilerplate被人们使用的方式常常是整合在cli库中。由于仓库本身的模板性质和git历史存在，并不合适使用npm分发或<code>git clone</code>快速搭建项目骨架。</p>
<p>碰巧此前学习svelte的时候接触到了<a target="_blank" rel="noopener" href="https://github.com/Rich-Harris/degit">degit</a>，degit做的事很简单，<strong>复制git仓库代码</strong>。这也正是一个称职的boilerplate发挥光和热的方式。</p>
<h2 id="degit使用"><a href="#degit使用" class="headerlink" title="degit使用"></a>degit使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">degit user/repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># these commands are equivalent</span></span><br><span class="line">degit github:user/repo</span><br><span class="line">degit git@github.com:user/repo</span><br><span class="line">degit https://github.com/user/repo</span><br><span class="line"></span><br><span class="line">degit user/repo my-new-project</span><br></pre></td></tr></table></figure>

<p>上面是一个degit的基本用法，类似<code>git clone</code>指定仓库地址和本地目录名，默认将项目当前<code>master</code>分支的代码拷贝到本地。还可以在仓库后使用<code>#</code>分隔，指定分支名、tag名或commit hash。目前（2019&#x2F;11&#x2F;12）degit支持github、gitlab、BitBucket以及Sourcehut，暂不支持私有仓库。</p>
<p>在一些情况下，我们可能希望在拷贝完代码后进行一些后置操作，如拷贝关联仓库或删除不必要文件等。对此，degit设计了<strong>actions</strong>来支持，可以在当前目录的<code>degit.json</code>中声明。目前actions只有<code>clone</code>和<code>remove</code>两种。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// degit.json</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;action&quot;</span>: <span class="string">&quot;clone&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src&quot;</span>: <span class="string">&quot;user/another-repo&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;action&quot;</span>: <span class="string">&quot;remove&quot;</span>,</span><br><span class="line">        <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;LICENSE&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="degit优势"><a href="#degit优势" class="headerlink" title="degit优势"></a>degit优势</h2><p>如README中提到的，degit和<code>git clone --depth 1</code>还是有所区别的：</p>
<ul>
<li><code>git clone</code>后，终归还是会有个<code>.git</code>目录，需要手动重置</li>
<li>degit在实现时增加了缓存策略，在有些情况下不需要重复下载代码，速度更快</li>
<li>“更少的字数”（<code>degit user/repo</code>而不是<code>git clone --depth 1 git@github.com:user/repo</code>）</li>
<li>灵活度更高，如前后置操作如actions的支持</li>
<li>更好的可扩展性，未来可以在degit基础上实现交互等更复杂的设计</li>
</ul>
<h2 id="degit原理"><a href="#degit原理" class="headerlink" title="degit原理"></a>degit原理</h2><p>那么degit快在哪里？它的思路借鉴于<a target="_blank" rel="noopener" href="https://github.com/vutran/zel">zel</a>和<a target="_blank" rel="noopener" href="https://github.com/lukeed/gittar">gittar</a>，即方便快捷地从git仓库中下载需要的源代码。原理上，<strong>利用某些git平台url的特定规则，从平台下载tar.gz包，再本地解压</strong>。</p>
<p>degit实现集中在<code>src/index.js</code>中。<code>src/bin.js</code>只用来实现cli部分的入口代码，<code>src/utils.js</code>则包含了一些工具函数。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>在<code>src/bin.js</code>中，流程分下面几步：</p>
<ol>
<li>利用<a target="_blank" rel="noopener" href="https://github.com/lukeed/mri">mri</a>做了基本的参数处理</li>
<li>实例化Degit对象，注册logger的监听方法</li>
<li>调用<code>clone</code>方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = <span class="title function_">degit</span>(src, args);</span><br><span class="line"></span><br><span class="line">    d.<span class="title function_">on</span>(<span class="string">&#x27;info&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(chalk.<span class="title function_">cyan</span>(<span class="string">`&gt; <span class="subst">$&#123;event.message.replace(<span class="string">&#x27;options.&#x27;</span>, <span class="string">&#x27;--&#x27;</span>)&#125;</span>`</span>));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    d.<span class="title function_">on</span>(<span class="string">&#x27;warn&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">            chalk.<span class="title function_">magenta</span>(<span class="string">`! <span class="subst">$&#123;event.message.replace(<span class="string">&#x27;options.&#x27;</span>, <span class="string">&#x27;--&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    d.<span class="title function_">clone</span>(dest)</span><br><span class="line">        <span class="comment">// .then(() =&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(chalk.<span class="title function_">red</span>(<span class="string">`! <span class="subst">$&#123;err.message.replace(<span class="string">&#x27;options.&#x27;</span>, <span class="string">&#x27;--&#x27;</span>)&#125;</span>`</span>));</span><br><span class="line">            process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Degit初始化"><a href="#Degit初始化" class="headerlink" title="Degit初始化"></a>Degit初始化</h3><p>对象实例包含下面几个成员，其中repo信息需要处理后才能拿到。</p>
<ul>
<li><code>src</code>，string，用户输入的仓库地址</li>
<li><code>cache</code>，boolean，是否使用缓存，来自命令行<code>-c</code>或<code>--cache</code>参数</li>
<li><code>force</code>，boolean，目标文件夹有内容时，是否覆盖，来自<code>-f</code>或<code>--force</code>参数</li>
<li><code>verbose</code>，boolean，是否打印详细日志，来自<code>-v</code>或<code>--verbose</code>参数</li>
<li><code>repo</code>，处理<code>src</code>拿到仓库的详情，包括<ul>
<li><code>site</code>，网页域名</li>
<li><code>user</code>，用户&#x2F;组织名</li>
<li><code>name</code>，仓库名</li>
<li><code>ref</code>，分支、tag、commit hash</li>
<li><code>url</code>，完整的HTTP url</li>
</ul>
</li>
<li><code>directiveActions</code>，actions配置对应的处理函数，包含<ul>
<li><code>clone</code>，递归处理src的仓库</li>
<li><code>remove</code>，调用<code>remove</code>方法移除指定文件</li>
</ul>
</li>
</ul>
<p>repo信息来自src经过正则匹配出的详细信息。由于要利用一些git平台的url拼接规则，需要排除已知平台以外的url。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持的范围</span></span><br><span class="line"><span class="keyword">const</span> supported = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;github&#x27;</span>, <span class="string">&#x27;gitlab&#x27;</span>, <span class="string">&#x27;bitbucket&#x27;</span>, <span class="string">&#x27;git.sr.ht&#x27;</span>]);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">src</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> match = <span class="regexp">/^(?:https:\/\/([^/]+)\/|git@([^/]+)[:/]|([^/]+)[:/])?([^/\s]+)\/([^/\s#]+)(?:#(.+))?/</span>.<span class="title function_">exec</span>(</span><br><span class="line">        src</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegitError</span>(<span class="string">`could not parse <span class="subst">$&#123;src&#125;</span>`</span>, &#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&#x27;BAD_SRC&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> site = (match[<span class="number">1</span>] || match[<span class="number">2</span>] || match[<span class="number">3</span>] || <span class="string">&#x27;github&#x27;</span>).<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/\.(com|org)$/</span>,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 排除范围外的url</span></span><br><span class="line">    <span class="keyword">if</span> (!supported.<span class="title function_">has</span>(site)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegitError</span>(</span><br><span class="line">            <span class="string">`degit supports GitHub, GitLab, Sourcehut and BitBucket`</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">code</span>: <span class="string">&#x27;UNSUPPORTED_HOST&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配出用户名、仓库名、分支/tag/commit hash名</span></span><br><span class="line">    <span class="keyword">const</span> user = match[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">const</span> name = match[<span class="number">5</span>].<span class="title function_">replace</span>(<span class="regexp">/\.git$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ref = match[<span class="number">6</span>] || <span class="string">&#x27;master&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完整的仓库地址，需要http开头的</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://<span class="subst">$&#123;site&#125;</span>.<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        site === <span class="string">&#x27;bitbucket&#x27;</span> ? <span class="string">&#x27;org&#x27;</span> : site === <span class="string">&#x27;git.sr.ht&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;com&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">    &#125;</span>/<span class="subst">$&#123;user&#125;</span>/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; site, user, name, ref, url &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仓库下载"><a href="#仓库下载" class="headerlink" title="仓库下载"></a>仓库下载</h3><p>下载仓库流程如下：</p>
<p><img src="https://s2.ax1x.com/2019/11/15/Mdbl6S.png" alt="degit流程"></p>
<h4 id="获取缓存信息"><a href="#获取缓存信息" class="headerlink" title="获取缓存信息"></a>获取缓存信息</h4><p>degit的缓存放在<code>/home</code>或<code>/tmp</code>下的<code>.degit</code>目录下，按照<code>site/user/name</code>的目录组织。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存目录</span></span><br><span class="line"><span class="keyword">const</span> base = path.<span class="title function_">join</span>(homeOrTmp, <span class="string">&#x27;.degit&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dir = path.<span class="title function_">join</span>(base, repo.<span class="property">site</span>, repo.<span class="property">user</span>, repo.<span class="property">name</span>);</span><br><span class="line"><span class="keyword">const</span> cached = <span class="title function_">tryRequire</span>(path.<span class="title function_">join</span>(dir, <span class="string">&#x27;map.json&#x27;</span>)) || &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>目录下有一个<code>map.json</code>和缓存的代码tar.gz包，包名格式为<code>&lt;commit-hash&gt;.tar.gz</code>。在map.json保存着此前使用过的分支名&#x2F;tag名&#x2F;简写commit名到commit hash的最新映射关系。形如下方：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;master&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4e3a4089b4f0275964eb10a432dc1c15526a0b4d&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这一步会尝试使用parse好的<code>site</code>、<code>user</code>、<code>name</code>属性找已有的缓存的<code>map.json</code>。没有找到时返回<code>&#123;&#125;</code>。</p>
<h4 id="获取commit-hash"><a href="#获取commit-hash" class="headerlink" title="获取commit hash"></a>获取commit hash</h4><p>这一步分两种情况;</p>
<ul>
<li>使用缓存时，直接从上一步拿到的<code>map.json</code>里面找<code>ref</code>对应的commit hash</li>
<li>不使用缓存时，需要从远端仓库拿分支名&#x2F;tag名到commit hash的对应关系（使用<code>git ls-remote</code>完成）。之后格式化为结构化数据并从中寻找<code>ref</code>对应的commit hash。如果中途失败，则fallback到使用缓存的方式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchRefs</span>(<span class="params">repo</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; stdout &#125; = <span class="keyword">await</span> <span class="title function_">exec</span>(<span class="string">`git ls-remote <span class="subst">$&#123;repo.url&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stdout</span><br><span class="line">            .<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            .<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line">            .<span class="title function_">map</span>(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> [hash, ref] = row.<span class="title function_">split</span>(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 格式化过程</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步若未找到hash，则无法构造下载的url，从而需要抛出错误。</p>
<h4 id="构造下载地址"><a href="#构造下载地址" class="headerlink" title="构造下载地址"></a>构造下载地址</h4><p>根据不同的git平台固定的源码tar.gz归档url规则，构造下载的url，这也是degit思路的基础。目前支持gitlab、bucket、github风格的url。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即将下载的tar.gz文件路径</span></span><br><span class="line"><span class="keyword">const</span> file = <span class="string">`<span class="subst">$&#123;dir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>.tar.gz`</span>;</span><br><span class="line"><span class="comment">// 下载的url</span></span><br><span class="line"><span class="keyword">const</span> url =</span><br><span class="line">    repo.<span class="property">site</span> === <span class="string">&#x27;gitlab&#x27;</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/repository/archive.tar.gz?ref=<span class="subst">$&#123;hash&#125;</span>`</span></span><br><span class="line">        : repo.<span class="property">site</span> === <span class="string">&#x27;bitbucket&#x27;</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/get/<span class="subst">$&#123;hash&#125;</span>.tar.gz`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/archive/<span class="subst">$&#123;hash&#125;</span>.tar.gz`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建目录并下载"><a href="#创建目录并下载" class="headerlink" title="创建目录并下载"></a>创建目录并下载</h4><p>不使用缓存时，会在创建缓存目录并下载。另外，指定<code>-f</code>或<code>--force</code>参数，会覆盖已有文件路径。最后使用https模块下载文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fs.<span class="title function_">statSync</span>(file);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">mkdirp</span>(path.<span class="title function_">dirname</span>(file));</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fetch</span>(url, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h4><p>下载成功会更新本地缓存，保证以后使用缓存时能使用尽量新的包。</p>
<ol>
<li>当前使用包的commit hash如果和指定分支&#x2F;tag&#x2F;commit hash对应的hash一致，则不需要更新</li>
<li>在需要更新时，检查老的hash是否还有使用，如果没有使用，则清除hash对应的tar.gz包</li>
<li>更新map.json里的对应关系</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateCache</span>(<span class="params">dir, repo, hash, cached</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cached[repo.<span class="property">ref</span>] === hash) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldHash = cached[repo.<span class="property">ref</span>];</span><br><span class="line">    <span class="keyword">if</span> (oldHash) &#123;</span><br><span class="line">        <span class="keyword">let</span> used = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cached[key] === hash) &#123;</span><br><span class="line">                used = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">            <span class="comment">// we no longer need this tar file</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fs.<span class="title function_">unlinkSync</span>(path.<span class="title function_">join</span>(dir, <span class="string">`<span class="subst">$&#123;oldHash&#125;</span>.tar.gz`</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cached[repo.<span class="property">ref</span>] = hash;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(</span><br><span class="line">        path.<span class="title function_">join</span>(dir, <span class="string">&#x27;map.json&#x27;</span>),</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(cached, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解压tar-gz包"><a href="#解压tar-gz包" class="headerlink" title="解压tar.gz包"></a>解压tar.gz包</h4><p>创建cli中输入的目标目录，并将已下载到缓存中tar.gz包解压到目标路径下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mkdirp</span>(dest);</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">untar</span>(file, dest);</span><br></pre></td></tr></table></figure>

<h4 id="actions处理"><a href="#actions处理" class="headerlink" title="actions处理"></a><code>actions</code>处理</h4><p>如果在当前目录下获取到了<code>degit.json</code>，则执行后续的<code>clone</code>或<code>remove</code>操作。</p>
<ul>
<li>clone，在目标目录下继续一遍clone流程</li>
<li>remove，删除指定文件或文件夹</li>
</ul>
<h2 id="degit改造"><a href="#degit改造" class="headerlink" title="degit改造"></a>degit改造</h2><p>degit虽好，但从上面也可以看到，支持仓库比较有限，且不支持私有仓库。在公司内部，无法从url推断git仓库类型时，degit就无法工作了。不过，借助degit本身的设计，稍微改造上面提到的“degit初始化”，“构造下载地址”部分，就可以让degit通过传参url风格的形式支持私有仓库。</p>
<ul>
<li>新增<code>-s</code>或<code>--style</code>命令行入参，表示git仓库url的风格，目前设计有github、gitlab、bitbucket这几个degit原始就支持的形式。</li>
<li>解析仓库地址信息时，若有style入参，则先判断是否在上述允许范围内；保留原有从域名解析style的部分，新增若未解析出style，则从入参里取；最后再抛出不支持的仓库地址错误</li>
<li>解析返回数据结构中，新增<code>style</code>字段表示url风格，原有的<code>site</code>为避免歧义，直接使用域名代替原有的域名前缀</li>
<li>在构造下载地址时，直接根据style字段拼接url</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">src, style</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (style &amp;&amp; !supportedGitStyle.<span class="title function_">has</span>(style)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegitError</span>(<span class="string">`degit supports styles of github, gitlab, bitbucket`</span>, &#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&#x27;UNSUPPORTED_STYLE&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> site = match[<span class="number">1</span>] || match[<span class="number">2</span>] || match[<span class="number">3</span>] || <span class="string">&#x27;github.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> gitStyle =</span><br><span class="line">        style ||</span><br><span class="line">        (match[<span class="number">1</span>] || match[<span class="number">2</span>] || match[<span class="number">3</span>] || <span class="string">&#x27;gitlab&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/\.(com|org)$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!supportedGitRepo.<span class="title function_">has</span>(gitStyle)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegitError</span>(</span><br><span class="line">            <span class="string">`degit supports GitHub, GitLab, Sourcehut and BitBucket without -s/--style parameters`</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">code</span>: <span class="string">&#x27;UNSUPPORTED_HOST&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = match[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">const</span> name = match[<span class="number">5</span>].<span class="title function_">replace</span>(<span class="regexp">/\.git$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ref = match[<span class="number">6</span>] || <span class="string">&#x27;master&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://<span class="subst">$&#123;site&#125;</span>/<span class="subst">$&#123;user&#125;</span>/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; site, user, name, ref, url, <span class="attr">style</span>: gitStyle &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接url处</span></span><br><span class="line"><span class="keyword">const</span> url =</span><br><span class="line">    repo.<span class="property">style</span> === <span class="string">&#x27;gitlab&#x27;</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/repository/archive.tar.gz?ref=<span class="subst">$&#123;hash&#125;</span>`</span></span><br><span class="line">        : repo.<span class="property">style</span> === <span class="string">&#x27;bitbucket&#x27;</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/get/<span class="subst">$&#123;hash&#125;</span>.tar.gz`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;repo.url&#125;</span>/archive/<span class="subst">$&#123;hash&#125;</span>.tar.gz`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><p>绝大多数私有仓库，都会对用户身份做校验，直接访问tar.gz链接会报401错误。这需要根据不同的内部平台自己做处理了。</p>
<p>因为特殊原因，改造后的包和代码不提供。</p>
<p><em>–END–</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/11/02/social-psychology-part-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/02/social-psychology-part-4/" class="post-title-link" itemprop="url">社会心理学 Part 4 - 应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-02 21:48:37" itemprop="dateCreated datePublished" datetime="2019-11-02T21:48:37+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-15 22:26:05" itemprop="dateModified" datetime="2019-11-15T22:26:05+08:00">2019-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/11/02/social-psychology-part-4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/02/social-psychology-part-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/07/26/social-psychology-part-1/">社会心理学 Part 1 - 导论 &amp; 社会思维</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/08/07/social-psychology-part-2/">社会心理学 Part 2 - 社会影响</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/09/24/social-psychology-part-3/">社会心理学 Part 3 - 社会关系</a></p>
</blockquote>
<h2 id="临床领域的应用"><a href="#临床领域的应用" class="headerlink" title="临床领域的应用"></a>临床领域的应用</h2><p>有时候你会遭遇生活中不顺的事情，这时<em>关注自我的焦虑会让你的情绪更加糟糕</em>。临床心理学将社会心理学一些概念和社会中实际应用连接起来。</p>
<h3 id="临床诊断的误差"><a href="#临床诊断的误差" class="headerlink" title="临床诊断的误差"></a>临床诊断的误差</h3><p>与非临床心理学家相比，临床心理学家更欢迎依赖于感受而非公式、统计分析的认识方式。<em>临床诊断</em>也是社会决策的一种，所以也会受到之前提到的错觉影响。我们需要提前了解可能导致错误印象的原因，以避免严重的误诊。</p>
<ul>
<li><strong>相关错觉</strong>，当研究领域难以做到定量时，就容易形成假相关性。查普曼等人的实验发现，假如学生或心理学家<strong>期望</strong>得到一种相关，那么他们大多数能得到这种相关。</li>
<li><strong>事后聪明和过分自信</strong>，人们在先入为主时很容易陷入过分自信，另外人们很容易从结论倒推到线索，形成事后聪明；事先知道某人自杀的被试更倾向于从材料中<em>预见到</em>他的自杀行为。</li>
<li><strong>自我证实的诊断</strong>，由于临床心理健康工作者可以自由选择询问问题，人们也往往会提供符合临床医生期望的信息。斯奈德和斯旺发现，人们总是寻找能够验证某一特质的信息来做测验，当面对一堆结构化的题目可以选择时，即使是最有经验的心理治疗师，在测验被试是否外向时，也会倾向于选择那些更容易引起外向行为的问题。</li>
<li><strong>统计预测优于临床预测</strong>。面试就是一个例子。在能进行访谈的情况下，临床心理学家的预测会更为差劲。对此的一个解释是，<em>我们高估了自己的认知能力</em>。</li>
</ul>
<p>要避免上面的误区就要相信数据，依赖于记录而非记忆，结合科学方法来验证假设——系统的观察和实验。</p>
<h3 id="心理问题"><a href="#心理问题" class="headerlink" title="心理问题"></a>心理问题</h3><h4 id="抑郁"><a href="#抑郁" class="headerlink" title="抑郁"></a>抑郁</h4><p>Alloy和Abramson的实验发现，抑郁的学生能准确地认识自己的控制程度。这种<strong>抑郁现实主义</strong>似乎说明，普通人往往夸大自己的能力和受欢迎程度，抑郁的人则有更清醒的认识，他们身份并没有体现出普通人的过分利己、控制错觉、对未来的不现实预期。良好的心理健康状况，正是建立在能把事情看得比实际好一些，并能在黯淡的现实中看到光明的能力上。</p>
<p>抑郁还体现在<strong>消极的解释风格</strong>，抑郁的人更倾向于将失败和挫折的原因归结为<strong>稳定的</strong>、<strong>普遍的</strong>和<strong>内在的</strong>。抑郁心境带来负面思维，负面思维又可以导致抑郁心境，形成恶性循环。有时这种负面思维可以使我们在面对未来生活时采用更好的策略，而抑郁倾向的人则总是自我关注的反思和自责。</p>
<p>压力导致的思虑受到消极归因的过滤和影响，很容易导致抑郁，有消极归因风格的人更容易在遇到不好的事情是变得抑郁。相反，当人们不那么关注自己而是将注意力集中在自身外的事情上时，会更容易得到快乐。抑郁是负性认知的原因和结果。</p>
<h4 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h4><p>孤独不等于孤单。感到孤独是感到被一个群体排斥、不被周围人喜欢、不能分享自身感受、与周围环境格格不入。男性更容易在被群体孤立时感到孤独，女性则是在被剥夺了一段亲密关系后更容易感到孤独。这似乎也验证了，男性的关系往往是<strong>肩并肩</strong>的，而女性的关系往往是<strong>面对面</strong>的。</p>
<p>孤独更容易让人产生负面认知，由于自我表露困难，他们蔑视自我表露太快太多的人，他们往往过度敏感，而且自尊较低。与不孤独的人相比，他们在和陌生人聊天时，更多谈论自己的事情而很少关心谈话对象的情况。</p>
<h4 id="焦虑"><a href="#焦虑" class="headerlink" title="焦虑"></a>焦虑</h4><p>社会焦虑，即<em>当我们想给他人留下好印象，但又怀疑自己能否做到的时候，我们就会感到焦虑</em>。比如：</p>
<ul>
<li>和身居高位的人交往</li>
<li>在一个评价场景下</li>
<li>过分敏感</li>
<li>身处一个新奇的没有概念的情境中，对社交规则并不熟悉</li>
</ul>
<p>这种情形下的自然倾向就是小心翼翼的自我保护：谨言慎行，不过分自信，和善且保持微笑。害羞是一种以过度敏感和担心别人想法为特征的社会焦虑。这种倾向的极端就是偏执狂，他们常常高估了其他人对自己的关注和评价程度。</p>
<p>为了减少这种社会焦虑，有些人会求助于酒精，通过酒精降低自我意识而达到减轻焦虑的效果。酒精滥用和焦虑也可以具有自我保护的功能，为自己贴上焦虑、害羞、酗酒的标签，就能为失败提供借口。但如果我们给害羞的人提供另一种更为方便地解释他们焦虑和失败的说法，他们就很可能放弃上面那种策略，从而变得不再害羞。</p>
<h4 id="疾病"><a href="#疾病" class="headerlink" title="疾病"></a>疾病</h4><p>在工业时代。至少一半的死亡和行为联系在一起。</p>
<p><strong>对疾病的反应</strong></p>
<ul>
<li>一旦发现症状，我们通常会用熟悉的疾病模式去解释，医科学生有时候会把病人的症状归结为最近学习的疾病模式</li>
<li>有些疾病是<strong>社会性构造</strong>的，如女性在经期前两三天，会更多感受到抑郁、紧张和易怒。实际上，这些感受会时常出现，但在生理周期临近时，就会被归结为经前综合征（PMS）。那些<strong>回忆</strong>自己经前情绪不佳的女性，在以记录的每日报告中并未表现出和其他时候的差别</li>
<li>人们认为症状来自于身体而不是心理时，他们会更愿意寻求治疗。女性比男性更多地报告症状，一方面她们对自己的内在状况更关注，另一方面，她们更愿意承认自己是软弱的，并寻求帮助</li>
<li>医生为病人开出的治疗方案更易理解时，病人更愿意接受治疗指示。如有40%存活几率就比有60%不能存活几率要更容易被接受</li>
</ul>
<p><strong>情绪与疾病</strong></p>
<p>心脏病和一种好斗的、缺乏耐心的以及易怒（很重要的一点）的人格相关联。消极情绪导致了慢性病人中抑郁和焦虑的高发率。</p>
<p>习得性无助的动物反应更消极，血液中检查表现出免疫反应更低。同样地，经受高度压力体验的人更易患病。</p>
<p>乐观主义者——那些对好事有稳定、普遍、内在解释的人通常比悲观主义者活得长。健康行为——运动、良好的营养条件、不酗酒都是促进乐观主义者长寿的基本因素。有研究者相信，积极的、充满希望的归因放个是一剂良药，著名的<strong>安慰剂效应</strong>就是一个应用（你认为一种治疗会起作用，那么它就会起作用）。</p>
<h3 id="社会心理治疗"><a href="#社会心理治疗" class="headerlink" title="社会心理治疗"></a>社会心理治疗</h3><p>社会心理学的治疗是不存在的，有的是利用社会心理学原则的现有治疗技术。下面是一些例子。</p>
<h4 id="外显行为引发内在变化"><a href="#外显行为引发内在变化" class="headerlink" title="外显行为引发内在变化"></a>外显行为引发内在变化</h4><p>态度来源于行为。我们即使不能通过意志力控制我们的感情，也能够通过行为来间接影响它。实验发现，我们说过的有关自己的话，能够影响我们的感觉，被实验者引导写自我赞美散文的被试表现出了更高的自尊。</p>
<p>对选择的知觉也很重要，被提醒是自愿选择减肥计划的儿童，表现出更高的责任感，也获得了更好的减肥效果。</p>
<h4 id="打破恶性循环"><a href="#打破恶性循环" class="headerlink" title="打破恶性循环"></a>打破恶性循环</h4><p>通过改变环境，训练个体更加积极的行为方式，转变消极思维，可以改善抑郁、孤独、社会性焦虑等等情况。</p>
<ul>
<li><strong>社会技能训练</strong>让个体可以在安全情境下练习新的行为，随着个体开始享受应对自如的好处，一个更加积极的自我知觉就可以形成。在人们在被引导下做出改变，他们才会倾向于归因于<em>自己的努力</em>而非他人的帮助，从而认可自己是有社会能力的。而这是咨询做不到的。</li>
<li>有些情况下，人们拥有社会技能，但是身边吹毛求疵的人是他们认为没有。<strong>解释风格疗法</strong>帮助他们通过每日记录，将成功的一部分归因于内在，失败的一部分归因于外在，从而利用改变归因改善了他们的消极情绪</li>
</ul>
<h4 id="利用内在归因"><a href="#利用内在归因" class="headerlink" title="利用内在归因"></a>利用内在归因</h4><p>一旦人们有所提高，将其归因于<strong>受自己控制</strong>的因素而非外在时，效果最为持久。相反，强制性手段会引发最强烈和迅速的行为改变，但是随着强制性手段消失，改变也会很快消失。</p>
<p>在一个减肥计划的实验中，被要求将饮食计划归因于自己的一组在减肥后保持了减肥效果。因为他们<strong>相信自己做到了</strong>。</p>
<h4 id="利用社会影响"><a href="#利用社会影响" class="headerlink" title="利用社会影响"></a>利用社会影响</h4><p>使用周到的<strong>中心途径</strong>提供更持久的态度和行为转变（说服）。因此，在治疗中，不要引起病人对专家表面上的同意，而是要改变病人自己的思维。治疗师的任务只是提供意见，给出有说服力的论证，并提出适当的问题来引导积极有利的想法。</p>
<p>引用哲学家帕斯卡在1620年《思想录》中的一句话：</p>
<blockquote>
<p>人们通常对他们自己发现的道理，比由别人发现的更加深信不疑</p>
</blockquote>
<h3 id="社会关系促进心理健康"><a href="#社会关系促进心理健康" class="headerlink" title="社会关系促进心理健康"></a>社会关系促进心理健康</h3><p>亲密关系会更多带来健康和幸福，而不是疾病。</p>
<p>亲密关系可以预测健康，那些给予最多社会支持的人寿命更长。这么来看，付出比仅仅是索取对自己更好。相反失去人际纽带则会增大患病可能性。在超过80个研究中，心血管及免疫系统的良好运行和社会支持呈现正相关。因此当我们遇到不快乐的事情时，朋友的建议、帮助、安慰的确是一剂良药。积极应对相比抑制情感，更有助于避开疾病风险。</p>
<p>贫困和收入不平等的地区，人们的寿命也相对较短。</p>
<p>除了健康，亲密关系也会带来幸福感。在个人主义国家中，那些报告集体主义倾向的人幸福感也相对较高。友谊和婚姻都能促进幸福感。大量的研究结果证明，大多数有依恋关系的人比没有的人更为幸福。已婚者报告感到更幸福，对生活的满意度也更高。当然，与是否结婚相比，更重要的是婚姻质量，幸运的是，大部分的已婚者婚姻是幸福的。</p>
<p>为什么已婚的人普遍更加幸福？一方面，已婚者更可能享受一种<strong>持久的、支持性的、亲密的人际关系</strong>，且更少感到孤独；另一方面，婚姻提供了配偶和伴侣的角色，这可以提供<strong>自尊的额外来源</strong>。举例，当工作失败时，我们还可以认为自己是一个好丈夫和一个好父亲。</p>
<p>提升幸福感有些可以考虑的地方：</p>
<ul>
<li><strong>控制你的时间</strong>，幸福的人感觉到他们能掌控自己的生命，这从他们对时间的掌握开始</li>
<li><strong>寻找合适的工作和休闲，发挥你的技能</strong></li>
<li>参加运动，获得健康身体</li>
<li><strong>保证充足睡眠</strong>，从而获得积极和精力旺盛的生活</li>
<li><strong>优先考虑亲密的人际关系</strong>，同时也要珍视这样的关系，不要认为他们对你好是理所当然</li>
<li><strong>关注自我以外的事</strong>，向需要帮助的人伸出援手</li>
<li>照顾自己的<strong>精神自我</strong></li>
</ul>
<h2 id="司法领域的应用"><a href="#司法领域的应用" class="headerlink" title="司法领域的应用"></a>司法领域的应用</h2><h3 id="目击者的证词可靠吗"><a href="#目击者的证词可靠吗" class="headerlink" title="目击者的证词可靠吗"></a>目击者的证词可靠吗</h3><p>证词的说服力受到生动性影响。</p>
<ul>
<li>生动的轶事和个人证词往往比强有力、抽象的信息更有说服力。实际上，目击者的生动解释很难被从陪审员的脑中抹除。</li>
<li>但是，目击者描述的生动并不代表描述的正确性。甚至有时，对细节描述较差的目击者反而能提供最准确的信息。</li>
</ul>
<p>目击者证词并不总是正确的，在研究中证实，目击者常因过于自信而有失准确。而这种自信让陪审员觉得证词更可靠。除非条件非常合适，最烦外貌特征非常显著，否则目击者确信程度和证词准确性只有中等程度相关。毕竟人眼不是摄像机，在视角、表情、光线上的细微差别人是不易察觉到的；同时，我们的记忆也是我们当时所知觉到的，一部分是基于我们的预期、看法和当前知识。</p>
<p>另外，在<strong>误导信息</strong>影响下，目击者可以回忆起错误的过去，并坚信记忆是真实的。<strong>重述</strong>也能使人们更容易相信回忆起来的东西，如接受了被告律师采访后，目击者给法官的证词更偏向被告。</p>
<p>人的记忆是不准确的，给予目击者证词的不同反馈，也会影响之后目击者的认识和证词。</p>
<h4 id="提高证词准确性"><a href="#提高证词准确性" class="headerlink" title="提高证词准确性"></a>提高证词准确性</h4><ul>
<li>开放式、没有立场的答案很简单的问题</li>
<li>充足的不受打断的时间回想</li>
<li><strong>准确的辨识总是自动的涌现的不太费力的</strong></li>
<li>在列队指认时明确他们看到的人可能在、也可能不在这个队列里，让目击者一次只看一个人，只给出“是”或“不是”这样简单的回答</li>
<li>使用上面的经验训练陪审团</li>
</ul>
<h3 id="影响陪审团判断的因素"><a href="#影响陪审团判断的因素" class="headerlink" title="影响陪审团判断的因素"></a>影响陪审团判断的因素</h3><p>陪审团能撇开偏见，以事实为根据，达成一致的判决。此时，事实起决定性作用。但是在做<em>社会决策</em>时，如被告是否有意犯罪，就会受到其他因素影响。</p>
<h4 id="被告特征"><a href="#被告特征" class="headerlink" title="被告特征"></a>被告特征</h4><ul>
<li>地位较高的被告常得到更为宽大的处理</li>
<li>漂亮的人们看起来更像好人</li>
<li><strong>在证据不足或很模糊时</strong>，审判会受到被告外表的影响。如果被定罪，没有吸引力的人使人们觉得更加危险，特别是性侵犯案件</li>
<li>和陪审团的相似性会带来好感，从而激发陪审团的同情心</li>
</ul>
<h4 id="法官指示"><a href="#法官指示" class="headerlink" title="法官指示"></a>法官指示</h4><ul>
<li>法官给陪审团的提示可能并不会达到预期效果，如提醒陪审团忽略不被允许的证据，如被告此前的负面事件。即使陪审员事先发誓保证公正性也不能避免这种影响。</li>
<li>有时，法官的声明反而会造成陪审员的逆反。</li>
</ul>
<p>所以法官通常会<strong>事先提醒</strong>陪审团注意某些特定类型的证据是无关的。</p>
<h3 id="陪审员个体如何受影响"><a href="#陪审员个体如何受影响" class="headerlink" title="陪审员个体如何受影响"></a>陪审员个体如何受影响</h3><h4 id="陪审员的理解"><a href="#陪审员的理解" class="headerlink" title="陪审员的理解"></a>陪审员的理解</h4><ul>
<li>律师以叙事这样生动的形式展示证据时，陪审员最易被说服</li>
<li>法官给予的标准法律术语可能并不能让陪审员理解，从而易走说服外部途径的人容易感情用事，做出过早的判断</li>
<li>陪审员对统计信息意义的理解有限</li>
</ul>
<h4 id="陪审团的选择"><a href="#陪审团的选择" class="headerlink" title="陪审团的选择"></a>陪审团的选择</h4><ul>
<li>审讯律师可以通过排除对自己委托人有偏见的陪审员获得令人满意的审判结果。不过，正如全书最开始提到，态度和个人特征也并不总能预测判决</li>
<li>陪审员公开做公正誓言和法官促使其公正的指示，都可以使绝大多数陪审员遵循公正准则</li>
<li>只有证据模糊时，陪审员的个性和总体态度才产生影响</li>
</ul>
<h4 id="“死刑认定”陪审员"><a href="#“死刑认定”陪审员" class="headerlink" title="“死刑认定”陪审员"></a>“死刑认定”陪审员</h4><p>倾向于死刑定罪的陪审员往往更加专断——更加严厉和具有惩罚性，无视可以减轻罪责的情况，对社会底层的人也更加傲慢。</p>
<h3 id="群体因素对陪审员的影响"><a href="#群体因素对陪审员的影响" class="headerlink" title="群体因素对陪审员的影响"></a>群体因素对陪审员的影响</h3><p>群体影响在陪审团中起着作用。群体裁决通常是最初被至少2&#x2F;3陪审员支持的选择。没有达到时，陪审团往往会悬置不决。</p>
<p>但少数派影响也是存在的。如果占少数的陪审员能够保持一致，坚持不懈，信心十足，他们将最有说服力，特别是在成功引起倒戈时。社会地位高的男性陪审员往往是其中最具有影响力的。另外，支持无罪的少数派会比支持顶嘴的少数派拥有更多成功机会。</p>
<p>受到群体极化影响，高专断小组在最初建议建立惩罚时，商议后会更为严厉；相反，低专断小组商议后会更加宽大。</p>
<h2 id="社会心理学和可持续发展的未来"><a href="#社会心理学和可持续发展的未来" class="headerlink" title="社会心理学和可持续发展的未来"></a>社会心理学和可持续发展的未来</h2><h3 id="全球危机"><a href="#全球危机" class="headerlink" title="全球危机"></a>全球危机</h3><p>人口爆炸、工业化导致的生态恶化带来全球危机，促使我们需要选择可持续发展的生活方式：</p>
<ul>
<li>提高科技效率和农业生产率，发展生态科技</li>
<li>控制消费和人口数量，以公共利益取代走向极端的个人主义和物质主义。倡导公共的思维方式，鼓励学校个性化教育</li>
</ul>
<h3 id="物质主义和财富"><a href="#物质主义和财富" class="headerlink" title="物质主义和财富"></a>物质主义和财富</h3><p>我们大多数人都认为财富和幸福之间必然存在着某种联系。的确，当人们感到不确定、不安全和贫困时，物质主义，即崇尚金钱和财富的观念会比较流行。缺乏安全感时，人们在得到一些新的占有物时常常能获得暂时的情绪提升。70年代以来，物质主义日益膨胀，精神信仰在日益消退。</p>
<p>然而幸福感和财富并不是严格挂钩的：</p>
<ul>
<li>发达国家中会有更多感到满意的人，但是人均GDP超过8000美元的国家中，国家财富和幸福感之间的关系就不存在了</li>
<li>对于富有的人，金钱既可以增加快乐也可以减少快乐</li>
<li>个人<strong>持久</strong>的幸福感并不随个人财富增多而增强。发达国家的经济增长并没有带来明显的民众信心提高</li>
</ul>
<h4 id="为何物质主义不能让人满意"><a href="#为何物质主义不能让人满意" class="headerlink" title="为何物质主义不能让人满意"></a>为何物质主义不能让人满意</h4><p>越是为财富努力奋斗的人体幸福感越低，转而<strong>追求亲密感，个人成长和为社会事业奋斗的人会体验更高质量的生活</strong>。为什么更优越的物质条件没有让我们更快乐呢？有两个主要原因。</p>
<p>一是<strong>人类的适应能力</strong>，第一章中提到，我们通常会<strong>低估</strong>自己的适应能力。<strong>适应水平现象</strong>意味着成功和失败，满意和不满都是相对于当下状态而言的。如果我们不断成功，我们会很快适应成功，以前的良好事件现在会变成中性事件，以前的中性事件现在让人感到失落。Brickman和Campbell指出，“当我们沉浸在某总成就带来的满足感时，它会迅速消退，并以一种冷漠感和更高的努力程度取代”。</p>
<blockquote>
<p>支出增长以适应收入增长 —— 帕金森第二定律</p>
</blockquote>
<p>另一个是<strong>社会比较</strong>的广泛存在。就像高考和大学志愿一样，人类的判断是由比较得出的。我们感觉到的好坏也依赖于我们和谁比较。所以说，社会贫富差距较小时，收入更均等，身边没有人明显超过自己，人民幸福感会得到提升。<strong>向上社会比较</strong>又会带来相对剥夺，从而让人一直处于不满意的状态。</p>
<h3 id="社会心理学给予的帮助"><a href="#社会心理学给予的帮助" class="headerlink" title="社会心理学给予的帮助"></a>社会心理学给予的帮助</h3><ul>
<li>调整适应，正确认识社会比较，有时可以<strong>向下社会比较</strong></li>
<li><strong>后物质主义</strong>逐渐显露，新一代人开始成熟起来，对人际关系、自然平衡的关注在逐渐增加。当今社会中出现了两大潮流：寻找精神港湾和更深入和有意义的追求。</li>
<li>用行动提高生活质量<ul>
<li>亲密、支持性的关系</li>
<li>团体信仰</li>
<li>积极的特质</li>
<li>集中精力（投入精神）于热爱的事业或兴趣</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/09/24/social-psychology-part-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/09/24/social-psychology-part-3/" class="post-title-link" itemprop="url">社会心理学 Part 3 - 社会关系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-24 22:56:20" itemprop="dateCreated datePublished" datetime="2019-09-24T22:56:20+08:00">2019-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-02 21:49:04" itemprop="dateModified" datetime="2019-11-02T21:49:04+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/09/24/social-psychology-part-3/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/24/social-psychology-part-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/07/26/social-psychology-part-1/">社会心理学 Part 1 - 导论 &amp; 社会思维</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/07/26/social-psychology-part-2/">社会心理学 Part 2 - 社会影响</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/11/02/social-psychology-part-4/">社会心理学 Part 4 - 应用</a></p>
</blockquote>
<p>这部分主要讨论社会中个体是如何联系的。</p>
<h2 id="偏见"><a href="#偏见" class="headerlink" title="偏见"></a>偏见</h2><p><em>人们对于肥胖者就有明显的偏见：缺少魅力、不太聪明、不够成功、缺少修养。</em></p>
<h3 id="界定偏见"><a href="#界定偏见" class="headerlink" title="界定偏见"></a>界定偏见</h3><ul>
<li><strong>偏见</strong>即对一个群体及其个体成员预先的负面判断</li>
<li>它是一种<strong>态度</strong></li>
<li><strong>负面评价是偏见的标志</strong></li>
<li>它源于行为辩解的需要，或是负面的<strong>刻板印象</strong></li>
</ul>
<p>刻板印象是对人群先入为主的推测，比如南方人感性，北方人粗犷。本身反映了文化或生理对人群的一种期望，并无大碍。但刻板印象<em>过度概括</em>或明显错误时，就形成了偏见。<strong>偏见的行为表示称为歧视</strong>。歧视包括种族歧视、性别歧视等等。</p>
<h4 id="种族偏见"><a href="#种族偏见" class="headerlink" title="种族偏见"></a>种族偏见</h4><p>关于种族偏见有下面一些研究结果：</p>
<ul>
<li>多数人只能看到其他人身上的偏见</li>
<li><strong>人们在最亲密的社交领域会表现出最明显的偏见</strong>，如婚姻、看病。</li>
<li>种族偏见随着年代发展，文化多样性深入，逐渐由明面表示变成较难察觉的内隐态度。这些态度以一种潜意识的体现。</li>
<li>偏见有一些微妙的隐式表示，如过度的种族敏感性、对成功赞扬过度，对过失批评过度等</li>
</ul>
<h4 id="性别偏见"><a href="#性别偏见" class="headerlink" title="性别偏见"></a>性别偏见</h4><p>性别的刻板印象不仅持有印象的人有，<strong>刻板化群体成员也接受这种刻板印象</strong>。比如，视男性为领导者的刻板印象。刻板印象并不是偏见，只是为有的偏见提供支持。除了坏的刻板印象外，也有好的刻板印象。比如，<strong>大部分人更喜欢女性而非男性</strong>， 即<em>女性妙效应</em>。</p>
<p>类似种族偏见，性别偏见已由堂而皇之转为微妙的偏见。</p>
<h3 id="社会情境"><a href="#社会情境" class="headerlink" title="社会情境"></a>社会情境</h3><p>偏见的来源复杂，社会来源是一部分。</p>
<ul>
<li><strong>不平等的社会地位滋生偏见</strong>。偏见可以帮助有钱有势的人将其经济和社会特权合理化。我们敬重地位高的人具有的能力，同时也喜爱那些能欣然接受自己较低地位的人</li>
<li><strong>社会支配性取向</strong>会影响偏见的接受程度。社会支配性高（即控制欲强）的人乐于接受偏见，比如反对破坏阶级等级的政策</li>
<li>权威人格的人，在孩提时期往往经历过苛刻的规矩。这可能会导致他们压抑自己的敌意和冲动，并将之投射到外群体身上</li>
<li>调查发现，宗教和偏见的相关并不能得出因果关系</li>
<li>偏见在被社会接受后，会有许多人随着<em>从众</em>走上相同的道路</li>
<li>有些社会制度也在不知不觉支持着偏见。比如，杂志和报纸上的男性照片多数专注于面部，而女性则不到1&#x2F;3，因为面孔突出的人被认为更有智慧、抱负和主见。电影、电视上的形象能会强化盛行的文化态度。</li>
</ul>
<h3 id="动机根源"><a href="#动机根源" class="headerlink" title="动机根源"></a>动机根源</h3><h4 id="挫折与攻击：替罪羊理论"><a href="#挫折与攻击：替罪羊理论" class="headerlink" title="挫折与攻击：替罪羊理论"></a>挫折与攻击：替罪羊理论</h4><p><strong>我们遭遇挫折的原因令人胆怯或莫名其妙时，往往会转移敌对方向</strong>。因此，往往繁荣时期更容易维护民族和睦。现实群体冲突理论认为有同样需求的物种竞争将最大化。如，敌视黑人的偏见在经济地位和黑人最接近的拜仁身上最为强烈。</p>
<h4 id="社会同一性理论：感觉比他人优越"><a href="#社会同一性理论：感觉比他人优越" class="headerlink" title="社会同一性理论：感觉比他人优越"></a>社会同一性理论：感觉比他人优越</h4><p>我们在社会中的自我感觉不仅仅包含自己，还包含自己的社会群体。我们将自己和群体联系在一起获得自尊，将自己群体和其他群体比较，并偏爱自己的群体。即<strong>社会同一性</strong>。</p>
<p>人们具有<strong>内群性偏见</strong>，即群体内比群体外好。这也是人们寻求积极自我概念的一个表现形式。当我们群体规模较小、经济地位较低时，我们会更容易表现出内群性偏见。即便是毫无逻辑依据的群体意识，也能产生内群性偏见，比如掷硬币的正反。当我们的群体表现较好时，我们会更强烈地认同该群体，从而使自己感觉更好；相反在表现不好时，内群性偏见就不那么明显。</p>
<p>偏见本身就可以让人获得高人一等的感觉，这本身就是一种心理学收益。对比自尊没有受到威胁的被试，体验到挫折感的学生对自己学校的评价更高；被引发出不安感的被试，在评价他人工作时更加苛刻。甚至，<strong>思考自己的死亡问题</strong>也会引发人们足够的不安全感以强化<em>内群体偏好</em>和<em>外群体偏见</em>。自尊受到威胁时，人们会诋毁外群体，已恢复自尊和社会同一性。相反，一旦归属感得到满足，人们就会更为接纳外群体。</p>
<p>综上，那么怎么避免偏见的动机呢？</p>
<p>首先，深植于潜意识中的偏见没那么好压抑。但也并非完全无法避免，比如产生内疚感，从内在角度出发避免偏见。</p>
<h3 id="认知根源"><a href="#认知根源" class="headerlink" title="认知根源"></a>认知根源</h3><p>知觉错觉是我们解释世界技巧的副产品。刻板印象是我们简化复杂世界的副产品。</p>
<h4 id="类别化"><a href="#类别化" class="headerlink" title="类别化"></a>类别化</h4><p>我们简化环境的方法之一就是分类。刻板印象也是类别化的一种体现。实际场景中还有些因素让我们依赖刻板印象：</p>
<ul>
<li>时间紧迫</li>
<li>心事重重</li>
<li>疲惫不堪</li>
<li>情绪激昂</li>
<li>年轻气盛而无法欣赏多样性</li>
</ul>
<p>实际上，我们会借助一些典型特征对眼前的人<strong>自发类别化</strong>，如中年商人，知识分子等。偏见建立在分类的基础上。</p>
<p>在我们把人划分成群体时，有可能会夸大群体内部的一致性和群体间的差异性，即<strong>外群体同质效应</strong>。，比如从群体决策中高估一个群体的全体一致性。我们越是熟悉一个社会群体，就越能看到起内部的多样性。比如，<strong>与我们自己种族的人相比，其中种族的人看起来更为相像</strong>。</p>
<h4 id="独特性"><a href="#独特性" class="headerlink" title="独特性"></a>独特性</h4><p>具有<em>独特性的人</em>，身上的优点和缺点都会被夸大。吸引我们注意力的人，看似对所发生的一些具有更大的责任。除了注意到独特的人，人们也会关注的那些违背期望的人。</p>
<p>作为独特的人本身，我们有时会错误认为，他人对我们的反应是针对我们的独特性而来，从而曲解他人的行为方式。因此即使双方都是善意的，一个强势的人和一个弱势的人之间自我意识的相互作用也会令双方紧张。同时，人们的<strong>污名意识</strong>会提醒自己在多大程度预期他人对他们产生刻板印象。</p>
<p><em>独特的案例</em>也会加深刻板印象。人们倾向于从个别生动案例来作出概括。独特、极端的案例具有吸引注意力的的效果。因此我们的对一个群体了解越少，就越容易受到少数生动案例的影响。刻板印象假定群体成员和个人特征间存在某种相关性，这其中自然存在虚假相关。</p>
<h4 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h4><p>人们的归因错误也影响着偏见的形成。比如我们总是热衷于将人们的行为归因于他们的内在倾向，而较为忽略重要的情境力量。</p>
<p><strong>利群偏差</strong></p>
<p>我们倾向于关注内群体的积极行为和忽视外群体的。内群体成员的积极行为往往被描述成一种普遍品质，而外群体成员则常被描述成一个特定的、孤立的行为。这在强调谦虚的群体或地位较低的群体中会不那么明显。</p>
<p>责备受害者可以起到为指责者本人优越地位辩护的作用。责备的出现是因为人们把外群体的失败归结于群体成员的内在品性有问题。</p>
<p><strong>公正世界现象</strong></p>
<p>当观察者无力改变受害者命运时，他们就会否定和贬低受害者。公正世界现象即指人们认为“我是一个公正的人，生活在一个公正的世界，因此这个世界的人们得到的是他们应得的东西”（可怜之人必有可恨之处）。这样的认识使人们有贬低受害者的倾向。</p>
<h3 id="偏见的后果"><a href="#偏见的后果" class="headerlink" title="偏见的后果"></a>偏见的后果</h3><h4 id="长期保留的刻板印象"><a href="#长期保留的刻板印象" class="headerlink" title="长期保留的刻板印象"></a>长期保留的刻板印象</h4><p><strong>我们的预断会引导我们的注意、判断和记忆</strong>。在刻板印象形成后，如果群体成员行为验证了期望，则会加深印象；相反，我们会对特殊情况闪烁其词。在现实中的体现就是，你无论怎么努力都无法摆脱某人对你的评价，一旦某人<em>预期</em>和你见面不愉快时，误会就很可能发生。</p>
<p>同时，当群体中出现特殊个体不符合刻板印象时，我们会通过分出一个子类的方式来保证自身认识的自洽，即<strong>再分类法</strong>和<strong>再分群法</strong>。子类作为群体的一部分获得承认。</p>
<h4 id="自我实现的预言"><a href="#自我实现的预言" class="headerlink" title="自我实现的预言"></a>自我实现的预言</h4><p>社会信念会自我验证，偏见会对其对象产生影响，向自我实现的方向发展。</p>
<h4 id="刻板形象威胁"><a href="#刻板形象威胁" class="headerlink" title="刻板形象威胁"></a>刻板形象威胁</h4><p>他人的刻板印象会威胁到个体表现，从而进一步印证刻板印象。比如，在暗示女性“没头脑”的刻板印象后，其在数学等理科表现上会变差。相反，正面的刻板印象可以促进成绩。</p>
<h4 id="个体判断的偏差"><a href="#个体判断的偏差" class="headerlink" title="个体判断的偏差"></a>个体判断的偏差</h4><p>幸运的是，这种偏差有，但是<strong>人们在评价个体时，往往比评价个体构成的群体更为积极</strong>。因为往往群体成员琐碎但生动的信息效果上好于群体泛泛的信息。</p>
<p>不过<strong>强烈而且显然相关</strong>的刻板印象还是会影响我们对个体的判断。同时，刻板印象会影响我们对事件的解释，这在我们对某人的信息模棱两可时较为明显。</p>
<p>在人们的行为违背了我们的刻板印象时，人们会做出比较极端的评价。</p>
<h2 id="攻击行为"><a href="#攻击行为" class="headerlink" title="攻击行为"></a>攻击行为</h2><p>攻击行为即意图伤害他人的身体行为或言语行为。攻击行为按目的不同还可以分为两类：<strong>敌意性攻击行为</strong>由愤怒引起，以伤害为目的；<strong>工具性攻击行为</strong>只是把伤害作为达到其他目的的一种手段。</p>
<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="生物学"><a href="#生物学" class="headerlink" title="生物学"></a>生物学</h4><p><strong>本能论</strong>认为人类的攻击行为源自自我破坏的原始冲动，这种冲动运用到他人身上时，成为了攻击行为。<strong>进化心理学</strong>认为攻击行为对于获取资源、抵抗攻击、威吓甚至干掉情敌、防止配偶不忠都是一种有效的策略，可以帮助他们的基因得到更高的保留几率。</p>
<p><strong>遗传基因</strong>和<strong>神经系统</strong>都对攻击行为有影响作用。另外，生物化学因素也会有影响，如激素和酒精。睾丸激素可以刺激人的攻击行为，神经递质5-羟色胺可以控制冲动，缺乏5-羟色胺的人群自我约束力较低，更愿意承担风险。</p>
<h4 id="挫折-攻击理论"><a href="#挫折-攻击理论" class="headerlink" title="挫折-攻击理论"></a>挫折-攻击理论</h4><p>最早对攻击行为的心理学解释理论是<strong>挫折——攻击理论</strong>，即挫折总会导致某种形式的攻击行为。而攻击能量并非总是朝向挫折源，当对方会表示反对或惩罚时，我们会将敌意转移到<em>安全</em>的目标上。</p>
<p>而后人们发现，并不是所有挫折都会指向攻击行为，也有一些其他因素会导致攻击行为。伯科威茨认为原有理论夸大了挫折和攻击行为间的关联，他认为<strong>挫折产生的只是愤怒——攻击行为的一种情绪预备状态，一旦有共计线索出现就会诱使人们产生攻击行为</strong>。愤怒起源于某个有其他行为选择的人阻挠了我们实现目标。</p>
<blockquote>
<p>“当不幸看上去不可避免时，人们可以耐心地承受；一旦人们感到他们可以摆脱这些不幸，它们就变得令人无法忍受了。 —— 托克维尔 1856</p>
</blockquote>
<p><em>挫折</em>和<em>剥夺</em>是两个要区分开的概念。挫折是指一个人得不到有吸引力的或是值得追求的目标；挫折是指他未能从这个对象上获得<strong>原本预期可以</strong>得到的快乐。这也是为什么生活水平改善并不会消除攻击行为，反而有所促进。当预期和现实有差距时，挫折感便产生了，<strong>即期望和实际所得间的差距产生挫折感</strong>。<strong>相对挫折</strong>是指我们把自己和他人比较时带来的挫折感。因此，电视、广告甚至朋友圈中描绘的幸福生活也是挫折感的一个可能来源。</p>
<h4 id="社会学习理论"><a href="#社会学习理论" class="headerlink" title="社会学习理论"></a>社会学习理论</h4><p>这种理论认为学习同样可以引导攻击行为。</p>
<p>人们可以习得攻击行为的回报，此时，攻击行为变成了为了得到特定回报而采取的手段。比如，恐怖主义可以让无职无权的极端分子获得全世界的关注。通过观察别人，人们也可以进行同样的学习，尤其是未成年的孩子。观察攻击行为不仅降低了他们的自我控制，还教会了他们怎样去攻击。身体富有攻击性的儿童往往来自惯用体罚的家长；得不到父亲关怀的孩子，暴力犯罪的可能性更高。</p>
<p>文化对攻击行为也有所影响，来自崇尚荣誉的文化的人，更易拥有攻击性的心理倾向。</p>
<h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><p>攻击行为的诱发因素有<strong>厌恶事件</strong>、<strong>唤醒</strong>、<strong>媒体</strong>、<strong>群体氛围</strong>。</p>
<h4 id="厌恶事件"><a href="#厌恶事件" class="headerlink" title="厌恶事件"></a>厌恶事件</h4><p>厌恶事件即引起厌恶感受的体验：</p>
<ul>
<li>疼痛</li>
<li>不适的炎热</li>
<li>受攻击</li>
<li>过度拥挤</li>
</ul>
<p>在动物身上的实验表明，遭受的待遇越残酷，它们对同伴施加的行为就越残忍。电击、炎热、“心理疼痛”（受挫）都可以引发攻击。厌恶的气味、香烟味、空气污染和攻击行为都有联系，但是环境因素中<em>炎热</em>是研究较多的。炎热高温会提升报复行为的几率和唤起我们带有敌意的想法。另外，收到攻击或侮辱很容易引起攻击行为。</p>
<h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>性唤醒和愤怒等其他形式的唤醒形式是可以相互增强的。挫败、酷热或侮辱性的情境都会提高我们的唤醒水平，这种情况一旦发生，唤醒状态就会和敌对想法、情绪一起构成攻击行为</p>
<h4 id="攻击线索"><a href="#攻击线索" class="headerlink" title="攻击线索"></a>攻击线索</h4><p>前文说过，在攻击线索的触发下，攻击行为最容易发生。<strong>枪支</strong>就会启动敌对性想法和惩罚性判断。它不仅让暴力成为可能，也可以刺激它的发生。枪支不只是提供线索，同时也能拉大攻击者和受害者的距离，让我们更为残忍。</p>
<h4 id="媒体影响：色情文学与性暴力"><a href="#媒体影响：色情文学与性暴力" class="headerlink" title="媒体影响：色情文学与性暴力"></a>媒体影响：色情文学与性暴力</h4><p>色情小说中的色情情节会：1）歪曲女人对性攻击的真实态度；2）增加男人对女人的攻击行为。在实验室实验中，连续观看3周性暴力电影后，男性被试对性暴力的焦虑水平显著下降，表现出对家庭暴力受害者更少的同情，且对受害者受伤程度估计偏低。</p>
<p>色情小说也会导致男性对女性实际的攻击行为。反复观看以强迫性行为为特征的色情影片容易导致：</p>
<ul>
<li>性伴侣吸引力下降</li>
<li>对通奸和女性对男性的性顺从更容易接受</li>
<li>对女性感知更容易从性的角度出发</li>
</ul>
<p>因此，在媒体意识教育中，需要能够让受众重新认识女性对性暴力的真实态度</p>
<h4 id="媒体影响：电视-amp-游戏"><a href="#媒体影响：电视-amp-游戏" class="headerlink" title="媒体影响：电视 &amp; 游戏"></a>媒体影响：电视 &amp; 游戏</h4><p>20世纪末，人们在电视上花的时间越来越多。<em>宣泄</em>假说认为观看暴力节目可以帮助人们释放被压抑的敌意，实际是这样么？</p>
<p>在看电视和行为的<em>相关研究</em>和实验研究中表明，电视和暴力<strong>不仅有相关关系，也有因果关系</strong>，即观看暴力会导致攻击增加。尤其是，当一个<strong>有魅力的人因正当原因实施适当暴力，这种暴力未受惩罚也未表现出伤害</strong>时，观看暴力节目的效果最为显著。暴力节目在三方面增加攻击行为：</p>
<ul>
<li>暴力节目会造成<strong>唤醒状态</strong></li>
<li>观看暴力会使人们<strong>降低抑制</strong></li>
<li>媒体内容会引起<strong>模仿</strong></li>
</ul>
<p>电视上的<strong>亲社会行为</strong>虽然也可以教孩子学习积极行为，但是节目中的攻击行为远远超出爱抚行为。电视在影响行为的同时，也影响着人的思想：</p>
<ul>
<li>重复观看暴力节目会产生<strong>脱敏作用</strong>，即对暴力的情绪敏感度下降。而暴力、尖叫、裸露镜头在电视节目中越来越常见</li>
<li>类似节目会<strong>改变知觉</strong>。看电视多的人会更容易夸张周围世界暴力发生的频率，更害怕人身攻击，更容易产生<em>脆弱感</em></li>
<li>观看暴力节目会启动潜意识中的相关认知，如对攻击性词汇更敏感</li>
</ul>
<p>类似地，电子游戏中的暴力血腥内容也在增多，且相比电视节目，参与感更强， 且会从攻击中获得奖赏，更易诱导人们做出攻击性行为和更富侵略性。和非暴力游戏比，玩暴力游戏时：</p>
<ul>
<li>唤醒水平提高</li>
<li>引发攻击性思维</li>
<li>唤醒攻击性情绪</li>
<li>诱发攻击性行为</li>
<li>减少亲社会行为</li>
</ul>
<p>过度地模拟暴力行为会促使攻击性倾向增强，而非宣泄暴力情绪。</p>
<h4 id="群体影响"><a href="#群体影响" class="headerlink" title="群体影响"></a>群体影响</h4><p>正如群体极化中提到的，群体通过<strong>责任扩散</strong>使攻击行为增大。服从的压力和去个体化使群体成员的自我认同在自身完全投入群体后逐渐消失。群体思维动员一个群体或文化做出异乎寻常的举动是常见现象。如对卢旺达图西族人的大屠杀。群体可以强化攻击倾向。</p>
<h3 id="如何减少攻击"><a href="#如何减少攻击" class="headerlink" title="如何减少攻击"></a>如何减少攻击</h3><p>分析了攻击的影响因素后，如何减少攻击行为呢？</p>
<p><strong>宣泄</strong>即释放聚集的攻击能量。在亚里士多德时代就有宣泄的说法，不过社会心理学家一致认为，与弗洛伊德等人的猜想相反，通过暴力行为不能实现宣泄，反而会增加攻击性。同样的，<strong>表达敌意会导致更多敌意</strong>。</p>
<p>如果攻击行为是习得的，那么减少厌恶体验可以减少攻击行为。</p>
<ul>
<li>避免给人们错误的、不可达到的预期，适当奖励合作性的非攻击性行为</li>
<li>如果要惩罚，需要的是<strong>惩罚的必然性而非严厉性</strong>。提高逮捕率而非刑期会更显著地带来犯罪量减少</li>
<li><strong>体罚会产生消极作用</strong>，根据以前的观点，很强的外部原因并不能内化孩子的行为。可以在孩子很小时奖励敏感性和合作，用非暴力的方式教育孩子达到此目的，积极地表达观点（“清理完你的房间，你就可以出去玩了”而不是“如果不清理好房间，你就别想出去玩”）</li>
<li>减少电视和电影上野蛮、色情、缺乏人性的表演</li>
<li>增加武器（如手枪）的获取难度，避免攻击性刺激</li>
</ul>
<p>有一种观点认为，当类似问题经常出现时，要追根溯源思考根本原因而非表面原因——改造我们的文化，挑战那些腐蚀年轻人的社会毒瘤和重建我们的道德根基。</p>
<h2 id="亲密关系：喜欢和爱"><a href="#亲密关系：喜欢和爱" class="headerlink" title="亲密关系：喜欢和爱"></a>亲密关系：喜欢和爱</h2><p>人和人之间终生的相互依赖性使人际关系成为我们生存的关键。我们会有一种强烈的<strong>归属需要</strong>，即与他人建立持续且亲密关系的需要。</p>
<ul>
<li>从进化角度看，相互依存才能使族群得以繁衍生息</li>
<li>正是因为人们渴望爱和被爱，才会在<em>化妆品、服装和塑形</em>上有巨额投入</li>
<li>社会关系的损伤会影响情绪。人们被拒绝时，会感到抑郁和生活乏味。相反，当我们感到被亲密关系支持时，会更加健康和快乐。</li>
<li>死亡会提醒我们更重视归属需要，重视与他人的关系并与我们所爱的人保持亲密</li>
<li>即使在虚拟世界里，被一个永远不可能见面的人拒绝，也会引起挫败感。这种创伤感会在大脑内有真实的生理对应</li>
</ul>
<p>可见，内心深处的归属需要得不到满足时，就会使我们感到不安。</p>
<h3 id="造就友谊和吸引的因素"><a href="#造就友谊和吸引的因素" class="headerlink" title="造就友谊和吸引的因素"></a>造就友谊和吸引的因素</h3><p><strong>接近性</strong>、<strong>外表吸引力</strong>、<strong>相似性</strong>、<strong>被喜欢的感觉</strong>。</p>
<h4 id="接近性"><a href="#接近性" class="headerlink" title="接近性"></a>接近性</h4><p>接近性相对于产生敌意，更容易产生喜欢。对比<strong>地理距离</strong>，<strong>功能性距离</strong>——人们生活轨迹相交的频率才是关键。有研究者猜测，只要是经常在一起，我们会爱上几乎是任何一个与自己有着大致相同的人格特征并且会回报我们感情的人。</p>
<p>接近诱发喜欢的其中一个原因就是<strong>易得性</strong>——更易产生相互交往。近距离会使人感到亲近。更甚者，仅仅是对相互交往的<strong>预期</strong>就可以引发喜欢。对一个人约会的预期也能促进喜欢。</p>
<p><strong>曝光效应</strong></p>
<p>各种实验表明，熟悉并不会引发轻视。实际上，<strong>熟悉诱发了喜欢</strong>。各种新异刺激——无意义音节、汉字、音乐片段、面孔——的<strong>曝光</strong>都能提高人们对它们的评价。</p>
<ul>
<li>不同语言和年龄的人都偏好自己名字中的字母或母语中频繁出现的字母</li>
<li>人们对熟悉的面孔评价更高，人们更喜欢镜子中镜像版的自己</li>
<li><strong>人们喜欢和自己相关的事物</strong>，如倾向于居住和自己名字相关的城市或选择和名字相关的职业</li>
<li>广告商和政治家们利用这个效应，即使人们对某商品或候选人没什么倾向性，仅仅通过简单的重复（电梯广告的病毒式营销），也可以增加商品销量或得票率。</li>
<li>在广告或政治标语中，通常使用简短的slogan代替唱片大陆，突出候选人名字或商品关键价值</li>
</ul>
<p>Zajonc通过实验发现，人们的直接感受并不借助于意识存在。他认为，<strong>情绪相比于思维是更即时的东西，情绪半独立于思维，可以先于认知</strong>。曝光效应会引发愉快的情绪，但是当重复没完没了时也会引起兴趣减弱。</p>
<p>1990华盛顿州的一次法官选举中，在没有开展竞选活动的情况下，名不见经传的候选人Charles Johnson因为姓名更熟悉战胜了Keith Carlo。</p>
<h4 id="外表吸引力"><a href="#外表吸引力" class="headerlink" title="外表吸引力"></a>外表吸引力</h4><p>人们都说外貌不重要，但行为上却不总是这样。现在的很多研究表示：<em>外貌的确是很重要的</em>。从某个角度说，美貌的确是一种财富。</p>
<p><strong>约会相关</strong></p>
<p>年轻女士的外表吸引力可以<strong>中度预测</strong>她约会的次数，而一位男性的外表对他约会的次数相关性则要小一些。哲学家罗素认为：<strong>“整体上来说，女人倾向于因性格而爱上男人，男人则倾向于因外表而爱上女人”</strong>。哈特菲尔德在明尼苏达大学的实验证实了这一点：<strong>男人的确更在意异性的外表吸引力</strong>。某位女性外表吸引力越大，男性就越喜欢他；当然，男性的外表吸引力也有童颜的效果。美貌使人愉悦。</p>
<p><strong>匹配现象</strong></p>
<p>人们一般与和自己同等吸引力的人结为伴侣。人们在选择伴侣上，尤其是<em>终身伴侣</em>上，倾向于选择不仅在智力，而且在外表吸引力方面和自己匹配的人。</p>
<p>外表上的匹配有利于良好关系的发展和维持。但是很多夫妻的吸引力并不匹配，却仍然幸福。这种情况下，吸引力较差的一方常常有其他方面的品质予以补偿。<strong>男性通常强调自己的财富和地位，并且希望寻求年轻和有吸引力法女性；女性则相反</strong>。</p>
<p><strong>刻板印象</strong></p>
<p>在儿童中，老师们倾向于认为那些有吸引力的孩子在学习上更聪明。所谓的<strong>巴特·辛普森效应</strong>即大多数人都认为，长相一般的孩子，他们的才干和社交技能都不如那些漂亮的同龄人。同时，在其他方面都<em>几乎相同</em>的情况下，我们仍会猜测漂亮的人更快乐、性感热情、更开朗、聪明和成功。这就是<strong>外表吸引力的刻板印象</strong>——美的就是好的。</p>
<p>小时候的童话里，白雪公主是善良且美丽的，而巫婆则是邪恶和丑陋的。尽管两者间并不会有明显相关性。</p>
<p>也是因为这样的刻板印象存在，20世纪70年代后，妇女在化妆品和整容方面的投资大大增加，对自己外貌深感不满的人也越来越多。Michael Kalick在1977年让学生们观看8位女士整形手术前后的照片，结果表明，被试不仅认为女女士们在术后更具吸引力，也认为她们更善良、敏锐、性感热情、更具责任感。</p>
<p>在城市化进程加快的背景下，人和人接触的时间越来越短暂，能给人留下第一印象的外表吸引力就显得愈发重要。在面试中，吸引力和外表修饰影响着第一印象甚至薪水。</p>
<p>之前我们提高过的<em>自我实现的预言</em>在这里也发挥着作用。研究表明，有吸引力的孩子和青年，某种程度他们的确不那么拘谨，更加外向且社交技能更强。从而在正反馈下变得更受欢迎。</p>
<p>长得漂亮没有坏处么？哈特菲尔德等人认为漂亮也会带来不快的性骚扰、同性的嫉妒和排斥，错误归因他人的欣赏。</p>
<p><strong>如何衡量吸引力</strong></p>
<p>讽刺的是，真正的吸引力是完美的平均——由计算机平均出来的平均面孔就很有吸引力。它们也会带来一种熟悉感。</p>
<p>从生物学角度讲，健康、年轻等富有生殖能力的女性特征以及能提供资源、保护能力的男性特征被认为具有吸引力。男性希望女性要有适度的外表吸引力，而女性则希望男性拥有财富和地位，且两性都喜欢有爱心的人和聪明的人。这是进化和文化共同造就的。从深层角度讲，我们的潜意识也被本能影响着。</p>
<p><strong>社会比较</strong>会影响吸引力评估。</p>
<ul>
<li>刚看过描述有吸引力异性作品的被试对比对照组对异性的评价更低</li>
<li><strong>性唤起</strong>会<strong>暂时性</strong>使异性看起来更具吸引力</li>
<li>对比效应在女性上更为明显</li>
<li>情人眼里出西施。我们会认为<strong>我们喜欢的人</strong>以及<strong>和我们相似的人</strong>具有吸引力。人们爱得越强烈，就越不觉得任何其他异性吸引人</li>
</ul>
<h4 id="相似-or-互补"><a href="#相似-or-互补" class="headerlink" title="相似 or 互补"></a>相似 or 互补</h4><p>找一个性格相似的人还是性格互补的人做伴侣？实验显示，</p>
<ul>
<li>丈夫和妻子间相似性越大，他们就越幸福且不容易离婚</li>
<li>某人态度的相似性会引发我们的喜欢。</li>
<li>人们喜欢和他们想法一致和言行一致的人。模仿可以促进和谐。</li>
<li>人们渴望相似伴侣的愿望要远远强于渴望漂亮伴侣的愿望</li>
</ul>
<p>相反，不同态度对喜欢的抑制甚于相似态度对喜欢的促进。态度一致性有助于人们促进和维持亲密关系。在恋人这样的亲密关系外，<strong>思想</strong>上的相似产生的吸引力比肤色的相似性更重要。不过这个世界是具有文化和思想多样性的，我们也需要尊重和欣赏这种差异，求同存异。</p>
<p>人格特质上的互补可以引发吸引么？研究者考察了这个问题，发现在各个方面，<strong>相似性仍然是主导因素</strong>。互补性产生的对比效果可能使一方感受更糟糕，如一个悲观的人和乐天的人在一起。另一方面，我们通常也不会认为那些表现出和我们相反的不好的特征的人是具有吸引力的。</p>
<h4 id="喜欢我们的人"><a href="#喜欢我们的人" class="headerlink" title="喜欢我们的人"></a>喜欢我们的人</h4><p>喜欢通常是相互的（*Really?<em>）。接近性和吸引力可以影响我们最初被谁吸引，相似性会影响长期的吸引。一个人喜欢他人的程度可以反过来预测对方喜欢他的程度（</em>Really?*）告知某些人他们被被人喜欢或仰慕时，他们就会产生一种回报的情感。因为通常来说，<strong>缺点比优点更具影响力</strong>，在我们评价别人和别人反过来评价我们时，<strong>消极消息占比都更多</strong>。</p>
<ul>
<li>坏心情比好心情更能影响我们的思维和记忆</li>
<li>坏事比一件好事更能产生更持久的效应</li>
<li>坏名声比好名声更易获得，且更难摆脱</li>
<li>糟糕的健康状态产生的痛苦远大于舒服产生的快乐</li>
</ul>
<p>奉承通常会使人感觉良好，但我们会认为<strong>批评比表扬更真诚</strong>。在赞美违背了事实后，我们很容易<em>归因</em>到别有用心的动机上。在一项实验中，被试大学生们被要求给出和女&#x2F;男朋友在一起的原因，那些注意力被引到外在原因的人，相对于引到内在原因的人，会表现出对恋人更少的爱恋和结婚可能性。</p>
<p>人们在自尊受到创伤的拒绝后，会表现出反弹行为——对伴侣评价更高，陷入更加激情的恋爱。相反，在获得尊重时，实验发现个体<strong>逐渐</strong>获得尊重，且推翻了目标任务原先的批评时，个体会更喜欢这个目标人物。批评之后的赞美之词才更为可信。频繁的赞扬可能会失去价值。因此，对比“过度赞扬”，<strong>保持坦率而真诚的关系——相互尊重、彼此接纳、保持忠诚——更可以让对方感到满意</strong>。真诚对营造两人间的良好关系很重要。</p>
<h4 id="关系中的回报"><a href="#关系中的回报" class="headerlink" title="关系中的回报"></a>关系中的回报</h4><p>吸引涉及两方——被吸引的一方和吸引他人的一方。“我喜欢XXX，是因为和她在一起感觉如何如何”。可以将这个观点总结为简单的<strong>吸引的回报理论</strong>：<strong>我们喜欢那些回报我们或与我们得到回报相关的人</strong>。推广一点，我们还喜欢和那些能<strong>让我们心情愉悦</strong>的人交往。这种<strong>“联系——喜欢”</strong>在多个实验中都被证实。</p>
<ul>
<li>舒适的环境能激发被试对被评价者的好感</li>
<li>如果你希望维系和伴侣的关系，那么继续把你们的关系和美好事物联系起来很重要</li>
<li><strong>接近性</strong>带来报偿，因为这种友谊付出的时间和精力都较小</li>
<li>我们喜欢<strong>有吸引力</strong>的人，因为他们身上可贵的品质能让我们受益</li>
<li>他人观点和我们<strong>相似</strong>，也会让我们觉得得到了回报。我们尤其喜欢<strong>那些被我们说服的，并开始认同我们观点的人</strong></li>
<li>我们喜欢被人喜欢和被人所爱</li>
</ul>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>爱情比喜欢更复杂。对爱情的研究首先也要建立界定和衡量的手段。Sternberg认为爱情由激情、亲密和忠诚组成：</p>
<ul>
<li>激情 + 亲密 &#x3D; 浪漫之爱</li>
<li>激情 + 承诺 &#x3D; 游戏之爱</li>
<li>亲密 + 承诺 &#x3D; 友谊之爱</li>
</ul>
<p>激情之爱即热恋状态——强烈渴望和对方在一起的一种状态。研究表明，持续的目光接触、点头和微笑都是激情之爱的标志。哈特菲尔德认为：<strong>任何一种生理唤醒状态最终都可以被归因为某种情绪</strong>。激情之爱就是我们在生理上被有吸引力的人唤醒所感知到的心理体验。这么来看，任何一种可以增加兴奋感的东西都应该可以增强对爱情的感受。沙科特和辛格提出的<strong>情绪两因素理论</strong>认为，当处于兴奋状态的男性对女性做出反应时，他们<strong>很容易把自己的某些生理唤醒错误地归因于这位女性</strong>。一些研究表明，生理唤醒可以促进罗曼蒂克式的反应。</p>
<ul>
<li><strong>观看恐怖电影、乘坐过山车、体育锻炼、饮酒、畅谈等促进生理唤醒的活动都有同样效果</strong>，特别是对那些我们觉得有吸引力的人</li>
<li>夫妻双方共同完成一项可以提高激活水平的活动后，会对其关系的总体情况报告更高的满意度</li>
</ul>
<p>和通常的观念相反，许多研究发现，其实<strong>男人比女人更容易坠入情网</strong>。相比于女性，男性很少技术一段即将迈入婚姻的爱情关系。但是，热恋中的女性也会有和伴侣一样多的感情投入，甚至更多。女性似乎比男性更注重友谊中的亲密感，也会更多关心她们的伴侣。而男性则更多地想到恋爱中的嬉戏以及性的方面。</p>
<h4 id="伴侣之爱"><a href="#伴侣之爱" class="headerlink" title="伴侣之爱"></a>伴侣之爱</h4><p>尽管激情之爱可以热火朝天，但终归还是会平静下来。如果一段亲密的感情经受得住时间的考验，那么它最终就会成为稳固而温馨的爱情，哈特菲尔德称为<strong>伴侣之爱</strong>（companionate love）。伴侣之爱相对平和，是一种深沉的情感依恋。</p>
<p>和吸毒的戒断效应以及抗药性很像，浪漫爱情会有产生之初的高峰和逐渐消退的趋势。曾经很大刺激的用量现在变得效果轻微了，然而一旦停止用药，并不能使你恢复原先状态，而是会引发强烈的戒断反应。那些分手、离异的人会吃惊的发现，虽然早已对另一半失去强烈爱恋，但分开后，生活居然如此空虚。</p>
<p>自由恋爱的夫妻在5年以上，会觉得彼此的“有爱情”的感觉越来越少，相反，那些包办婚姻的夫妇则报告逐渐增长的爱情体验。当然整体上，自由选择伴侣的女性更多地感到快乐。在过去20年陡然增高的离婚率，至少部分源自人们越来越多强调强烈积极的情绪体验在生活中的重要性。这一点在偏向集体主义的文化则并中不明显。热恋中的相互迷恋逐渐减退还有一个重要原因是，夫妇得到了孩子，使他们不能再只关注彼此。在孩子独立离开家庭后，一些失去的浪漫感觉又会重新出现，父母可以重新关注彼此。</p>
<h3 id="促进亲密关系的因素"><a href="#促进亲密关系的因素" class="headerlink" title="促进亲密关系的因素"></a>促进亲密关系的因素</h3><h4 id="依恋"><a href="#依恋" class="headerlink" title="依恋"></a>依恋</h4><p>爱情不仅是一种选择的体验，也是一种生物性驱使。我们的归属需要具有适应性意义，合作促进我们种族的生存和基因的传递。婴儿期对成人的依赖增强了人类间的联系。<strong>与他人的亲密依恋关系构成了一个人生活的核心</strong>，人们都是通过这些亲密依恋关系来获得力量和享受生活的。</p>
<p>所有的依恋都有一些共有因素，双方的理解、提供和接受支持、重视并享受和相爱的人在一起。当然激情之爱还会有些其他特征：身体上的亲昵、排他性的期待以及对爱人的强烈迷恋。依恋在婴儿期还可以再细分为三种大类：</p>
<ul>
<li><strong>安全性依恋</strong>，大约七成以上，在母亲在场时能舒适地玩耍，母亲离开后变得紧张，母亲回来时跑向母亲并继续玩耍。这种婴儿在成人后会更容易接近别人，不会太过依赖或被抛弃而苦恼。这样的恋人也更容易将关系维持在令人满意和持久的状态。</li>
<li><strong>回避型依赖</strong>，大约两成，这类婴儿在和母亲分离或重逢时，虽然有内部的生理唤醒，但极少表现出悲伤。这类婴儿成人后往往会回避亲密关系，并对这种关系表现出较少兴趣，并倾向于摆脱这种关系。他们更易涉及<strong>一夜情</strong>，而较少有爱情。</li>
<li><strong>不安全型依赖</strong>，约一成。在陌生环境下，这类婴儿会充满焦虑地粘在母亲身边。母亲离开后会哭泣。母亲回来后，他们会表现出冷漠和敌意。成年后，焦虑——矛盾型人格使他们对别人不够信任，产生<strong>较强的占有欲和忌妒心</strong>。他们与同一个人的关系会反复出现破裂的情况。</li>
</ul>
<p>这种早期依恋方式也能形成<em>内部工作模式</em>，或关于人与人之间相互关系的独特思考方法。观察发现，敏感、反应型的母亲会让孩子对世界的可靠性形成基本信任感，有利于培养安全型依恋的孩子。</p>
<h4 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h4><p>吸引的公平原则：你和你伴侣从感情中所得应该和你们投入的成正比。处于<em>长期的公正</em>关系的人不在乎短期的公正。对他们来说，这些只是“社交债务”的产生和偿还。<strong>不斤斤计较</strong>是友谊的标志。</p>
<p>对公平的知觉也很重要。处于公平关系的人往往满意度更高，知觉到的不公平可以预测婚姻紧张和对婚姻生活的不满意度。知觉到不公平是一个<strong>正反馈</strong>过程：觉得不公平的一方会更加沮丧和苦恼，从而加剧感受到不公平。</p>
<h4 id="自我表露"><a href="#自我表露" class="headerlink" title="自我表露"></a>自我表露</h4><p>在美满婚姻或亲密友谊中，信任会取代顾虑，使我们更容易展现自己，而不必担心失去友情和爱情。这一特点表现为<strong>自我表露</strong>。</p>
<p>被他人挑选为表露对象通常是很令人高兴的事。相反，如果缺乏发展这种亲密关系的机会，我们就容易感到孤独的痛苦。对于那些我们期望与之有更多交往的人，我们会更多自我表露，且<strong>安全型依恋的人会比其他类型自我表露更多</strong>。而且表露间存在<strong>表露互惠效应</strong>，一个人的自我表露会引发对方的自我表露，我们会对那些敞开胸怀的人表露更多，但是亲密关系的发展也不会立即而来（否则就显得不够谨慎和可靠）。它更像跳舞，我表露一点，你表露一点，一次不要太多，有一个持续的相互回应的过程。亲密关系的增加会创造很强的激情感觉，到亲密关系稳定后，激情就相对较小。</p>
<p>有些人——主要是女性——特别善于使人“敞开心扉”，她们可以轻易地引发他人亲密的自我表露。这类人似乎都是好的倾听者。心理学家Rogers称这种人为“促进成长”的听众，表露自己情感，倾听他人情感。</p>
<p>这样的自我表露有助于我们扔掉面具，表现真实的自己——培植爱情的方式。对他人敞开心扉可以是人们间的交往更加愉快。经常敞开心扉的夫妻或情侣会报告更高的满意度且保持更长久的爱情。两个自我相互联系、相互倾诉、相互认同；两个自我保持个性，又共享很多活动，为彼此的相同之处感到愉悦并相互支持——这就是爱情的精髓。</p>
<h3 id="亲密关系如何结束"><a href="#亲密关系如何结束" class="headerlink" title="亲密关系如何结束"></a>亲密关系如何结束</h3><p>人们将自己不满意的婚姻关系和想象中可从别处获得的支持和情感相比，选择离婚的人越来越多。</p>
<h4 id="离婚"><a href="#离婚" class="headerlink" title="离婚"></a>离婚</h4><p>相对于集体主义中，结婚更意味着承担责任；个人主义者则因为“我们彼此相爱”。个人主义者期待婚姻中有更多激情和个人的自我实现。那些结婚时就已考虑成熟且打算长相厮守的人，确实会有更健康、稳定而长久的婚姻。</p>
<p>符合下面条件的夫妇通常不会离婚：</p>
<ul>
<li>20岁后结婚</li>
<li>都在稳定的双亲家庭里长大</li>
<li>结婚前谈了很长时间恋爱</li>
<li>接受过较好且相似的教育</li>
<li>有稳定收入</li>
<li>居住在小城镇或农场</li>
<li>结婚前没有同居或怀孕过</li>
<li>彼此间有虔诚的承诺</li>
<li>年龄、信仰和受教育水平相似</li>
</ul>
<h4 id="分离过程"><a href="#分离过程" class="headerlink" title="分离过程"></a>分离过程</h4><p>对于深入和长久的依恋关系，离开是一个过程，而不是一个事件。Baumeister &amp; Wotman的报告显示，在数月或数年后，拒绝别人的爱，比被拒绝更能够唤起更多痛苦。痛苦中来自伤害别人的内疚，对心碎恋人的执着的不安，也来自不止如何反应。</p>
<p>在婚姻关系令人痛苦时，有下面4种反应：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>被动的</th>
<th>主动的</th>
</tr>
</thead>
<tbody><tr>
<td>建设性</td>
<td><strong>忠诚</strong>：等待改善</td>
<td><strong>表达</strong>：试图改善关系</td>
</tr>
<tr>
<td>破坏性</td>
<td><strong>忽略</strong>：无视对方</td>
<td><strong>退出</strong>：结束婚姻关系</td>
</tr>
</tbody></table>
<p>健康的婚姻不见得没有冲突，而是夫妻双方能够调和差异。<strong>痛苦和争吵并不能预测离婚</strong>（几乎所有夫妇都经历过冲突）。真正能预测婚姻危机的因素是<strong>冷漠、希望破灭和无助</strong>。</p>
<p>相反，婚姻成功的夫妻有时能从沟通训练中获益，学会避免恶意侮辱，平息怒火，不讲冲突矛头只指向个人。幸福的夫妻间会减少抱怨和责难，增加肯定和赞同，腾出时间表达彼此观点，每天一起祈祷和休闲，并以此改善关系。类似地，持久的凝视等<strong>模仿相爱的行为能够激发爱情</strong>。Sternberg认为，通过扮演和表达爱意，最初的浪漫和激情能够发展成持久的爱情。</p>
<p>在现代生活中，亲密而持久的婚姻关系正在减少。人们需要付出努力才能防止爱情减退。爱情是在内心决定去爱一个人并对其做出长相厮守的承诺；爱情是可以经营的，它需要相爱的人共同去培育。</p>
<h2 id="利他"><a href="#利他" class="headerlink" title="利他"></a>利他</h2><p>利他主义（Altruism）：自私自利的反义词。</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>从观察角度和解释层次上，大致分为下面3类：</p>
<table>
<thead>
<tr>
<th>理论</th>
<th>解释层次</th>
<th>外在帮助</th>
<th>内在帮助</th>
</tr>
</thead>
<tbody><tr>
<td><strong>社会交换</strong></td>
<td>心理学</td>
<td>帮助的外在回报</td>
<td>内疚-&gt;帮助的情感补偿</td>
</tr>
<tr>
<td><strong>社会规范</strong></td>
<td>社会学</td>
<td>互惠规范</td>
<td>社会责任规范</td>
</tr>
<tr>
<td><strong>进化理论</strong></td>
<td>生物学</td>
<td>互惠</td>
<td>亲缘选择</td>
</tr>
</tbody></table>
<h4 id="获得回报，避免惩罚"><a href="#获得回报，避免惩罚" class="headerlink" title="获得回报，避免惩罚"></a>获得回报，避免惩罚</h4><p>包括社会交换理论在内的几种理论都认为，帮助行为可以使施与者和接收者共同受益，并产生社会性商品的交换——爱、服务等。</p>
<p><strong>社会交换</strong></p>
<p>帮助行为的有些回报是外部的，比如，商人捐款以获得良好形象，让顺路人搭车已获得赞赏。我们会最热心地帮助对我们<strong>有吸引力</strong>或<strong>渴望得到其赞许</strong>的人。当然，给予对方情感支持，也会让自己产生积极心境。志愿者行为也能有益于成年人的精神状态甚至健康状况。</p>
<p>这种收益分析看起来有些有失身份，难道我们没有“纯粹”的利他行为吗？斯金纳在1971年对帮助行为的分析提到，“只有当我们不能解释别人做好事的原因时，我们才会因此信任他们。只有当我们找不到外在解释时，我们才会把行为归因于他们内在的品质而不是外部原因”。</p>
<p><strong>内部回报</strong></p>
<p>很多时候，帮助行为也会来自内部原因，比如助人者的情绪状态或个人品质。接近一个痛苦的人，我们也会感到痛苦，从而实施帮助也会减轻自己的<strong>痛苦感</strong>。痛苦仅是一个例子，除了痛苦外，<strong>内疚</strong>也是我们想尽量摆脱的消极情绪。实验显示，人们会<strong>尽其所能消除内疚感，减少不良感受，恢复自我形象</strong>。</p>
<ul>
<li>违规行为会引发被试的负罪感，从而倾向于帮助行为，将功补过</li>
<li>说了谎的被试更乐意无偿付出一点时间提供帮助</li>
</ul>
<p>我们在犯错后的行善愿望表明，我们既需要减轻个人的内疚感，也需要<strong>恢复动摇了的积极的自我形象</strong>。即使我们的内疚感是他人所不知的，我们也会用行动来减轻它。除了利他行为外，内疚感还能促使人们坦白、道歉，避免再犯错误，还会使人更敏感，增进亲密关系。</p>
<p>除了内疚感，<strong>消极情绪</strong>也对利他行为有影响，但有趣的是，儿童和成人的影响正好相反：</p>
<ul>
<li>消极情绪减少儿童的帮助行为</li>
<li>消极情绪促进成人的帮助行为</li>
</ul>
<p>Cialdini等人推测，利他行为带来自我满足和内在回报这一认知来自<em>社会化过程</em>，所以在成人身上很明显，而儿童却没有体现，虽然儿童也有共情能力。实验结果和“人生来自私”的观点不谋而合，孩子们随着年龄增长，学会站在他人角度看待问题，帮助行为也随之发展起来。不过，个别消极情绪例外，如<strong>愤怒</strong>或<strong>极度的悲伤</strong>的人会处于强烈的自我关注时期，从而抑制了对他人的付出。只有注意力被引到他人的被试才认为帮助别人特别有意义。</p>
<p>和消极情绪相反，<strong>快乐的人更乐于帮助别人</strong>。这一点不论在儿童还是成人身上都是如此。因为帮助行为能够维持好的心境，同时积极的心境又会产生积极想法和饱满的自尊。快乐的门槛很容易达到，<strong>从害怕到轻松的心境</strong>也很容易引发帮助行为，如被误诊、或误开罚单。不过随着快乐的心境逐渐消逝，助人性也随之降低。</p>
<p><strong>社会规范</strong></p>
<p>这里说的规范即<em>社会期望</em>。人类社会中一个普遍的道德准则是<strong>互惠规范</strong>，即<strong>对于曾帮助我们的人，我们应该予以帮助，而不是伤害</strong>。这种支持性的联系，信任和合作行为保证了团体的正常运作。当人们不能给予回报时，他们可能会因为接受了援助而感到受威胁和被贬低。因此，骄傲、自尊心强的人通常不愿意寻求帮助。</p>
<p>另一条重要的社会规范是<strong>社会责任规范</strong>，即<strong>人们应该帮助那些需要帮助的人</strong>。一些实验表明，即使帮助者不为人知，或不能期待任何回报，他们也会帮助那些需要帮助的人。至于如何鉴别“需要帮助的人”，<strong>归因</strong>很重要。如何一个人穷困潦倒是因为自身原因（懒，不道德），社会规范会让他们自食其果；如果相反是因为环境原因，他们就会得到关怀和帮助。这一规范使人们帮助那些最需要帮助和最应该得到帮助的人。</p>
<p>女性在被知觉为更柔弱和更具依赖性上，会得到男性更多的帮助。而女性对不同性别的求助者则一视同仁。男性会更多地帮助那些<strong>外表有吸引力</strong>的女性，而不是那些外表不具吸引力的人。女性不仅特定场景下能获得更多帮助，她们在身体和精神上也需求更多帮助。</p>
<h4 id="进化心理学"><a href="#进化心理学" class="headerlink" title="进化心理学"></a>进化心理学</h4><p>我们的基因驱使我们采用让其存活能力最大化的生活方式（来自<a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2018/11/22/selfish-gene/">《自私的基因》</a>观点），<strong>亲缘保护</strong>和互惠就是。<strong>亲缘选择</strong>让我们偏袒那些和自己拥有相同基因的人，我们的子女和亲兄弟间有天然的基因相似性，所以可以说帮助近亲是我们的本性。亲缘保护还决定了种族内的群体偏好，这也是导致诸多冲突的根源。</p>
<p>生命体帮助他人，也是因为它期待着得到回报性的帮助。不作出互惠行为的个体则会被抛弃和排斥。互惠在<strong>小的、与外界隔离的群体中更好地发挥作用</strong>（可能因为相互信赖更强）。因此，互惠行为在偏远乡村比在大城市发生得更多。互惠特征能保持至今有一个进化的原因：群体间竞争时，相互支持、互惠的群体比不互惠的群体能维持更长时间。</p>
<h4 id="真正的利他"><a href="#真正的利他" class="headerlink" title="真正的利他"></a>真正的利他</h4><p>上面我们从内在（避免痛苦）和外在（获得回报或逃脱惩罚）分析了利他的动机，似乎还存在着由<strong>共情</strong>引发的真正的利他行为，即帮助别人的意愿不仅受利己考虑影响，也会来自无私的考虑。<strong>当我们感到和某人有关联时，就会产生共情</strong>。这也是为什么从众中提到个性化的受害者更能引人共鸣。实验发现，共情被唤起的人通常会施与帮助。但是<strong>如果同时知道有别的方式能让我们好受些，我们就不太可能帮助别人</strong>。</p>
<p>巴特森和其同事认为共情导致的利他行为有利有弊，缺点之一是会引起偏爱、不公正的帮助行为，并对广泛的公共利益冷漠。</p>
<h3 id="何时会提供帮助"><a href="#何时会提供帮助" class="headerlink" title="何时会提供帮助"></a>何时会提供帮助</h3><p>在场人数、个人情绪、价值观念、时间紧迫度都会影响帮助行为。</p>
<h4 id="在场人数"><a href="#在场人数" class="headerlink" title="在场人数"></a>在场人数</h4><p>在更多人在场的情况下，受害者较少有机会得到帮助。在旁观者增多时，任何一个旁观者都会更少注意到事件发生，更少把它解释为紧急情况，更少认为自己有采取行动的责任。</p>
<p><strong>注意</strong></p>
<p>在群体人数较多时，群体中的个人会较少注意紧急情况的发生。</p>
<p><strong>解释</strong></p>
<p>如从众一章中所说的“信息影响”，在对环境不够熟悉时，<strong>每个人通常会以他人行为作为现实情况的线索</strong>。另一方面，这种错觉又被<strong>透明错觉</strong>所助长，透明错觉指出我们通常会<strong>高估</strong>他人了解我们内心状态的能力。因为，我们对自己情境的关心会来的更明显，对自身情绪也更敏感，所以会以为他人能很容易发现。在这两种错觉的叠加下，我们往往会忽视或误解需要帮助的线索。</p>
<p>对行为的解释很重要，一个尝试打开车锁的人到底是小偷还是被锁在门外的人，我们对其的解释会影响我们的反应，帮助抑或报警。陌生人之间的暴力也会得到更多的干预行为。</p>
<p><strong>责任归属</strong></p>
<p>人群变大时，帮助情境会变模糊。相反，当紧急情况很清晰时，群体中的人提供帮助的可能性就远小于独处的人。这也在一定程度上解释了，为什么城里人通常比乡村人不愿意帮助别人，在大城市因遇到需要帮助的人太多，会产生“同情疲劳”和“感官超载”。另外，责任扩散也是原因之一，群体中个人感觉到的责任被分散。</p>
<p>在一项实验中，面对面的被试由于有<strong>表情交流</strong>，要比背对背的被试更容易提供帮助。相对相互孤立的群体，相互联系的群体会提供更多帮助。</p>
<h4 id="他人的示范作用"><a href="#他人的示范作用" class="headerlink" title="他人的示范作用"></a>他人的示范作用</h4><p>亲社会的榜样可以促进利他行为。目睹令人感动的善举，常常会引发一种升华的状态：胸腔被温暖和激情膨胀的特殊感，令人们战栗、流泪、喉咙抽紧。孩子不仅听从耳濡的教诲，也从目染的行为中学习道德观。</p>
<h4 id="时间压力"><a href="#时间压力" class="headerlink" title="时间压力"></a>时间压力</h4><p><strong>时间充裕且认为自己的角色无关紧要</strong>的被试会放弃事务停下来提供帮助。</p>
<h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><p>上一章提到，相似性引起喜欢，我们也更多地对那些跟我们相似的人产生共情。在实验中，被试对和自己有相似特征的面孔更信任和慷慨。相似性也会引起同种族的偏爱行为，不过，由于很少有人希望明确表现出偏见，所以实验中这种偏爱倾向没那么明显。</p>
<h3 id="谁会提供帮助"><a href="#谁会提供帮助" class="headerlink" title="谁会提供帮助"></a>谁会提供帮助</h3><ul>
<li><strong>人格特征</strong>。具有较积极情绪，较高共情能力和高自我效能感的人更易提供帮助。不过助人性的个体特征没那么明显，需要和<strong>特定情境</strong>结合在一起分析。当受助者是陌生人且情境有危险性时，男性更常伸出援手。而在安全的场景下，如志愿者或花时间的陪伴，女性更乐意一些。尤其是基于亲密关系的关心而不是帮助陌生人。</li>
<li><strong>宗教信仰</strong>。在长期帮助上，如志愿者工作和慈善捐款，宗教信仰有更好的预测性。在各种社会团体中，宗教团体的成员和公民参与的各种形式有最紧密的联系。</li>
</ul>
<h3 id="如何增加帮助行为"><a href="#如何增加帮助行为" class="headerlink" title="如何增加帮助行为"></a>如何增加帮助行为</h3><p>根据上面对帮助行为的分析，可以从个人角度和社会角度去做。</p>
<h4 id="个人角度"><a href="#个人角度" class="headerlink" title="个人角度"></a>个人角度</h4><p>去除对利他行为的抑制。<strong>减少模糊性，提高责任感</strong>。个人化的方式能使人感到不是匿名的，因而有更高的责任感，任何能让旁观者变得凸显个人特征的事情——个人请求、目光接触、告知姓名、会面预期——都增加了帮助的可能性。同时，自我意识更高的人更经常将理想付诸于实践。</p>
<p>另一方面，可以<strong>引起内疚和对自我形象的关心</strong>。<strong>留面子（door-in-the-face）</strong>是利用前者的手段，先提出较过分的请求，在被拒绝后，利用拒绝者的内疚提出想要的请求通常会被满足。比如，研究者先提出一个非常大的请求——承诺为不良儿童做为期两年的无偿咨询，在被全部拒绝后，从侧面切入：“好吧，如果你不愿意，这点小事你愿意帮忙吗？”。Cialdini和Schroeder提供了引发个体关注自我形象的方法：<strong>请求非常微小的帮助</strong>，以至于不好意思被拒绝。因为此时拒绝，通常证明自己的自私。</p>
<h4 id="社会角度"><a href="#社会角度" class="headerlink" title="社会角度"></a>社会角度</h4><ul>
<li><strong>教化道德包容</strong>，避免道德排除，利他主义社会化的第一步就是去除天然的内群体偏爱</li>
<li><strong>树立利他主义榜样</strong>，亲社会的电视榜样所起的所用远大于发社会榜样的作用</li>
<li><strong>归因为利他主义动机</strong>，给予一种行为超过适度的反馈时，个体可能将行为归于奖励这一外在动机。在没有报酬和潜在社会压力时，如果答应帮助别人，会产生最强的无私感。但这不意味着不能有褒奖，意外的褒奖能令人感到胜任和有价值，需避免的是过度的滥用的奖励。助人行动能够促进把自己看作“富有同情心和乐于助人的人”，而这种知觉又反过来促进了进一步的帮助行为</li>
<li><strong>习得的利他主义</strong>，即在了解上面这些会影响帮助行为的因素后，人们就会意识到群体情境对帮助行为的一些抑制作用，从而去避免</li>
</ul>
<h2 id="冲突和和解"><a href="#冲突和和解" class="headerlink" title="冲突和和解"></a>冲突和和解</h2><p>冲突是<strong>被知觉到</strong>的行为或目标的不相容。无论冲突的双方能否正确感知对方的行为，他们总会认为一方的获益就是另一方的损失。但从另一方面来看，冲突体现了<strong>参与、承诺和关心</strong>。在能够被理解和解决的情况下，冲突可以<strong>促进人际关系的变化和发展</strong>。从积极意义上讲，<em>和平</em>是创造性处理冲突得到的结果。</p>
<h3 id="冲突是如何产生的"><a href="#冲突是如何产生的" class="headerlink" title="冲突是如何产生的"></a>冲突是如何产生的</h3><p>冲突来自于多种方面，实际上，不论是人与人的，还是国与国的冲突，其产生原因都是大体相似的。</p>
<h4 id="社会困境"><a href="#社会困境" class="headerlink" title="社会困境"></a>社会困境</h4><p>社会困境即<strong>个人利益和集体利益</strong>相互冲突，在个体追逐自己的私利时，避免不了地损害了集体的或其他团头的利益。<strong>囚徒困境</strong>和<strong>公共地悲剧</strong>就是两个典型案例。</p>
<p><strong>囚徒困境</strong>即，两个囚犯有守口如瓶和指认对方两种选择，对于个人来讲背叛对方总能得到更好的结果，但实际上双方都选择对个体更差的策略时，能获得更大的收益。囚徒困境有一个限制条件： 双方<strong>只做1次决策</strong>，所以没有长远考虑的机会。军备竞赛等囚徒困境的实际案例频繁地发生在现实生活中，无条件地信任他人和采取合作态度反而会让自己陷入被动。</p>
<p><strong>公共地悲剧</strong>即个人对公共资源的过度滥用，比如共同放牧的草原等。在经济学角度讲，一个人对公共资源的使用减少了他人的使用，这种<strong>负外部性</strong>使每个人对公共资源的成本评估较低，从而造成滥用。这也是为什么，<strong>当一种资源未获得明确分配时，人们往往不自觉地消费更多</strong>。</p>
<p>当然也有人，如亚当·斯密认为，从某一方面，由于每个人都试图通过努力使自己利益最大化，这一过程也会使整个社会产值达到最大。</p>
<p>有一些手段可以缓解这种个人利益和集体利益的冲突：</p>
<ul>
<li>设立管理条例</li>
<li>设置税和管理费等，提高人们的评估成本</li>
<li><strong>缩小群体规模</strong>，在一个较小的团体中，人们能更明确地感到自我责任和自己对集体的影响，更容易从集体获得满足感。从而更为节制。因此，也有些政治理论家和社会心理学家建议将公共资源划分为较小的单位。</li>
<li>在小范围内的公共资源，可以采用<strong>沟通</strong>的方式，开放、坦诚而明确的交流可以消除不信任，产生合作行为</li>
<li>在社会范围倡导利他规范，当合作行为可以<strong>明显增进公共福利</strong>时，个人就更可能表现出符合社会规范的行为</li>
</ul>
<h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><p>竞争是个人和个人之间极为常见的引发冲突的因素。竞争可以加强知觉到的差异，并<strong>引发更多的攻击行为</strong>。在谢里夫的山贼洞夏令营实验中，分胜负的竞争活动带来了激烈的冲突、对别组成员的歧视、组内强烈的团结意识和集体荣誉感。另外，群体极化又会加剧冲突。</p>
<p>在以下两种情况下，竞争更易于引发冲突：</p>
<ul>
<li>人们知觉到诸如金钱、工作岗位等资源时<strong>有限</strong>，<strong>零和</strong>时</li>
<li>一个明显成为潜在竞争者的外部团体</li>
</ul>
<h4 id="知觉到的不公正"><a href="#知觉到的不公正" class="headerlink" title="知觉到的不公正"></a>知觉到的不公正</h4><p>每个人对于公平的定义都不同，大体上可以分为<strong>根据付出分配</strong>和<strong>根据需要分配</strong>（共产主义）。</p>
<p>在实验中，人们通常不会<em>主动</em>要求对自己或自己所在团体给予优待，但是当他们接受更多好处时，往往会欣然接受，并相信他们获得的就是他们应得的。占了便宜的个人和小组，有的会产生<strong>负罪感</strong>，从而引发道歉或提供补偿，有的则通过贬低他人的付出来缓解自己的罪恶感。对于那些利益受损者，他们或<strong>接受并认同</strong>，或<strong>寻求其他补偿</strong>，或<strong>通过报复</strong>来获得心理平衡。</p>
<p>有意思的是，一个人越是对自我投入评价越高，就越会感到怀才不遇且意图报复。女性更经常视自己和男性平等时，她们的相对剥夺感也越强。</p>
<h4 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h4><p>本章开头介绍冲突概念时，特意强调了“被知觉到”一词。实际上，由于下面一些因素，我们经常有误解的不一致性。</p>
<ul>
<li><strong>自我服务偏见</strong>会高估自己做的好事，却不为自己做的坏事负责任</li>
<li><strong>自我合理化</strong>让人们倾向于否认自己的错误</li>
<li><strong>基本归因偏差</strong>使冲突的双方都把对方的敌意行为归因于他们邪恶的品质</li>
<li><strong>群体思维</strong>会在群体中固化利己、自我合理化和群体偏见，从而形成难以改变的<strong>刻板印象</strong>。</li>
</ul>
<p>在冲突双方的眼里，对方的形象都是被扭曲的：</p>
<ul>
<li>把自己的目标看得最重要</li>
<li>为“我们”感到骄傲，贬低“他们”</li>
<li>坚信自己利益被损害</li>
<li>强调对集体的热爱、团结和忠诚</li>
<li>鼓励自我牺牲，压制批评</li>
</ul>
<p><strong>镜像知觉</strong></p>
<p>在冲突中，扭曲的误解可以达到惊人的一致性，如美苏冷战中双方国民对对方国家的印象。在冲突被双方知觉到时，至少有一方对另一方存在误解，伴随自我证实的预言，双方的敌意程度会在恶性循环中加深。这种负面的<strong>镜像知觉</strong>很多时候会成为通往和平的障碍——冲突的一方认为和自己持相反立场的攻击者的攻击动机显示了他们嗜血的本性，而与自己信仰相同的攻击者则不过是自卫或还击而已。</p>
<p>津巴多指出，冲突会将世界一分为二，即好人和坏人，非黑即白，冲突中对立的双方常常<strong>夸大这种差异</strong>。换位思考可以缓解这种趋势，但绝非易事。激化冲突的另一错误观念是“领导邪恶——民众善良论”，即领导阶级是邪恶的，他们控制和操纵着善良的民众。在台独、港独问题上就能很容易发现这点。</p>
<p><strong>简单化思维</strong></p>
<p>冲突形势越紧张，理智的思考变得困难。对敌人的看法也会变得更简化和刻板，如经验式的判断。在大战爆发、军事冲突、革命前，发起攻击的领导者会表现出愈加简化的思维方式，有个原因是这样更有助于传达给群众，和让群众理解。</p>
<p><strong>知觉转化</strong></p>
<p>误解程度会伴随冲突程度起伏变化。比如国家间的关系也会影响国民对其他国家的认识和观念。</p>
<p>从上面可以发现，在我们能够抛开偏见，并解决实际存在的分歧时才能结束冲突。一个忠告是，<strong>在冲突中不要认为别人和你在价值观和道德上格格不入</strong>，进行换位思考。</p>
<h3 id="获得和平"><a href="#获得和平" class="headerlink" title="获得和平"></a>获得和平</h3><p>上面提到冲突因何而起（社会困境、激烈竞争、知觉到的不公正、误解），解决冲突也有4个建议，简称4C：</p>
<ul>
<li>接触，contact</li>
<li>合作，cooperation</li>
<li>沟通，communication</li>
<li>调和，conciliation</li>
</ul>
<h4 id="接触"><a href="#接触" class="headerlink" title="接触"></a>接触</h4><p>在紧张程度不是很高时，可以通过接触增进相互了解，以期获得和平。</p>
<ul>
<li>接近性和曝光效应使我们更喜欢接触更多的人</li>
<li>“行为验证态度”让我们暗示自己，达到缓和效果</li>
</ul>
<p>以种族隔离为例，种族接触可以减少种族歧视，实验发现，在种族以外，<strong>接触也能够预测偏见的减少</strong>。但是，情况不总是这样，很多国际学生交流项目并不能使学生对居住国产生所预期的积极影响。接触也需要有一些其他限制条件配合才能改善种族态度，如<strong>友谊</strong>和<strong>平等接触</strong>。</p>
<p>和其他群体建立的友谊的人，往往容易对这些群体产生积极的态度，这种情感纽带降低了焦虑。友谊是成功接触的关键。另外，接触需要是平等的，如果接触是竞争性的，或不平等的，那么结果反而会恶化，比如主人和仆人，狱警和囚犯。反例则是同事、同学、邻居等。种族多样化引起的非正式班内互动可以促进致力提高和对差异化的更大程度接受。</p>
<h4 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h4><p><strong>共同的外部威胁</strong>或<strong>超级目标</strong>可以建立起内部团结和合作。</p>
<p>民族间的冲突会提高民族自尊心，在战争时期面对一个明确的外部威胁时，我们的群体归属感会极度高涨，小布什在911时期的民众支持率从51%飙升到90%。因为这一点，甚至有时候，领导人会<strong>刻意创造出一个假想敌来提高民族凝聚力</strong>，奥威尔《1984》里的老大哥就是这么做的。在现实生活中，一个共同的强大的敌人也是一种强大的凝聚力量，《三体》中三体星人的入侵就带来了全人类的空前凝聚。</p>
<p>另一种凝聚力量是<strong>超级目标</strong>，即集中力量办大事。谢里夫实验中，最后通过修复水管、解决骑车抛锚等问题，又降低了团员们的敌意，使他们变回了朋友。成年人和谢里夫实验中的小男孩是一样的。一起工作对分解小团体，建立一个更大的更具包容性的团体很有用。当然，合作需要是<strong>成功的</strong>，失败的合作反而会恶化冲突。</p>
<p>由于人们天然的社会性，我们的自我概念中除了我是谁，还包括我们的社会同一性，即我们是谁，能强化自我概念和自豪感，我们“是谁”也暗示了我们“不是谁”。<strong>内群体偏见</strong>有时会造成冲突，并在群体极化下演变成暴力行为，比如球迷间的斗殴。伴随成功，人们的群体认同也会高涨，电竞战队获胜会为它带来更多粉丝。为了促进“内群体一致性”，很多学校都强制要求身着校服，消除小群体竞争，增进合作。</p>
<p>除了上面两例，<strong>合作性学习</strong>也能够改善个体间关系，减少冲突，改善种族态度。相对于传统的、充满竞争的学校里学习的学生，在学习参加混合民族学习小组的学生，有更好的种族态度。合作性学习有助于建立更亲密接触，产生户主和支持的关系。“拼图”式学习即把学生分为小组，拆分任务为小部分，组内每个学生各自承担一部分，自行学习后将学习成果教授给其他成员，共同完成对学习材料的学习。其中每个小组成员都会感受到自己的必要性，这种相互帮助的气氛也使成员对同伴更加喜爱。</p>
<p>上面提到的共同敌人、超级目标和合作性学习总结起来就是，<strong>为实现一个目标而进行平等的接触</strong>。</p>
<p>我们每天都在处理各种各样的社会身份，我们的自豪感需要我们用户更广泛群体、民族的身份认同。在种族多元化的文化中，尤其是历史并不悠久的国家中，种族身份和国家身份同时存在，人们需要平衡它们之间的关系。有时需要通过提出一致的理想来推广公民身份的认同，如美国的“合众为一”。</p>
<h4 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h4><p>沟通也可以分为几种形式：<strong>谈判</strong>，<strong>调解</strong>，<strong>仲裁</strong>。</p>
<p>谈判并不总能达到双赢的结果，有时迟到的协议会造成双输的后果</p>
<p>第三方调解人可以让冲突双方做出让步并挽回面子。调解人需要让他们暂时放弃冲突中的自身需求，把非输既赢变成“双赢”。克制的沟通可以减少自我证实的误解，有时<strong>建设性地解决冲突比保持沉默能带来更多和谐</strong>。</p>
<p>那么如何界定建设性的争吵呢：</p>
<ul>
<li>不要过早道歉</li>
<li>不要保持沉默，或逃离现场</li>
<li>不要引入无关话题</li>
<li>不要人身攻击</li>
<li>不要假装同意</li>
<li>要私下争吵，避开他人</li>
<li>要清晰界定问题</li>
<li>要接受对自己的反馈</li>
<li>澄清自己的态度，直面问题</li>
<li>提问以引导对方表达其观点</li>
<li>等待对方平静下来</li>
<li>提出双方都满意的建议</li>
</ul>
<p>冲突达到建设性结果，一定程度建立在<em>信任</em>的基础上。双方互不信任时，就需要第三方调解的介入。调解人需要建立一种情境，帮助双方理解对方，并感到被对方理解。中立的第三方还可以提出双方都接受的建议。</p>
<p>如果冲突连调解都无法解决，就需要<em>仲裁</em>来给出一个确定方案，大多数的争论者都会陷入过度乐观，即相信仲裁结果对自己有利。</p>
<h4 id="和解"><a href="#和解" class="headerlink" title="和解"></a>和解</h4><p>和解是双方面的，单方的妥协让步是行不通的。Charles Osgood提出了GRIT方案：逐步（Graduat），互惠（reciprocat），主动（initiative）地减少紧张（tension reduction）。GRIT要求一方在宣布希望调和的愿望时，做出一些小的意在降低冲突的行为。和解行动并不需要发起者在某一领域做出大的牺牲，但是要保持“坚定、公平、友善”。在实验室里进行的长期的两难实验中，“投桃报李”策略被证明是成功的（《自私的基因》中也有提到）。</p>
<p>和解行动可以使双方从紧张的台阶下来，使接触、合作、沟通重新变得可能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/blog/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">30:45</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/12/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">155</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">476</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/25/dart-best-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/25/dart-best-practice/" class="post-title-link" itemprop="url">Dart快速入门 效率篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-06-25 00:51:28 / 修改时间：00:54:59" itemprop="dateCreated datePublished" datetime="2019-06-25T00:51:28+08:00">2019-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/25/dart-best-practice/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/25/dart-best-practice/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考自<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/effective-dart">Effective Dart</a>，截至2019&#x2F;06&#x2F;12</p>
</blockquote>
<h2 id="通用原则"><a href="#通用原则" class="headerlink" title="通用原则"></a>通用原则</h2><p>类似其他编程语言，有下面两点注意事项：</p>
<ul>
<li>Be consistent, 统一风格</li>
<li>Be brief, 保持精简，DRY</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>指南以下面的关键词开头：</p>
<ul>
<li><strong>要</strong>，一定遵守，下面没有前缀的就是以此开头</li>
<li><strong>不要</strong>，这么做不是个好主意</li>
<li><strong>推荐</strong>，应该遵守，当不遵守时确保有合理理由</li>
<li><strong>避免</strong>，和上面相反，除非有足够好的理由，否则不应该这么做</li>
<li><strong>考虑</strong>，根据实际情况而定</li>
</ul>
<p>同时会提到下面这些客体：</p>
<ul>
<li><strong>库成员</strong>，顶级变量、getter、setter、函数</li>
<li><strong>类成员</strong>，类变量、getter、setter、函数</li>
<li><strong>成员</strong>，库成员或类成员</li>
<li><strong>变量</strong></li>
<li><strong>属性</strong>，类中的成员变量、getter、setter，顶级变量、getter、setter</li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>类名用UpperCamelCase风格</li>
<li>库和文件名用lowercase_with_underscores风格</li>
<li>导入前缀用lowercase_with_underscores风格<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:javascript_utils/javascript_utils.dart&#x27;</span> <span class="keyword">as</span> js_utils;</span><br></pre></td></tr></table></figure></li>
<li>其他标识符使用lowerCamelCase风格</li>
<li><strong>推荐</strong>使用lowerCamelCase风格命名常量<ul>
<li>原因：CAPS_STYLE可读性差&#x2F;可能会用于final变量&#x2F;和枚举不搭</li>
</ul>
</li>
<li>把超过2个字母的缩略词当做一般单词来做首字母大写<ul>
<li>原因：提高可读性</li>
</ul>
</li>
<li><strong>不要</strong>在标识符前加前缀<ul>
<li>举例：<code>kTimes</code></li>
</ul>
</li>
</ul>
<h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><ul>
<li>把”dart:”导入语句放在最前</li>
<li>把”package:”放在相对导入前</li>
<li><strong>推荐</strong>把第三方”package:”导入放在其他语句前</li>
<li>export语句放在最后</li>
<li>按字母序排序</li>
</ul>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><ul>
<li>使用dartfmt帮你美化</li>
<li><strong>考虑</strong>让你的代码更容易美化</li>
<li><strong>避免</strong>每行超过80字符</li>
<li>所有控制结构都使用大括号<ul>
<li>只有if语句写成1行时可以省略</li>
</ul>
</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>使用句子的形式表达注释</li>
<li>用单行注释符表达注释</li>
</ul>
<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><ul>
<li>用<code>///</code>表达文档注释</li>
<li><strong>推荐</strong>为公开API书写注释</li>
<li><strong>考虑</strong>为私有API书写注释</li>
<li>用一句话为文档注释开头</li>
<li>类似git commit message，第一行后空出一行独立成段</li>
<li>去掉能从上下文直接读出的冗余信息</li>
<li><strong>推荐</strong>使用第三人称动词开头表示函数、方法注释</li>
<li><strong>推荐</strong>使用名词短语开头表示变量、成员、getter、setter注释</li>
<li><strong>推荐</strong>使用名词短语开头表示库、类型注释</li>
<li><strong>考虑</strong>在注释中添加示例代码</li>
<li>在注释中用<code>[]</code>方括号引用作用域里的标识符</li>
<li>使用简短平实的语言描述参数、返回值和异常</li>
<li>在注解（annotation）前添加注释</li>
</ul>
<h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p>Dart允许在comment中使用Markdown格式。</p>
<ul>
<li><strong>避免</strong>滥用markdown</li>
<li><strong>避免</strong>使用html格式化文本</li>
<li><strong>推荐</strong>使用反引号（```）格式化代码</li>
</ul>
<h4 id="行文"><a href="#行文" class="headerlink" title="行文"></a>行文</h4><ul>
<li><strong>推荐</strong>简洁清晰</li>
<li><strong>避免</strong>使用缩写和首字母缩略词</li>
<li><strong>推荐</strong>使用“this”而不是“the”来引用实例成员</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>下面的规则是书写Dart代码时需要知道的指导原则，尤其是维护你类库的人。</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><ul>
<li><p>出于历史原因，Dart允许通过<code>part of</code>的方式使用库的一部分文件，使用时通过路径而不是变量名引用</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> my_library;</span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">part</span> of <span class="string">&quot;../../my_library.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">part</span> of my_library</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要从库的<code>src</code>文件夹下引用代码</p>
</li>
<li><p><strong>推荐</strong>使用相对路径应用库，但是不要跨<code>src</code>文件夹引用</p>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>在长字符串场景下，使用邻接字符串而不是“+”链接<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line">raiseAlarm(</span><br><span class="line">    <span class="string">&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27;</span></span><br><span class="line">    <span class="string">&#x27;parts are overrun by martians. Unclear which are which.&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>推荐</strong>使用插值构造字符串</li>
<li><strong>避免</strong>在插值中使用多余的大括号（对于简单的变量）</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li>尽可能使用字面量形式定义集合，必要时提供泛型类型即可<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">var</span> points = [];</span><br><span class="line"><span class="keyword">var</span> userMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">var</span> userMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure></li>
<li>不使用length属性判断集合是否为空，Dart提供了<code>isEmpty</code>和<code>isNotEmpty</code></li>
<li><strong>考虑</strong>使用高阶函数来明确表达你的意图<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aquaticNames = animals</span><br><span class="line">    .where((animal) =&gt; animal.isAquatic)</span><br><span class="line">    .map((animal) =&gt; animal.name);</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>在<code>Iterable.forEach()</code>中使用函数声明，Dart里的<code>for-in</code>循环可以很好完成该工作，当然函数本身已经定义好除外。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> person <span class="keyword">in</span> people) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">people.forEach(<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure></li>
<li>使用<code>iterable.toList</code>替代<code>List.from</code>，只在改变list类型时使用<code>List.from</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a List&lt;int&gt;:</span></span><br><span class="line"><span class="keyword">var</span> iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints &quot;List&lt;int&gt;&quot;:</span></span><br><span class="line"><span class="built_in">print</span>(iterable.toList().runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints &quot;List&lt;dynamic&gt;&quot;:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">List</span>.from(iterable).runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use it with a type</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4</span>]; <span class="comment">// List&lt;num&gt;.</span></span><br><span class="line">numbers.removeAt(<span class="number">1</span>); <span class="comment">// Now it only contains integers.</span></span><br><span class="line"><span class="keyword">var</span> ints = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.from(numbers);</span><br></pre></td></tr></table></figure></li>
<li>使用高级的<code>whereType</code>方法从collection中过滤出特定类型元素<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> ints = objects.whereType&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li>有类似用法时，不使用<code>cast()</code>方法<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuff = &lt;<span class="built_in">dynamic</span>&gt;[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="keyword">var</span> ints = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.from(stuff);</span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">var</span> ints = stuff.toList().cast&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>使用<code>cast()</code>方法，用该方法可能更慢且更有风险，通常情况下有下面一些备选方案<ul>
<li>创建有正确类型的list</li>
<li>使用每个集合元素时进行casting操作<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="keyword">void</span> printEvens(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objects) &#123;</span><br><span class="line">  <span class="comment">// We happen to know the list only contains ints.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> objects) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((n <span class="keyword">as</span> <span class="built_in">int</span>).isEven) <span class="built_in">print</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">void</span> printEvens(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objects) &#123;</span><br><span class="line">  <span class="comment">// We happen to know the list only contains ints.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> objects.cast&lt;<span class="built_in">int</span>&gt;()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n.isEven) <span class="built_in">print</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>真正想要强制类型转换时，使用附加类型的<code>List.from</code></li>
</ul>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>使用函数声明形式命名有名函数（不要使用lambda表达式）</li>
<li>当有有名函数可以完成任务时，不要创建lambda表达式<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line">names.forEach(<span class="built_in">print</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line">names.forEach((name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>使用<code>=</code>分隔入参和它的默认值</li>
<li>不要显式地使用<code>null</code>作为默认值（直接不指定即可）<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> error([<span class="built_in">String</span> message]) &#123;</span><br><span class="line">  stderr.write(message ?? <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>不要显式地使用null初始化变量（语言保证了行为可靠性，不需要再显式设置成null）</li>
<li>不要存储computed value（即可以推算出的值） ，减少冗余信息，保证数据唯一可信源，使用getter和setter去动态推导出它们</li>
<li><strong>考虑</strong>忽略局部变量的类型，Dart有强大的静态分析工具帮你推断类型。</li>
</ul>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><ul>
<li>不要创建没必要的getter和setter</li>
<li><strong>推荐</strong>使用final限定只读属性</li>
<li><strong>考虑</strong>使用<code>=&gt;</code>实现只有单一返回语句的函数，对于多行语句建议还是老老实实使用花括号<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> width =&gt; right - left;</span><br><span class="line"><span class="built_in">bool</span> ready(<span class="built_in">num</span> time) =&gt; minTime == <span class="keyword">null</span> || minTime &lt;= time;</span><br><span class="line">containsValue(<span class="built_in">String</span> value) =&gt; getValues().contains(value);</span><br></pre></td></tr></table></figure></li>
<li>不要使用<code>this.</code>访问成员，除非遇到变量冲突<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    update(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> update(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> update(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尽可能地在定义变量时初始化该值</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>尽可能使用更简洁的初始化形式<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要在初始化形式中定义类型</li>
<li>使用<code>;</code>代替<code>&#123;&#125;</code>表示空方法<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要使用可选的<code>new</code>来返回一个对象<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(<span class="string">&#x27;Increment&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      Text(<span class="string">&#x27;Click!&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要无谓地使用<code>const</code>（基本上const可能出现在所有你能使用<code>new</code>的地方），因为有些语境已经隐式包含了const语义<ul>
<li>字面量集合</li>
<li>const构造函数调用</li>
<li>metadata注解</li>
<li>switch的每一个case</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li>不要在<code>on</code>以外的语句中丢弃错误，因为在没有<code>on</code>限定时，catch会捕获<em>所有</em>异常</li>
<li>要只在编程错误时抛出Error的异常</li>
<li>不要显式地捕获Error及其子类</li>
<li>使用<code>rethrow</code>重新抛出异常</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li><strong>推荐</strong>使用<code>async</code>和<code>await</code>提升你的异步代码可读性</li>
<li>只在必要的时候使用<code>async</code><ul>
<li>代码块中使用了<code>await</code></li>
<li>希望返回一个Future</li>
<li>希望更方便地处理异步中出现的Error</li>
<li>异步事件发生具有先后顺序</li>
</ul>
</li>
<li><strong>考虑</strong>使用高阶函数处理stream</li>
<li><strong>避免</strong>直接使用<code>Completer</code></li>
<li>用<code>Future&lt;T&gt;</code>而不是<code>T</code>判断<code>FutureOr&lt;T&gt;</code>的具体类型</li>
</ul>
<h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>使用一致的术语</li>
<li><strong>避免</strong>缩写，只使用广为人知的缩写</li>
<li><strong>推荐</strong>把描述中心词放在最后</li>
<li><strong>考虑</strong>尽量让代码看起来像普通的句子</li>
<li><strong>推荐</strong>使用名词短语命名非布尔类型的成员或变量</li>
<li><strong>推荐</strong>使用非命令式短语命名布尔类型成员或变量<ul>
<li>比如配合be动词的不同时态，<code>isEnabled</code>, <code>hasShown</code>等</li>
<li>配合助动词，比如<code>hasChildren</code>, <code>canSave</code></li>
</ul>
</li>
<li>有可能的情况下，<strong>考虑</strong>省去上一种情况里的动词</li>
<li><strong>推荐</strong>使用正向含义的布尔类型变量&#x2F;方法名</li>
<li><strong>推荐</strong>使用命令式动词命名带有副作用的函数和方法</li>
<li><strong>考虑</strong>使用名词短语或非命令式动词命名返回数据为主要功能的方法或函数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.elementAt(<span class="number">3</span>)</span><br><span class="line">string.codeUnitAt(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>考虑</strong>使用命令式动词表示你需要对方法所做工作有所关心</li>
<li><strong>避免</strong>使用<em>get</em>开头的命名，它通常能用getter代替</li>
<li><strong>推荐</strong>使用<code>to___()</code>来命名类型转换</li>
<li><strong>推荐</strong>使用<code>as___()</code>来命名类型快照</li>
<li><strong>避免</strong>在命名中使用方法、函数的入参</li>
<li>使用助记符命名类型参数<ul>
<li><code>E</code>代表集合元素</li>
<li><code>K</code>和<code>V</code>代表key和value</li>
<li><code>R</code>代表return type</li>
<li><code>T</code>, <code>S</code>和<code>U</code>命名单一通用且上下文表意清晰的泛型</li>
<li>除上面情况外，可以使用完整词汇作为泛型类型名</li>
</ul>
</li>
</ul>
<h4 id="库-1"><a href="#库-1" class="headerlink" title="库"></a>库</h4><p>下划线开头的成员表示成员是私有的，这个特性是内置在Dart语言中的。</p>
<ul>
<li><strong>推荐</strong>使用私有声明，未用<code>_</code>开头的库中的公开声明、顶级定义表示其他库可以访问这些成员，同时也会受到库实现契约的约束。</li>
<li><strong>考虑</strong>在同一个库内定义多个类，这样便于在类之间共享私有变量</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>Dart是纯OOP的语言，它的所有对象都是类实例。当然不像Java，Dart也允许你定义顶级的变量、函数…</p>
<ul>
<li><strong>避免</strong>定义一个函数就可以实现的只有一个实现方法的抽象类<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Predicate&lt;E&gt; = <span class="built_in">bool</span> <span class="built_in">Function</span>(E element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> test(E element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>定义只有静态成员的类，可以使用顶级变量、函数更方便地实现等价效果。当然，如果变量属于一个组，可以这么实现</li>
<li><strong>避免</strong>不必要地定义子类</li>
<li><strong>避免</strong>实现一个不作为接口的类</li>
<li><strong>避免</strong>mixin不设计用作mixin的类</li>
<li>在你的类支持拓展时，定义好文档</li>
<li>在你的类作为接口存在时，定义好文档</li>
<li>在你的类作为mixin存在时，定义好文档</li>
</ul>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><strong>考虑</strong>在类支持的情况下，让构造函数成为const</li>
</ul>
<h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><ul>
<li><strong>考虑</strong>尽可能地把成员变量和顶级变量定义为final类型</li>
<li>使用setter和getter定义computed value</li>
<li>不要使用没有getter的setter</li>
<li><strong>避免</strong>在返回bool，double，int，num的方法里返回null</li>
<li><strong>避免</strong>在方法中返回this，只为了串联调用函数</li>
</ul>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>Dart中的类型可以帮助使用者理解你API中的静态类型设计，它分两种：类型注解和类型参数。前一种放在变量名前注解变量类型，后一种作为泛型参数传入。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">String</span> parameter) &#123;</span><br><span class="line">  <span class="built_in">bool</span> result = parameter.length == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; ints = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>在未指定类型时，Dart会从上下文自动推断或者使用缺省的<code>dynamic</code>类型。</p>
<p>简言之，Dart提供了强大的类型推导简化了你声明类型的负担，但同时不声明类型会降低API的可读性，下面一些guideline帮你在两点间找到一个平衡。</p>
<ul>
<li><strong>推荐</strong>对于类型表意不清晰的public属性和顶级变量使用类型注解<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">bool</span>&gt; install(PackageId id, <span class="built_in">String</span> destination) =&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> screenWidth = <span class="number">640</span>; <span class="comment">// Inferred as int.</span></span><br></pre></td></tr></table></figure></li>
<li><strong>考虑</strong>对于类型表意不清晰的private属性添加类型注解</li>
<li><strong>避免</strong>为局部变量添加类型注解，如果你需要静态类型提供的便利，可以借助<code>is</code>限制变量类型</li>
<li><strong>避免</strong>在方法表达式上使用类型，考虑到方法表达式通常作为方法入参，类型可以自动推断，不需要类型注解</li>
<li><strong>避免</strong>冗余的泛型和类型注解<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; things = <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; things = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li>在不希望使用Dart推断的类型时，使用类型注解</li>
<li><strong>推荐</strong>使用显示的dynamic代替Dart推断失败回退的dynamic</li>
<li><strong>推荐</strong>在Function类型注解中添加函数类型签名</li>
<li>不要为setter指定返回值</li>
<li>使用新式的typeof判断类型<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Comparison&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T, T);</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Object</code>代替<code>dynamic</code>表示可以接受任何对象</li>
<li>使用<code>Future&lt;void&gt;</code>作为无返回值的异步函数返回类型</li>
<li>不使用<code>FutureOr&lt;T&gt;</code>作为返回值</li>
</ul>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>避免</strong>位置参数作为可选布尔参数，这样可读性比较差<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">new</span> Task(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Task(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">new</span> ListBox(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Button(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good case</span></span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>将用户想忽略的参数放在位置可选参数的前列</li>
<li><strong>避免</strong>使用强制的无意义的参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad case</span></span><br><span class="line">string.substring(start, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></li>
<li>使用<strong>左闭右开</strong>区间表示两个参数代表的范围</li>
</ul>
<h4 id="相同判断"><a href="#相同判断" class="headerlink" title="相同判断"></a>相同判断</h4><ul>
<li>覆写<code>==</code>的同时覆写<code>hashCode</code>，默认的哈希函数实现了恒等式哈希。<strong>任何两个相等的两个对象必须具有相同的哈希值</strong>。</li>
<li><code>==</code>需要遵循数学的相等规则<ul>
<li>自反，a &#x3D;&#x3D; a</li>
<li>对称，a &#x3D;&#x3D; b &#x3D;&gt; b &#x3D;&#x3D; a</li>
<li>传递，a &#x3D;&#x3D; b &amp;&amp; b &#x3D;&#x3D; c &#x3D;&gt; a &#x3D;&#x3D; c</li>
</ul>
</li>
<li><strong>避免</strong>为可变对象自定义相等函数，<code>hashCode</code>函数会增加你的工作量</li>
<li>不要在自定义<code>==</code>中判断null，Dart也已经替你做了这部分工作</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/16/dart-lang-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/16/dart-lang-intro/" class="post-title-link" itemprop="url">Dart快速入门 语法篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-06-16 00:13:19 / 修改时间：00:17:49" itemprop="dateCreated datePublished" datetime="2019-06-16T00:13:19+08:00">2019-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/16/dart-lang-intro/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/16/dart-lang-intro/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义个方法。</span></span><br><span class="line">printNumber(<span class="built_in">num</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>.&#x27;</span>); <span class="comment">// 在控制台打印内容。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是程序执行的入口。</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 定义并初始化一个变量。</span></span><br><span class="line">  printNumber(number); <span class="comment">// 调用一个方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注释：<code>//</code>或<code>/* ... */</code>，同其他主流语言</li>
<li>类型：num、String、int、bool等</li>
<li>字面量：42，’Hello world!’</li>
<li>函数：类似<code>print()</code>的形式</li>
<li>字符串插值</li>
<li>入口方法：<code>main</code></li>
</ul>
<h2 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念"></a>基本理念</h2><ul>
<li><strong>所有可以用变量引用的都是对象，每个对象都是一个类的实例</strong>，例如数字、方法、null，<strong>所有对象都继承Object类</strong></li>
<li>Dart是<strong>强类型语言</strong>。但是不强制使用类型标注，因为它可以通过推导得到变量类型。在你明确不希望有类型时，使用<code>dynamic</code>关键字表示动态类型</li>
<li>Dart支持泛型，比如<code>List&lt;int&gt;</code></li>
<li>Dart支持顶级方法<code>main()</code>，支持类的静态方法、实例方法，也可以在函数内使用函数</li>
<li>类似地，Dart支持全局变量、局部变量和在类中定义的成员变量</li>
<li>Dart<strong>没有</strong>public、protected、private的区分，如果标识符以<code>_</code>开头，那么该标识符就是私有的</li>
<li>Dart的变量名只能以<strong>下划线和字母</strong>开头，后跟<strong>字符或数字</strong></li>
<li>Dart区分语句块和表达式，只有表达式有值。</li>
</ul>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>分为三类：</p>
<ul>
<li>对于只在特定上下文环境下生效的<strong>上下文关键字</strong>，可以用作标识符</li>
<li>对于<strong>内置标识符</strong>，为了便于移植JavaScript代码到Dart，这些关键字不可用作类或类型名或import的前缀</li>
<li>其他关键字为保留字</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Dart&#x27;</span>;</span><br><span class="line">Dynamic name = <span class="string">&#x27;Dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据<em>基本理念</em>，变量都是存储值的引用。使用<code>var</code>修饰时，变量类型会自动推导；也可以显示声明变量类型，或者使用<code>dynamic</code>关键字表示变量可能有多种类型。</p>
<p>任何没有初始化的变量默认值都为null。</p>
<p>常量使用<code>final</code>或<code>const</code>（实例变量只能用<code>final</code>）。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> title = <span class="string">&#x27;FE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> percent = <span class="number">0.314</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span>[];</span><br><span class="line"><span class="keyword">const</span> baz = []; <span class="comment">// 和上面一个效果</span></span><br></pre></td></tr></table></figure>

<ul>
<li>final变量只能赋值一次，const变量是编译时常量。</li>
<li><code>const</code>除了用来定义不变量，还可以用来创建不变的值，以及定义创建常量的构造函数。在这么用时可以省略构造过程，像上面的baz变量一样</li>
</ul>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists (也被称之为 arrays)</li>
<li>maps</li>
<li>runes (用于在字符串中表示 Unicode 字符)</li>
<li>symbols</li>
</ul>
<p>再次重申，Dart中变量都是一个对象，所以你都可以使用构造函数来初始化。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>有<code>int</code>和<code>double</code>两种类型。提供了原生操作符和<code>abs()</code>等常用函数，整数和浮点数的字面量初始化类似js。</p>
<p>字符串和数字互转：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(onePointOne == <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">&#x27;3.14&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Dart的字符串是UTF-16编码的字符序列。可以使用单引号或双引号创建。字符串中用<code>$&#123;expr&#125;</code>的语法使用表达式，**如果表达式是一个标识符，可以省去<code>&#123;&#125;</code>**，对<code>&#123;&#125;</code>内的表达式，Dart使用<code>toString()</code>方法转成字符串使用。</p>
<p>使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>表示多行字符串。使用<code>r&#39;&#39;</code>表示纯字符串。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>布尔类型有两个字面量值，<code>true</code>和<code>false</code>。和JavaScript不同的是，在<code>if</code>语句等使用bool类型的地方，<strong>只有<code>true</code>被认为是true，其余所有值都是false</strong>。这也是为了避免JavaScript中判断true、false时坑爹的地方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;JS prints this line.&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Dart in production mode prints this line.&#x27;</span>);</span><br><span class="line">  <span class="comment">// However, in checked mode, if (1) throws an</span></span><br><span class="line">  <span class="comment">// exception because 1 is not boolean.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List的字面量写法和JavaScript一样。Dart会做类型推导，在元素类型不一致时报错。你可以使用const语句定义一个不变的List对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>2.3后，Dart支持<code>...</code>解构操作符，以及对空列表兼容的<code>...?</code>。同时支持collection if和collection for语法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = [</span><br><span class="line">  <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Furniture&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Plants&#x27;</span>,</span><br><span class="line">  <span class="keyword">if</span> (promoActive) <span class="string">&#x27;Outlet&#x27;</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> listOfInts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> listOfStrings = [</span><br><span class="line">  <span class="string">&#x27;#0&#x27;</span>,</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> listOfInts) <span class="string">&#x27;#<span class="subst">$i</span>&#x27;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>2.2版本后支持</p>
</blockquote>
<p>一组元素唯一的无序列表。字面量写法类似数学中集合的定义方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> halogens = &#123;<span class="string">&#x27;fluorine&#x27;</span>, <span class="string">&#x27;chlorine&#x27;</span>, <span class="string">&#x27;bromine&#x27;</span>, <span class="string">&#x27;iodine&#x27;</span>, <span class="string">&#x27;astatine&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用构造函数的方式创建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line">elements.add(<span class="string">&#x27;fluorine&#x27;</span>);</span><br><span class="line">elements.addAll(halogens);</span><br></pre></td></tr></table></figure>

<p>类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>表达键值对数据，每个键只出现一次，且<strong>可以是任意类型</strong>。类似Set，可以使用字面量和构造函数两种方式构造。使用字面量时，Dart会做类型推导。</p>
<p>Map的设置和JavaScript类似，另外类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>
<h3 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h3><p>Dart用Rune类型表示UTF-32的字符，如emoji等。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>用来代表Dart中声明的操作符或标识符，可以在标识符前添加<code>#</code>获取标识符的Symbol对象。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>类似JavaScript，Dart中的Function也是对象并具有Function类型。推荐使用显式类型声明方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dart支持箭头函数。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数分两种：命名参数、位置参数。</p>
<p>命名参数使用<code>param: value</code>指定，在调用时使用<code>&#123;param1, param2&#125;</code>的形式传递参数。支持在参数前添加<code>@required</code>表示参数必选。</p>
<p>位置参数使用<code>[]</code>包裹方法参数，使用时不传参数即可。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>定义方法时，可以使用<code>=</code>定义可选参数的默认值。否则默认值为null。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>每个应用都需要有顶级的<code>main()</code>函数作为入口，返回值void类型，并且有可选的<code>List&lt;String&gt;</code>参数（用于解析命令行输入的参数数据）。如</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">&quot;#sample_text_id&quot;</span>)</span><br><span class="line">    ..text = <span class="string">&quot;Click me!&quot;</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>..</code>语法为级联调用，表示在一个对象上执行多个操作。</p>
</blockquote>
<h3 id="第一公民"><a href="#第一公民" class="headerlink" title="第一公民"></a>第一公民</h3><p>类似JavaScript，Dart中Function可以作为参数、返回值、变量、对象使用。同样也有匿名函数可以使用，区别是箭头后是语句块时，不使用箭头，只在之后是表达式时使用箭头。</p>
<h3 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h3><p>Dart是静态作用域，即变量的作用域在写代码时就确定了，作用域层级即大括号的层级。</p>
<p>类似JavaScript，Dart的闭包意味着方法可以封闭其作用域内的变量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Returns a function that adds [addBy] to the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">function&#x27;s argument.</span></span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// Create a function that adds 2.</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function that adds 4.</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>所有函数<strong>必须返回一个值</strong>，否则默认<code>return null</code>。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li><code>~/</code>返回取整截断的商</li>
<li>使用<code>==</code>判断相等性<ul>
<li>会调用左侧对象的<code>==</code>方法，和后面的对象对比</li>
</ul>
</li>
<li>类型转换：<ul>
<li><code>as</code>，类型转换，类似typescript中的as</li>
<li><code>is</code> 判断对象是否是指定类型</li>
<li><code>is!</code> 判断对象是否不是指定类型</li>
</ul>
</li>
<li><code>??=</code>在value不是null时赋值给变量</li>
<li><code>expr1 ?? expr2</code>表示如果expr1是非null则返回其值，否则执行expr2并返回</li>
<li><code>..</code> 级联操作符，表示在一个对象上连续调用多个函数以及访问成员变量，可以嵌套</li>
<li><code>?.</code>和<code>.</code>类似，但是在左侧操作对象为null时返回null<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>for循环中，Dart会自动捕获当时的index索引值，避免JavaScript中问题。对interable的对象可以使用<code>forEach()</code>方法遍历，对List、Set还支持<code>for-in</code>形式的遍历</li>
<li><code>switch</code>中的每个case（除了空case）都必须有<code>break</code></li>
<li><code>assert</code>在检查模式下会被跳过</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>和JavaScript中的异常类似。</p>
<p>不一样的是，可以使用<code>on</code>或<code>catch</code>捕获异常，可以通过<code>rethrow</code>在其中重新抛出异常。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>构造方式类似ES6中引入JavaScript Class。</li>
<li>用成员方式声明的类变量在定义时初始化，也就是在构造函数前</li>
<li>可以使用Object的runtimeType属性来判断实例的类型</li>
<li>使用const关键字结合构造函数可以构造出不可变的对象实例</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>使用和类名同名的方法作为构造函数（或者使用<em>命名构造函数</em>）。因为把构造函数参数赋值给实例变量的场景太常见了，Dart提供了下面的语法糖。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用命名构造函数实现多个构造函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    y = json[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类不会从父类继承构造函数</strong>，在未定义构造函数时，会有一个默认构造函数，这个函数没有参数，且会调起父类的没有参数的构造函数。</p>
<p>在有初始化参数列表（initializer list）的情况下，初始化参数列表在父类构造函数前执行。</p>
<ol>
<li>初始化参数列表</li>
<li>父类无参构造函数</li>
<li>子类无参构造函数</li>
</ol>
<p>父类没有无参构造函数时，需要手动调用父类的其他构造函数。</p>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>在执行父类构造函数前，可以初始化实例参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initializer list sets instance variables before</span></span><br><span class="line">  <span class="comment">// the constructor body runs.</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">        y = jsonMap[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在冒号右边用逗号隔开初始化表达式。注意：等号右边无法访问<code>this</code>。</p>
<h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>重定向构造函数没有代码，<strong>在构造函数声明后</strong>，用冒号调用其他构造函数</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果类支持提供状态不变的对象，需要定义一个<code>const</code>构造函数，且所有类变量都要是<code>final</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>当你的构造函数不需要返回新对象，而从其他地方获取时（如缓存），使用工厂构造函数。**工厂构造函数内无法访问<code>this</code>**。调用时方式和普通构造函数等同。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>类方法可以访问<code>this</code>，另外对于类对象的每个属性都有隐含的getter和setter（final除外）。也可以显式使用<code>get</code>和<code>set</code>定义getter和setter的行为。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Dart使用<code>extends</code>继承，用<code>super</code>指代父类，用<code>@overide</code>注解重载操作。</li>
<li>Dart中有抽象类&#x2F;抽象方法，设计和使用类似Java的抽象类&#x2F;抽象方法。如果你希望抽象类可实例化，可以定义一个工厂工造函数。</li>
<li>每个类都隐式的定义了一个包含所有实例成员的接口，通过使用<code>implement</code>实现若干其他类的API（不包括构造函数）</li>
<li>可以重载一些操作符，如<code>+</code>, <code>-</code>, <code>[]</code>, <code>&gt;&gt;</code>等，实现在特定类上的特定表现</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Overrides + (a + b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Overrides - (a - b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是，Dart提供<code>noSuchMethod()</code>方法，在访问不存在的类实例或方法时被调用。如果没有填写，默认使用Object的同名方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@proxy</span><br><span class="line">class A &#123;</span><br><span class="line">  void noSuchMethod(Invocation inv) &#123;</span><br><span class="line">     print(&#x27;You tried to use a non-existent member: &#x27; +</span><br><span class="line">        &#x27;$&#123;inv.memberName&#125;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是特殊的类，使用<code>enum</code>关键字定义。每个枚举值都有index属性的<code>getter</code>函数，枚举的<code>values</code>常量可以返回所有枚举值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>

<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>Dart中提供了<strong>多类继承</strong>中重用类代码的mixin，用<code>with</code>结合mixin类实现，这种类没有构造函数。除非你想像正常类一样使用mixin，否则使用<code>mixin</code>关键字。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当限制mixin只在特定类中使用时，结合<code>on</code>让mixin也能调用父类方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类变量、函数"><a href="#类变量、函数" class="headerlink" title="类变量、函数"></a>类变量、函数</h3><p>使用<code>static</code>前缀修饰，表示类级别的变量、函数。类变量只在第一次使用时初始化。静态方法无法访问this。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型的两个动机：</p>
<ul>
<li>有助于IDE、环境、同事帮你定位问题和代码自动生成</li>
<li>减少重复代码</li>
</ul>
<p>List和Map的泛型定义类似C++风格。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>: <span class="string">&#x27;Homepage&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>: <span class="string">&#x27;Hints for web robots&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>: <span class="string">&#x27;We are people, not machines&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">var</span> views = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在泛型中使用<code>extends</code>可以限制泛型的具体类型。在1.21之后，Dart支持泛型函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>使用<code>import</code>和<code>library</code>引入和导出模块。<code>_</code>开头的标识符只在库内部可见。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:mylib/mylib.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:utils/utils.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;  <span class="comment">// 指定库前缀，避免重名</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo; <span class="comment">// 部分导入</span></span><br></pre></td></tr></table></figure>

<p><code>dart:</code>开头代表内置库，<code>package:</code>开头代表外部库。外部库使用<code>pub</code>包管理器管理。</p>
<h3 id="懒加载库"><a href="#懒加载库" class="headerlink" title="懒加载库"></a>懒加载库</h3><p>懒加载即在使用时再加载库，如优化app启动时间，加载很可能用不到的功能。</p>
<p>加载时使用<code>deferred as</code>导入，使用<code>loadLibrary()</code>方法加载。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:deferred/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p>Dart中返回<code>Future</code>和<code>Stream</code>的方法都是异步的，意味着设置好耗时操作（I&#x2F;O）后就返回。类似ES7中的<code>await</code>和<code>async</code>，你也可以像组织同步代码一样组织你的异步代码。</p>
<p>Dart中声明异步方法是<strong>在函数名后加入async</strong>，这类方法返回一个<code>Future</code>对象，了解JS中<code>Promise</code>的同学可以很快理解Future是做什么的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something else.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回值是Stream时，使用<code>await for</code>的形式接收Stream中的数据。另外别忘了用<code>async</code>修饰外界函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>惰性生产数据，类似ES6中的<code>function*</code>。Dart提供两种类型：</p>
<ul>
<li>同步：返回Iterator</li>
<li>异步：返回Stream</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可调用的类"><a href="#可调用的类" class="headerlink" title="可调用的类"></a>可调用的类</h2><p>类中实现了<code>call()</code>方法时，类实例可以当做方法调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">wf(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类似typescript中的interface定义，Dart可以借助<code>typedef</code>进行一些更复杂的类型判断。typedef只是类型别名的一种说法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare); <span class="comment">// True!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>使用元数据给代码添加额外信息，也能便于文档自动生成。</p>
<ul>
<li><code>@deprecated</code></li>
<li><code>@override</code></li>
<li><code>@proxy</code></li>
</ul>
<p>你还可以自定义自己的元数据注解：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;todo.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@todo</span>(<span class="string">&#x27;seth&#x27;</span>, <span class="string">&#x27;make this do something&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行，<code>//</code></li>
<li>多行，<code>/**/</code></li>
<li>文档注释， <code>///</code>开头，或<code>/**</code>开头，<code>*/</code>结束</li>
</ul>
<p>遵守规范的注释风格会有助于文档自动生成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/05/28/the-pragmatic-programmer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/05/28/the-pragmatic-programmer/" class="post-title-link" itemprop="url">《程序员修炼之道》 —— 从小工到专家</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-28 23:55:53" itemprop="dateCreated datePublished" datetime="2019-05-28T23:55:53+08:00">2019-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-29 01:42:03" itemprop="dateModified" datetime="2019-05-29T01:42:03+08:00">2019-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/05/28/the-pragmatic-programmer/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/05/28/the-pragmatic-programmer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《程序员修炼之道》这个书名实际上不如原版《The Pragmatic Programmer： From Journeyman to Master》来得更清晰明了。此书第一版写于1999年，我看的是11年的版本，但还是透流露着不少世纪初的观念和视野。除开一部分观点认识的过时，书中绝大多数观点都四溢着国外互联网行业的工作风格和流程，和国内凶猛生长、一把梭就是干的风格各有不同，甚至我感觉国内IT，尤其是互联网企业里的工作流更加讲求实效。尽管和读之前的预期不大一样，里面许多经验还是很有借鉴意义，比如正交性、不要依赖巧合等等。</p>
<p>书中内容在项目管理、编程哲学、以及编程过程的各个方面都有涉及，在这些方面上更加深入的探讨，书的最后也推荐了继续阅读的材料。下面就各章节的关键观点加以整理。</p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>关于本书的读法：</p>
<ul>
<li>能不能让正确原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志</li>
<li>要能内化书中提到的各个小提示，不实践的话，是不会有太大收获的</li>
<li><strong>思考，你的工作</strong>，多思考</li>
</ul>
<h2 id="实效哲学"><a href="#实效哲学" class="headerlink" title="实效哲学"></a>实效哲学</h2><ul>
<li><strong>对你的源码负责</strong></li>
<li><strong>不要容忍破窗</strong>，它们会增大你软件的熵（这个也是要结合实际情况看的）</li>
<li><strong>记住大图景</strong>，注意方向是否有误，不要光低头做事</li>
<li><strong>知道在何时打住</strong>，你不可能做到完美</li>
<li><strong>定期为你的知识资产投资</strong>，就像经济投资一样<ul>
<li>定期投资</li>
<li>多元化</li>
<li>管理风险，不要把所有技术放在一个篮子里</li>
<li>低买高卖，能看清形势</li>
</ul>
</li>
<li>为此，你需要<ul>
<li><strong>每年至少学习一种新语言</strong></li>
<li><strong>每季度阅读一本技术书籍</strong></li>
<li>也要阅读非技术书籍</li>
</ul>
</li>
<li><strong>批判地思考你读到和听到的</strong></li>
<li><strong>如何表达自己很重要</strong>，这会增加你的影响力<ul>
<li>你想让谁知道</li>
<li>你想让他们知道什么</li>
<li>他们是否感兴趣</li>
<li>他们需要知道细节么</li>
<li>如何促使他们与你交流</li>
</ul>
</li>
</ul>
<h2 id="实效途径"><a href="#实效途径" class="headerlink" title="实效途径"></a>实效途径</h2><ul>
<li><strong>DRY，不要重复自己</strong><ul>
<li>强加的重复 &#x3D;&gt; 使用自动生成，减少是信息冗知识</li>
<li>无意的重复 &#x3D;&gt; 优良的设计</li>
<li>无耐心的重复 &#x3D;&gt; 考虑长远</li>
<li>开发者间的重复 &#x3D;&gt; 加强组内交流，制定代码规范，<strong>制造更容易复用的环境</strong></li>
</ul>
</li>
<li><strong>减少无关事物的影响</strong>，非正交 &#x3D;&gt; 次级效应 &#x3D;&gt; 补偿行为 &#x3D;&gt; 经验依赖<ul>
<li>好处：提高生产率（促进复用）、降低风险（风险隔离，易测试）</li>
<li>分层设计、抽象和接口约定</li>
<li>避免使用全局变量</li>
<li>考虑使用库的代码侵入性</li>
<li>文档和认同正交性</li>
</ul>
</li>
<li><em>不存在最终决策</em>，当需求变动频繁的时候，不仅要思考程序架构如何适应这种变动，也要反思是否是设计者没想清楚到底要做什么</li>
<li><strong>使用曳光弹找到目标</strong>，即MVP + 快速迭代 + 即时的反馈<ul>
<li>逐步逼近，摸着石头过河</li>
<li>曳光弹模式永远包含着一个可用的软件版本</li>
</ul>
</li>
<li><strong>原型和便笺</strong>，使用原型去表达和快速验证项目的可行性</li>
<li><strong>靠近问题领域编程</strong><ul>
<li>使用DSL（Domain Specified Language）</li>
</ul>
</li>
<li><strong>估算，以避免意外</strong>，主要用来估计工期、分析风险<ul>
<li>适当地降低估算速度，慎重思考隐藏的风险</li>
</ul>
</li>
</ul>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><p>工具成为双手和大脑的延伸，优秀的工具可以放大你的才干。</p>
<ul>
<li><strong>纯文本以其自解释能力几乎可以永久保存</strong>，XML、JSON就是利用此成为通用的数据表现形式</li>
<li><strong>利用shell的力量</strong>，它是自动化任务避不开的工具</li>
<li><strong>要能烂熟地使用你的编辑器</strong>、<strong>要使用高级的编辑器</strong>，由于你的所有开发工作都建立在它上面，做好这两点可以节省你大量时间<ul>
<li>反思一下，在用你的编辑器时，你有遇到过到比较繁琐的操作吗？</li>
<li>是因为你不会高级使用方式，还是编辑器本身不支持？</li>
</ul>
</li>
<li><em>总是使用源码控制</em>（这一点早已成为共识）</li>
<li>调试，debug<ul>
<li><strong>通常认为匪夷所思的bug，都来自健忘、自大和愚蠢</strong></li>
<li>QA角色的重要性之一：帮助复现、找到规律性</li>
<li>橡皮鸭调试法</li>
<li><strong>二分查找法</strong></li>
<li>如果bug来自某人的错误假设，那么需要清除团队其他人的相同误解</li>
</ul>
</li>
<li><strong>学习一种文本操纵语言或工具</strong>，例如awk，sed，处理数据和结果时一定能用上</li>
<li><strong>编写代码生成器</strong><ul>
<li>开发者手动触发，如模板代码</li>
<li>程序自动出发，如scheme to idl，idl to code</li>
</ul>
</li>
</ul>
<h2 id="偏执编程"><a href="#偏执编程" class="headerlink" title="偏执编程"></a>偏执编程</h2><ul>
<li><strong>通过合约设计</strong>，约定好接口，合作方基于接口开发<ul>
<li>强类型语言更容易实现这一点</li>
</ul>
</li>
<li><strong>早崩溃</strong>，这在需要编译的软件开发上比较科学，对于web应用来说却不是这样</li>
<li><strong>使用断言确保某事不会发生</strong>，减少预设条件代理的隐藏bug<ul>
<li>不要滥用断言</li>
</ul>
</li>
<li><strong>只在异常处用异常</strong></li>
<li><strong>一定记住释放请求的资源</strong>，如内存、句柄等，可以通过封装统一的资源类实现自动的资源释放</li>
</ul>
<h2 id="时间的魔力"><a href="#时间的魔力" class="headerlink" title="时间的魔力"></a>时间的魔力</h2><ul>
<li><strong>德墨忒尔法则</strong>，使模块间的依赖减少到最小<ul>
<li>物理解耦</li>
</ul>
</li>
<li><strong>要配置不要hardcode</strong>，使用元数据动态描述你的程序<ul>
<li><strong>抽象放进代码，细节放进元数据</strong></li>
</ul>
</li>
<li>时间耦合：考虑并发和事件的发生顺序<ul>
<li>在异步代码中，总考虑并发</li>
</ul>
</li>
<li>一些GUI的设计模式<ul>
<li>发布订阅</li>
<li>MVC</li>
</ul>
</li>
<li><strong>基于规则&#x2F;规则集的黑板系统</strong><ul>
<li>黑板给出统一接口</li>
<li>耦合方通过调用黑板接口避免耦合</li>
<li>黑板通过规则给出输出</li>
</ul>
</li>
</ul>
<h2 id="编码时"><a href="#编码时" class="headerlink" title="编码时"></a>编码时</h2><ul>
<li><strong>不要靠巧合编程</strong><ul>
<li>改动要有文档沉淀</li>
<li>只依靠文档中记录的行为</li>
<li>把你的假设记入文档</li>
</ul>
</li>
<li><strong>在大数据量时</strong>，考虑算法数量级<ul>
<li>兼顾效率和可读性</li>
</ul>
</li>
<li><strong>早重构，常重构</strong>，代码是业务设计的近似同构体，常重构才能保证代码完美贴合需求设计<ul>
<li>重构和功能开发分开进行</li>
<li>重构一定要有测试</li>
</ul>
</li>
<li>优秀的代码不是看新增了多少行，而是看删除了多少行</li>
<li>编写易于测试的代码<ul>
<li>测试你的软件，否则你的用户会代你做测试</li>
</ul>
</li>
</ul>
<h2 id="项目开始前"><a href="#项目开始前" class="headerlink" title="项目开始前"></a>项目开始前</h2><blockquote>
<p>完美，不是在没有什么需要增加，而是在没有什么需要去掉的时候达到的。</p>
</blockquote>
<ul>
<li>去挖掘需求，思考用户做特定事情的原因，和如何去做的方式，<strong>让需求成为一种一般性的陈述</strong><ul>
<li><strong>制作需求文档时的一大危险是太过具体，好的需求文档会保持抽象</strong></li>
<li>经常性复盘</li>
<li>鼓励文档分享和交流</li>
</ul>
</li>
<li><strong>巧妙解决看似不能解决的难题</strong>，关键要找到<strong>真正的约束</strong>，去思考<ul>
<li>有更容易的方法么</li>
<li>你是在解决真正的问题，还是被外围的技术问题转移了注意力</li>
<li>这件事为什么是一个问题</li>
<li>是什么让它难以解决</li>
<li>它必须这么做么</li>
<li>它必须完成么</li>
</ul>
</li>
<li><strong>准备好再开始，但不要让它成为你懈怠的借口</strong></li>
<li><strong>不要成为方法学的奴隶</strong></li>
</ul>
<h2 id="实效项目"><a href="#实效项目" class="headerlink" title="实效项目"></a>实效项目</h2><ul>
<li>团队建设<ul>
<li>不留破窗户（考验leader的管理能力）</li>
<li>经常性的复盘和例会</li>
<li>减少团队成员分工的冗余</li>
<li>自动化项目流程 &#x3D;&gt; 效率工程团队开发内部工具</li>
<li>制造context，给成员足够空间</li>
</ul>
</li>
<li><strong>不要使用手动流程</strong>，它不可控且难以复制<ul>
<li>shell、crontab</li>
<li>CI和自动化持续集成</li>
<li>代码生成</li>
<li>自动化测试</li>
<li>代码review和源码版本控制流程</li>
</ul>
</li>
<li><strong>常测试，早测试，自动化测试</strong><ul>
<li>单元测试&#x2F;集成测试&#x2F;压力测试&#x2F;回归测试</li>
<li><strong>测试状态覆盖，而不是代码覆盖</strong>，代码覆盖率提供的意义有限</li>
</ul>
</li>
<li>关于如何生产文本<ul>
<li>所有文档都是代码的反映</li>
<li>源码注释应该去把项目里那些难以描述、容易忘记、不能记录在其他地方的东西记载下来</li>
<li>比无意义的名称更糟糕的是<strong>有误导性</strong>的名称</li>
<li>除非有程序或人工维护，否则任何形式的文档都只是<strong>快照</strong></li>
</ul>
</li>
<li><strong>温和地超出用户期望</strong>，如<ul>
<li>友好的新手指引</li>
<li>快捷键</li>
<li>自动化安装</li>
</ul>
</li>
<li><strong>自豪地为你的作品签名</strong></li>
</ul>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li>《人月神话》</li>
<li>《Unix编程艺术》</li>
<li>《Effective C++》</li>
<li>《集市与大教堂》</li>
</ul>
<p><em>–END–</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/05/07/principles-of-microeconomics-terms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/05/07/principles-of-microeconomics-terms/" class="post-title-link" itemprop="url">《经济学原理》 - 微观经济学原理笔记 附：术语</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-05-07 00:47:54 / 修改时间：00:54:32" itemprop="dateCreated datePublished" datetime="2019-05-07T00:47:54+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/05/07/principles-of-microeconomics-terms/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/05/07/principles-of-microeconomics-terms/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>正文：<a target="_blank" rel="noopener" href="//shenlvmeng.github.io/blog/2019/05/07/principles-of-microeconomics/">《经济学原理》 - 微观经济学原理笔记</a></p>
</blockquote>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><h3 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h3><ul>
<li>稀缺性：社会资源的有限性</li>
<li>经济学：研究社会如何管理自己的稀缺资源</li>
<li><strong>机会成本</strong>：为得到某种东西必须放弃的东西</li>
<li>理性人：系统有目的地尽最大努力实现其目标的人</li>
<li>边际变动：对行动计划的增量调整</li>
<li><strong>激励</strong>：引起一个人做出某种行为的某种东西</li>
<li>市场经济：在许多企业和家庭在物品与服务市场上交互交易时。通过他们的分散决策配置资源的经济</li>
<li>产权：个人拥有并控制稀缺资源的能力认证</li>
<li>生产率：单位劳动投入所生产的物品与服务数量</li>
<li>通货膨胀：经济中物价总水平的上升</li>
<li>经济周期：就业和生产等禁忌活动的波动</li>
</ul>
<h3 id="像经济学家一样思考"><a href="#像经济学家一样思考" class="headerlink" title="像经济学家一样思考"></a>像经济学家一样思考</h3><ul>
<li>循环流量图：一个说明货币如何通过市场在家庭和企业间流动的经济模型</li>
<li>生产可能性边界：生产要素和生产技术固定时，一个经济所能生产的数目组合的图形</li>
<li>微观经济学：研究家庭和企业如何做出决策，以及它们如何在市场上相互交易</li>
<li>宏观经济学：研究整体经济现象</li>
<li>实证表述：描述世界时什么样</li>
<li>规范表述：描述世界应该是什么样</li>
</ul>
<h3 id="相互依存性和贸易的好处"><a href="#相互依存性和贸易的好处" class="headerlink" title="相互依存性和贸易的好处"></a>相互依存性和贸易的好处</h3><ul>
<li><strong>绝对优势</strong>：一个生产者用比另一个生产者更少的投入生产某种物品的能力</li>
<li><strong>比较优势</strong>：一个生产者以低于另一个生产者的机会成本生产某种物品的能力</li>
</ul>
<h2 id="市场如何运行"><a href="#市场如何运行" class="headerlink" title="市场如何运行"></a>市场如何运行</h2><h3 id="供给和需求的市场力量"><a href="#供给和需求的市场力量" class="headerlink" title="供给和需求的市场力量"></a>供给和需求的市场力量</h3><ul>
<li>市场：由某种物品或服务的买者与卖者组成的群体</li>
<li>竞争市场：买者和卖者都很多，以至于每个人对市场价格的影响都微乎其微</li>
<li>需求量：买者愿意并且能够购买的一种物品的数量</li>
<li>需求定理：其他条件不变时，价格和物品的需求量成反比</li>
<li>正常物品：随着收入增加需求量增加的物品</li>
<li>低档物品：随着收入增加需求量减少的物品</li>
<li>替代品：一个物品价格的上升引起另一种物品需求量上升的物品</li>
<li>互补品：一个物品价格的上升引起另一种物品需求量下降的物品</li>
<li>供给量：卖者愿意并且能够出售该物品的数量</li>
<li>供给定理：其他条件不变时，价格和物品的供给量成正比</li>
<li>均衡：市场价格达到是供给量和需求量相等的状态</li>
<li><strong>均衡价格（市场出清价格）</strong>：使供给和需求平衡的价格</li>
<li><strong>供求定理</strong>：认为任何一种物品的价格都会自发调整并达到平衡</li>
</ul>
<h3 id="弹性及其应用"><a href="#弹性及其应用" class="headerlink" title="弹性及其应用"></a>弹性及其应用</h3><ul>
<li>弹性：更亮需求量或供给量对某种决定因素的变动的反应程度指标</li>
<li>总收益：对于一种物品，买者支付而卖者得到的量</li>
<li>需求收入弹性：消费者收入变动程度对一种物品需求量变动程度的影响程度</li>
<li>需求的交叉价格弹性：衡量一种物品需求量对另一种物品价格变动的反应程度</li>
<li>供给价格弹性</li>
</ul>
<h3 id="供给、需求和政府政策"><a href="#供给、需求和政府政策" class="headerlink" title="供给、需求和政府政策"></a>供给、需求和政府政策</h3><ul>
<li>价格上限：出售商品的法定最高价格</li>
<li>价格下限：出售商品的法定最低价格</li>
<li>税收归宿：税收负担在市场参与者中分配的方式</li>
</ul>
<h2 id="市场和福利"><a href="#市场和福利" class="headerlink" title="市场和福利"></a>市场和福利</h2><h3 id="消费者、生产者、市场效率"><a href="#消费者、生产者、市场效率" class="headerlink" title="消费者、生产者、市场效率"></a>消费者、生产者、市场效率</h3><ul>
<li>福利经济学：研究资源配置如何影响经济福利的学问</li>
<li>支付意愿：买者愿意为某种物品支付的最高价</li>
<li>消费者剩余：买者愿意为某种物品支付的量减去实际支付的量</li>
<li>成本：卖者为了生产一种物品必须放弃的所有东西的价值</li>
<li>生产者剩余：卖者出售一种物品得到的量减去其生产成本</li>
<li>效率：资源配置使得社会所有成员总剩余最大化的性质</li>
<li>平等：社会成员平均分配经济成果的性质</li>
</ul>
<h3 id="赋税和国际贸易"><a href="#赋税和国际贸易" class="headerlink" title="赋税和国际贸易"></a>赋税和国际贸易</h3><ul>
<li>无谓损失：市场扭曲（如税收）引起的总剩余下降</li>
<li>世界价格：一种物品在世界市场上通行的价格</li>
<li>关税：对国外生产、国内销售的物品征税</li>
</ul>
<h2 id="公共部门经济学"><a href="#公共部门经济学" class="headerlink" title="公共部门经济学"></a>公共部门经济学</h2><h3 id="外部性"><a href="#外部性" class="headerlink" title="外部性"></a>外部性</h3><ul>
<li>外部性：一个人的行为对旁观者福利的无补偿影响</li>
<li>外部性内在化：改变激励，使人们考虑到自己行为的外部效应</li>
<li>矫正税：引导私人决策者考虑外部性引起的社会成本的税收</li>
<li>科斯定理：私人各方可以无成本地协商资源配置时，他们就可以解决外部性问题</li>
<li>交易成本：各方在达成协议与遵守协议过程中发生的成本</li>
<li>排他性：物品使用可以阻止另一个人使用的特性</li>
<li>消费中的竞争性：使用一种物品将减少其他人使用的特性</li>
<li>私人物品&#x2F;公共物品&#x2F;公共资源&#x2F;俱乐部物品</li>
</ul>
<h3 id="税制"><a href="#税制" class="headerlink" title="税制"></a>税制</h3><ul>
<li>预算赤字：政府支出大于收入</li>
<li>预算盈余：政府收入大于支出</li>
<li>边际税率：增加收入引起的额外税收</li>
<li>平均税率：支付税收占收入的比例</li>
<li>定额税：对每个人征收的等量的税收</li>
<li>受益原则、支付能力原则</li>
<li>纵向平等、横向平等</li>
<li>比例税、累进税、累退税</li>
<li>粘蝇纸理论</li>
</ul>
<h2 id="企业行为和行业组织"><a href="#企业行为和行业组织" class="headerlink" title="企业行为和行业组织"></a>企业行为和行业组织</h2><h3 id="生产成本"><a href="#生产成本" class="headerlink" title="生产成本"></a>生产成本</h3><ul>
<li>总收益：企业出售产品得到的货币量</li>
<li>总成本：企业用于生产的投入品的市场价值</li>
<li>利润：总收益 - 总成本</li>
<li>显性成本：需要企业支出货币的投入成本</li>
<li>隐形成本：不需要企业支出货币的投入成本</li>
<li>经济利润：总收益 - 显性成本 - 隐性成本</li>
<li>会计利润：总收益 - 显性成本</li>
<li>生产函数：投入量和产量的函数</li>
<li>边际产量：增加一单位投入引起的产量增加</li>
<li>边际产量递减：投入边际产量随投入增加而递减的特征</li>
<li>固定成本：不随产量变动的成本</li>
<li>可变成本：随产量变动的成本</li>
<li>平均总成本、平均固定成本、平均可变成本、边际成本</li>
<li>有效规模：使总成本最小的产量</li>
<li>规模经济、规模不经济、规模收益不变</li>
</ul>
<h3 id="竞争市场上的企业"><a href="#竞争市场上的企业" class="headerlink" title="竞争市场上的企业"></a>竞争市场上的企业</h3><ul>
<li>竞争市场：有许多交易相同产品的买者和卖者，以至于买卖双方都是价格的接受者</li>
<li>平均收益、边际收益</li>
<li>沉没成本：已经发生而且无法收回的成本</li>
</ul>
<h3 id="垄断"><a href="#垄断" class="headerlink" title="垄断"></a>垄断</h3><ul>
<li>垄断企业：一种没有相近替代品的产品的唯一卖者</li>
<li>自然垄断：一个企业能够以低于绝大多数企业成本的方式向市场供给物品或服务产生的垄断</li>
<li>价格歧视：对不同顾客以不同价格出售同一物品</li>
</ul>
<h3 id="垄断竞争"><a href="#垄断竞争" class="headerlink" title="垄断竞争"></a>垄断竞争</h3><ul>
<li>寡头：只有少数几个提供相似或相同产品的卖家的市场</li>
<li>垄断竞争：存在许多出售相似但不相同的企业的市场结构</li>
</ul>
<h3 id="寡头"><a href="#寡头" class="headerlink" title="寡头"></a>寡头</h3><ul>
<li>勾结：市场上的企业就生产产量或收取价格达成的协议</li>
<li>卡特尔：联合行事的企业集团</li>
<li>纳什均衡：相互作用而经济主体再讲其他所有主体所选策略为既定时，选择他们自己最优策略的状态</li>
<li>囚徒困境、占优策略</li>
</ul>
<h2 id="生产要素市场"><a href="#生产要素市场" class="headerlink" title="生产要素市场"></a>生产要素市场</h2><ul>
<li>生产要素：生产物品和服务的投入</li>
<li>劳动的边际产量：增加一单位劳动所引起的产量增加量</li>
<li>边际产量值：一种投入的边际产量乘以产品价格</li>
<li>资本：用于生产物品与服务的设备和建筑物</li>
<li>补偿性工资差别：抵消不同工作<strong>非货币特性</strong>而产生的工资差别</li>
<li>人力资本：对人的投资的积累，如教育、在职培训</li>
<li>歧视：对仅仅是种族、民族、性别、年龄或其他个人特征不同的相似个人提供不同机会</li>
<li>贫困率、贫困线</li>
<li>功利主义：主张政府应该选择使社会上所有人总效用最大化</li>
<li>自由主义、自由至上主义</li>
<li>负所得税：向高收入人群征税给低收入家庭补助</li>
</ul>
<h2 id="深入探讨的论题"><a href="#深入探讨的论题" class="headerlink" title="深入探讨的论题"></a>深入探讨的论题</h2><ul>
<li>预算约束线：对消费者可以支付得起的消费组合的限制</li>
<li>无差异曲线：表示给消费者同等满足程度的消费组合的曲线</li>
<li>边际替代率：消费者愿意以一种物品交换另一种物品的比率</li>
<li>吉芬物品：价格上升引起需求增加的物品</li>
<li>道德风险：一个没有受到完全监督的人从事不诚实行为的倾向</li>
<li>逆向选择：从无信息一方的角度看，无法观察到的特征组合变为不合意的倾向</li>
<li>经济政治学：用经济学的方法研究政府</li>
<li>康多塞悖论、阿罗不可能定理、中值选民定理</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/05/07/principles-of-microeconomics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/05/07/principles-of-microeconomics/" class="post-title-link" itemprop="url">《经济学原理》 - 微观经济学原理笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-07 00:46:47" itemprop="dateCreated datePublished" datetime="2019-05-07T00:46:47+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-01 23:57:49" itemprop="dateModified" datetime="2020-06-01T23:57:49+08:00">2020-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/05/07/principles-of-microeconomics/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/05/07/principles-of-microeconomics/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>全文参考自《经济学原理》曼昆版 微观经济学分册<br>术语：<a target="_blank" rel="noopener" href="//shenlvmeng.github.io/blog/2019/05/07/principles-of-microeconomics-terms/">《经济学原理》 - 微观经济学原理笔记 附：术语</a><br>宏观经济学：<a target="_blank" rel="noopener" href="//shenlvmeng.github.io/blog/2020/06/01/principles-of-macroeconomics/">《经济学原理》 - 宏观经济学原理笔记</a></p>
</blockquote>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><h3 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h3><ul>
<li><strong>稀缺性</strong>指社会资源有限，不能生产人们希望的所有物品和服务。</li>
<li><strong>经济学</strong>研究社会如何管理自己的稀缺资源</li>
</ul>
<p>经济学有些核心思想，<strong>十大原理</strong>可以做一个简要的概括。经济由群体中的个人组成，因此个人的行为可以反映经济的行为。下面从个人角度分类举出这些原理。</p>
<h4 id="人们如何做出决策"><a href="#人们如何做出决策" class="headerlink" title="人们如何做出决策"></a>人们如何做出决策</h4><ul>
<li><strong>原理1：人们总会面临权衡取舍</strong></li>
<li><strong>原理2：某种东西的成本是为了得到它需要舍弃的东西</strong>（机会成本）</li>
<li><strong>原理3：理性人考虑边际量</strong>。一个人对任何物品的支付意愿基于增加1单位物品获得的<strong>边际收益</strong>。当且仅当一个行为的边际收益大于边际成本时，理性决策者才会采取这个行为</li>
<li><strong>原理4：人们会对激励做出反应</strong>。因为理性人会通过比较成本和收益做出决策。比如降息会激励人们取出储蓄拿来投资。我们在分析决策时，不仅要考虑直接影响，还应该能考虑通过激励造成的间接影响</li>
</ul>
<h4 id="人们如何相互影响"><a href="#人们如何相互影响" class="headerlink" title="人们如何相互影响"></a>人们如何相互影响</h4><ul>
<li><strong>原理5：贸易可以使每个人的状况都变得更好</strong>，即非零和。</li>
<li><strong>原理6：市场通常是组织经济活动的一种好方法</strong>。根据亚当·斯密的观察结果，市场经济中价格作为一只“看不见的手”指引经济活动。它的推论是，任何限制或阻碍这只手的行为会扭曲家庭和企业的决策，并造成不良影响。比如税收、中央计划经济。<ul>
<li>市场经济中，参与者受利己心的驱动，但往往比他处于公共利益考虑时，更能有效促进公共的利益</li>
<li>“让人们各行其是，不要让政府沉重的手知道他们的行为，结果往往会最好”</li>
</ul>
</li>
<li><strong>原理7：政府有时可以改善市场结果</strong>。<ul>
<li>政府制定制度，通过权威以便个人可以拥有并控制稀缺资源</li>
<li>“看不见的手”考虑不了<strong>外部性</strong>和<strong>市场势力</strong>这两种市场失灵的情况。因为需要政府进行干预，以促进效率或促进平等</li>
</ul>
</li>
</ul>
<h4 id="整体经济如何运行"><a href="#整体经济如何运行" class="headerlink" title="整体经济如何运行"></a>整体经济如何运行</h4><ul>
<li><strong>原理8：一国的生活水平取决于它生产物品和服务的能力</strong>。更细致地说，几乎所有生活水平的差别都可以归因于<strong>生产率</strong>的差别</li>
<li><strong>原理9：政府发行货币过多时，物价会上升</strong>，即通货膨胀。</li>
<li><strong>原理10：社会面临通货膨胀和失业间的短期权衡取舍</strong><ul>
<li>货币量增加 -&gt; 社会整体支出水平上升 -&gt; 物品服务需求增加 -&gt; 企业提高物价，雇佣更多的工人生产 -&gt; 更少的失业</li>
</ul>
</li>
</ul>
<h3 id="像经济学家一样思考"><a href="#像经济学家一样思考" class="headerlink" title="像经济学家一样思考"></a>像经济学家一样思考</h3><h4 id="作为科学家"><a href="#作为科学家" class="headerlink" title="作为科学家"></a>作为科学家</h4><p>经济学同其他科学一样，有提出理论 -&gt; 收集数据 -&gt; 分析数据几个步骤，不同的是经济学同其他社会科学一样，研究的是人。</p>
<ul>
<li>同样是观察、理论、验证；经济学的<strong>验证</strong>通常只能从真实的历史事件中入手</li>
<li>同样是简化问题，经济学中也有<strong>假设</strong>，并在假设基础上建立<strong>模型</strong>，以此了解世界</li>
<li>第一个模型：<strong>循环流量图</strong>，描述家庭和企业的货币流转<ul>
<li>在物品与服务市场，家庭是买者，企业是卖者</li>
<li>在生产要素市场，家庭是卖者，企业是买者</li>
</ul>
</li>
<li>绝大多数经济模型都通过数学工具构建，比如最简单的<strong>生产可能性边界</strong><ul>
<li>表示技术和生产要素固定时，经济所能生产的产品组合</li>
<li>曲线斜率代表某产品的机会成本</li>
<li>曲线上的某点是当前稀缺资源的生产极限，它被称为是“有效率的”。曲线面积内的点是“无效率的”，曲线面积外的点在当前条件下无法达成。</li>
<li><strong>站在原点看，边界通常是向外凸出的</strong></li>
</ul>
</li>
<li>微观经济学与宏观经济学</li>
</ul>
<h4 id="作为政策顾问"><a href="#作为政策顾问" class="headerlink" title="作为政策顾问"></a>作为政策顾问</h4><ul>
<li>经济学家分析世界时是科学家，帮助改善世界时，它们是政策顾问（工程师）</li>
<li><strong>实证表述</strong>与<strong>规范表述</strong><ul>
<li>实证表述通过证据验证；规范表述除了证据还会涉及道德、政治哲学等价值观</li>
<li>经济学中的大多数内容都是<strong>实证表述</strong>，站在科学家立场上的</li>
</ul>
</li>
<li><em>（个人感悟）世界由自然科学家们定义和主导，而“人”则由社会科学家（如经济学家、哲学家）们定义和主导</em></li>
<li>经济学家只是施政的一个影响因素而已，最终政策是多方角力的结果</li>
</ul>
<h4 id="造成经济学家矛盾的原因"><a href="#造成经济学家矛盾的原因" class="headerlink" title="造成经济学家矛盾的原因"></a>造成经济学家矛盾的原因</h4><ul>
<li>科学判断不同，这与自然科学一致。</li>
<li>价值观不一致</li>
</ul>
<h4 id="附：图表"><a href="#附：图表" class="headerlink" title="附：图表"></a>附：图表</h4><ul>
<li>通常用图形直观地说明一组事件如何引起另一组事件的发生</li>
<li>两个陷阱：变动由未画出的第三个变量引起；反向因果关系<ul>
<li>打火机和癌症的正相关</li>
<li>家用旅行车和家庭人口增加的正相关</li>
</ul>
</li>
</ul>
<h3 id="相互依存性和贸易的好处"><a href="#相互依存性和贸易的好处" class="headerlink" title="相互依存性和贸易的好处"></a>相互依存性和贸易的好处</h3><ul>
<li>出发点是：贸易可以使每个人状况都变得更好</li>
</ul>
<h4 id="简单的经济学寓言"><a href="#简单的经济学寓言" class="headerlink" title="简单的经济学寓言"></a>简单的经济学寓言</h4><ul>
<li>自给自足时，生产可能性边界即消费可能性边界。</li>
<li>相互贸易时，由于专业化，每人专注于擅长的工作，双方的消费可能性边界将大于生产可能性边界</li>
</ul>
<h4 id="比较优势：专业化的动力"><a href="#比较优势：专业化的动力" class="headerlink" title="比较优势：专业化的动力"></a>比较优势：专业化的动力</h4><ul>
<li>绝对优势和比较优势</li>
<li>比较优势用机会成本衡量，所以<strong>两个生产者间相互比较，比较优势一定是有高有低而不会都较高的</strong></li>
<li>不同的机会成本导致贸易可以增加经济总产量，每个人专门生产自己有比较优势的物品。同时由于机会成本不同，双方都可以议价，并以<strong>低于自己生产某物品机会成本的价格得到该物品从而从贸易中获益</strong>。</li>
<li>比较优势原理：<strong>贸易可以使社会上每个人都获益，因为它使人们可以专门从事他们具有比较优势的活动</strong>。这也是经济学家反对贸易限制的主要依据</li>
<li>通过上面分析还能得到一个结论：<strong>由于双方都要获益，因此贸易的价格要在两种机会成本之间才能达成交易</strong></li>
</ul>
<h4 id="比较优势的应用"><a href="#比较优势的应用" class="headerlink" title="比较优势的应用"></a>比较优势的应用</h4><ul>
<li>Tom Fordy应该雇人修剪草坪，而去拍广告</li>
<li><strong>自由贸易中，每种物品应该由生产这种物品机会成本较低的国家生产</strong></li>
</ul>
<h2 id="市场如何运行"><a href="#市场如何运行" class="headerlink" title="市场如何运行"></a>市场如何运行</h2><h3 id="供给与需求的市场力量"><a href="#供给与需求的市场力量" class="headerlink" title="供给与需求的市场力量"></a>供给与需求的市场力量</h3><h4 id="市场与竞争"><a href="#市场与竞争" class="headerlink" title="市场与竞争"></a>市场与竞争</h4><ul>
<li>比较优势说明贸易可以使双方状况都变好，而物品和服务是通过市场中的<strong>供给与需求</strong>交流的</li>
<li>供给和需求是人们在市场上相互交易的行为<ul>
<li>市场上，买者决定需求，卖者决定供给</li>
</ul>
</li>
<li>完全竞争的两个特征 &#x2F; 价格接受者 &#x2F; 垄断</li>
</ul>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul>
<li>需求定理：需求量和价格成反比</li>
<li>区分市场需求和个人需求</li>
<li>影响需求曲线的一些因素<ul>
<li>收入：正常物品和低档物品</li>
<li>相关物品的价格：替代品</li>
<li>爱好、预期、买者总量</li>
</ul>
</li>
</ul>
<h4 id="供给"><a href="#供给" class="headerlink" title="供给"></a>供给</h4><ul>
<li>供给定理：价格和供给量成正比</li>
<li>区分市场供给和个人供给</li>
<li>影响供给曲线的一些因素<ul>
<li>投入品价格</li>
<li>技术</li>
<li>预期、卖者数量</li>
</ul>
</li>
</ul>
<h4 id="需求和供给的结合"><a href="#需求和供给的结合" class="headerlink" title="需求和供给的结合"></a>需求和供给的结合</h4><ul>
<li>市场的均衡是上述两条线的交点<ul>
<li>均衡价格（市场出清价格）</li>
<li>过剩和短缺（<strong>沿着曲线移动</strong>）</li>
<li><strong>供求定理</strong>：认为任何一种物品的价格都会自发调整并达到平衡</li>
</ul>
</li>
<li>均衡变动：曲线的移动、新平衡的达成<ul>
<li><strong>判断影响的是供给还是需求还是都有</strong></li>
<li>区分<strong>供给变动</strong>，<strong>供给量变动</strong>，<strong>需求变动</strong>，<strong>需求量变动</strong></li>
</ul>
</li>
<li>价格决定了社会稀有资源的配置 &#x2F; 一只看不见的手</li>
</ul>
<h3 id="弹性及其应用"><a href="#弹性及其应用" class="headerlink" title="弹性及其应用"></a>弹性及其应用</h3><ul>
<li>需求价格弹性和影响因素<ul>
<li>可替代品的可获得性&#x2F;必需品和奢侈品&#x2F;市场和时间的范围</li>
</ul>
</li>
<li>计算方式：需求量<strong>变动</strong>百分比 &#x2F; 价格<strong>变动</strong>百分比<ul>
<li><strong>中点法</strong>，避免同一场景的不同方向得到不同结果</li>
</ul>
</li>
<li>弹性值和需求曲线的斜率<ul>
<li>富有弹性、缺乏弹性、单位弹性</li>
</ul>
</li>
<li>收益的计算：数目 * 价格<ul>
<li>富有弹性时，价格上升引起收益增加</li>
<li>缺乏弹性时，价格上升引起收益减少</li>
</ul>
</li>
<li>需求收入弹性和需求交叉价格弹性</li>
</ul>
<p>一些应用的例子：</p>
<ul>
<li>小麦技术的进步减少了农民收入，鼓励人们离开农业</li>
<li>OPEC不能长期维持高油价</li>
<li>禁毒在短期内会增加毒品相关犯罪</li>
</ul>
<h3 id="供给、需求和政府政策"><a href="#供给、需求和政府政策" class="headerlink" title="供给、需求和政府政策"></a>供给、需求和政府政策</h3><h4 id="价格控制"><a href="#价格控制" class="headerlink" title="价格控制"></a>价格控制</h4><ul>
<li><strong>限制性约束</strong>的价格上限（低于均衡价格）将造成物品短缺，引起稀缺物品分配效率的降低<ul>
<li>限制油价</li>
<li>长期的租金控制引起人们租不到房，房东不愿意优化自己的房</li>
</ul>
</li>
<li>同样地，<strong>限制性约束</strong>的价格下限很容易引起过剩<ul>
<li>劳动力市场的最低工资会导致失业</li>
<li>计划经济导致生活必需品的缺乏</li>
</ul>
</li>
</ul>
<h4 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h4><ul>
<li>税收抑制了市场活动，导致物品销售量减少，减少了市场规模，同时买者和卖者分摊了税收负担。</li>
<li><strong>对买者征税和对卖者征税是相同的</strong>，税收归宿决定于供给和需求的力量。</li>
<li><strong>税收楔子</strong>与相对弹性<ul>
<li>更有弹性的一方承担较少的部分，<strong>税收负担更多由缺乏弹性的市场一方承担</strong></li>
<li>应用：工薪税更多由劳动者承担；奢侈品税由奢侈品供应者承担</li>
</ul>
</li>
</ul>
<h2 id="市场和福利"><a href="#市场和福利" class="headerlink" title="市场和福利"></a>市场和福利</h2><h3 id="消费者、生产者、市场效率"><a href="#消费者、生产者、市场效率" class="headerlink" title="消费者、生产者、市场效率"></a>消费者、生产者、市场效率</h3><ul>
<li>福利经济学，讨论资源配置和经济福利的关系</li>
<li>消费者参与市场的收益 - 支付意愿和消费者剩余<ul>
<li>图表表示：<strong>需求曲线以下和价格以上的面积</strong></li>
<li>实际意义：衡量买者从一件物品中得到<strong>自我感觉</strong>的利益，通常情况下，也可以反映经济福利程度</li>
</ul>
</li>
<li>生产者参与市场的收益 - 成本和生产者剩余<ul>
<li>图表表示：<strong>价格以下和供给曲线以上的面积</strong></li>
<li>实际意义：衡量卖者的福利程度</li>
</ul>
</li>
<li>市场效率、平等<ul>
<li>总剩余：生产者剩余 + 消费者剩余</li>
<li>效率和平等</li>
<li>自由市场把物品供给分配给对这些物品评价最高的买者，评价用购买意愿衡量</li>
<li>自由市场把物品的需求分配给能够以最低成本生产这些物品的卖者</li>
<li><strong>自由市场生产出使消费者和生产者剩余总和最大化的物品量</strong></li>
</ul>
</li>
<li>之前的讨论都建立在假设的基础上、市场失灵时，市场无法有效地配置资源<ul>
<li>非完全竞争：市场势力</li>
<li>外部性</li>
</ul>
</li>
<li>应用<ul>
<li>不论是供给提高（技术演进、成本降低）还是需求提高，都能提高生产者、消费者剩余，即市场效率。间接地，，也会促进互补品的繁荣，引起替代品的消亡</li>
</ul>
</li>
</ul>
<h3 id="赋税的代价"><a href="#赋税的代价" class="headerlink" title="赋税的代价"></a>赋税的代价</h3><ul>
<li>税收收入的矩形表示 &#x3D;&gt; 社会总剩余的下降</li>
<li><strong>买者和卖者因税收遭受的损失大于政府筹集到的收入</strong></li>
<li>税收引起的<strong>无谓损失</strong>因为它使卖者和买者不能实现贸易的好处，这个好处可以用税收楔子的三角形衡量。三角形内的贸易带来的剩余由于小于税收被阻止。</li>
<li><strong>供给和需求的弹性越大，税收带来的无谓损失就越大</strong><ul>
<li>无谓损失越大，政府实施一项计划的成本就越高</li>
</ul>
</li>
<li>政府的税收收入随着征税的增长会<strong>先变大再变小</strong>，而无谓损失是<strong>一直扩大的</strong></li>
</ul>
<h3 id="国际贸易"><a href="#国际贸易" class="headerlink" title="国际贸易"></a>国际贸易</h3><ul>
<li>国内价格反映了物品的机会成本，即国内具有比较优势的商品</li>
<li>假定世界价格是既定的，用世界价格线和供求线形成的三角形表示进出口国收益<ul>
<li>世界价格较低时，消费者剩余增加，生产者剩余减少，总体收益</li>
<li>世界价格较高时，消费者剩余降低，生产者剩余增加，总体收益</li>
<li>贸易<strong>可以</strong>使每个人的情况都变好</li>
</ul>
</li>
<li>关税和无谓损失<ul>
<li>关税使价格更逼近均衡价格，减少了进口量，但带来了无谓损失</li>
<li>无谓损失来自过度生产和消费不足</li>
</ul>
</li>
<li><strong>贸易在消灭一些工作岗位的同时，也创造了比较优势行业上的工作岗位</strong>（保护主义）</li>
<li>自由贸易在提高效率的同时，可以会牺牲平等</li>
</ul>
<h2 id="公共部门经济学"><a href="#公共部门经济学" class="headerlink" title="公共部门经济学"></a>公共部门经济学</h2><h3 id="外部性"><a href="#外部性" class="headerlink" title="外部性"></a>外部性</h3><ul>
<li>正外部性和负外部性</li>
<li>外部性内在化<ul>
<li><strong>负外部性使市场生产数量大于社会合意数量，正外部性则相反</strong></li>
<li>对正外部性补贴，负外部性征税</li>
</ul>
</li>
<li>如何针对<ul>
<li>命令和控制 —— 管制</li>
<li>以市场为基础 —— 矫正税和补贴</li>
<li>可交易的污染量 —— 污染许可证</li>
</ul>
</li>
<li>矫正税鼓励公司开发更环保的技术，比管制更灵活，同时还能增加政府收入</li>
<li><strong>矫正税决定了污染价格，污染许可证决定了污染量</strong></li>
<li>外部性的私人解决办法<ul>
<li>道德规范 &amp; 慈善行为</li>
<li>外部性内在化是一些企业进行多类型经营的一个原因</li>
</ul>
</li>
<li>科斯定理：私人可以有效率地解决外部性<ul>
<li>交易成本影响科斯定理</li>
</ul>
</li>
</ul>
<h3 id="公共物品和公共资源"><a href="#公共物品和公共资源" class="headerlink" title="公共物品和公共资源"></a>公共物品和公共资源</h3><ul>
<li>私人市场不能保证没有价格的物品的适当配置</li>
<li><strong>私人物品&#x2F;公共物品&#x2F;公共资源&#x2F;俱乐部物品</strong></li>
<li>公共物品<ul>
<li>公共物品的总利益大于成本时，就可以不考虑<strong>搭便车者</strong>的存在</li>
<li>公共物品的成本-收益分析：并不像私人物品市场，买者和卖者通过出价表达物品的评价和成本</li>
</ul>
</li>
<li>公共资源<ul>
<li><strong>公地悲剧</strong>：一个人使用公共资源会减少他人使用，由于负外部性的存在，公共资源往往被过度使用</li>
<li>解决措施：征收矫正税或颁发许可证；将公共资源变为私人物品</li>
<li>举例：清洁的空气、水、拥堵的道路、动植物资源等</li>
</ul>
</li>
<li>为什么象牙的商业价值是大象的噩梦，而奶牛的商业价值却是它的护身符呢？<ul>
<li>因为<strong>大象是公共资源，而奶牛是私人物品</strong></li>
<li><strong>产权缺失</strong>引起市场失灵，政府可以释放市场的力量，从而让资源配置更有效率，增进经济福利</li>
</ul>
</li>
</ul>
<h3 id="税制"><a href="#税制" class="headerlink" title="税制"></a>税制</h3><h4 id="联邦政府"><a href="#联邦政府" class="headerlink" title="联邦政府"></a>联邦政府</h4><ul>
<li>收入：个人所得税、社会保险税（工薪税）、公司所得税、销售税</li>
<li>支出：收入保障、医疗、国防、债券利息</li>
<li>赤字和盈余<ul>
<li>赤字可以通过发行政府债券筹资，并在盈余时偿还</li>
<li>人口老龄化带来的财政挑战</li>
</ul>
</li>
</ul>
<h4 id="地方政府"><a href="#地方政府" class="headerlink" title="地方政府"></a>地方政府</h4><ul>
<li>收入：销售税、财产税、许可证收费、公共交通收费</li>
<li>支出：教育、医疗</li>
</ul>
<h4 id="税收的效率"><a href="#税收的效率" class="headerlink" title="税收的效率"></a>税收的效率</h4><ul>
<li>税收的成本来自于扭曲决策时的<strong>无谓损失</strong>和纳税人承担的<strong>管理负担</strong></li>
<li>消费税的转型</li>
<li>边际税率和平均税率</li>
<li>定额税：<strong>有效率但无法保证平等</strong></li>
</ul>
<h4 id="税收的平等"><a href="#税收的平等" class="headerlink" title="税收的平等"></a>税收的平等</h4><ul>
<li>受益原则：认为人们应该根据从政府服务的收益多少来纳税</li>
<li>支付能力原则：认为应该根据人们可承受负担来纳税<ul>
<li><strong>纵向平等</strong>：支付能力强的人多纳税</li>
<li>比例税、累进税、累退税</li>
<li><strong>横向平等</strong>：相似支付能力的人纳税相似</li>
</ul>
</li>
<li>税收归宿和税收平等<ul>
<li>粘蝇纸理论</li>
</ul>
</li>
</ul>
<h2 id="企业行为和产业组织"><a href="#企业行为和产业组织" class="headerlink" title="企业行为和产业组织"></a>企业行为和产业组织</h2><h3 id="生产成本"><a href="#生产成本" class="headerlink" title="生产成本"></a>生产成本</h3><ul>
<li>我们通常可以假设：<strong>企业的目标就是利润最大化</strong></li>
<li>收益、成本、利润的计算</li>
<li>机会成本：显性、隐性成本<ul>
<li>容易被忽略的隐性成本</li>
</ul>
</li>
<li>经济利润与会计利润<ul>
<li>区别：是否考虑隐性成本</li>
<li><strong>经济利润是企业经营者供给物品或服务的动机源泉</strong></li>
</ul>
</li>
</ul>
<h4 id="生产与成本"><a href="#生产与成本" class="headerlink" title="生产与成本"></a>生产与成本</h4><ul>
<li>生产函数：投入量和产量的函数</li>
<li>边际产量、边际产量递减</li>
<li>总成本曲线：产量和总成本的关系函数<ul>
<li>在边际产量递减时，生产函数越来越平坦，而总成本曲线越来越陡峭</li>
<li><strong>由于投入量和成本的近似性，生产函数几乎是总成本曲线的反函数</strong></li>
</ul>
</li>
<li>固定成本：租金、人力等</li>
<li>可变成本：投入品、时薪</li>
<li>平均总成本（ATC）、平均可变成本（AVC）、边际成本（MC）<ul>
<li>递增的边际成本</li>
<li>U形的平均总成本</li>
<li>U形平均总成本的最低点对应的产量叫做<strong>有效规模</strong></li>
</ul>
</li>
<li><strong>边际成本曲线和平均总成本曲线在有效规模处相交</strong></li>
<li>典型的成本曲线三个特征<ul>
<li>最终递增的边际成本曲线</li>
<li>U形的平均总成本曲线</li>
<li>两者相交于有效规模处</li>
</ul>
</li>
</ul>
<h4 id="短期和长期成本"><a href="#短期和长期成本" class="headerlink" title="短期和长期成本"></a>短期和长期成本</h4><ul>
<li>企业的长期成本曲线不同于短期成本曲线<ul>
<li>大、中、小型工程的ATC曲线</li>
</ul>
</li>
<li>规模经济、规模不经济、规模收益不变<ul>
<li>长期平均总成本随产量增加的几种变化情况</li>
<li>规模经济通常来自<strong>专业化和分工</strong>，规模不经济通常来自<strong>沟通成本和协调问题</strong></li>
</ul>
</li>
<li><strong>愈精细的分工（专业化）愈容易带来规模经济</strong></li>
</ul>
<h3 id="竞争市场上的企业"><a href="#竞争市场上的企业" class="headerlink" title="竞争市场上的企业"></a>竞争市场上的企业</h3><h4 id="竞争市场"><a href="#竞争市场" class="headerlink" title="竞争市场"></a>竞争市场</h4><ul>
<li>竞争市场<ul>
<li>市场上有众多买家、卖家</li>
<li>交易的物品大体相同</li>
<li><strong>企业可以自由进入或退出市场</strong></li>
</ul>
</li>
<li>平均收益：物品的价格</li>
<li>边际收益：<strong>对竞争企业来说</strong>，边际收益等于物品价格</li>
</ul>
<h4 id="利润最大化"><a href="#利润最大化" class="headerlink" title="利润最大化"></a>利润最大化</h4><ul>
<li>通过比较边际收益和边际成本，可以找到利润最大化的产量，因此对于竞争企业来说，利润最大化的产量点即价格和边际成本曲线的交点<ul>
<li>边际成本小于边际收益时，增加产量</li>
<li>边际成本大于边际收益时，减少产量</li>
<li>两者相等时，利润最大化</li>
</ul>
</li>
<li><strong>实际上，企业的边际曲线决定了企业在任何价格时愿意供给的物品数量，即供给曲线</strong></li>
</ul>
<h4 id="短期-x2F-长期决策"><a href="#短期-x2F-长期决策" class="headerlink" title="短期&#x2F;长期决策"></a>短期&#x2F;长期决策</h4><ul>
<li>短期供给曲线：价格（平均收益）小于平均可变成本（AVC）时，企业<strong>停止营业</strong>，大于AVC时，产量沿着MC曲线移动</li>
<li><strong>沉没成本的无关性</strong>：<strong>短期内</strong>，供给曲线和固定成本没有关系<ul>
<li>应用：弄丢了电影票不影响再买一张的决定、淡季的餐馆和高尔夫球场的决策</li>
</ul>
</li>
<li>长期供给曲线：价格（平均收益）小于平均总成本（ATC）时，企业<strong>退出市场</strong>，进入的标准刚好相反</li>
<li>利润的图形表示</li>
</ul>
<h4 id="竞争市场的供给曲线"><a href="#竞争市场的供给曲线" class="headerlink" title="竞争市场的供给曲线"></a>竞争市场的供给曲线</h4><p>上面讨论的单个企业的短期、长期供给决策，下面看下市场上短期和长期的供给曲线</p>
<ul>
<li>短期：企业数目固定，供给曲线等于边际成本曲线的叠加</li>
<li>长期：企业可以自由离开和加入，达到均衡时，留在市场中的企业利润必定为0。此时，<strong>价格&#x3D;ATC</strong>，而对企业而言，会选择让<strong>价格&#x3D;MC</strong>保证利润最大化，所以最终使<strong>ATC&#x3D;MC</strong>，让市场中每个企业都达到<strong>有效规模</strong>，供给曲线等于固定价格，<strong>完全富有弹性</strong>。</li>
<li>由于这里的成本是<strong>机会成本</strong>，实际上<strong>会计成本</strong>是大于0的，所以企业还会留在市场中</li>
<li>短期、长期内的需求移动<ul>
<li>短期内带来企业的盈利、亏损</li>
<li>长期内随着企业离开和进入市场，价格回到长期均衡</li>
</ul>
</li>
<li>长期供给曲线可能会向右上方倾斜<ul>
<li>生产资源数量有限</li>
<li>鼓励新企业加入，就需要提高价格 -&gt; 甚至能有企业长期盈利</li>
</ul>
</li>
</ul>
<h3 id="垄断"><a href="#垄断" class="headerlink" title="垄断"></a>垄断</h3><ul>
<li>垄断企业是<strong>价格决定者</strong></li>
<li>垄断企业的<strong>进入壁垒</strong><ul>
<li>垄断资源</li>
<li>政府管制：版权和专利</li>
<li>生产流程：规模经济产生的自然垄断，一个企业能够以低于其他企业的成本供应产品</li>
</ul>
</li>
<li>为保证能卖出产品，垄断企业的需求曲线斜向右下方<ul>
<li><strong>垄断者的边际收益总小于物品价格</strong></li>
</ul>
</li>
<li>在垄断企业利润最大化时，P &gt; MR &#x3D; MC<ul>
<li>先找到MC &#x3D; MR的生产数量点，再对应需求曲线找到合适定价的价格</li>
<li>在市场竞争者增多时，价格会逐渐回落到等于边际成本</li>
</ul>
</li>
</ul>
<h4 id="垄断的福利代价"><a href="#垄断的福利代价" class="headerlink" title="垄断的福利代价"></a>垄断的福利代价</h4><ul>
<li>无谓损失：垄断者生产的产量总小于社会有效率的产量<ul>
<li>类似于收税：这里私人企业得到的“税收”正是<strong>垄断利润</strong></li>
<li>对应到现实生活，无谓损失即无效率的低产量</li>
</ul>
</li>
</ul>
<h4 id="价格歧视"><a href="#价格歧视" class="headerlink" title="价格歧视"></a>价格歧视</h4><p>根据消费者对商品的评价差异化确定价格。</p>
<ul>
<li><strong>竞争市场中，不会出现物品的价格歧视</strong></li>
<li>价格歧视可以实现垄断者的利润最大化</li>
<li>价格歧视要求能够根据支付意愿划分顾客</li>
<li>价格歧视可以增进社会福利，不过是生产者的剩余</li>
<li>价格歧视增加了垄断利润，<strong>完全价格歧视可以让生产者获取市场的全部剩余，避免无谓损失</strong>，然而实际中通常做不到<ul>
<li>举例：电影票、飞机票、折扣券、数量折扣</li>
</ul>
</li>
</ul>
<h4 id="针对垄断的公共政策"><a href="#针对垄断的公共政策" class="headerlink" title="针对垄断的公共政策"></a>针对垄断的公共政策</h4><ul>
<li><strong>增加市场竞争性</strong>：反托拉斯法</li>
<li><strong>管制</strong>：直接限制垄断企业的定价</li>
<li><strong>公有制</strong>：政府自己经营 -&gt; 带来市场效率下降</li>
<li><strong>不作为</strong></li>
</ul>
<h3 id="垄断竞争"><a href="#垄断竞争" class="headerlink" title="垄断竞争"></a>垄断竞争</h3><p>既有竞争性又有垄断性的市场，比如小说。</p>
<ul>
<li>寡头，集中率衡量</li>
<li>垄断竞争：<strong>许多卖者</strong>，<strong>产品有差别</strong>，<strong>自由进出</strong></li>
<li>市场组织的分类<ul>
<li>垄断</li>
<li>寡头</li>
<li>垄断竞争</li>
<li>完全竞争</li>
</ul>
</li>
</ul>
<h4 id="差别产品竞争"><a href="#差别产品竞争" class="headerlink" title="差别产品竞争"></a>差别产品竞争</h4><ul>
<li><strong>短期中</strong>，垄断竞争的分析方式和垄断一样</li>
<li><strong>长期中</strong>，企业可以自由进出，并最终达到利润为0的情况，即MR&#x3D;MC，P&#x3D;ATC。价格曲线和平均总成本曲线相切</li>
<li>一些结论，均衡点在ATC变小的部分，此时MC &lt; ATC<ul>
<li>在长期均衡下，对比完全竞争，产量是小于有效规模的，即<strong>有过剩生产能力</strong></li>
<li><strong>高于边际成本的价格加成</strong>，因此此时，每新增一个客户，都会使生产者利润增加，生产者有激励去吸引更多顾客</li>
</ul>
</li>
<li>因为P &gt; ATC，垄断竞争也会带来无谓损失</li>
</ul>
<h4 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h4><ul>
<li>由于垄断企业出售价格大于边际成本，因此都有激励做广告来吸引买者买自己的特定产品<ul>
<li>产品间差异越大的行业，收益中用于广告的成本越大</li>
<li>总体来说，广告促进了竞争</li>
</ul>
</li>
<li>广告本身的质量与否影响着人们对产品质量的评价</li>
</ul>
<h3 id="寡头"><a href="#寡头" class="headerlink" title="寡头"></a>寡头</h3><ul>
<li>勾结、卡特尔：禁止卡特尔内协商生产数目或价格是困难的</li>
<li><strong>纳什均衡</strong>的达成<ul>
<li>寡头价格低于垄断价格，但高于竞争价格</li>
<li>随着企业的增多，市场会越来越接近竞争市场</li>
</ul>
</li>
<li>寡头和囚徒困境：<strong>维持合作是困难的</strong><ul>
<li>军备竞赛</li>
<li>公共资源</li>
<li>寡头的囚徒困境对社会是有益的</li>
</ul>
</li>
<li>多次合作能让合作者更关注长远利益、而避免囚徒困境</li>
<li>贸易限制、托拉斯法</li>
<li>一些看似的反竞争操作，可能有合理的经营目的<ul>
<li>转售价格维持</li>
<li>掠夺性定价</li>
<li>搭售</li>
</ul>
</li>
</ul>
<h2 id="劳动市场经济学"><a href="#劳动市场经济学" class="headerlink" title="劳动市场经济学"></a>劳动市场经济学</h2><h3 id="生产要素市场"><a href="#生产要素市场" class="headerlink" title="生产要素市场"></a>生产要素市场</h3><p>生产要素需求是<strong>派生需求</strong>，是通过<strong>向另外的市场供给物品所产生的需求</strong></p>
<h4 id="劳动的需求和供给"><a href="#劳动的需求和供给" class="headerlink" title="劳动的需求和供给"></a>劳动的需求和供给</h4><ul>
<li>分析前提：<strong>企业具有竞争性、企业追求利润最大化</strong></li>
<li>边际产量值：一种投入的边际产量乘以产品价格</li>
<li>边际产量、边际产量递减 &#x3D;&gt; <strong>向右下方倾斜的边际产量值曲线</strong></li>
<li>竞争性、追求利润最大化的企业雇佣的工人数会达到使<strong>劳动边际产量等于工资</strong>的那一点，即<strong>边际产量值曲线也是劳动需求曲线</strong></li>
<li>工作和闲暇的权衡</li>
</ul>
<h4 id="劳动的均衡"><a href="#劳动的均衡" class="headerlink" title="劳动的均衡"></a>劳动的均衡</h4><p>这里的均衡建立在<strong>竞争市场</strong>的基础上，即工资对买卖双方来说是既定的。买方垄断的情况较少出现。</p>
<ul>
<li>均衡时，<strong>工资等于劳动的边际产量值</strong></li>
<li>供给、需求的移动</li>
</ul>
<h4 id="其他生产要素"><a href="#其他生产要素" class="headerlink" title="其他生产要素"></a>其他生产要素</h4><ul>
<li><strong>劳动、土地和资本</strong></li>
<li><strong>租赁价格</strong>和<strong>购买价格</strong><ul>
<li>对于租赁价格，劳动、土地、资本各自赚到了他们在生产过程中的边际贡献的价值</li>
<li>对比劳动收入、资本收入是通过多种方式支付给家庭的，如股利等</li>
</ul>
</li>
<li>生产要素间相互联系</li>
</ul>
<p>工人的工资反映了他们所所生产的物品&#x2F;服务的市场价格。这也解释了为何程序员的工资比加油站服务员高，IT服务业者的收入比便利店收银员高。</p>
<h3 id="收入和歧视"><a href="#收入和歧视" class="headerlink" title="收入和歧视"></a>收入和歧视</h3><p>产生收入差距的原因</p>
<ul>
<li>补偿性工资差别</li>
<li>人力资本：对人的投资的积累。<ul>
<li>受教育程度高的工人往往有着较高的边际生产率</li>
<li>工作效率、工具的提升，和非熟练劳动需求的转移拉开的熟练、非熟练工资的差距</li>
<li>高等教育也是一种投资</li>
</ul>
</li>
<li>教育作为一种信号</li>
<li>能力、努力和机遇</li>
<li>超级明星<ul>
<li><strong>市场上每个人都想享受最优生产者提供的物品</strong></li>
<li><strong>生产物品的技术使最优生产者低成本提供物品成为可能</strong></li>
</ul>
</li>
<li>最低工资法、工会、效率工资</li>
</ul>
<h4 id="歧视经济学"><a href="#歧视经济学" class="headerlink" title="歧视经济学"></a>歧视经济学</h4><ul>
<li>劳动市场上的歧视并不能直观地分析</li>
<li>竞争市场会对雇主的歧视做“自然的矫正”，<strong>那些只对赚钱有兴趣的企业占据优势地位</strong><ul>
<li>这种歧视只有在<strong>顾客偏好</strong>和<strong>政府政策</strong>存在时，才能维持下去</li>
</ul>
</li>
</ul>
<h3 id="收入不平等和贫困"><a href="#收入不平等和贫困" class="headerlink" title="收入不平等和贫困"></a>收入不平等和贫困</h3><ul>
<li>贫困率、贫困线<ul>
<li>影响衡量不平等的因素：<strong>实物转移支付、生命周期、暂时收入和持久收入</strong></li>
<li>实质生活水平上的不平等比年收入的不平等要小得多</li>
</ul>
</li>
<li>收入再分配的政治哲学<ul>
<li>功利主义：社会效用最大化</li>
<li>自由主义：政策需要客观公正，即由对社会现状一无所知的社会参与者得出<ul>
<li>最大最小准则：主张应该使社会上状况最差的人福利最大化</li>
</ul>
</li>
<li>自由至上主义：预先设定规则，惩罚违规者，强调过程而非结果，不进行收入再分配</li>
</ul>
</li>
<li>减少不平等的政策<ul>
<li>最低工资</li>
<li>福利</li>
<li>负所得税、劳动所得税减免</li>
<li>实物转移支付</li>
<li>反贫困计划、工作激励</li>
</ul>
</li>
</ul>
<h2 id="深入探讨的论题"><a href="#深入探讨的论题" class="headerlink" title="深入探讨的论题"></a>深入探讨的论题</h2><h3 id="消费者选择理论"><a href="#消费者选择理论" class="headerlink" title="消费者选择理论"></a>消费者选择理论</h3><ul>
<li>预算约束曲线：在既定收入下，消费某种物品引起另一种物品消费量的变化</li>
<li>消费者偏好：<strong>无差异曲线、边际替代率</strong></li>
<li>无差异曲线的4个特征<ul>
<li>较高的无差异曲线给消费者的满足感更高</li>
<li>无差异曲线向右下方倾斜</li>
<li>无差异曲线不相交</li>
<li>无差异曲线凸向原点</li>
</ul>
</li>
<li>完全替代品和完全互补品<ul>
<li>完全替代品：边际替代率为定值，一条直线</li>
<li>完全互补品：无差异曲线为直角</li>
</ul>
</li>
</ul>
<h4 id="消费者选择什么"><a href="#消费者选择什么" class="headerlink" title="消费者选择什么"></a>消费者选择什么</h4><ul>
<li>消费者选择什么：最优点<ul>
<li>最优点处，消费者选择的两种物品组合要使<strong>边际替代率</strong>等于<strong>相对价格</strong></li>
<li>相对价格和边际交换率分别代表市场和消费者对两种物品的评价</li>
<li>用<strong>效用</strong>来描述最优点的平衡状态：对X物品支出的每美元的边际效用等于用于Y物品支出的每美元的边际效用</li>
</ul>
</li>
<li>收入变动对选择的影响<ul>
<li>正常物品和低档物品</li>
</ul>
</li>
<li>价格变动对选择的影响<ul>
<li>预算约束线的外扩</li>
<li>收入效应：向更高无差异曲线移动引起的消费变动</li>
<li>替代效应：沿着无差异曲线变动到不同标记替代率的点的消费变动</li>
</ul>
</li>
<li>收入效应、替代效应的应用<ul>
<li>吉芬物品：价格上升引起需求增加，和物品的低档程度有关</li>
<li>工资如何影响劳动供给：取决于劳动者如何衡量收入效应和替代效应</li>
</ul>
</li>
</ul>
<h3 id="微观经济学前沿"><a href="#微观经济学前沿" class="headerlink" title="微观经济学前沿"></a>微观经济学前沿</h3><h4 id="不对称信息"><a href="#不对称信息" class="headerlink" title="不对称信息"></a>不对称信息</h4><ul>
<li>隐蔽性行为和道德风险：代理人和委托人<ul>
<li>公司管理中，股东、董事会和管理层就分属委托人和代理人，道德风险即管理层可以做出违背股东利益的公司决策</li>
</ul>
</li>
<li>隐蔽性特征：逆向选择<ul>
<li>卖者了解得更多，买者承担风险</li>
<li>有信息一方披露信息：<strong>发信号</strong></li>
<li>无信息一方迫使有信息一方披露信息：<strong>筛选</strong></li>
</ul>
</li>
</ul>
<h4 id="政府经济学"><a href="#政府经济学" class="headerlink" title="政府经济学"></a>政府经济学</h4><p>用经济学的方法分析政府</p>
<ul>
<li><strong>康多塞悖论</strong>：（多于两种选择时）多数原则没有产生可传递的社会偏好<ul>
<li>投票顺序会影响结果</li>
<li>多数投票本身可能并不能告诉我们社会想要什么结果</li>
</ul>
</li>
<li><strong>阿罗不可能定理</strong>：没有一种投票制度可以满足下列所有条件<ul>
<li>确定性</li>
<li>传递性</li>
<li>不相关选择的独立性：任何两个结果之间的排序不取决于别的结果</li>
<li>没有独裁者</li>
</ul>
</li>
<li>阿罗不可能定理意味着<strong>无法把社会成员的个人偏好加总成社会偏好</strong></li>
<li><strong>中值选民定理</strong>：多数原则将产生中值选民最偏好的结果<ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E9%80%89%E6%B0%91%E5%AE%9A%E7%90%86/10025349#3">前提</a></li>
<li>应用：大选时，两党都会尽量争取中值选民的支持，因此政治主张也会趋同</li>
</ul>
</li>
</ul>
<h4 id="行为经济学"><a href="#行为经济学" class="headerlink" title="行为经济学"></a>行为经济学</h4><p>社会心理学和经济学的融合</p>
<ul>
<li>人不总是理性：左位偏差</li>
<li>人想要公平</li>
<li>人是善变的</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/blog/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">31:15</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

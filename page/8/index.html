<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/8/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">424</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/09/10/php-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/09/10/php-note/" class="post-title-link" itemprop="url">（旧文）PHP语言介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-09-10 21:02:17 / 修改时间：21:04:17" itemprop="dateCreated datePublished" datetime="2019-09-10T21:02:17+08:00">2019-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/09/10/php-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/10/php-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="//php.net">php.net</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PHP来源于工程PHP&#x2F;FI，由Rasmus Lerdorf创建于1995年，起初只是一套简单的Perl脚本，名字叫做“Personal Home Page Tools”，语法也和Perl很像，随着用户的增加，改进为用C语言实现。1997年，Andi Gutmans 和 Zeev Suraski 重写了代码，推出第三版，PHP&#x2F;FI也演变成PHP（PHP: Hypertext Preprocessor）。注意，这是一个递归的缩写。</p>
<p>1999年，由两人改进的更具模块化的“Zend Engine”引入PHP，在结合了许多新功能后，2000年5月发布官方版PHP 4.0。如今广泛使用的5.x版本从2004年起发布。5.x版本支持完整的面向对象模型。目前的最新版本已经到了7.x版本（直接从稳定的5.6版跃迁）。</p>
<p>由于丰富的PHP主要用于服务端的脚本程序，就像其他的CGI程序，如收集表单，生成网页，发送&#x2F;接收Cookie等。除此以外，PHP还用于命令行脚本，编写桌面应用程序。这两种开发可能会用到PHP的拓展库。由于解析器的存在，PHP的跨平台能力很好。 </p>
<p>关于php的绝大多数内容都可以在<a target="_blank" rel="noopener" href="//php.net">php.net</a>上找到，上面介绍的历史也是如此。本文的绝大多数内容更是如此。</p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>在通常情况下，php用于服务器端脚本，安装配置较之Javascript复杂很多。在Unix环境下，假设服务器环境（如Apache, Nginx等）已经安装完毕，可以通过configure脚本安装配置。Windows环境下，通过MSI文件安装配置PHP和所有内置以及PECL拓展库。此外Mac OS X，云平台等安装各有不同，详见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/install.php">官方教程</a>。</p>
<p>配置文件（<code>php.ini</code>）在PHP启动时被读取，作为服务器模块版本的PHP，仅在服务器启动时读取1次，作为CGI和CLI版本，每次调用都会读取。用户亦可自定义自己的<code>user.ini</code>文件。PHP的有些指令可以在PHP脚本中用<code>ini_set()</code>设定，有些只能在<code>php.ini</code>或<code>httpd.conf</code>中设定。这些是由指令的模式决定的，模式有4种：<code>PHP_INI_USER</code>, <code>PHP_INI_PERDIR</code>, <code>PHP_INI_SYSTEM</code>, <code>PHP_INI_ALL</code>。具体见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/configuration.changes.modes.php">文档</a>。</p>
<p>PHP作为Apache模块运行时，还可以用<code>php_value</code>, <code>php_flag</code>, <code>php_admin_value</code>, <code>php_admin_flag</code>命令设置。</p>
<h2 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h2><p>与C等语言通过代码输出HTML不同的是，PHP页面本身就是HTML，你也完全可以像通常建立HTML页面那样创建和编辑PHP页面，只不过其中嵌入了<code>&lt;?php</code>和<code>?&gt;</code>包裹的PHP代码。与Javascript不同的是，PHP运行在服务端，用户无从得知脚本是如何运行的。</p>
<p>值得一提的是，除了上述的开始和结束标记，使用<code>&lt;script language =&quot;php&quot;&gt;&lt;/script&gt;</code>或者asp风格的短标记<code>&lt;?=</code>, <code>&lt;%=</code>也行（<em>不建议</em>）。在这一对标记之外的内容都会被PHP解析器忽略。可以在脚本中通过<code>phpinfo()</code>打印php的整体配置信息。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在html语句中嵌入php语句时，尽量做到将业务逻辑和展示语句隔离开对维护php工程有着极大的好处。</p>
<h2 id="特性参考"><a href="#特性参考" class="headerlink" title="特性参考"></a>特性参考</h2><h3 id="PHP标识"><a href="#PHP标识" class="headerlink" title="PHP标识"></a>PHP标识</h3><p>如上文中提到，PHP通过<code>&lt;?php</code>和<code>?&gt;</code>分隔php脚本，在<code>php.ini</code>激活<code>short_open_tag</code>配置后，支持使用短标记作为分隔符。<strong>如果文件内容为纯PHP代码，最好在文末删除结束标记，以免打印意料之外的空白</strong>。如下示例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="comment">// ... more code</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Last statement&quot;</span>;</span><br><span class="line"><span class="comment">// stop here</span></span><br></pre></td></tr></table></figure>

<p>PHP使用<strong>分号</strong>作为分隔符，支持C，C++，Perl风格的注释。即<code>//</code>，<code>/**/</code>和<code>#</code>。</p>
<h3 id="类型-amp-类型转换"><a href="#类型-amp-类型转换" class="headerlink" title="类型 &amp; 类型转换"></a>类型 &amp; 类型转换</h3><p>PHP的原始数据类型有<strong>boolean，integer，float，string，array，object，resource，NULL</strong>。其中前4种为标量，第5，6中为复合类型。resouce表示资源，<strong>NULL表示无类型</strong>。PHP中<strong>float也称为double</strong>。在确保代码易读性上，还有mixed，number和callback几种伪类型。需要注意的是，PHP和Javascript一样，类型往往根据上下文确定。</p>
<h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>和JavaScript类似。</p>
<p>只有TRUE或FALSE，除了false以外，还有下列假值：</p>
<ul>
<li>0</li>
<li>0.0</li>
<li>‘’</li>
<li>“0”</li>
<li>[],</li>
<li>{}（仅4.0）</li>
<li>NULL</li>
</ul>
<p>其余均为真值（包含任何resource）。和Javascript类似，支持&#x3D;&#x3D;&#x3D;全等。</p>
<h4 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h4><p>有十进制，十六进制，八进制，二进制表示。除十进制外，分别以<code>0</code>, <code>0x</code>, <code>0b</code>开头。5.0.5后最大值可以用常量<code>PHP_INT_MAX</code>设置。<strong>整数溢出时会被解释为float</strong>。<strong>注意：八进制中传递非法数字后，后面数字会被忽略</strong>。类型转换时，可以使用<code>intval()</code>。在浮点数过大，分数强制转换和其他类型转换时，结果未定义。</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>又称为double和real，支持科学记数法。运算时精度有限，高精度要求下参考任意精度数学函数和gmp函数。在比较大小时需要谨慎，可以采用相减之差和最大容忍度比较的方法作折衷。常量<code>NAN</code>表示浮点计算中不可描述的值，为float类型，不等于任何其他变量，甚至自身。可以用<code>is_nan()</code>检查。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>和JavaScript区别较大。</p>
<ul>
<li>PHP字符串的字符占1个字节，因此不支持Unicode。字符串最长可达2GB</li>
<li>表示字符串有4种方法，<strong>单引号，双引号，heredoc和nowdoc</strong>。<ul>
<li>单引号下，只转义单引号和反斜线，其余字符均为plain text，支持多行；</li>
<li>双引号下，对换行回车制表符等特殊字符进行转义，还会对变量解析（$xxx）的形式（和Javascript相似）。</li>
<li>Heredoc结构里，在&lt;&lt;&lt;符号后提供一个标识符然后换行，接下来是字符串本身，字符串后另起一行用前面定义的标识符作为结束标志。中间内容的处理方式同双引号。</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">Example of string</span></span><br><span class="line"><span class="string">spanning multiple lines</span></span><br><span class="line"><span class="string">using heredoc syntax.</span></span><br><span class="line"><span class="string">EOD</span>;</span><br></pre></td></tr></table></figure>

<p>5.3.0以后，可以使用heredoc结构初始化静态变量和类的属性以及常量。nowdoc结构类似于单引号版的heredoc，但是跟在<code>&lt;&lt;&lt;</code>之后的标识符要用单引号括起来，多用在不解析特殊字符的大段文本中。在双引号或heredoc结构中，变量会被解析，简单语法下，PHP解析器会去组合尽量多的标识形成一个合法的<strong>变量名</strong>。复杂语法下，<code>$</code>符号的<strong>外侧或里侧</strong>会紧贴<code>&#123;&#125;</code>，来实现更复杂的变量表达式。</p>
<p>字符串中的字符可以用<code>[]</code>或者<code>&#123;&#125;</code>（不建议）访问。下标超出字符串长度时，会将<strong>多出的长度用空格填充</strong>。另外，字符串使用<code>.</code>连接。使用<code>strval()</code>转换变量为字符串，boolean会转成<code>&quot;1&quot;</code>或<code>&quot;&quot;</code>。integer和float作字面转换。**array总转换成<code>&quot;Array&quot;</code>**。object总转换成”Object”。NULL总转变成<code>&quot;&quot;</code>。</p>
<p><code>serialize()</code>可以串行化大部分PHP值。字符串转为数值时，类似Javascript的<code>parseInt()/parseFloat()</code>，试图从头转换直到遇到不合法字符，支持科学记数法。区别在于PHP中失败时返回<code>0</code>而不是<code>NAN</code>。</p>
<p>关于string的更多介绍，参加<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.types.string.php#language.types.string">官方文档String</a>一章。</p>
<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$array</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&quot;foo&quot;</span> =&gt; <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span> =&gt; <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自 PHP 5.4 起</span></span><br><span class="line"><span class="variable">$array</span> = [</span><br><span class="line">    <span class="string">&quot;foo&quot;</span> =&gt; <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span> =&gt; <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>与Javascript区别较大，PHP中的数组也是个<strong>有序</strong>映射，描述了keys到values的映射。array使用<code>array()</code>初始化，在5.4版本后支持字面量定义。<strong>key可以是integer或string</strong>（integer时是数组，string时是键值对），value可以是任何类型。使用<code>[]</code>访问和修改数组元素，通过<code>unset()</code>删除某键值对（类似与Javascript的<code>delete</code>）。有趣的是，使用<code>[]</code>不指定键名时，则取当前最大整数索引值（曾经存在即可），新的键名在之上加1。可以使用<code>array_values()</code>重建索引。</p>
<p>转换为数组时，除object、NULL类型外，其余类型得到只有一个元素的数组。object类型转换时，单元为对象的属性，键名为成员变量名，还有其他特殊情况见文档<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.types.array.php">数组</a>部分。NULL会转换为一个空数组。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$A</span>; <span class="comment">// This will become &#x27;\0A\0A&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$A</span>; <span class="comment">// This will become &#x27;\0B\0A&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$AA</span>; <span class="comment">// This will become &#x27;AA&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>((<span class="keyword">array</span>) <span class="keyword">new</span> <span class="title function_ invoke__">B</span>());</span><br></pre></td></tr></table></figure>

<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>对象，通过new来实例化一个类产生。转换为对象时，PHP会创建一个内置类stdClass的实例，可以通过<code>new stdClass()</code>创建一个空对象。php 7后，还有<code>new class&#123;&#125;</code>和<code>(object) []</code>方法。</p>
<h4 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h4><p>用于保存到外部资源的一个引用，通过专门的函数建立和使用，由Zend引擎维护资源回收。</p>
<h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>表示一个变量没有值。可细分为被赋值为<code>NULL</code>，尚未赋值和被<code>unset()</code>。<strong>NULL不区分大小写</strong>。</p>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>类似Javascript中的function类型，一些函数如<code>call_user_func()</code>可以接收用户定义的回调函数作为参数。传递时，以string类型传递函数名。5.3.0后可以直接传递closure给回调参数。</p>
<p>其余伪类型多用于代码的说明注释中，如<code>mixed</code>表述多种不确定类型，<code>void</code>表述函数返回值无用或不接受任何参数等。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>使用<code>var_dump()</code>查看值和类型，<code>gettype()</code>查看类型，<code>is_int</code>&#x2F;<code>is_string</code>&#x2F;…判断类型，<code>(type)</code>或<code>settype()</code>强制类型转换。PHP的强制转换和C非常相似。目前支持<code>(int)</code>, <code>(bool)</code>, <code>(float)</code>, <code>(string)</code>, <code>(array)</code>, <code>(object)</code>, <code>(unset)</code>（转换为<code>NULL</code>）。5.2版本后支持<code>(binary)</code>转换。</p>
<p>除了强制转换，PHP中会根据需要对变量自动转换，如加法。与Javascript的<code>+</code>不大不同，PHP会优先将操作数转为float，否则会将操作数解释为integer。数组的键名会优先转换为integer（仅十进制），再转换为string。下面就是一个有趣的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$foo</span> = <span class="string">&quot;0&quot;</span>;  <span class="comment">// $foo is a string</span></span><br><span class="line">  <span class="variable">$foo</span> += <span class="number">2</span>;   <span class="comment">// $foo is an int now</span></span><br><span class="line">  <span class="variable">$foo</span> = <span class="variable">$foo</span> + <span class="number">1.3</span>;  <span class="comment">// $foo is a float now (3.3)</span></span><br><span class="line">  <span class="variable">$foo</span> = <span class="number">5</span> + <span class="string">&quot;10 Little Piggies&quot;</span>; <span class="comment">// $foo is an integer (15)</span></span><br><span class="line">  <span class="variable">$foo</span> = <span class="number">5</span> + <span class="string">&quot;Small Pigs&quot;</span>;     <span class="comment">// $foo is an integer (5)</span></span><br></pre></td></tr></table></figure>

<h3 id="变量-amp-常量"><a href="#变量-amp-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h3><p>PHP变量以<code>$</code>符号开头，只能包含数字字母（这里说的字母包含ASCII字符）和下划线且不能以数字开头。变量区分大小写。<code>$this</code>是特殊变量不能赋值。可以在<code>$</code>前加<code>&amp;</code>符号<strong>引用赋值</strong>，在改变原变量时，目标变量也会改动。<code>isset()</code>可以检查变量是否已被赋值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$var</span> = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"><span class="variable">$Var</span> = <span class="string">&#x27;Joe&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$var</span>, <span class="subst">$Var</span>&quot;</span>;      <span class="comment">// 输出 &quot;Bob, Joe&quot;</span></span><br><span class="line"></span><br><span class="line">$<span class="number">4</span>site = <span class="string">&#x27;not yet&#x27;</span>;     <span class="comment">// 非法变量名；以数字开头</span></span><br><span class="line"><span class="variable">$_4site</span> = <span class="string">&#x27;not yet&#x27;</span>;    <span class="comment">// 合法变量名；以下划线开头</span></span><br><span class="line"><span class="variable">$i</span>站点is = <span class="string">&#x27;mansikka&#x27;</span>;  <span class="comment">// 合法变量名；可以用中文</span></span><br></pre></td></tr></table></figure>

<p>用户在为变量命名时，有几点要注意的。function, class, interface, 常量和函数外定义的变量会进入全局命名空间；建议在函数名中用<code>_</code>区分，类名中用驼峰或首字母大写的驼峰命名。注意：很多情况下，PHP会自动将变量名中的点转换成下划线。</p>
<h4 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h4><p>PHP中的变量名可以很方便地改变，而且可变变量可以用在数组或对象中，如下面的例子，。使用可变变量时，注意通过花括号给属性名清晰定界。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// Given these variables ...</span></span><br><span class="line"><span class="variable">$nameTypes</span>    = <span class="keyword">array</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;last&quot;</span>, <span class="string">&quot;company&quot;</span>);</span><br><span class="line"><span class="variable">$name_first</span>   = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="variable">$name_last</span>    = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="variable">$name_company</span> = <span class="string">&quot;PHP.net&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then this loop is ...</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$nameTypes</span> <span class="keyword">as</span> <span class="variable">$type</span>)</span><br><span class="line">  <span class="keyword">print</span> $&#123;<span class="string">&quot;name_<span class="subst">$type</span>&quot;</span>&#125; . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... equivalent to this print statement.</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;<span class="subst">$name_first</span>\n<span class="subst">$name_last</span>\n<span class="subst">$name_company</span>\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>PHP提供许多预定义的变量。PHP中的许多预定义变量都是“超全局的”，这意味着它们在脚本的全部作用域都可见。这种类型在4.1版本中被引入，有<code>$GLOBALS</code>, <code>$_SERVER</code>, <code>$_GET</code>, <code>$_POST</code>, <code>$_FILES</code>, <code>$_COOKIE</code>, <code>$_SESSION</code>, <code>$_REQUEST</code>, <code>$_ENV</code>。它们在5.4版本后不能作为函数的输入参数。通过这些预设的超全局变量，PHP可以轻松地获取请求的各种参数。</p>
<p>除了上述超全局变量外，还有<code>$php_errormsg</code>, <code>$HTTP_RAW_POST_DATA</code>（使用php:&#x2F;&#x2F;input代替）, <code>$http_response_header</code>(使用HTTP包装其时，该变量会被自动填充)，<code>$argc</code>和<code>$argv</code>分别代表传递给脚本的参数数目和参数数组（运行在命令行下时）。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量作用域通常为文件作用域。函数内部的声明的变量被限制在函数作用域内。同时，和Javascript相同，<strong>PHP没有块级作用域</strong>。注意，PHP中定义全局变量需使用<code>global</code>关键字。在函数内部，变量优先视作局部变量。下面的脚本不会有任何输出，因为<code>echo</code>引用了一个局部变量<code>$a</code>，但是在函数作用域内它并没有被赋值。要想$a在函数作用域内可见，需要在引用前声明<code>global</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>; <span class="comment">/* global scope */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">/* reference to local scope variable */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">Test2</span>();</span><br></pre></td></tr></table></figure>

<p>静态变量通过<code>static</code>声明，<strong>仅在局部作用域存在</strong>，程序离开作用域时内容不丢失。静态变量不能使用表达式初始化。在下面的例子中，函数仅在第一次调用时初始化<code>$a</code>变量，之后每次调用都会输出<code>$a</code>，并加一。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="variable">$a</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="variable">$a</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在类外，常量通过<code>define(name. value)</code>函数定义。在类内使用<code>const</code>定义常量（5.3.0后）。常量的命名规范同C。常量只能是标量。<strong>在访问常量值时，名字前不带<code>$</code><strong>。常量名事先无法确定时，使用<code>constant()</code>获取常量。</strong>常量没有作用域的限制</strong>，可以在任何位置访问。</p>
<p>PHP定义了大量的魔术常量，都以两个下划线开头和结尾。有<code>__LINE__</code>，<code>__FILE__</code>, <code>__DIR__</code>, <code>__FUNCTION__</code>, <code>__CLASS__</code>, <code>__TRAIT__</code>, <code>METHOD__</code>, <code>__NAMESPACE__</code>。具体解释见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.constants.predefined.php">官方文档</a>。</p>
<h3 id="表达式-amp-流程"><a href="#表达式-amp-流程" class="headerlink" title="表达式 &amp; 流程"></a>表达式 &amp; 流程</h3><p>PHP的表达式根据官方的定义表述，是<em>任何有值的东西</em>。表达式的组成类似于其他语言，从略。值得注意的有以下几点：</p>
<ul>
<li>PHP的逻辑运算符同时有<code>&amp;&amp;</code>, <code>||</code>以及<code>and</code>, <code>xor</code>, <code>or</code>两套，但是<strong>后一套的优先级最低</strong>。</li>
<li>PHP提供<code>@</code>作为错误控制运算符，放置在表达式前可以忽略产生的任何错误信息。<strong>强烈不建议使用</strong>。</li>
<li>反引号``执行其中的shell命令，并将输出结果返回，等同于执行<code>shell_exec()</code>。</li>
<li><code>+</code>, <code>==</code>, <code>===</code>还可以用于数组间的运算，进行数组的连接，键值对相同的检测。</li>
<li><code>instanceof</code>用于确定变量是否属于某个类的实例。用法如<code>$a instanceof MyClass</code></li>
</ul>
<p>算法流程上，PHP类似C风格。不同点有：</p>
<ul>
<li>提供在<code>&lt;?php&gt;</code>闭合标签内使用<code>for endfor</code>这种用法</li>
<li><code>foreach(array as $key =&gt; $value)</code>便于遍历数组。（注意：在<code>$value</code>前<code>&amp;</code>可以在<code>foreach</code>循环中改变<code>value</code>的值）</li>
<li><code>break</code>可以接受一个可选的数字决定跳出几层循环</li>
<li><code>continue</code>接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是<code>1</code></li>
<li><code>declare</code>设定一段代码的施行指令，目前只支持<code>ticks</code>和<code>encoding</code>。前者控制执行计时的若干条命令后的操作，后者决定代码的运行编码。</li>
<li><code>require</code>和<code>include</code>效果类似，用法同C，它们也有带后缀<code>_once</code>的操作符</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>PHP的函数定义和其他语言类似，定义的函数都具有全局作用域。不同的是</p>
<ul>
<li>PHP可以使用<code>create_function(args, code)</code>这样的函数定义函数（类似JS中的<code>new Function()</code>）</li>
<li>函数需要先定义后使用（这个只是与Javascript不同）</li>
<li>PHP可以定义有条件的函数，通过用if包裹和放在function定义内</li>
</ul>
<p>和C&#x2F;C++风格很像的是：</p>
<ul>
<li>PHP函数参数接收的是一个复制，需要传递引用改变原值；</li>
<li>支持默认参数，需放在最右；</li>
<li>5.0之后支持对输入参数类型检查，到5.4为止支持class &#x2F; array &#x2F; callable类型，7.0以后支持标量类型。如果给出的值类型不对，那么将会产生一个错误</li>
<li>7.0之后支持不对输入参数强制类型转换。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This doesn&#x27;t extend C.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">C <span class="variable">$c</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">get_class</span>(<span class="variable">$c</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="keyword">new</span> C);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="keyword">new</span> D);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="keyword">new</span> E);</span><br></pre></td></tr></table></figure>

<p>和Js相似的一点时，5.6版之后支持使用<code>...</code>符号获取参数列表。</p>
<p>和可变变量一样，PHP中有可变函数，用法和可变变量一样。在调用对象的静态方法时，函数调用要优于静态属性，下面是一个例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="variable">$variable</span> = <span class="string">&#x27;static property&#x27;</span>;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">Variable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Method Variable called&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title class_">Foo</span>::<span class="variable">$variable</span>; <span class="comment">// This prints &#x27;static property&#x27;. It does need a $variable in this scope.</span></span><br><span class="line"><span class="variable">$variable</span> = <span class="string">&quot;Variable&quot;</span>;</span><br><span class="line"><span class="title class_">Foo</span>::<span class="variable">$variable</span>();  <span class="comment">// This calls $foo-&gt;Variable() reading $variable in this scope.</span></span><br></pre></td></tr></table></figure>

<p>5.3之后，PHP也支持匿名函数，并可以传递给一个变量储存。实际中，这种表达式会被转换为内置类Closure的对象实例。闭包可以从父作用域继承变量，但是此类变量需要用<em>use结构</em>传递进去，类似于<code>function() use($a)&#123;&#125;</code>这样的形式。</p>
<h3 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h3><p>PHP承袭着面向对象语言对类和对象的处理。类以<code>class</code>开头，里面包含属性和方法等，可以包含自己的常量。通过<code>new</code>实例化，通过<code>extends</code>实现继承。子类使用<code>parent::</code>访问被覆盖的属性或方法，使用<code>self::</code>自身的静态属性和方法。5.5之后使用<code>ClassName::class</code>可以获取带有命名空间的完整类名。轻量级的类可以通过强制转换关联数组实现。</p>
<p>类中的静态属性通过<code>::</code>访问，非静态属性通过<code>-&gt;</code>访问。定义常量时使用<code>const</code>，常量的值必须是一个定值（5.6之后可以是数学运算结果）。PHP 5新增了关键字<code>final</code>，修饰方法或者类不可被继承。</p>
<p>PHP 5中，**<code>__autoload()</code>函数会在使用未定义的类时自动调用**，5.3.0之后通常使用<code>spl_autoload_register()</code>作为<code>autoload</code>的替代。<code>__construct()</code>和<code>__destruct()</code>分别是构造和析构函数，5.3.3之前，在没有<code>__construct()</code>函数也没有父类时，会寻找命名空间中与类名同名的方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">spl_autoload_register</span>(function (<span class="variable">$class_name</span>) &#123;</span><br><span class="line">    <span class="keyword">require_once</span> <span class="variable">$class_name</span> . <span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span>  = <span class="keyword">new</span> <span class="title class_">MyClass1</span>();</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> <span class="title class_">MyClass2</span>();</span><br></pre></td></tr></table></figure>

<h4 id="trait-amp-匿名类"><a href="#trait-amp-匿名类" class="headerlink" title="trait &amp; 匿名类"></a>trait &amp; 匿名类</h4><p>在访问控制，继承，抽象类，接口等方面PHP和传统的面向对象语言很像。在5.4.0后，PHP提供了<strong>trait作为类之间代码水平复用的特性（很像mixin）</strong>。在class定义中使用<code>use</code>来获取trait，类似interface，一个类可以插入多个trait，trait会覆盖基类方法而被当前类方法覆盖。在多个trait的同名方法发生冲突时，通过<code>insteadof</code>和<code>as</code>来决定使用哪个，具体见<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.traits.php">trait文档</a>。trait的功能使用依赖注入也可以完成，相关讨论见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7892749/traits-in-php-any-real-world-examples-best-practices">stackoverflow trait practives</a>与<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9205083/traits-vs-interfaces">trait vs interface</a>。trait甚至还支持抽象成员和静态成员。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">smallTalk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bigTalk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">smallTalk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bigTalk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">A</span>, <span class="title">B</span> &#123;</span><br><span class="line">        <span class="title">B</span>::<span class="title">smallTalk</span> <span class="title">insteadof</span> <span class="title">A</span>;</span><br><span class="line">        A::<span class="variable constant_">bigTalk</span> <span class="keyword">insteadof</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aliased_Talker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">A</span>, <span class="title">B</span> &#123;</span><br><span class="line">        <span class="title">B</span>::<span class="title">smallTalk</span> <span class="title">insteadof</span> <span class="title">A</span>;</span><br><span class="line">        A::<span class="variable constant_">bigTalk</span> <span class="keyword">insteadof</span> B;</span><br><span class="line">        B::<span class="variable constant_">bigTalk</span> <span class="keyword">as</span> talk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP7.0之后支持匿名类，用于创建一次性的简单对象。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// PHP 7 之前的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"><span class="variable">$msg</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$util</span>-&gt;<span class="title function_ invoke__">setLogger</span>(<span class="keyword">new</span> <span class="title class_">Logger</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 PHP 7+ 后的代码</span></span><br><span class="line"><span class="variable">$util</span>-&gt;<span class="title function_ invoke__">setLogger</span>(<span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> function <span class="title function_ invoke__">log</span>(<span class="variable">$msg</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="“重载”"><a href="#“重载”" class="headerlink" title="“重载”"></a>“重载”</h4><p>PHP提供的<strong>重载（overload）</strong>语义和其他大部分OOP语言不同，指在调用当前环境下未定义或不可见的类属性或方法时调用重载方法。PHP借助<strong>魔术方法</strong>实现重载。读写不可访问属性时，<code>__get()</code>和<code>__set()</code>分别被调用；对不可访问属性调用<code>isset</code>和<code>unset</code>时，<code>__isset()</code>和<code>__unset()</code>分别被调用。<strong>属性重载只能在对象中进行</strong>。调用不可访问的方法和静态方法时，<code>__call()</code>和<code>__callStatic()</code>分别被调用，方法重载用法类似属性重载。重载的示例见文档。（<em>不建议使用这个特性，这会影响ide补全和代码的可读性</em>）。</p>
<p>PHP5提供foreach方法遍历对象，默认情况可见属性都会被遍历，可以让类实现<code>Iterator</code>接口从而自行决定如何处理遍历。实现<code>IteratorAggregate</code>接口可以代替实现所有的Iterator方法，<code>IteratorAggregate</code>只需实现<code>IteratorAggregate::getIterator()</code>方法即可。</p>
<h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>PHP将所有<code>__</code>开头的类方法保留为<strong>魔术方法</strong>，<code>__sleep()</code>方法在<code>serialize()</code>函数前调用，应返回一个包含对象中所有应被序列化的变量名称的数组，相对的<code>__wakeup()</code>在反序列化函数前调用。<code>__toString()</code>在把一个类视作字符串时怎样回应时调用。<code>__invoke()</code>在把一个类视作函数调用时调用。更多方法见<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php">魔术方法页面</a>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$link</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$server</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$db</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$server</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$db</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;server = <span class="variable">$server</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;db = <span class="variable">$db</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">connect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;link = <span class="title function_ invoke__">mysql_connect</span>(<span class="variable">$this</span>-&gt;server, <span class="variable">$this</span>-&gt;username, <span class="variable">$this</span>-&gt;password);</span><br><span class="line">        <span class="title function_ invoke__">mysql_select_db</span>(<span class="variable">$this</span>-&gt;db, <span class="variable">$this</span>-&gt;link);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;server&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;db&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">connect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP使用<code>clone</code>创造对象的浅复制（即只创造属性的引用），魔术方法<code>__clone()</code>在clone完成后调用。PHP 5中的对象甚至可以相互比较，使用<code>==</code>判断属性和属性值是否一致，<code>===</code>判断变量是否是同一个实例。</p>
<p>自5.3.0起，PHP增加了<code>static::</code>关键字和<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.late-static-bindings.php">后期静态绑定</a>的功能，用于在继承范围内引用静态调用的类。静态环境下绑定静态方法可以让子类在<strong>自己的环境</strong>下（自己的this）调用继承自基类的方法。这种方式绑定非静态方法时，会出现不同结果，尽量避免使用。</p>
<p>对象通过<code>serialize()</code>和<code>unserialize()</code>来序列化和反序列化一个对象，对象的方法和静态成员不会保留。<strong>在解序列的文件域内需要包含类的定义</strong>。</p>
<h4 id="预定义接口"><a href="#预定义接口" class="headerlink" title="预定义接口"></a>预定义接口</h4><p>PHP预定义了许多接口。<code>Traversal</code>接口监测一个类是否可以使用foreach进行遍历（仅供引擎使用）。<code>Iterator</code>接口用来实现对象的foreach迭代，有<code>rewind</code>, <code>current</code>, <code>key</code>, <code>next</code>, <code>valid</code>等成员方法。除此以外还有聚合迭代，数组式访问，序列化，生成器接口等接口和Closure类。这里从略。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间是PHP一个比较有特点的特性。在PHP中用命名空间解决<strong>类库和用户代码名字冲突的问题</strong>。实际上命名空间所做的事情就是代码模块化，正如Java的packages和Javascript里CommonJS规范一样。命名空间的命名方法类似变量，不允许使用PHP或php开头的命名空间。下面是一个命名空间的范例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">my</span>\<span class="title class_">name</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MYCONST</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> \my\name\MyClass; </span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">strlen</span>(<span class="string">&#x27;hi&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">namespace</span>\<span class="title class_">MYCONST</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">__NAMESPACE__</span> . <span class="string">&#x27;\MYCONST&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">constant</span>(<span class="variable">$d</span>);</span><br></pre></td></tr></table></figure>

<p>除了<code>declare</code>语句以外，<strong>namespace的定义需在文件的最前面</strong>。PHP与其它的语言特征不同，同一个命名空间可以定义在多个文件中，即<strong>允许将同一个命名空间的内容分割存放在不同的文件中</strong>。在命名空间中使用define定义常量时，需要带上<code>__NAMESPACE__</code>，否则意味着定义在全局空间下。</p>
<p>PHP中的命名空间和文件目录很像，也支持层级化的定义方法，即定义子命名空间，父子间通过反斜线<code>\</code>隔开。可以在单文件内定义多个namespace（<strong>不提倡</strong>），建议namespace间通过大括号隔离开。PHP命名空间可以和文件系统进行类比，类名非限定时，会在当前空间寻找，以<code>\</code>开头时从全局空间寻找（相对目录），否则从当前空间起向下寻找（绝对目录）。下面是一个使用了三种方法的样例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Foo</span>\<span class="title class_">Bar</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;file1.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO</span> = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticmethod</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非限定名称 */</span></span><br><span class="line"><span class="title function_ invoke__">foo</span>();     <span class="comment">// 解析为 Foo\Bar\foo</span></span><br><span class="line">foo::<span class="title function_ invoke__">staticmethod</span>();     <span class="comment">// 解析为类 Foo\Bar\foo的静态方法static method</span></span><br><span class="line"><span class="keyword">echo</span> FOO; <span class="comment">// 解析为常量 Foo\Bar\FOO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 限定名称 */</span></span><br><span class="line">subnamespace\<span class="title function_ invoke__">foo</span>(); <span class="comment">// 解析为函数 Foo\Bar\subnamespace\foo</span></span><br><span class="line">subnamespace\foo::<span class="title function_ invoke__">staticmethod</span>(); <span class="comment">// 解析为类 Foo\Bar\subnamespace\foo, 以及类的方法 staticmethod</span></span><br><span class="line"><span class="keyword">echo</span> subnamespace\FOO; <span class="comment">// 解析为常量 Foo\Bar\subnamespace\FOO</span></span><br><span class="line">                                  </span><br><span class="line"><span class="comment">/* 完全限定名称 */</span></span><br><span class="line">\Foo\Bar\<span class="title function_ invoke__">foo</span>(); <span class="comment">// 解析为函数 Foo\Bar\foo</span></span><br><span class="line">\Foo\Bar\foo::<span class="title function_ invoke__">staticmethod</span>(); <span class="comment">// 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod</span></span><br><span class="line"><span class="keyword">echo</span> \Foo\Bar\FOO; <span class="comment">// 解析为常量 Foo\Bar\FOO</span></span><br></pre></td></tr></table></figure>

<p>命名空间的装载和名称的解析是在编译期完成的。命名空间有三种定义方法：</p>
<ul>
<li>非限定名称：名称中不包含命名空间分割符，即\，如Foo</li>
<li>限定名称：名称中包含命名空间分割符，如Foo\Bar</li>
<li>完全限定名称：名称中包含命名空间分割符，且以\开始的标识符，如\Foo\Bar</li>
</ul>
<p>PHP支持使用<code>namespace</code>关键字或<code>__NAMESPACE__</code>魔术常量获取当前所在命名空间。所有支持命名空间的PHP版本支持三种别名或导入方式：<strong>为类名称使用别名</strong>、<strong>为接口使用别名</strong>、<strong>为命名空间名称使用别名</strong>。这么做类似于在操作系统中创建符号连接。别名通过操作符<code>use as</code>实现。注意：导入命名空间后文件内的类名，接口名等会收到导入的影响。在一个命名空间中，当PHP遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP会退而使用全局空间中的函数或常量。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称。</p>
<h3 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h3><p>PHP的错误类型有很多，可以见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/errorfunc.constants.php">类型列表</a>。PHP对错误的汇报方式由<code>php.ini</code>中的<code>error_reporting</code>命令控制，可以在运行时通过<code>error_reporting()</code>函数动态修改。在开发环境，建议将级别设置到<code>E_ALL</code>，同时在脚本的开头设置级别。<code>php.ini</code>中的<code>display_errors</code>指令控制是否将错误显示在脚本输出中，建议在生产环境中关闭。<code>log_errors</code>指令控制错误记录。</p>
<p>PHP 5中异常可以被抛出，由try&#x2F;catch语句块获取。<code>catch</code>获得的是一个<code>Exception</code>类的实例。类似Java，可以在catch后加上finally语句块。Exception是一个类，有<code>getMessage</code>，<code>getTraceAsString</code>等方法可以使用和拓展，详见介绍。PHP 7中，大多数错误都被作为Error异常抛出，可以被第一个匹配的try&#x2F;catch语句块捕获，否则交给PHP相应的异常处理函数处理，如果尚未通过<code>set_exception_handler()</code>注册童永刚异常处理函数，则会报告一个Fatal Error。注意：捕获错误或异常时，若在自定义命名空间下，Exception需要用完全限定方式书写。</p>
<p>7.0以后的版本中，<code>Error</code>和<code>Exception</code>同属于<code>Throwable</code>类型，这一点与5.x版本不同。代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//To catch both exceptions and errors in PHP 5.x and 7, add a catch block for Exception AFTER catching Throwable first.</span></span><br><span class="line"><span class="comment">//Once PHP 5.x support is no longer needed, the block catching Exception can be removed.</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Code that may throw an Exception or Error.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">Throwable</span> <span class="variable">$t</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Executed only in PHP 7, will not match in PHP 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Executed only in PHP 5, will not be reached in PHP 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h3><p>PHP中的生成器的概念与Java等高级语言中生成器的概念无二。生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以<code>yield</code>生成许多它所需要的值。当一个生成器被调用的时候，它返回一个可以被遍历的对象。PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态。<strong>生成器不可以返回值</strong>。return语句只会终止生成器继续执行。</p>
<p><strong>yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数</strong>。可以使用yield返回键值对，引用或<code>NULL</code>等。在PHP 7以后，使用<code>yield from</code>可以从实现了Iterator接口的对象或使用yield的函数中yield值。如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count_to_ten</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="keyword">new</span> <span class="built_in">ArrayIterator</span>([<span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="title function_ invoke__">seven_eight</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="keyword">from</span> <span class="title function_ invoke__">nine_ten</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seven_eight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="title function_ invoke__">eight</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nine_ten</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = <span class="title function_ invoke__">count_to_ten</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$gen</span> <span class="keyword">as</span> <span class="variable">$num</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$num</span> &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">getReturn</span>();</span><br></pre></td></tr></table></figure>

<p>对比生成器和实现Iterator接口的类来看，生成器的代码可读性更高，代码量也更少，缺憾在于不能多次迭代和回退，除非重建或使用clone。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>PHP的引用意味着不同的名字访问同一个变量内容</strong>，通过在变量前加上<code>&amp;</code>使用。在对一个未定义的变量进行引用参数传递或引用返回时，会自动创建该变量。不使用<code>&amp;</code>符号时，意味着生成一个拷贝。</p>
<p>在进行引用传递时，只能传递变量，New语句和函数中返回的引用；引用返回时，需要在函数名前加上&amp;符号，同时接受返回值的变量也需写为接收引用的形式。<br>通过<code>unset</code>销毁引用，销毁引用的同时不会销毁原变量（类似于删除符号链接）。<code>global $var</code>实际上就是创建了到<code>$GLOBALS[]</code>的引用。<code>$this</code>也是同理。</p>
<h3 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h3><p>PHP带有内置URL风格的封装协议，可用于类似<code>fopen()</code>、<code>copy()</code>、<code>file_exists()</code>和<code>filesize()</code>的文件系统函数，如file, http, ftp, php, zlib, data等。其中<code>php://</code>提供的是输入输出流和错误描述符的访问能力。创建数据流前，可以通过<code>stream_context_create()</code>创建上下文选项，定义数据流的选项。</p>
<h2 id="函数参考"><a href="#函数参考" class="headerlink" title="函数参考"></a>函数参考</h2><p>PHP本身提供了海量的函数。且都可以全局访问到。</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>内核部分的函数，不能通过编译选项去除。PHP这部分的函数和介绍相当多，这里只撷选了常用的部分。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>这部分的函数主要用来进行和数组相关的操作，由于PHP中的数组包括了键值对这样类似对象的功能，函数的数量很多，甚至有些冗余。</p>
<ul>
<li><code>array_chunk</code> 将数组分割为多个，单元数目由size决定。返回一个多维数组。</li>
<li><code>array_merge</code> 将多个数组的单元合并在一起，字符串键名相同时，后面的值会覆盖前一个。类似的还有array_merge_recursive。</li>
<li><code>array_count_values</code> 统计数组中所有的值出现的次数，返回一个关联数组</li>
<li><code>array_diff</code> 计算数组的差集，返回在array1但不在array2的元素</li>
<li><code>array_intersect</code> 计算数组的交集，返回一个在array1中出现同时也在其他所有参数数组中出现的值。在差和交的名称前加上u的函数可以自己指定比较方法。</li>
<li><code>array_fill</code> 用给定的值填充数组的num个条目，start_index为返回数组的第一个索引值。array_fill_keys函数可以填充键值对。<code>array_pad</code> 用值将数组填充到指定长度。键从第一个整型数开始，否则从0开始。</li>
<li><code>array_flip</code> 返回一个交换键和值的数组。不合法的值将不会反转。类似的<code>array_reverse</code>返回一个单元顺序相反的数组。</li>
<li><code>array_combine(array $keys , array $values)</code>返回一个由<code>keys</code>数组作键，<code>values</code>数组作值的新数组，两个数组长度不一样时抛出异常。<code>array_keys(array $array [, mixed $search_value [, bool $strict= false ]])</code>返回所有值为<code>search_value</code>的键名，<code>strict</code>表示是否进行严格比较。类似地，<code>array_values(array $input)</code>返回一个由所有值组成的数组，并建立起数字索引。</li>
<li><code>array_multisort</code>用来一次多多个数组排序，输入数组被当作一个数据表的若干列来排序。常用在对数据库数据的排序。返回值为bool类型。</li>
<li><code>array_push</code>和<code>array_pop</code>分别在array的末尾弹出或压入一个元素。</li>
<li><code>array_shift</code>和<code>array_uinshift</code>完成类似于上面的功能，不过是在数组开头。</li>
<li><code>array_product()</code>和<code>array_sum()</code>分别返回数组的乘积和总和。</li>
<li><code>array_filter</code>用回调函数过滤数组单元。没有回调函数时将删除input中等值于FALSE的条目。</li>
<li><code>array_map</code>返回一个arr1所有单元经过callback作用后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。</li>
<li><code>array_walk</code>使用用户自定义的函数对数组每个函数做回调处理。</li>
<li><code>array_reduce</code>根据回调将array简化为一个值。function变量可以读取result和item。</li>
<li><code>array_replace(array $array1 , array $array2 [, array $... ])</code>将前面的数组的键值对覆盖为后面的键值对。多维数组下有recursive版本。</li>
<li><code>array_key_exists</code>检查键名是否存在于数组中。<code>array_search(mixed $needle , array $haystack [, bool $strict = false ])</code>在数组中搜索给定值。</li>
<li><code>array_slice</code>根据offset和length从数组中取出一段。</li>
<li><code>array_splice</code>把input数组中由offset和length指定的单元去掉，如果提供了replacement参数，则用其中的单元取代。</li>
<li><code>array_unique</code>用于移除数组中重复的值</li>
</ul>
<p>除了这些，还有<code>is_array()</code>，<code>explode()</code>，<code>split()</code>等不以array开头的函数和数组相关，大多用来进行一些简单的操作，列表见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/ref.array.php">数组参考</a>。和数组排序相关的函数也有很多，它们在排序依据，是否稳定等方面各不相同，更多内容参考对数组进行排序。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>和字符串相关的函数也很多，但只有以str开头的是严格意义上的字符串函数。下面列举了部分：</p>
<ul>
<li><code>addslashes</code>转义字符串中的单引号，双引号，反斜线和NUL</li>
<li><code>chr</code>返回ASCII码对应的字符，<code>ord()</code>是其互补函数</li>
<li><code>chunk_split($body[,int $chunklen = 76 [,string $end = &quot;\r\n&quot; ]] )</code>拆分<code>$body</code>为<code>$chunklen</code>的小块，每块后用<code>$end</code>结尾</li>
<li><code>crypt</code>返回一个单向字符串散列，<code>md5</code>计算字符串的MD5散列值，<code>sha1</code>计算sha1散列值</li>
<li>echo 输出一组字符串</li>
<li><code>explode</code>使用一个字符串分割另一个字符串；类似地，<code>implode</code>将一个一维数组的值转为字符串。又写作<code>join</code>。</li>
<li><code>htmlentites</code>转义所有的特殊字符为HTML实体；<code>html_entity_decode()</code>实现相反的步骤。</li>
<li><code>htmlspecialchars()</code>和<code>htmlspecialchars_decode()</code>完成的功能和上面相似，但是转义的字符只有<code>&amp;</code>，<code>&quot;</code>，<code>&#39;</code>，<code>&lt;</code>，<code>&gt;</code>。</li>
<li><code>lcfirst</code>将首字母小写，<code>ucfirst</code>将首字母大写，<code>ucwords</code>将每个单词的首字母大写</li>
<li><code>ltrim</code>，<code>rtrim</code>和<code>trim</code>删除字符串首部，尾端和两端的空白。</li>
<li><code>str_getcsv</code>解析csv字符串为一个数组</li>
<li><code>str_pad</code>使用另一个字符串填充字符串到指定长度</li>
<li><code>str_repeat</code> 重复一个字符串</li>
<li><code>str_replace</code> 字符串替换，<code>preg_replace</code>的特殊情况</li>
<li><code>str_shuffle</code>随机打乱一个字符串</li>
<li><code>str_split</code>将一个字符串转换为数组</li>
<li><code>strstr</code>查找字符串的第一次出现。<code>stristr()</code>则不区分大小写地查找</li>
<li><code>strcmp</code>二进制安全字符串比较大小，<code>strncmp</code>类似，不过允许指定比较的长度，<code>strnatcmp</code>以自然顺序比较字符串</li>
<li><code>strlen</code>获取字符串长度</li>
<li><code>strpos</code>查找字符串初次出现位置，<code>strrpos</code>查找最后一次出现，<code>strripos</code>不区分大小写查找最后一次出现</li>
<li><code>strrev</code>反转字符串</li>
<li><code>strip_tags</code>去除str中的空字符，HTML标记和PHP标记，和<code>fgetss()</code>机制一样</li>
<li><code>strtoupper</code>将字符串转化为大写，<code>strtolower</code>将字符串转换为小写</li>
<li><code>strtr()</code>翻译、转换指定字符</li>
<li><code>substr</code>返回字符串的子串</li>
<li><code>substr_count</code>返回子字符串在字符串中出现的次数。</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><code>boolvar()</code>转换变量为bool类型</li>
<li><code>empty()</code>判断变量是否为空</li>
<li><code>isset()</code>检测变量是否已设置</li>
<li><code>intval()</code>获取变量整数值，<code>floatval()</code>获取变量浮点数值，<code>strval()</code>获取变量的字符串表示</li>
<li><code>get_resource_type()</code>获取资源类型</li>
<li><code>gettype()</code>获取变量类型，<code>settype($var, string $type)</code>设置变量类型</li>
<li><code>is_array</code>, <code>is_bool</code>, <code>is_callable</code>, <code>is_float</code>, <code>is_int</code>, <code>is_null</code>, <code>is_numeric</code>, <code>is_object</code>, <code>is_resource</code>, <code>is_scalar</code>, <code>is_string</code>用来检测各种类型。</li>
<li><code>print_r()</code>和<code>var_dump()</code>打印变量的相关信息，<code>var_export()</code>以合法PHP代码的形式返回变量的字符串表示</li>
<li><code>serialize()</code>序列化一个变量，<code>unserialize()</code>反序列化一个变量</li>
<li><code>unset()</code>销毁指定的变量</li>
</ul>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><ul>
<li><code>spl_autoload_register()</code>尝试在类名未定义时启动类的自动加载</li>
<li><code>class_alias</code>为一个类创建别名。</li>
<li><code>class_exists</code>检查指定的类是否定义</li>
<li><code>get_class()</code>返回对象实例所属类的名字。类似地还有<code>get_class_vars</code>和<code>get_class_methods</code>函数。</li>
<li><code>get_declare_classes</code>和<code>get_declare_interfaces</code>以及<code>get_declare_traits</code>获取脚本中已定义的类、接口、trait数组。</li>
<li><code>method_exists( mixed $object , string $method_name )</code>检查类方法是否存在于指定object中，类似地还有<code>property_exsits</code>，<code>interface_exists</code>和<code>trait_exist</code>等</li>
</ul>
<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>PHP中的时间以64为数字存储。使用时需要配置好<code>php.ini</code>中时区等信息。<code>DateTime</code>，<code>DateTimeZone</code>，<code>DateInterval</code>等对象便于进行相关的操作。PHP同时提供了OOP风格和过程化风格两种方式使用函数。其中<code>DateTime</code>和<code>DateTimeImmutable</code>都继承自<code>DateTimeInterface</code>接口，有着<code>diff</code>，<code>format</code>，<code>getTimestamp</code>，<code>getTimezone</code>等方法。</p>
<p>DateTime中的部分方法如下：</p>
<ul>
<li><code>add(DateInterval $interval)</code>在当前时间上加上一个时间段</li>
<li><code>sub(DateInterval $interval)</code>在当前时间上减去一个时间段。</li>
<li><code>__construct()</code>，创建一个对象，过程化风格: <code>date_create()</code></li>
<li><code>createFromFormat</code>创建一种时间格式format的写法格式见<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/datetime.createfromformat.php">参考</a>。</li>
<li><code>modify</code>修改当前时间，modify为合法的时间格式。</li>
<li><code>setDate(int $year, int $month, int $day )</code>设置日期</li>
<li><code>setTime(int $hour ,int $minute [,int $second = 0 ])</code>设置时间。</li>
<li><code>setTimestamp()</code>设置时间戳。</li>
</ul>
<p>上述方法都有对应的过程化风格的对应函数。</p>
<p>DatePeriod和DateTimeZone等的介绍从略。除了以上的对象方法过程化的函数外，还有以下一些常用方法：</p>
<ul>
<li><code>date($format[, $timestamp)</code>，格式化一个本地时间</li>
<li><code>getdate()</code>，获得日期时间信息，<code>localtime</code>功能类似，返回一个数组。</li>
<li><code>mktime</code>获得一个日期的时间戳，默认为当前。类似的还有<code>time</code>，<code>microtime</code>，返回一个时间戳类型</li>
<li><code>strtotime</code>将英文文本的日期时间解析为Unix时间戳</li>
<li>有意思的是<code>date_sunset</code>和<code>date_sunrise</code>可以获取指定时间戳的日出日落时间</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li><code>basename()</code>返回路径的文件名部分；<code>dirname()</code>返回路径中的目录部分，<code>realpath()</code>返回规范的绝对路径名</li>
<li><code>chgrp()</code>改变文件所属组，类似的还有<code>chmod</code>和<code>chown</code></li>
<li><code>copy</code>用于拷贝文件，<code>rename</code>用于移动和重命名文件。注意，这里没有delete函数。<code>unlink</code>用于删除文件</li>
<li><code>link ()</code>建立一个硬连接，<code>linkinfo</code>, <code>lstat</code>给出连接信息。<code>symlink</code>创建一个符号连接。</li>
<li><code>mkdir</code>和<code>rmdir</code>用来创建和删除文件夹</li>
<li><code>file</code>把整个文件都入到一个数组中，一行一个元素，可以使用URL作为文件名。<code>file_exists</code>检查文件或目录是否已存在。<code>tmpfile</code>则会建立一个关闭后自动删除的临时文件。</li>
<li><code>file_get_contents</code>将文件读入到字符串中，可以使用<code>stream_context_create</code>创建上下文进行更细致的操作。</li>
<li><code>file_put_contents()</code>写文件，和依次调用<code>fopen()</code>, <code>fwrite()</code>, <code>fclose()</code>效果一样。</li>
<li><code>fileatime</code>, <code>filectime</code>, <code>filemtime</code>, <code>filegroup</code>, <code>fileowner</code>, <code>fileperms</code>, <code>filesize</code>, <code>filetype</code>, <code>stat</code>等和字面意义一样获取文件的各方面信息。它们接收文件路径作为参数。</li>
<li><code>is_dir</code>, <code>is_executable</code>, <code>is_file</code>, <code>is_link</code>, <code>is_readable</code>, <code>is_uploaded_file</code>, <code>is_writable</code>检查文件各种属性</li>
<li><code>fopen</code>打开一个文件，返回一个resource句柄，可以交给<code>fread</code>, <code>fwrite</code>, <code>fscanf</code>, <code>fclose</code>等函数做读写操作。</li>
<li><code>fgets</code>从当前指针处读取一行，<code>fgetc</code>读取一个字符，<code>fstat</code>返回文件信息，<code>ftruncate</code>将文件阶段到给定长度。</li>
<li><code>glob()</code>寻找和pattern匹配的文件路径</li>
</ul>
<p>Directory类通过<code>dir()</code>创建。Directory实例有<code>close</code>，<code>read</code>，<code>rewind</code>三种方法。分别用来释放句柄，读取条目和倒回开头。初次以外还有下面这些常用的目录相关函数。</p>
<ul>
<li><code>chdir(string $directory)</code>用来改变当前目录，</li>
<li><code>getcwd</code>取得当前工作目录</li>
<li><code>scandir()</code>返回一个包含目录中所有文件和目录的数组</li>
<li><code>closedir()</code>关闭通过<code>opendir()</code>打开的目录流。</li>
<li><code>readdir()</code>返回目录中下一个文件的文件名。文件名以在文件系统中的排序返回。</li>
</ul>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>下面这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式：</p>
<ul>
<li><code>debug_backtrace()</code>产生一条PHP的回溯跟踪，返回数组类型；<code>debug_print_backtrace()</code>则将回溯打印出来。</li>
<li><code>error_get_last()</code>获取最后一个发生错误的信息，<code>error_clear_last()</code>清除最后一个错误信息</li>
<li><code>error_log()</code>发送错误信息到web服务器的错误日志或是一个文件里。</li>
<li><code>error_reporting()</code>设置应该报告的PHP错误级别。</li>
<li><code>set_error_handler</code>, <code>set_exception_handler</code>, <code>restore_error_handler</code>, <code>restore_exception_handler</code>分别是设置和重置错误以及异常处理的函数</li>
<li><code>trigger_error()</code>触发一个用户级别的错误条件，在运行出现异常时，需要产生一个特定响应时很有用。</li>
</ul>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>在会话支持下，每个访问网站的用户都有一个唯一的id标识，这个标识可以存储在cookie中，也可以通过URL传递。当一个访问者访问网站时，PHP将自动检查(如果<code>session.auto_start</code>被设置为1）或者在你要求下检查(明确通过<code>session_start()</code>或者隐式通<code> session_register()</code>) 当前会话 id 是否是先前发送的请求创建. 如果是这种情况，那么先前保存的环境将被重建。</p>
<p>安全方面需要注意以下几点：</p>
<ul>
<li><code>session.cookie_lifetime=0</code>, 即浏览器不持久化存储cookie数据</li>
<li><code>session.use_cookies=On</code> 并且<code>session.use_only_cookies=On</code>，即通过HTTP cookie实现会话ID管理</li>
<li><code>session.use_strict_mode=On</code>，即禁止使用未初始化会话id的会话，从而防止Javascript进行会话ID的注入</li>
<li><code>session.cookie_httponly=On</code>，禁止Javascript访问会话ID</li>
<li><code>session.cookie_secure=On</code>，仅在HTTPS协议下访问session ID，用在仅支持HTTPS的站点</li>
<li><code>session.hash_function=&quot;sha256&quot;</code>。 高强度的散列函数可以产生高强度的会话ID</li>
</ul>
<p>其他注意事项可以在PHP的<a target="_blank" rel="noopener" href="http://php.net/manual/zh/session.security.php">会话与安全章节</a>找到，根据实际需要选择。下面是一些session函数的使用:</p>
<ul>
<li><code>session_destroy()</code>, 销毁一个会话里的全部数据，但不会重置相关全局变量也不会重置cookie，再次使用时需要重新调用<code>session_start()</code>函数。为彻底删除session，需要调用<code>setcookie()</code>清除cookie中的session ID。</li>
<li><code>session_cache_expire()</code>设置或读取当前缓存到期时间（这个只和浏览器页面刷新缓存有关）</li>
<li><code>session_id()</code>获取&#x2F;设置当前会话ID，PHP仅允许会话ID包括a-z A-Z 0-9 ,（逗号） -（减号）.如果不是用cookie来存储session ID，session ID通常附在SID常量中，放在URL里。</li>
<li><code>session_regenerate_id()</code>在不修改当前session数据的前提下使用新的ID替换原有会话ID。如果启用了<code>session.use_trans_sid</code>选项,那么必须在调用<code>session_regenerate_id()</code>函数之后开始进行输出工作，否则会导致使用原有的会话 ID</li>
<li><code>session_start()</code>创建新会话或者重用现有会话。 如果通过GET或者POST方式，或者使cookie提交了会话ID，则会重用现有会话。</li>
<li><code>session_status()</code>返回当前会话状态</li>
<li><code>session_write_close()</code>写入session数据，然后关闭会话</li>
<li><code>session_name()</code>设置或返回当前回话名称，名称应短小易懂，且不能由纯数字组成，如<code>website_id</code>。</li>
<li><code>session_save_path()</code>读取&#x2F;设置当前会话的保存路径</li>
<li><code>session_unset()</code>释放当前会话注册的所有会话变量</li>
</ul>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>这部分函数提供执行系统本身命令的能力。注意，<strong>以加锁方式打开的文件，必须在执行后台程序前关闭</strong>。</p>
<ul>
<li><code>escapeshellarg(string $arg)</code>和<code>escapeshellcmd(string $command)</code>对参数和命令元字符转义，保证安全。</li>
<li><code>exec()</code>和<code>passthru()</code>都能执行一个外部程序，区别是前者返回结果的最后一行，后者返回未经处理的全部输出数据。</li>
<li><code>shell_exec()</code>在shell环境下执行命令，以字符串的形式返回完整的字符串。</li>
<li><code>system(string $command[, int &amp;$return_var ] )</code>执行 command 参数所指定的命令，并且输出执行结果。</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><ul>
<li><code>call_user_func(callable $callback [, mixed $parameter [, mixed $... ]])</code>把第一个参数作为回掉函数调用。在参数很多时，建议使用$callback(…values)的形式传入数组。类似的还有<code>forward_static_call</code>和<code>forward_static_call_array</code>用来调用静态方法。</li>
<li><code>func_get_arg(int $arg_num)</code>和<code>func_get_arg()</code>返回自定义函数的参数和参数列表，用在函数体内。</li>
<li><code>function_exists()</code>判断函数是否定义</li>
<li><code>register_shutdown_function</code>, <code>register_tick_function</code>用来注册<code>exit</code>之后和每个tick后执行的函数</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>这部分函数自5.1.2版本后成为核心的一部分。</p>
<ul>
<li><code>hash()</code>根据指定的哈希算法生成哈希值。类似的还有<code>hash_file</code>。</li>
<li><code>hash_hmac()</code>使用HMAC方法生成带有密钥的哈希值，类似的还有<code>hash_hmac_file</code>。</li>
<li><code>hash_init()</code>初始化一个哈希运算上下文，返回resource类型</li>
<li><code>hash_update(resource $context , string $data)</code>向活跃的哈希运算上下文中填充数据。细化的，还有<code>hash_update_file</code>和<code>hash_update_stream</code>两个函数。</li>
<li><code>hash_final()</code>结束哈希上下文，返回摘要内容。</li>
<li><code>hash_copy()</code>返回一个哈希运算上下文副本。</li>
</ul>
<h4 id="PHP自身"><a href="#PHP自身" class="headerlink" title="PHP自身"></a>PHP自身</h4><p>这些函数允许你获得许多关于PHP本身的参数。</p>
<ul>
<li><code>assert()</code>检查一个断言是否为FALSE，并在失败的时候调用<code>assert_options()</code>中指定的回调函数</li>
<li><code>dl()</code>运行时加载一个PHP扩展</li>
<li><code>get_cfg_var()</code>获取PHP配置选项的值</li>
<li><code>get_current_user()</code>获取当前PHP脚本所有者名称</li>
<li><code>get_included_files()</code>返回被include和require文件名的 array</li>
<li><code>ini_get()</code>获取一个配置选项的值</li>
<li><code>ini_set()</code>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复</li>
<li><code>ini_restore()</code>恢复指定的配置选项到它的原始值</li>
<li><code>memory_get_usage()</code>返回当前分配给你的 PHP 脚本的内存量，单位是字节（byte）</li>
<li><code>php_sapi_name()</code>返回web服务器和PHP之间的接口类型</li>
<li><code>php_uname()</code>返回运行PHP的系统的有关信息</li>
<li><code>phpinfo([int $what = INFO_ALL])</code>输出关于 PHP 配置的信息。可以通过<code>what</code>筛选输出内容。</li>
<li><code>phpversion()</code>获取当前的PHP版本</li>
<li><code>version_compare()</code>对比两个「PHP 规范化」的版本数字字符串</li>
</ul>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>这部分函数处理integer和float范围内的计算。预定义常量包括<code>M_PI</code>, <code>M_E</code>, <code>M_LOG2E</code>, <code>M_LN2</code>, <code>M_PI_2</code>, <code>M_1_PI</code>, <code>M_SQRT2</code>, <code>M_SQRT3</code>, <code>INF</code>等诸多数学常量。函数名和其他语言类似。</p>
<ul>
<li>三角函数相关：<code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>计算单位为弧度</li>
<li>双曲函数相关：<code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code>, <code>atan2</code></li>
<li>对数相关：<code>log</code>, <code>log10</code>, <code>log1p</code></li>
<li>指数相关：<code>pow</code>, <code>exp</code>, <code>expm</code></li>
<li>近似相关：<code>round</code>, <code>floor</code>, <code>ceil</code></li>
<li>随机数相关： <code>rand(int $min , int $max)</code>, <code>mt_rand</code>（用法同<code>rand</code>，性能更好）, <code>srand</code>和<code>mt_srand</code>（现已不需要使用）</li>
<li>进制转换相关：<code>bindec</code>, <code>octdec</code>, <code>hexdec</code>转为十进制数（读取字符串，输出数字），相对应还有<code>decbin</code>, <code>decbin</code>, <code>dechex</code>。<code>base_convert()</code>可以做任意进制转换</li>
<li>角度相关：<code>deg2rad</code>角度转弧度</li>
<li>运算相关：<code>intdiv</code>返回商的整数部分，<code>fmod</code>返回浮点数余数。<code>abs</code>计算绝对值，<code>sqrt</code>计算开根号</li>
<li>判断相关：<code>is_finite</code>, <code>is_infinite</code>, <code>is_nan</code>,</li>
<li>其他：<code>max</code>, <code>min</code>（可以输入数组）, <code>pi</code>, <code>hypot</code>（根据直角边计算三角形斜边长）</li>
</ul>
<h4 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h4><p>PHP脚本有输出时，输出控制函数可以用这些来控制输出。如通过<code>ob_start()</code>将下文的输出放在缓冲区直到调用<code>ob_end_flush()</code>。通常配合<code>header()</code>使用，在真正返回数据前写入header和cookie。</p>
<p>从略。</p>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul>
<li><code>constant()</code>返回一个常量的值</li>
<li><code>define()</code>定义一个常量</li>
<li><code>exit()</code>输出一个消息并且退出当前脚本，<code>die</code>是<code>exit</code>的同名函数。</li>
<li><code>highlight_file()</code>语法高亮一个文件</li>
<li><code>highlight_string()</code>语法高亮一个字符串，使用方法同上。</li>
<li><code>sleep()</code>延迟指定秒数执行。类似的还有<code>usleep</code>以指定微秒数暂缓执行，<code>time_sleep_until</code>使脚本睡眠到指定时间</li>
<li><code>uniqid()</code>返回一个基于当前微秒级时间的带前缀的唯一ID。</li>
</ul>
<h3 id="绑定拓展库"><a href="#绑定拓展库" class="headerlink" title="绑定拓展库"></a>绑定拓展库</h3><p>下面的拓展库绑定在PHP发行包中。较之内核部分的函数，更偏向为解决某类问题而设计。这里也只摘选部分常用的介绍。</p>
<h4 id="Ctype"><a href="#Ctype" class="headerlink" title="Ctype"></a>Ctype</h4><p>用来检测 在当前的区域设定下，一个字符或者字符串 是否仅包含指定类型的字符。根据官方描述，<strong>“如果可以满足需求，请优先考虑使用 ctype 函数， 而不是正则表达式或者对应的 “str_*” 和 “is_*” 函数。 因为 ctype 使用的是原生 C 库，所以会有明显的性能优势”</strong>。在4.2.0版本后，这些函数是默认启动的。</p>
<ul>
<li><code>ctype_alpha()</code>纯字符检测</li>
<li><code>ctype_upper()</code>大写字母检测</li>
<li><code>ctype_lower()</code>小写字母检测</li>
<li><code>ctype_digit()</code>纯数字检测</li>
<li><code>ctype_alnum()</code>检查字符串内的字符否全部为字母或数字</li>
<li><code>ctype_cntrl()</code>控制字符检测</li>
<li><code>ctype_print()</code>字符是否都可以打印</li>
<li><code>ctype_graph()</code>字符输出是否都是可见的</li>
<li><code>ctype_punct()</code>字符是否都可打印却不是字母数组和空白</li>
<li><code>ctype_space()</code>空白字符检测</li>
<li><code>ctype_xdigit()</code>十六进制字符串检测</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>在PHP5.3版本后，原来的POSIX Regex不再推荐使用。兼容Perl的正则表达式库PCRE仍可以使用，且默认开启。这里仅介绍PCRE相关函数，它们均以<code>preg</code>开头。</p>
<ul>
<li><code>preg_match()</code>返回pattern在subject中的匹配次数</li>
<li><code>preg_match_all()</code>搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以指定顺序输出到matches结果中.</li>
<li><code>preg_replace()</code>执行一个正则表达式的搜索和替换，当$pattern和$replacement都是数组时，会进行相对应位置的替换。</li>
<li><code>preg_grep(string $pattern , array $input [, int $flags = 0 ])</code>返回给定数组input中与模式pattern 匹配的元素组成的数组.</li>
<li><code>preg_split()</code>通过正则表达式分割字符串，返回一个数组。</li>
</ul>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>自5.2.0起，JSON拓展默认内置并编译进PHP。</p>
<ul>
<li><code>json_encode()</code>JSON编码一个变量。</li>
<li><code>json_decode()</code>解码一个JSON格式的字符串</li>
<li><code>json_last_error()</code>返回JSON编码时最后的错误</li>
</ul>
<h4 id="多字节字符串"><a href="#多字节字符串" class="headerlink" title="多字节字符串"></a>多字节字符串</h4><p>在汉语中，每个字符通常占用2个字节，在使用string的相关函数时，可能会出现意外问题。多字节字符串即为了解决此问题。这不是一个默认扩展，需要在configure选项中显式激活。详见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/mbstring.installation.php">安装</a>。另外，<code>mbstring</code>支持“函数重载”，即使用<code>mb_xxx</code>替代原有的字符串函数。</p>
<ul>
<li><code>mb_detect_encoding()</code>检测字符的编码</li>
<li><code>mb_ereg_xxx</code>打头的与<code>preg_xxx</code>同名的函数为正则匹配多字节版</li>
<li><code>mb_strlen()</code>获取字符串长度。</li>
<li><code>mb_split()</code>使用正则表达式分割多字节字符串</li>
<li><code>mb_substr()</code>执行一个多字节安全的<code>substr()</code>操作</li>
<li><code>mb_strpos()</code>查找字符串在另一个字符串中首次出现的位置；类似地，<code>mb_strrpos</code>查找最后出现的位置。</li>
<li><code>mb_strstr ()</code>查找字符串在另一个字符串里的首次出现；类似地，<code>mb_strrchr()</code>查找指定字符在另一个字符串中最后一次的出现</li>
</ul>
<h4 id="BCMath"><a href="#BCMath" class="headerlink" title="BCMath"></a>BCMath</h4><p>这部分函数进行任意大小和精度的数字的二进制计算。自4.0.4后随PHP一起发布。Windows版本下是默认支持的。</p>
<ul>
<li><code>string bcadd(string $left_operand , string $right_operand [, int $scale ] )</code>加法。scale用来决定小数点位数，输入输出均未string类型，下同。</li>
<li><code>bcsub()</code>减法</li>
<li><code>int bccomp()</code>比较</li>
<li><code>bcmul()</code>乘法</li>
<li><code>bcdiv()</code>除法</li>
<li><code>bcmod()</code>取模</li>
<li><code>bcpow()</code>乘方</li>
<li><code>bcsqrt()</code>二次方根</li>
<li><code>bcscale()</code>设置所有bc数学函数的默认小数点位数</li>
</ul>
<h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p>PHP可以处理各种格式的图像，并把它们输出到浏览器。这需要在编译时指定GD库（除了<code>getimagesize()</code>函数）。GD库不仅能处理图像，还能对字体进行处理。使用PHP可以动态修改图像文件，或为图像添加水印信息，甚至创建一个图像。</p>
<p>下面是和图像信息相关的函数：</p>
<ul>
<li><code>gd_info()</code>获取当前安装的GD库信息</li>
<li><code>getimagesize()</code>获取图像大小，返回数组类型，按顺序分别是宽度，高度，类型，描述宽高的字符串。<code>getimagesizefromstring</code>函数则通过打开的图片信息（字符串格式）中读取图像尺寸信息</li>
<li><code>image_type_to_extension()</code>获取图像类型的文件后缀</li>
<li><code>imageistruecolor(resource $image)</code>检查图像是否为真彩色</li>
<li><code>imagesx()</code>返回image所代表的图像宽度；<code>imagesy()</code>返回所代表的图像高度</li>
<li><code>imagetypes()</code>返回PHP支持的图像类型，int类型。</li>
</ul>
<p>剩下还有众多以<code>image</code>开头的和创建、输出、删除图像，画图、编辑图片、设置颜色、设置字体相关的函数，见<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/book.image.php">参考</a>。</p>
<h4 id="Exif"><a href="#Exif" class="headerlink" title="Exif"></a>Exif</h4><p>通过Exif拓展，可以操作图像元数据。必须使用<code>--enable-exif</code>选项编译PHP，Windows用户还需要启用mbstring扩展。</p>
<ul>
<li><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名</li>
<li><code>exif_read_data()</code>函数从JPEG或TIFF图像文件中读取EXIF头信息</li>
<li><code>exif_thumbnail()</code>读取TIFF或JPEG图像中的嵌入缩略图。如果图像不包含缩略图则返回FALSE</li>
</ul>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Socket拓展基于流行的BSD sockets，实现了和socket通讯功能的底层接口。在编译PHP时必须在配置中添加—enable-sockets配置项。利用这部分函数可以很方便地搭建起socket服务器和客户端，示例见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/sockets.examples.php">官网</a>。</p>
<ul>
<li><code>socket_create(int $domain , int $type , int $protocol)</code>创建并返回一个套接字（resource类型）。其中<code>domain</code>指定使用的网络协议族，<code>type</code>指定建立的套接字类型，<code>protocol</code>指定使用的具体协议。</li>
<li><code>socket_create_listen()</code>在某端口打开socket以接收连接。</li>
<li><code>socket_bind()</code>绑定网络地址到套接字的源。</li>
<li><code>socket_connect()</code>使用address作为目的地址，建立套接字连接。</li>
<li><code>socket_listen()</code>在创建好socket资源，并绑定了source address后，可以调用此函数监听进入的数据流。</li>
<li><code>socket_accept()</code>在依次使用socket_create创建套接字，使用<code>socket_bind</code>绑定端口，使用<code>socket_listen</code>监听连接后。该函数允许到此套接字上的连接，返回一个新的socket资源用来通信。</li>
<li><code>socket_read()</code>从已连接的socket中读取一段长度的数据，返回读出的数据。</li>
<li><code>socket_recv()</code>功能同上，返回字节数并将数据存放在<code>$buf</code>中。</li>
<li><code>socket_recvfrom() </code>从已连接和还未连接的socket中读取数据。</li>
<li><code>socket_write()</code>向socket中写入数据</li>
<li><code>socket_send()</code>向已连接的socket中写入数据。</li>
<li><code>socket_sendto()</code>向socket中发送数据而不管是否已连接</li>
<li><code>socket_getsockname()</code>和<code>socket_getpeername()</code>获取本地和远端socket信息</li>
<li><code>socket_set_block()</code>和<code>socket_set_nonblock()</code>设置socket是否阻塞</li>
<li><code>socket_set_option()</code>设置套接字选项</li>
<li><code>socket_shutdown()</code>停止从socket中读写数据</li>
<li><code>socket_close()</code>关闭给定的socket资源</li>
</ul>
<h3 id="外部拓展库"><a href="#外部拓展库" class="headerlink" title="外部拓展库"></a>外部拓展库</h3><p>这些扩展库已经绑定在PHP发行包中，但是要编译以下扩展库，需要外部的库文件。这里仅介绍常用的cURL库。Mysqli和Mongo等可能会用得到的库介绍从略。</p>
<h4 id="client-URL"><a href="#client-URL" class="headerlink" title="client URL"></a>client URL</h4><p>PHP支持Daniel Stenberg创建的libcurl库，能够连接通讯各种服务器、使用各种协议。这些curl函数在PHP 4.0.2中引入。需要安装libcurl包才能使用PHP的cURL函数。安装过程从略。curl的使用流程思路和socket，mysql等十分相似，先使用<code>curl_init()</code>初始化会话，再使用<code>curl_setopt()</code>设置选项，然后通过<code>curl_exec()</code>执行会话，最后使用<code>curl_close()</code>关闭。</p>
<ul>
<li><code>curl_setopt()</code>设置一个传输选项，常用的设置包括<code>CURLOPT_URL</code>, <code>CURLOPT_HEADER</code>, <code>CURLOPT_RETURNTRANSFER</code>, <code>CURLOPT_TIMEOUT</code>等。类似的，还有<code>curl_setopt_array</code>函数。</li>
<li><code>curl_reset()</code>重置一个libcurl会话句柄的所有的选项</li>
<li><code>curl_exec()</code>执行一个cURL会话。返回TRUE或执行的结果，或是FALSE。</li>
<li><code>curl_close()</code>关闭一个会话，释放所有相关资源</li>
<li><code>curl_getinfo()</code>获取最后一次传输的相关信息。</li>
<li><code>curl_error()</code>返回一条最近一次cURL操作明确的文本的错误信息</li>
<li><code>curl_version()</code>获取cURL版本信息</li>
</ul>
<h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p>这里列举的特点更多是PHP语言的特殊使用方式与应用特性。如HTTP用户认证（介绍见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/features.http-auth.php">官网</a>），cookie等。</p>
<p>PHP透明地支持HTTP cookie，在PHP的网络函数中可以用<code>setcookie()</code>或<code>setrawcookie()</code>函数来设置cookie。cookie是HTTP标头的一部分，因此<code>setcookie()</code>函数必须在其它信息被输出到浏览器前调用，这和对header()函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的cookie或者其它HTTP标头。</p>
<p>PHP允许用户使用POST方法上传文本和二进制文件。一个上传文件的HTML表单代码类似如下，其中的<code>MAX_FILE_SIZE</code>隐藏字段在浏览器端限制了文件大小（单位字节，不建议依赖于此）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The data encoding type, enctype, MUST be specified as below --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;__URL__&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MAX_FILE_SIZE must precede the file input field --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MAX_FILE_SIZE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Name of input element determines name in $_FILES array --&gt;</span></span><br><span class="line">    Send this file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;userfile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send File&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全局变量<code>$_FILES</code>自PHP4.1.0起存在，包含了所有上传的文件信息。<code>$_FILES[&#39;userfile&#39;]</code>数组有<code>name</code>, <code>type</code>, <code>size</code>, <code>tmp_name</code>, <code>error</code>等字段。error字段状态码在0-7间，分别表示上传成功&#x2F;文件过大&#x2F;部分上传&#x2F;没有文件&#x2F;找不到临时文件夹&#x2F;写入失败。文件被上传后，默认地会被储存到服务端的默认临时目录中。</p>
<p>PHP支持同时上传多个文件并将它们的信息自动以数组的形式组织。要完成这项功能，需要在HTML表单中对文件上传域使用和多选框与复选框相同的数组式提交语法。像下面的代码那样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;file-upload.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  Send these files:<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;userfile[]&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;userfile[]&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send files&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，PHP还支持PUT方法上传文件，内容见官方文档。下面是一个允许用户上传图片的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/plain; charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Undefined | Multiple Files | $_FILES Corruption Attack</span></span><br><span class="line">    <span class="comment">// If this request falls under any of them, treat it invalid.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        !<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;error&#x27;</span>]) ||</span><br><span class="line">        <span class="title function_ invoke__">is_array</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;error&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Invalid parameters.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check $_FILES[&#x27;upfile&#x27;][&#x27;error&#x27;] value.</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;error&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> UPLOAD_ERR_OK:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UPLOAD_ERR_NO_FILE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;No file sent.&#x27;</span>);</span><br><span class="line">        <span class="keyword">case</span> UPLOAD_ERR_INI_SIZE:</span><br><span class="line">        <span class="keyword">case</span> UPLOAD_ERR_FORM_SIZE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Exceeded filesize limit.&#x27;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Unknown errors.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You should also check filesize here. </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1000000</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Exceeded filesize limit.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT TRUST $_FILES[&#x27;upfile&#x27;][&#x27;mime&#x27;] VALUE !!</span></span><br><span class="line">    <span class="comment">// Check MIME Type by yourself.</span></span><br><span class="line">    <span class="variable">$finfo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">finfo</span>(FILEINFO_MIME_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> === <span class="variable">$ext</span> = <span class="title function_ invoke__">array_search</span>(</span><br><span class="line">        <span class="variable">$finfo</span>-&gt;<span class="title function_ invoke__">file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]),</span><br><span class="line">        <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;jpg&#x27;</span> =&gt; <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;png&#x27;</span> =&gt; <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;gif&#x27;</span> =&gt; <span class="string">&#x27;image/gif&#x27;</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Invalid file format.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You should name it uniquely.</span></span><br><span class="line">    <span class="comment">// DO NOT USE $_FILES[&#x27;upfile&#x27;][&#x27;name&#x27;] WITHOUT ANY VALIDATION !!</span></span><br><span class="line">    <span class="comment">// On this example, obtain safe unique name from its binary data.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">move_uploaded_file</span>(</span><br><span class="line">        <span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>],</span><br><span class="line">        <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;./uploads/%s.%s&#x27;</span>,</span><br><span class="line">            <span class="title function_ invoke__">sha1_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]),</span><br><span class="line">            <span class="variable">$ext</span></span><br><span class="line">        )</span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&#x27;Failed to move uploaded file.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;File is uploaded successfully.&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">RuntimeException</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在php.ini文件中激活了<code>allow_url_fopen</code>选项后，可以在大多数需要用文件名作为参数的函数中使用HTTP和FTP的URL来代替文件名。同时，也可以在<code>include</code>、<code>include_once</code>、<code>require</code>及<code>require_once</code>语句中使用URL。如果有合法的访问权限，以一个用户的身份和某FTP服务器建立了链接，还可以向该FTP服务器端的文件进行写操作。</p>
<p>持久的数据库连接是指在脚本结束运行时不关闭的连接。当收到一个持久连接的请求时。PHP将检查是否已经存在一个（前面已经开启的）相同的持久连接。如果存在，将直接使用这个连接；如果不存在，则建立一个新的连接。所谓“相同”的连接是指用相同的用户名和密码到相同主机的连接。</p>
<p>PHP 5.3后使用GC作为新的垃圾回收机制。每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。通常，PHP中的垃圾回收机制，仅仅在循环回收算法确实运行时会有时间消耗上的增加。但是在平常的(更小的)脚本中应根本就没有性能影响。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>PHP作为一种强大的语言，无论是以模块还是CGI的方式安装，它的解释器都可以在服务器上访问文件、运行命令以及创建网络连接等。这些功能也许会给服务器添加很多不安全因素，但是只要正确地安装和配置PHP，以及编写安全的代码，那么PHP相对于Perl和C来说，是能创建出更安全的CGI程序的。这部分提出一些原则，在不同环境下尽可能提高安全性。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>以CGI模式安装PHP时，它的设计可以用以避免访问系统文件和服务器的任意目录。在安装时配置一些选项可以有助避免这类攻击。具体见<a target="_blank" rel="noopener" href="http://php.net/manual/zh/security.cgi-bin.attacks.php">文档介绍</a>。同理，以Apache模块安装时，权限的注意也请见<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/security.apache.php">官网介绍</a>。</p>
<h3 id="Session安全"><a href="#Session安全" class="headerlink" title="Session安全"></a>Session安全</h3><p>这部分见<a href="####session">Session部分</a>的安全介绍。</p>
<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>PHP被设计为以用户级别来访问文件系统，所以完全有可能通过编写一段PHP代码来读取系统文件如<code>/etc/passwd</code>，更改网络连接以及发送大量打印任务等等。因此必须确保PHP代码读取和写入的是合适的文件。</p>
<p>由于PHP的文件系统操作是基于C语言的函数的，Null字符在C语言中用于标识字符串结束，一个完整的字符串是从其开头到遇见Null字符为止。因此，任何用于操作文件系统的字符串（特别是程序外部输入的字符串）都必须经过适当的检查。</p>
<p>这种安全问题也会出现在执行来自用户输入的命令。通常有两条路可以选择：1）检查所有来自外部的变量（<strong>黑名单</strong>）；2）后台写死可以执行的文件名或命令有限集（<strong>白名单</strong>）</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>由于敏感数据和机密数据通常存储在数据库中，数据库安全和保护显得尤为重要。<strong>PHP本身并不能保护数据库的安全</strong>。这里只是讲述怎样用PHP脚本对数据库进行基本的访问和操作。</p>
<p><strong>设计数据库时，永远不要使用数据库所有者或超级用户帐号来连接数据库</strong>，因为这些帐号可以执行任意的操作。应该为程序的每个方面创建不同的数据库帐号，并赋予对数据库对象的极有限的权限。同时，一些功能可以用视图（view）、触发器（trigger）或者规则（rule）在数据库层面完成。</p>
<p><strong>连接数据库</strong>时，把连接建立在 SSL 加密技术上可以增加客户端和服务器端通信的安全性，或者SSH也可以用于加密客户端和数据库之间的连接。</p>
<p><strong>存储模型</strong>中，可以散列一些没必要明文显示的数据，建议加盐散列，同时采用新的SHA散列算法（如SHA-2或SHA-3）以增加安全程度。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>这部分内容是极为常见的网络安全问题，通过构造特殊的SQL语句，获取数据库信息甚至主机权限，介绍从略。</p>
<p>在预防措施上，<strong>永远不要信任外部输入的任何数据，包括表单里和cookie的信息</strong>。</p>
<ul>
<li>使用权限被严格限制的帐号访问数据库</li>
<li>检查输入的数据是否具有所期望的数据格式</li>
<li>减少SQL语句的拼接使用</li>
<li>使用数据库特定的敏感字符转义函数</li>
<li>还可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图</li>
</ul>
<h3 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h3><p>错误报告是一把双刃剑。一方面可以提高安全性，另一方面又有利于攻击者收集服务器的信息以便寻找弱点。PHP的独有的错误提示风格可以说明系统在运行 PHP，一个函数错误可能暴露系统正在使用的数据库，一个文件系统或者PHP的错误就会暴露web服务器具有什么权限，以及文件在服务器上的组织结构等。</p>
<p>有三个常用的办法处理这些问题。第一个是彻底地检查所有函数，并尝试弥补大多数错误。第二个是对在线系统彻底关闭错误报告。第三个是使用 PHP 自定义的错误处理函数创建自己的错误处理机制</p>
<p>可以通过<code>error_reporting()</code>帮助找到错误所在并使代码更安全。发布程序前，设置为<code>E_ALL</code>找到所有使用不当的地方；正式发布后，设为0彻底关闭错误报告或设置<code>php.ini</code>中的<code>display_errors</code>为<code>off</code>。</p>
<h3 id="隐藏PHP"><a href="#隐藏PHP" class="headerlink" title="隐藏PHP"></a>隐藏PHP</h3><p>一些简单的方法可以帮助隐藏 PHP，这样做可以提高攻击者发现系统弱点的难度。在<code>php.ini</code>文件里设置<code>expose_php = off</code>，可以减少他们能获得的有用信息。</p>
<p>另一个策略就是让web服务器用PHP解析不同扩展名。无论是通过<code>.htaccess</code>文件还是Apache的配置文件，都可以设置能误导攻击者的文件扩展名。</p>
<p>更多机智的隐藏方法见官网<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/security.hiding.php">隐藏PHP</a>一节。</p>
<h2 id="内核-1"><a href="#内核-1" class="headerlink" title="内核"></a>内核</h2><p>考虑到重点所在，这部分内容仅简单地介绍一些涉及到PHP内部原理的东西。由于PHP运行在C语言的基础上，以下的内容和C语言编程靠近。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>用C语言编程时，开发者要手工地进行内存管理。因为PHP经常用作Web服务器的模块，内存管理与预防内存泄漏紧密关联。此外，Zend引擎要面对一个十分特殊的使用模式：在一段比较短的时间内，许多zval结构大小的内存块和其他的小内存块被请求又再被释放。为了满足以上的需求，Zend引擎提供为了处理请求相关数据提供了一种特殊的内存管理器。请求相关数据是指只需要服务于单个请求，最迟会在请求结束时释放的数据。<em>API介绍从略</em>。</p>
<p>因为安全原因，在请求结束时，Zend引擎会释放所有由上面提到的API所分配的内存。</p>
<h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><p>PHP变量，通常来说，由两部分组成：标签（例如，可能是符号表中的一个条目）和实际变量容器。变量容器，在代码中称为zval，掌握了所需处理变量的所有数据。 包括实际值、当前类型、统计指向此容器的标签的数量，和指示这些标签是引用还是副本的标志。在PHP 5.3中，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> <span class="title">zval</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zvalue_value</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> lval;                 <span class="comment">/* long value */</span></span><br><span class="line">    <span class="type">double</span> dval;               <span class="comment">/* double value */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>                   <span class="comment">/* string type */</span></span><br><span class="line">        <span class="type">char</span> *val;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;             <span class="comment">/* hash table value */</span></span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Variable information */</span></span><br><span class="line">    zvalue_value value;        <span class="comment">/* value */</span></span><br><span class="line">    zend_uint refcount__gc;</span><br><span class="line">    zend_uchar type;           <span class="comment">/* active type */</span></span><br><span class="line">    zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有关函数，类和对象，流等的介绍从略。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q: PHP 版本之间有什么联系？<br>A: PHP&#x2F;FI 2.0是最早的PHP版本，已经不再支持。PHP 3是PHP&#x2F;FI 2.0的后继者，要好很多。PHP 5是目前一代的PHP，内部使用了Zend 2引擎，除了很多新功能之外还提供了许多附加的面向对象编程（OOP）特性。<br><br><br>Q: 可以同时运行几个不同版本的PHP吗？<br>A: 可以，请参阅见PHP源程序发行包中的 INSTALL文件。<br><br><br>Q: 应该上哪儿去找我的<code>php.ini</code>文件<br>A: UNIX中默认在<code>/usr/local/lib</code>目录中，也就是<code>&lt;install-path&gt;/lib</code>。可以在编译时通过 <code>--with-config-file-path</code>标记来改变路径。Windows中<code>php.ini</code>文件的默认路径在Windows目录下。如果使用的是Apache服务器，则会首先在Apache的安装目录中寻找<code>php.ini</code>。<br><br><br>Q: PHP是否仅限于处理GET和POST请求方法？<br>A: 不是，PHP有可能处理任何请求方法，例如<code>CONNECT</code>。适当的回应状态可以用<code>header()</code>发送。<br><br><br>Q: 我忘了PHP函数的参数顺序，它们是随机的吗？<br>A: 通常情况下，数组函数的参数里，needle在前，haystack在后；字符串函数中，haystack在前，needle在后。<br><br><br>Q: PHP选项<code>register_globals</code>对我有什么影响？<br>A: 强烈不建议开启此选项，<code>register_globals</code>会自动生成变量。<br><br><br>Q: 我需要直接访问请求报头中的信息，怎么能办到？<br>A: 如果以Apache的模块方式运行PHP，那么函数<code>getallheaders()</code>可以做这件事。<br><br><br>Q: 如果不建议使用常用散列函数保护密码， 那么我应该如何对密码进行散列处理？<br>A: 当进行密码散列处理的时候，有两个必须考虑的因素： 计算量以及“盐”。 散列算法的计算量越大，暴力破解所需的时间就越长。PHP 5.5提供了一个原生密码散列API， 它提供一种安全的方式来完成密码散列和验证。 PHP 5.3.7及后续版本中都提供了一个纯PHP的兼容库。PHP 5.3及后续版本中，还可以使用<code>crypt()</code>函数，它支持多种散列算法。针对每种受支持的散列算法，PHP都提供了对应的原生实现。<br><br><br>Q: “盐”是什么？<br>A: 加解密领域中的“盐”是指在进行散列处理的过程中 加入的一些数据，用来避免从已计算的散列值表（被称作“彩虹表”中对比输出数据从而获取明文密码的风险。<br><br><br>Q: 我在使用<code>&lt;input type=&quot;image&quot;&gt;</code>标记，但是没有<code>$foo.x</code>和<code>$foo.y</code>变量，它们哪去了？<br>A: 当提交表单时，可以用图片代替标准的提交按钮，用类似这样的标记<br><code>&lt;input type=&quot;image&quot; src=&quot;image.gif&quot; name=&quot;foo&quot; /&gt;</code><br>当用户点击了图片的任何部分，该表单会被发送到服务器并加上两个额外的变量：<code>foo.x</code>和<code>foo.y</code>。因为<code>foo.x</code>和 <code>foo.y</code>在PHP中会成为非法的变量名，它们被自动转换成了<code>foo_x</code>和<code>foo_y</code>。也就是用下划线代替了点。<br><br><br>Q: PHP 5中还能用MySQL吗？好像找不到了。<br>A: MySQL依然被支持，唯一区别是PHP 5中默认为不激活。这意味着在PHP的configure一行中不包含有<code>--with-mysql</code>选项，因此必须在编译时手工加入。Windows用户可以编辑<code>php.ini</code>并激活<code>php_mysql.dll</code>。<br><br><br>Q: 在函数定义中，参数旁边的<code>&amp;</code>是什么意思？<br>A: 这表示该参数是引用传递，该函数会修改其值。鼓励使用的方法是在函数定义中指定哪些参数应该用引用传递。在函数调用时通过引用传递参数是不推荐的，因为它影响到了代码的整洁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://php.net/manual/zh/book.password.php">php.net</a></li>
<li><a target="_blank" rel="noopener" href="https://laravel-china.github.io/php-the-right-way/">PHP之道中文版</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/09/01/roadmap-refactor-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/09/01/roadmap-refactor-log/" class="post-title-link" itemprop="url">roadmap工程化改造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-09-01 17:25:31 / 修改时间：17:27:57" itemprop="dateCreated datePublished" datetime="2019-09-01T17:25:31+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/09/01/roadmap-refactor-log/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/01/roadmap-refactor-log/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/shenlvmeng/roadmap">roadmap</a>最近使用typescript重构到了1.0.0版本，下面是一些记录</p>
</blockquote>
<p>1.0.0项目由两部分组成：<strong>Electron程序</strong>、<strong>web网页</strong>。两者不直接关联，通过配置文件<code>roadmap.config.json</code>解耦。</p>
<p>另外，Electron程序和web网页属于两套开发流程，互不干扰，在使用配置文件作为接口的基础上，可以独立开发和升级。</p>
<h2 id="Electron程序"><a href="#Electron程序" class="headerlink" title="Electron程序"></a>Electron程序</h2><p>提供给用户程序，通过输入地图配置、gpx文件、定位图片物料，产出<code>roadmap.config.json</code>。整体使用Electron + webpack + TypeScript的脚手架。</p>
<p>Electron工作重点在gpx文件转换和图片压缩：</p>
<ul>
<li>gpx文件使用<code>parse-gpx</code>库解析，产出JSON字符串</li>
<li>图片压缩，保留EXIF信息的图片压缩，产出压缩后的图片</li>
</ul>
<p>最后加上用户的输入，综合产出<code>roadmap.config.json</code>。</p>
<h3 id="gpx解析"><a href="#gpx解析" class="headerlink" title="gpx解析"></a>gpx解析</h3><blockquote>
<p>见src&#x2F;main&#x2F;gpx2json.ts</p>
</blockquote>
<p>使用<code>parse-gpx</code>库解析，将经纬度坐标换算到百度地图坐标，产出保留经纬度、海拔信息的结构体，储存为JSON文件，便于网页读取。</p>
<h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><blockquote>
<p>见src&#x2F;renderer&#x2F;image.ts</p>
</blockquote>
<p>带有EXIF信息的图片通常体积很大，不适合直接放在网页，会严重拖慢网页加载速度。而经过调研，常见的图片压缩工具都不会保留图片EXIF信息，即使保留也不会保留我们需要的经纬度、海拔信息。</p>
<p>另外，满足要求的图片压缩工具（如Adobe PhotoShop）没法整合在整个流程中。因此需要自己实现。</p>
<p>思路是：</p>
<ul>
<li>读取原始图片中的EXIF信息</li>
<li>借助canvas压缩图片体积、同时调整图片尺寸</li>
<li>再度组合EXIF信息和压缩后的图片，得到保留完整EXIF信息的压缩图片</li>
</ul>
<h3 id="网页模板"><a href="#网页模板" class="headerlink" title="网页模板"></a>网页模板</h3><p>使用<code>html-loader</code>加载已经产出好的<code>output.html</code>，读取为字符串，直接输出到指定目录即可。</p>
<p>网页模板的开发流程见portal一节。</p>
<h3 id="产物"><a href="#产物" class="headerlink" title="产物"></a>产物</h3><blockquote>
<p>样例见src&#x2F;test&#x2F;portal</p>
</blockquote>
<p>产物生成在桌面的roadmap-output文件夹，<strong>新生成的文件夹会覆盖老的</strong>。内容如下：</p>
<ul>
<li><code>index.html</code> 目标网页</li>
<li><code>roadmap.config.json</code> 配置信息</li>
<li><code>data</code><ul>
<li><code>xx.json</code> gpx内容</li>
<li><code>images</code> 图片信息</li>
</ul>
</li>
</ul>
<h2 id="roadmap-config-json"><a href="#roadmap-config-json" class="headerlink" title="roadmap.config.json"></a>roadmap.config.json</h2><p>用于解耦。包含了基础的配置信息</p>
<ul>
<li>city 默认定位的中心城市</li>
<li>title 网页标题</li>
<li>gpxCount gpx路径数</li>
<li>imgTitles 图片标题，不需要和图片一一对应</li>
</ul>
<h2 id="web网页（portal）"><a href="#web网页（portal）" class="headerlink" title="web网页（portal）"></a>web网页（portal）</h2><p>web网页为了便于迭代，使用了和Electron程序独立的webpack工程。在<code>config</code>中有独立的webpack配置，有独立的webpack调试、打包命令。</p>
<p>工程位于<code>src/portal</code>，使用TypeScript。产物位于<code>portal</code>目录下，由Electron程序引用。</p>
<p>在portal工程的webpack配置中：</p>
<ul>
<li>使用<code>MiniCssExtractPlugin</code>抽出css为css资源文件，加载时的避免样式闪动</li>
<li>使用<code>HtmlWebpackInlineSourcePlugin</code>将引用的css和js文件inline，使得Electron程序只需引用一个HTML文件即可</li>
<li>需要配置html-loader的<code>attr</code>，避免web网页在加载时，里面的<code>&lt;img&gt;</code>标签的<code>src</code>属性被解析</li>
</ul>
<h3 id="gps轨迹"><a href="#gps轨迹" class="headerlink" title="gps轨迹"></a>gps轨迹</h3><p>使用百度地图API绘制polyline实现，Electron程序生成的JSON中，已经提前转成百度地图坐标地址。</p>
<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>图片存储于免费的<a target="_blank" rel="noopener" href="https://imgchr.com/">路过图床</a>，因为不支持自定义访问路径，因此需要将上传图床后的路径保存为图片的title，在网页加载时，通过压缩图的title找到图片在图床上的对应地址（这个地方的设计待优化，所以暂时未开放）。</p>
<p>图片的位置使用EXIF.js读取压缩图片的EXIF信息拿到，转换坐标后绘制在地图上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/08/25/async-hooks-and-cls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/08/25/async-hooks-and-cls/" class="post-title-link" itemprop="url">NodeJS async_hooks API与CLS（Continuation-local-storage）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-25 22:55:52" itemprop="dateCreated datePublished" datetime="2019-08-25T22:55:52+08:00">2019-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-09-16 16:47:59" itemprop="dateModified" datetime="2019-09-16T16:47:59+08:00">2019-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/08/25/async-hooks-and-cls/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/25/async-hooks-and-cls/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="async-hooks"><a href="#async-hooks" class="headerlink" title="async_hooks"></a>async_hooks</h2><p><a target="_blank" rel="noopener" href="https://nodejs.org/api/async_hooks.html#async_hooks_async_hooks">async_hooks</a>是nodejs在8.2.1后引入的特性，目前仍然是Experimental状态。它被用来追踪NodeJS中异步资源的生命周期。</p>
<p>在async_hooks特性加入之前，想要了解异步调用上下文或追踪异步调用逻辑是件比较困难的事情:</p>
<ul>
<li>最早在v0.11中有实现<a target="_blank" rel="noopener" href="https://github.com/nodejs/node-v0.x-archive/pull/6011">AsyncListener</a>，但在v0.12时<a target="_blank" rel="noopener" href="https://github.com/nodejs/node-v0.x-archive/pull/8110">被移除</a></li>
<li>在Node6和7时，有非官方的<a target="_blank" rel="noopener" href="http://blog.trevnorris.com/2015/02/asyncwrap-tutorial-introduction.html">AsyncWrap</a>实现，指定回调函数监听异步资源的创建、调用前、调用后时机</li>
</ul>
<p>async_hooks友好地解决了异步资源创建、调用的追踪问题：</p>
<ul>
<li>异步资源代表一个关联了回调的对象，回调可能被调用1次或多次，比如<code>net.createServer()</code>里的<code>connect</code>事件或<code>fs.open()</code>。<code>AsyncHook</code>不区分这些场景，统一视作异步资源</li>
<li>每一个异步上下文都有一个关联的id，即asyncId。asyncId是从1开始递增的，同一个async上下文中的id相同（在未enable async hook时，promise执行不会被分配asyncId）。<code>executionAsyncId()</code>可以获取当前异步上下文的asyncId，<code>triggerAsyncId()</code>获取触发当前异步上下文的异步上下文。借助asynId和triggerAsyncId可以追踪异步的调用关系和链路。</li>
<li><code>async_hooks.createHook()</code>函数可以注册异步资源生命周期中init&#x2F;before&#x2F;after&#x2F;destroy&#x2F;promiseResolve事件的监听函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_hooks = <span class="built_in">require</span>(<span class="string">&#x27;async_hooks&#x27;</span>)</span><br><span class="line"><span class="comment">// ID of the current execution context</span></span><br><span class="line"><span class="keyword">const</span> eid = async_hooks.<span class="title function_">executionAsyncId</span>()</span><br><span class="line"><span class="comment">// ID of the handle responsible for triggering the callback of the</span></span><br><span class="line"><span class="comment">// current execution scope to call</span></span><br><span class="line"><span class="keyword">const</span> tid = async_hooks.<span class="title function_">triggerAsyncId</span>()</span><br><span class="line"><span class="keyword">const</span> asyncHook = async_hooks.<span class="title function_">createHook</span>(&#123;</span><br><span class="line">    <span class="comment">// called during object construction</span></span><br><span class="line">    <span class="attr">init</span>: <span class="keyword">function</span> (<span class="params">asyncId, type, triggerAsyncId, resource</span>) &#123; &#125;,</span><br><span class="line">    <span class="comment">// called just before the resource&#x27;s callback is called</span></span><br><span class="line">    <span class="attr">before</span>: <span class="keyword">function</span> (<span class="params">asyncId</span>) &#123; &#125;,</span><br><span class="line">    <span class="comment">// called just after the resource&#x27;s callback has finished</span></span><br><span class="line">    <span class="attr">after</span>: <span class="keyword">function</span> (<span class="params">asyncId</span>) &#123; &#125;,</span><br><span class="line">    <span class="comment">// called when an AsyncWrap instance is destroyed</span></span><br><span class="line">    <span class="attr">destroy</span>: <span class="keyword">function</span> (<span class="params">asyncId</span>) &#123; &#125;,</span><br><span class="line">    <span class="comment">// called only for promise resources, when the `resolve`</span></span><br><span class="line">    <span class="comment">// function passed to the `Promise` constructor is invoked</span></span><br><span class="line">    <span class="attr">promiseResolve</span>: <span class="keyword">function</span> (<span class="params">asyncId</span>) &#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// starts listening for async events</span></span><br><span class="line">asyncHook.<span class="title function_">enable</span>()</span><br><span class="line"><span class="comment">// stops listening for new async events</span></span><br><span class="line">asyncHook.<span class="title function_">disable</span>()</span><br></pre></td></tr></table></figure>

<h3 id="executionAsyncId和triggerAsyncId"><a href="#executionAsyncId和triggerAsyncId" class="headerlink" title="executionAsyncId和triggerAsyncId"></a>executionAsyncId和triggerAsyncId</h3><p>调用<code>executionAsyncId</code>和<code>triggerAsyncId</code>函数获取当前异步上下文的asyncId和triggerAsyncId。</p>
<p><code>executionAsyncId</code>的返回值由运行时决定，<code>triggerAsyncId</code>可以返回当前上下文的触发原因上下文id。见下面的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>(<span class="function">(<span class="params">conn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Returns the ID of the server, not of the new connection, because the</span></span><br><span class="line">    <span class="comment">// callback runs in the execution scope of the server&#x27;s MakeCallback().</span></span><br><span class="line">    async_hooks.<span class="title function_">executionAsyncId</span>();</span><br><span class="line">    <span class="comment">// The resource that caused (or triggered) this callback to be called</span></span><br><span class="line">    <span class="comment">// was that of the new connection. Thus the return value of triggerAsyncId()</span></span><br><span class="line">    <span class="comment">// is the asyncId of &quot;conn&quot;.</span></span><br><span class="line">    async_hooks.<span class="title function_">triggerAsyncId</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Returns the ID of a TickObject (i.e. process.nextTick()) because all</span></span><br><span class="line">    <span class="comment">// callbacks passed to .listen() are wrapped in a nextTick().</span></span><br><span class="line">    async_hooks.<span class="title function_">executionAsyncId</span>();</span><br><span class="line">    <span class="comment">// Even though all callbacks passed to .listen() are wrapped in a nextTick()</span></span><br><span class="line">    <span class="comment">// the callback itself exists because the call to the server&#x27;s .listen()</span></span><br><span class="line">    <span class="comment">// was made. So the return value would be the ID of the server.</span></span><br><span class="line">    async_hooks.<span class="title function_">triggerAsyncId</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="createHook"><a href="#createHook" class="headerlink" title="createHook"></a><code>createHook</code></h3><p>更常用地，我们使用<code>async_hooks.createHook</code>创建异步资源的钩子，注册异步资源生命周期各阶段的回调函数，目前支持init&#x2F;before&#x2F;after&#x2F;destroy&#x2F;promiseResolve这几种。</p>
<p><strong>注意</strong>：打印信息到控制台也是一个异步操作，<code>console.log()</code>会触发AsyncHooks的各个回调。因此AsyncHook回调内使用<code>console.log()</code>或类似异步日志打印，会造成无限递归。一种解决办法是使用<code>fs.writeFileSync</code>或<code>process._rawDebug</code>这种同步日志操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debug</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a function like this one when debugging inside an AsyncHooks callback</span></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;log.out&#x27;</span>, <span class="string">`<span class="subst">$&#123;util.format(...args)&#125;</span>\n`</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">    <span class="comment">// OR</span></span><br><span class="line">    process.<span class="title function_">_rawDebug</span>(<span class="string">`<span class="subst">$&#123;util.format(...args)&#125;</span>\n`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="init-asyncId-type-triggerAsyncId-resource"><a href="#init-asyncId-type-triggerAsyncId-resource" class="headerlink" title="init(asyncId, type, triggerAsyncId, resource)"></a>init(asyncId, type, triggerAsyncId, resource)</h4><p>在<em>可能</em>会触发异步事件的资源构造时调用。这不代表后面的<code>before/after</code>事件回调会在<code>destroy</code>回调触发，只是说有这个可能。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>().<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">close</span>(); &#125;);</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>参数解释如下：</p>
<ul>
<li><code>asyncId</code> 异步资源id</li>
<li><code>type</code> 异步资源类型，字符串枚举值，具体参见<a target="_blank" rel="noopener" href="https://nodejs.org/api/async_hooks.html#async_hooks_type">官方文档</a></li>
<li><code>triggerAsyncId</code> 触发当前异步资源创建的异步上下文的asyncId</li>
<li><code>resource</code> 被初始化的异步资源对象</li>
</ul>
<p><code>triggerAsyncId</code>表示的是资源创建的原因，<code>async_hooks.executionAsyncId()</code>表示的是资源创建的时机。如下面例子里体现的一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async_hooks.<span class="title function_">createHook</span>(&#123;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params">asyncId, type, triggerAsyncId</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> eid = async_hooks.<span class="title function_">executionAsyncId</span>();</span><br><span class="line">    fs.<span class="title function_">writeSync</span>(</span><br><span class="line">      <span class="number">1</span>, <span class="string">`<span class="subst">$&#123;type&#125;</span>(<span class="subst">$&#123;asyncId&#125;</span>): trigger: <span class="subst">$&#123;triggerAsyncId&#125;</span> execution: <span class="subst">$&#123;eid&#125;</span>\n`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">enable</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>(<span class="function">(<span class="params">conn</span>) =&gt;</span> &#123;&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>nc localhost 8080</code>后，打印信息如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCPSERVERWRAP(5): trigger: 1 execution: 1</span><br><span class="line">TCPWRAP(7): trigger: 5 execution: 0</span><br></pre></td></tr></table></figure>

<h4 id="before-asyncId"><a href="#before-asyncId" class="headerlink" title="before(asyncId)"></a>before(asyncId)</h4><p>在异步操作初始化完成（如TCP服务器接收新连接）或资源准备完成（写数据到磁盘），准备执行回调时触发。入参<code>asyncId</code>即这个异步资源的ID。<code>before</code>事件可能会触发0~N次。</p>
<ul>
<li>0次，异步操作被撤销</li>
<li>&gt; 1次，持久化的异步资源，如TCP服务器</li>
</ul>
<h4 id="after-asyncId"><a href="#after-asyncId" class="headerlink" title="after(asyncId)"></a>after(asyncId)</h4><p>回调执行完成后立即触发。当执行回调过程中有未捕获异常，会在触发“uncaughtException”事件后触发。</p>
<h4 id="destroy-asyncId"><a href="#destroy-asyncId" class="headerlink" title="destroy(asyncId)"></a>destroy(asyncId)</h4><p>当asyncId对应的异步资源被销毁时调用。有些异步资源的销毁要依赖垃圾回收机制，所以当引用了传递到<code>init</code>函数的resource时，destory事件可能永远不会被触发，从而造成内存泄漏。</p>
<h4 id="promiseResolve-asyncId"><a href="#promiseResolve-asyncId" class="headerlink" title="promiseResolve(asyncId)"></a>promiseResolve(asyncId)</h4><p>当Promise构造器中的resolve函数被执行时，promiseResolve事件被触发。有些情况下，有些resolve函数是被隐式执行的，比如<code>.then</code>函数会返回一个新的Promise，这个时候也会被调用。</p>
<p>当<code>new Promise((resolve) =&gt; resolve(true)).then((a) =&gt; &#123;&#125;);</code>语句执行时，会顺序触发下列函数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init for PROMISE with id 5, trigger id: 1</span><br><span class="line">  promise resolve 5      # corresponds to resolve(true)</span><br><span class="line">init for PROMISE with id 6, trigger id: 5  # the Promise returned by then()</span><br><span class="line">  before 6               # the then() callback is entered</span><br><span class="line">  promise resolve 6      # the then() callback resolves the promise by returning</span><br><span class="line">  after 6</span><br></pre></td></tr></table></figure>

<p>AsyncHook实例定义好后，需要通过<code>enable</code>开启。可以使用<code>disable</code>关闭AsyncHook的回调执行。</p>
<p>下面是一个AsyncHook的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> indent = <span class="number">0</span>;</span><br><span class="line">async_hooks.<span class="title function_">createHook</span>(&#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params">asyncId, type, triggerAsyncId</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> eid = async_hooks.<span class="title function_">executionAsyncId</span>();</span><br><span class="line">        <span class="keyword">const</span> indentStr = <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(indent);</span><br><span class="line">        fs.<span class="title function_">writeSync</span>(</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;indentStr&#125;</span><span class="subst">$&#123;type&#125;</span>(<span class="subst">$&#123;asyncId&#125;</span>):`</span> +</span><br><span class="line">            <span class="string">` trigger: <span class="subst">$&#123;triggerAsyncId&#125;</span> execution: <span class="subst">$&#123;eid&#125;</span>\n`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">before</span>(<span class="params">asyncId</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> indentStr = <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(indent);</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;log.out&#x27;</span>, <span class="string">`<span class="subst">$&#123;indentStr&#125;</span>before:  <span class="subst">$&#123;asyncId&#125;</span>\n`</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">        indent += <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">after</span>(<span class="params">asyncId</span>) &#123;</span><br><span class="line">        indent -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> indentStr = <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(indent);</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;log.out&#x27;</span>, <span class="string">`<span class="subst">$&#123;indentStr&#125;</span>after:  <span class="subst">$&#123;asyncId&#125;</span>\n`</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">destroy</span>(<span class="params">asyncId</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> indentStr = <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(indent);</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;log.out&#x27;</span>, <span class="string">`<span class="subst">$&#123;indentStr&#125;</span>destroy:  <span class="subst">$&#123;asyncId&#125;</span>\n`</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">enable</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>(<span class="function">() =&gt;</span> &#123;&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Let&#x27;s wait 10ms before logging the server started.</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>, async_hooks.<span class="title function_">executionAsyncId</span>());</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在启动服务器后，打印信息如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TCPSERVERWRAP(5): trigger: 1 execution: 1</span><br><span class="line">TickObject(6): trigger: 5 execution: 1</span><br><span class="line">before:  6</span><br><span class="line">  Timeout(7): trigger: 6 execution: 6</span><br><span class="line">after:   6</span><br><span class="line">destroy: 6</span><br><span class="line">before:  7</span><br><span class="line">&gt;&gt;&gt; 7</span><br><span class="line">  TickObject(8): trigger: 7 execution: 7</span><br><span class="line">after:   7</span><br><span class="line">before:  8</span><br><span class="line">after:   8</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>可以直接参考<a target="_blank" rel="noopener" href="https://nodejs.org/api/async_hooks.html#async_hooks_error_handling">官方文档描述</a></p>
<h3 id="可以用来干嘛"><a href="#可以用来干嘛" class="headerlink" title="可以用来干嘛"></a>可以用来干嘛</h3><p>一个最为人知的使用场景是我们下面会提到的CLS（Continuation-local-storage）。cls-hooked库通过async_hooks建立了context对象和当前async执行上下文的关系，从而在整个执行链（execution chain）上维护一个统一的数据存储。</p>
<p>还有一个是结合<a target="_blank" rel="noopener" href="https://nodejs.org/api/perf_hooks.html">Performance Timing API</a>这样的性能监测工具诊断整个异步操作流程的性能。比如<a target="_blank" rel="noopener" href="https://clinicjs.org/blog/introducing-bubbleprof/">这篇文章</a>所介绍的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/async_hooks.html">Async Hooks | Node.js Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://itnext.io/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9">A Pragmatic Overview of Async Hooks API in Node.js</a></li>
</ul>
<h2 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h2><p><a target="_blank" rel="noopener" href="https://github.com/othiym23/node-continuation-local-storage">Continuation-local storage(CLS)</a>类似线程编程里的线程存储，不过基于nodeJS风格的链式回调函数调用。它得名于函数式编程中的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-passing style</a>，旨在链式函数调用过程中维护一个持久的数据。</p>
<p>在node V8之前，分别基于AsyncListener和AsyncWrap实现。在V8后，基于async_hook实现的库名为<a target="_blank" rel="noopener" href="https://github.com/jeff-lewis/cls-hooked#readme">cls-hooked</a>。但使用方法一致。</p>
<p>这里借用cls README里的一个例子。假设你写了一个获取用户信息的模块，将获取到的用户信息放在session中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createNamespace = <span class="built_in">require</span>(<span class="string">&#x27;cls-hooked&#x27;</span>).<span class="property">createNamespace</span>;</span><br><span class="line"><span class="keyword">var</span> session = <span class="title function_">createNamespace</span>(<span class="string">&#x27;my session&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = <span class="built_in">require</span>(<span class="string">&#x27;./lib/db.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params">options, next</span>) &#123;</span><br><span class="line">  db.<span class="title function_">fetchUserById</span>(options.<span class="property">id</span>, <span class="keyword">function</span> (<span class="params">error, user</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">next</span>(error);</span><br><span class="line"></span><br><span class="line">    session.<span class="title function_">set</span>(<span class="string">&#x27;user&#x27;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，需要将用户信息转化为一个HTML文档，你在另外一个文件中定义了转换函数，并从session中取出你想要的用户信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send_response.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNamespace = <span class="built_in">require</span>(<span class="string">&#x27;cls-hooked&#x27;</span>).<span class="property">getNamespace</span>;</span><br><span class="line"><span class="keyword">var</span> session = <span class="title function_">getNamespace</span>(<span class="string">&#x27;my session&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = <span class="built_in">require</span>(<span class="string">&#x27;./lib/render.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">finish</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> user = session.<span class="title function_">get</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">  <span class="title function_">render</span>(&#123;<span class="attr">user</span>: user&#125;).<span class="title function_">pipe</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>cls的使用围绕namespace展开，你可以根据需要自由组织namespace，需要持久化的信息读写在namespace的context上进行。</p>
<ul>
<li><code>cls.createNamespace</code>、<code>cls.getNamespace</code> 创建和获取一个namespace</li>
<li><code>cls.destroyNamespace</code>、<code>cls.reset</code> 删除一个namespace和重置所有namespace</li>
<li><code>ns.get</code>、<code>ns.set</code> 在namespace的context上读取和设置持久化数据</li>
<li><code>ns.run</code>、<code>ns.runAndReturn</code>、<code>ns.runPromise</code> 在给定context下执行函数</li>
<li><code>ns.bind</code>、<code>ns.bindEmitter</code> 绑定context到给定函数或eventEmitter</li>
<li><code>context</code> 维护持久化数据的plain object</li>
</ul>
<p>更多API参考<a target="_blank" rel="noopener" href="https://github.com/jeff-lewis/cls-hooked#clscreatenamespacename">文档</a>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>正如上面所说，“cls-hooked库通过async_hooks建立了context对象和当前async执行上下文的关系”。下面有张图通过例子描述了cls的工作过程：</p>
<p><img src="https://miro.medium.com/max/924/1*PPk_uEmQFVKO16byHpwnXA.jpeg" alt="CLS workflow"></p>
<p>简单拆解一下：</p>
<ul>
<li>首先，我们有一个典型的web server和应用上的中间件，我们在整个应用的生命周期里创建一个cls的namespace。</li>
<li>新请求到达中间件时，cls通过<code>ns.run</code>（别的方式也行）创建一个空的cls context，并入栈该context，设置为active context。</li>
<li>由于cls内部注册了AsyncHook，在<code>init</code>阶段，在Map中关联对应active context到当前asyncId。从而有异步操作（如查数据库）时，此前入栈的context就和操作的asyncId对应上。此后get<br>、set操作都会针对同一active context进行。</li>
<li>异步操作完成后，<code>after</code>回调触发，active context变成undefined，同时出栈当前context。当<code>destroy</code>回调触发时，会将关联到asyncId的context从Map中移除。</li>
</ul>
<p>在cls-hooked实现中，</p>
<ul>
<li><code>ns.get</code>和<code>ns.set</code>和<code>ns.active</code>相关联</li>
<li><code>ns.active</code>通过<code>ns.enter</code>、<code>ns.exit</code>变更或者在<code>init</code>回调中从contextMap中改变。</li>
<li><code>ns.enter</code>、<code>ns.exit</code>、<code>init</code>回调最终都经由<code>ns.runxxx</code>或<code>ns.bindxxx</code>得到初始的context</li>
<li>cls-hooked借助async_hook和<code>ns.enter</code>、<code>ns.exit</code>保证异步流程中context和异步上下文的正确对应关系</li>
</ul>
<p>考虑到cls-hooked的js代码可读性，可维护性和工程角度上还有改善空间，基于上面的原理，做了ts的重构，源码见这里(待补充)，供大家参考和学习cls-hooked。</p>
<h3 id="追踪logId"><a href="#追踪logId" class="headerlink" title="追踪logId"></a>追踪logId</h3><blockquote>
<p>醉翁之意不在酒</p>
</blockquote>
<p>有了cls的帮助，我们就可以利用它帮我们持久化logId，避免“continuation-passing-context”。可以写一个中间件，为req、res包装context，同时为每次请求持久化logId。在后面的controller、services这些位置就可以拿到之前持久化的logId。</p>
<p>一个express风格的中间件类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cls = <span class="built_in">require</span>(<span class="string">&#x27;cls-hooked&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> uuidv4 = <span class="built_in">require</span>(<span class="string">&#x27;uuid/v4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clsNamespace = cls.<span class="title function_">createNamespace</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clsMiddleware</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// req and res are event emitters. We want to access CLS context inside of their event callbacks</span></span><br><span class="line">  clsNamespace.<span class="title function_">bind</span>(req);</span><br><span class="line">  clsNamespace.<span class="title function_">bind</span>(res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> logId = <span class="title function_">uuidv4</span>();</span><br><span class="line"></span><br><span class="line">  clsNamespace.<span class="title function_">run</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    clsNamespace.<span class="title function_">set</span>(<span class="string">&#x27;logId&#x27;</span>, logId);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// controller.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">controller</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> traceID = clsNamespace.<span class="title function_">get</span>(<span class="string">&#x27;logId&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个思路的基础上，有类似<a target="_blank" rel="noopener" href="https://github.com/puzpuzpuz/cls-rtracer">cls-rtracer</a>或<a target="_blank" rel="noopener" href="https://github.com/keenondrums/cls-proxify">cls-proxify</a>这样的库，提供针对express、koa、fastify等常见后端框架的中间件，只需简单指定配置，便可以在请求的生命周期里透传logId，免去“continuation-passing-context”的尴尬，对已有代码侵入性也很小。有需要透传logId，但并不想（或暂时不能）使用后端框架的场景下可以考虑使用这种方案。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/nodejs/node-v0.x-archive/issues/5243">context: core module to manage generic contexts for async call chains · Issue #5423</a></li>
<li><a target="_blank" rel="noopener" href="https://datahero.com/blog/2014/05/22/node-js-preserving-data-across-async-callbacks/">Node.js – Preserving Data Across Async Callbacks</a></li>
<li><a target="_blank" rel="noopener" href="https://itnext.io/nodejs-logging-made-right-117a19e8b4ce">NodeJS logging made right</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/08/07/social-psychology-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/08/07/social-psychology-part-2/" class="post-title-link" itemprop="url">社会心理学 Part 2 - 社会影响</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-07 00:13:53" itemprop="dateCreated datePublished" datetime="2019-08-07T00:13:53+08:00">2019-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-02 21:49:03" itemprop="dateModified" datetime="2019-11-02T21:49:03+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/08/07/social-psychology-part-2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/07/social-psychology-part-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/07/26/social-psychology-part-1/">社会心理学 Part 1 - 导论 &amp; 社会思维</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/09/24/social-psychology-part-3/">社会心理学 Part 3 - 社会关系</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/11/02/social-psychology-part-4/">社会心理学 Part 4 - 应用</a></p>
</blockquote>
<p>这部分主要讨论社会给个人的影响。</p>
<h2 id="基因、文化和性别"><a href="#基因、文化和性别" class="headerlink" title="基因、文化和性别"></a>基因、文化和性别</h2><h3 id="基因和文化的影响"><a href="#基因和文化的影响" class="headerlink" title="基因和文化的影响"></a>基因和文化的影响</h3><ul>
<li>进化观点：强调人类的联系、相似性</li>
<li>文化观点：强调人类的多样性</li>
</ul>
<p>自然选择过程决定了我们的许多共性特征。<strong>进化心理学</strong>即基于此研究自然如何影响那些适应特定环境的生理特征，以及有利于基因存活和延续的心里特征和社会行为。</p>
<p>在共有生理基础上，<strong>文化</strong>赋予人类以多样性。文化更强调人类的适应性。我们的大多数行为都是受社会影响的。当与来自不同文化背景的人一起工作、生活时，会更容易理解文化如何影响我们和文化间的差异性。文化中会自然形成强迫人们遵从传统的社会行为的期待，即社会<strong>规范</strong>。<strong>私人空间</strong>是一种我们自己与他人间维持润滑和缓冲的空间，不同个体间需求的私人空间也不同。</p>
<p>文化除了差异性，还具有内在的统一性，比如对乱伦的限制，对战犯的处理上。而且罗杰·布朗提出，人和人之间不仅会形成某种等级地位，在和地位较高的人说话时，语气往往更尊敬（就像和陌生人说话一样），而和地位较低的人则像和熟人聊天，进而可以推出：</p>
<ol>
<li>强调沟通的形式不仅反映社会距离也反映社会地位</li>
<li><strong>亲密关系往往由较高地位的人控制</strong>。地位更高的人是亲密关系发展的制定者。比如开会发言、约会吃饭。</li>
</ol>
<h4 id="社会角色"><a href="#社会角色" class="headerlink" title="社会角色"></a>社会角色</h4><ul>
<li>社会角色比角色扮演者本身有更长久的生命力。</li>
<li>一种社会角色伴随的是<strong>一系列</strong>的社会规范</li>
<li>社会角色具有强大的影响力，我们倾向于接纳自己的角色</li>
</ul>
<p>在实验中，地位更高的人认为自己更应该受到优待，且具有更高的能力，尽管地位是实验分配的。相反，较低下的社会角色会主动削弱自己的自我效能感，自我赋能可以打破这种困境。</p>
<p>角色互换可以帮助人们更好地理解对方，毕竟，<strong>人类大部分的冲突和争论都源自人们过于关注自己的意见而非寻找问题的正确答案</strong>。</p>
<h3 id="性别相似性和差异性"><a href="#性别相似性和差异性" class="headerlink" title="性别相似性和差异性"></a>性别相似性和差异性</h3><p>对于个体意识以及社会关系而言，种族和性别是最重要的两个维度。对性别差异上的研究不能被用来验证偏见和加深刻板印象。男性和女性有很多性别上的不同：</p>
<ul>
<li>男性有更多神经元，女性有更多神经连接</li>
<li>男性更有独立性，女性更具联系性。女性比男性更注重亲密关系。女性更易用<strong>关系性</strong>的词汇描述自己，乐于接受他人帮助，体验更多和关系相关的情感，努力使关系更协调；男性在谈话时常常关注任务和大群体的关系。<ul>
<li>工作上，男性更倾向于看重报酬、提升机会、挑战和权力，而女性更看重合理时间安排、私人关系、帮助他人的机会，如护士、教师</li>
<li>女性在家庭上会花更多时间照顾孩子和老人，<strong>相互支持感</strong>对女性的婚姻满意度是极为关键的</li>
<li>女性比男性更可能为他人的经历产生、表现出<strong>共情</strong>的反应。有一种解释是，女性具有更强的理解他人情绪的能力。</li>
<li>女性在记忆面部特征和其他外部特征上更为出色，非言语表达情绪的能力也很出色。男人在传达愤怒上更明显。</li>
</ul>
</li>
<li>几乎所有社会，都是男性处于统治地位。<ul>
<li>男性比女性更关心社会统治问题</li>
<li>男性交流的方式可以加强他们的社会权力，在没有界定领导角色的场景下，男性倾向于<strong>指示性</strong>的领导方式，女性倾向于<strong>民主化</strong>的方式</li>
<li>男性比女性更强调胜利、超期和控制他人，同样也更爱冒险。</li>
<li>男性的谈话方式可以反映他们对独立的关注，而女性更注重关系</li>
</ul>
</li>
<li>男性承认自己比女性有更多攻击行为。有研究显示，女性苏沪会发起更多攻击行为，但是男性更容易造成伤害</li>
<li>性特征<ul>
<li>男性比女性更可能发生性活动</li>
<li>男性进行更多性幻想，态度也更开放，而且试图寻找更多性伴侣，更容易引发性唤醒，更多要求性爱，很少拒绝性爱，且更偏爱形式各异的性爱</li>
<li>人类学家唐纳德·西蒙指出，“在世界各地，性都被理解成为女性所拥有的，男性想得到的东西”</li>
<li>在185个国家的调查中发现，男人越稀有，女性怀孕的比率就越高。而当女人稀少时，女性性行为的市场价值就会提升，她们会要求更高的价格</li>
<li>性幻想上，女性更注重感情</li>
</ul>
</li>
</ul>
<p>进化和文化交织地影响着性别行为。</p>
<h4 id="进化对性别行为的影响"><a href="#进化对性别行为的影响" class="headerlink" title="进化对性别行为的影响"></a>进化对性别行为的影响</h4><p>两性在后天可养成的行为上，如果面临相同的适应挑战，会趋向相同。而在约会、婚配、繁殖行为等天生行为上会存在差异。由于自然会选择那些有助于基因遗传的特性，所以我们天生就追求那些增加基因遗传性的生活方式。从而：</p>
<ul>
<li>女性会更加小心考察男性的身体健康和资源状况，谨慎处理自己的繁殖机会。男性则需要和他人竞争，以便把自己的基因遗传下去。简言之，男性寻求更广泛的繁殖、女性寻求更明智的繁殖</li>
<li>男性偏爱有生殖力旺盛外表特征的女性，而女性偏爱有财产和地位这些能为后代提供足够保护和抚养的男性</li>
</ul>
<p>在人进入中年和老年时，男女性会渐渐趋同，女性变得独断自信，而男性可能更好共情更少支配他人。一方面是激素的影响减弱，另一方面是社会期待对个体的限制减弱。</p>
<h4 id="文化对性别行为的影响"><a href="#文化对性别行为的影响" class="headerlink" title="文化对性别行为的影响"></a>文化对性别行为的影响</h4><p>文化是大群体共享的代代相传的“共同假设”。文化对不同性别的期待界定了性别角色。在实验中，男女性都趋向于让自己的表现和对方的性别角色期望相符合。由于文化的地域性和年代性，不同地区和年代下的性别角色也是在变化的。总体上讲，男女的性别角色已经没有以前那么大了。</p>
<p>在文化的代代相传上，<strong>教养论</strong>认为，父母抚养孩子的方式决定孩子成为什么样的人。因为孩子会接受父母的很多价值观。而后在一些调查研究中发现，孩子的人格差异受<strong>同伴的影响</strong>更大。孩子通常从更大的孩子身上学习，直到那些和父母同一代的年轻人。总结来说，</p>
<ul>
<li>父母一代对孩子一代的联系是松散的，文化的传承是间接的，孩子受同伴影响更多</li>
<li>不过父母可以决定孩子身边的同伴，如学校、社区</li>
</ul>
<p>整体来看，生物因素和文化因素交互影响我们的态度和行为。与此同时，人是具有主观能动性的，人本身具有改变自己态度和行为的能力。</p>
<ul>
<li>同一种社会情境付不同人有不同的影响</li>
<li>人们可以选择自己所处的情境</li>
<li>人们能创造自己的环境</li>
</ul>
<h2 id="从众"><a href="#从众" class="headerlink" title="从众"></a>从众</h2><h3 id="什么是从众"><a href="#什么是从众" class="headerlink" title="什么是从众"></a>什么是从众</h3><p><strong>从众</strong>是指根据他人而做出的行为或信念的改变，有三种形态：</p>
<ul>
<li>顺从，为了得到奖励或避免惩罚</li>
<li>服从，通过明确命令引起的顺从行为</li>
<li>接纳，真诚的内在的从众行为</li>
</ul>
<h3 id="从众的经典研究"><a href="#从众的经典研究" class="headerlink" title="从众的经典研究"></a>从众的经典研究</h3><p>这里介绍三例影响较大的经典研究：</p>
<ul>
<li>谢里夫的规范形成研究（社会传染）</li>
<li>阿施的群体压力研究（社会压力）</li>
<li>米尔格拉姆的服从实验</li>
</ul>
<p>它们分别从三个不同角度研究了在外界压力逐步增大的情境下，我们的从众行为是怎样形成和表现的。</p>
<h4 id="谢里夫的规范形成研究"><a href="#谢里夫的规范形成研究" class="headerlink" title="谢里夫的规范形成研究"></a>谢里夫的规范形成研究</h4><p>Muzafer Sheriff研究了在暗示下，个体是怎样形成群体规范的。通过一个巧妙的关于光点似动现象的实验，谢里夫发现了个体的<strong>易受暗示</strong>性。我们对现实的看法未必来自我们自己的观点。一个人的咳嗽、笑或打呵欠会引起周围人的效仿，即社会传染效应。</p>
<p>这种暗示还会在更大范围内传递。如自杀事件的报道会引起自杀率的轻微上升，报道得越厉害，增加得就越多。一方面因为青少年是易感人群，容易模仿；另一方面是在暗示的作用下，我们不能透过现象寻找本质原因。“群体癔症”也是因为社会传染而引起的集体妄想表现。</p>
<h4 id="阿施的群体压力研究"><a href="#阿施的群体压力研究" class="headerlink" title="阿施的群体压力研究"></a>阿施的群体压力研究</h4><p>谢里夫的实验针对的是模糊的现实场景，而阿施则通过同谋实验者为被试制造出“刻意”的社会压力，研究此时的从众行为。具体表现为让被试一个一个回答简单问题，在前面的同谋者都赞同明显错误答案时，研究发现有一小部分人在不安和内心冲突后赞同了明显错误的答案。</p>
<h4 id="米尔格拉姆的服从实验"><a href="#米尔格拉姆的服从实验" class="headerlink" title="米尔格拉姆的服从实验"></a>米尔格拉姆的服从实验</h4><p>阿施的群体压力实验距离现实较远，社会压力并没有强迫个体服从。米尔格拉姆通过实验研究在社会压力直接强迫个体时，从众行为是如何表现的。具体表现为，邀请同谋扮演学习者和被试扮演教师，隔离开学子和和教师，让教师考察学习者，并在学习者给出错误答案时，在研究者的要求下提升点击学习者的电压。电压从15伏到450伏（当然电击是假的，学习者的痛苦反应也只是录音）。</p>
<p>被试的所有人都认为在135伏左右会不服从研究者的命令。实际上，有65%的被试进行实验一直到450伏，而不顾学习者的“哭喊”和“抗议”。实验结论在发表后，被质疑是否具有伦理问题，让被试在实验后质疑自我。对此米尔格拉姆解释实验结束后，会告诉被试真相，在事后回访时也只有1%的被试表示很遗憾。</p>
<h3 id="服从行为的影响因素"><a href="#服从行为的影响因素" class="headerlink" title="服从行为的影响因素"></a>服从行为的影响因素</h3><h4 id="受害者的情感距离"><a href="#受害者的情感距离" class="headerlink" title="受害者的情感距离"></a>受害者的情感距离</h4><p>米尔格拉姆的被试在无法看到和听到学习者（同样学习者也看不到被试）时，其行动表现出的同情最少，相反在实验中可以听到抗议，甚至可以看到被试时，完全服从的比例有所下降。</p>
<p><strong>我们很容易贬低远离自己或失去个性的人</strong>。甚至对于巨大大灾难，人们也会无动于衷。</p>
<ul>
<li><strong>火车轨道困境</strong>中，人们对于绑在火车道上的单个人的同情要甚于火车道上的一群人</li>
<li><strong>人们对于个性化的人是最富有同情心的</strong>，这就是为什么人们通常用令人感动的照片赋予饥饿人群、动物权利、新生儿以个性化</li>
<li>同样，如果对受害者个性化，无辜的受害者会博得更多同情。一个误落矿井的男孩是一条鲜活的生命，而一场核战争的牺牲者只是一个数字</li>
</ul>
<h4 id="权威的接近和合法性"><a href="#权威的接近和合法性" class="headerlink" title="权威的接近和合法性"></a>权威的接近和合法性</h4><p>米尔格拉姆的实验中发现，要求命令的发出者在<strong>空间距离的接近性会增加服从度</strong>。当命令通过电话发出时，服从度有较大下降。同时<strong>权威必须要具有合法性</strong>，当研究者告知仪器可以自动进行实验，换作另外一个人代替他发出命令时，被试中出现了反叛的现象。</p>
<h4 id="权威机构和释放效应"><a href="#权威机构和释放效应" class="headerlink" title="权威机构和释放效应"></a>权威机构和释放效应</h4><ul>
<li><strong>机构声望能增加命令的合法性</strong>。实验在耶鲁大学进行和在普通城市的普通办公楼进行时，完全服从的比例有所下降。</li>
<li>尽管群体在被直接强迫时会有从众表现，但当有参与者接二连三地表示反对和不满时，<strong>释放效应</strong>会引起对命令的强烈反抗</li>
</ul>
<h3 id="从众研究的反思"><a href="#从众研究的反思" class="headerlink" title="从众研究的反思"></a>从众研究的反思</h3><ul>
<li>当外界影响超过内在信仰，个人知觉被淹没时，态度便无法决定行为。强有力的社会压力（命令）会超越力量较弱的因素（受害者的抗争）。可怕的是，结合之前提到的<strong>登门槛现象</strong>，当电压一点点增大时，被试早已降低了态度和行为的不协调感，内化了行为的合法性，很容易接受之前被强迫的命令。即<strong>顺从滋生接纳</strong>。施暴者会在暴力一点点升级时，贬低被害者以减轻负罪感，而慢慢从命令的执行者变成冷漠的杀人机器。</li>
<li><strong>社会情境具有极大的影响力</strong>，它虽然没有明文规定，但指导着公众行为。比如，米尔格拉姆在要求学生主动要求乘坐地铁的乘客让座时，有过半人都让了座，而同时学生也发现要这样做真得很难。情境有时会诱使普通人赞同谬误或向邪恶屈服。当人们分散分工时，邪恶似乎更容易进行。</li>
<li>人们对罪恶的执行者存在<strong>基本归因错误</strong>，误认为他们本来就是内心邪恶的人。从而忽视了邪恶行为的产生原因主要来自外在环境，我们离他们其实并不远。普通人，可以心中并没有任何仇恨，只是做本职工作，也可以成为可怕破坏性行动的执行者。善良的人们有时也会堕落，而且他们会对自己不道德的行为进行合理化归因。</li>
</ul>
<h3 id="从众行为的影响因素"><a href="#从众行为的影响因素" class="headerlink" title="从众行为的影响因素"></a>从众行为的影响因素</h3><ul>
<li>任务难度：在阿施的社会压力实验中，<strong>任务判断非常困难或让被试感觉无法胜任时</strong>，从中比率会升高。</li>
<li>群体规模：在实验室实验中，群体规模增加到5个人的过程中，从众行为会极大提升，但大于5个人时，从众程度增加便不明显，甚至有所下降。<strong>多个小群体</strong>的一致意见会使观点更可信</li>
<li>群体一致性：群体一致性被破坏时，群体的社会影响力会下降。这也是为什么<strong>当你能找到和你立场一致的人时，你为某件事站出来就容易得多</strong>。同时，观察到其他人的异议时，即使这种异议时错误的、和自己矛盾的，也会增强我们自己独立性</li>
<li>群体凝聚力：群体外的人提出的“少数派观点”对我们的影响小于我们群体内“少数派观点”对我们的影响。一个群体的<strong>凝聚力</strong>越强，对成员的影响力就越大。</li>
<li>地位：<strong>我们会避免与地位低的或被自己嘲笑的人意见一致</strong>，而更向地位高的人靠拢。这里的地位高低完全由我们自己的观察决定。</li>
<li>公开反映：与面对群体比，在私人空间里，我们更容易坚持自己的信仰</li>
<li>事前承诺：<strong>个体一旦对自己的立场作出了公开承诺，就很少屈服于社会压力</strong>。公开的承诺会让人无法后退</li>
</ul>
<h3 id="从众原因和差异性"><a href="#从众原因和差异性" class="headerlink" title="从众原因和差异性"></a>从众原因和差异性</h3><p>主要来自两种影响：</p>
<ul>
<li><strong>规范影响</strong>，避免被群体拒绝，避免受到不合规范的惩罚。有时，高昂的代价会迫使人们支持自己不相信的东西，或至少压制自己的反对意见。即<strong>我们想得到他人的喜爱和赞赏</strong>。</li>
<li><strong>信息影响</strong>，他人的反应会影响我们对模糊情境的解释，和群体保持一致会使人们更容易证实自己的决策树正确的。即<strong>我们想要做出正确的行为</strong></li>
</ul>
<p>个性和文化能判断从众行为对个体的影响程度。就个性来讲，几乎是和环境一起影响着人们的从众行为。而文化中，在不同时不同地对人们从众行为的指示也是不一样的。</p>
<h3 id="从众行为的抵制"><a href="#从众行为的抵制" class="headerlink" title="从众行为的抵制"></a>从众行为的抵制</h3><h4 id="逆反"><a href="#逆反" class="headerlink" title="逆反"></a>逆反</h4><p>个体非常看重自己的自由感和自我效能感时，如果社会压力很明显，以至于<strong>威胁到个体自由感</strong>时，会引起个体反抗。逆反，即人们采取行动保护自己的自由感。努力限制自由会引起“反从众”，比如可以用来解释性胁迫。</p>
<h4 id="坚持独特性"><a href="#坚持独特性" class="headerlink" title="坚持独特性"></a>坚持独特性</h4><p><strong>个体认为自己是独特的，且这种独特感是中等程度时</strong>，会产生良好的自我感觉。因此，我们都在努力保持<strong>一定程度</strong>的独特性，这也是潮流多变的原因。在实验中，那些听到其他人发表观点和自己相同的人，反而会改变自己的观点来维护自己的独特性。</p>
<p>把自己看成独特的个体也会出现在“自发性自我概念中”，即上一篇提到的“虚假独特性”。自我介绍时，我们会倾向于描述自己较独特的一面。有种解释是，<strong>只有这样，个体与众不同时，个体才会意识到自我存在</strong>。更进一步，我们不仅追求与众不同，还追求正确方向上的独特性，即<strong>好于众人</strong>。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>极致的个体主义里，不把任何事情归功于任何人，也不期望从任何人那里得到什么，孤立地看待自己的习惯，好像整个命运掌握在自己手里。相反，集体主义中，学生通常穿着校服避免个性，显示团结一致，抑制个体的冲突以求融洽相处。</p>
<p>可能求同存异是一种折中的更好的融合，平衡自己的独立性需要和社会关系需要，私密性和社会性，个体性和同一性。</p>
<h2 id="说服"><a href="#说服" class="headerlink" title="说服"></a>说服</h2><p>说服也是社会对我们的一种常见影响，在生活中，说服几乎无处不在。对个人而言，说服有利有弊，主要由信息背后的目的和包含的内容决定，我们称好的说服为“教育”，不好的说服为“洗脑”。有人认为文化塑造是从上而下的，有一部分中坚分子控制着信息观念的传播。</p>
<p>说服，即个体从知晓信息到做出行动的过程。在对人的作用上，主要分为两种途径：</p>
<ul>
<li><strong>中心途径</strong>，当人们能全面系统地对某个问题进行思考时，关注论据合理性时，更多使用中心途径。即<strong>知晓-&gt;理解-&gt;相信-&gt;记住-&gt;行动</strong>。比如电脑等数码产品的广告</li>
<li><strong>外周途径</strong>，当人们忙于其他事情或不关注论据本身时，更多使用外周途径。这时，人们不会关心论据是否让人信服，而会“跟着感觉走”。比如饮料、烟草广告。</li>
</ul>
<p>相比之下：</p>
<ul>
<li>中心途径需要人详细分析论据，需要时间，往往能形成更持久的行为改变</li>
<li>外周途径通常基于启发性规则（如相信专家），形成较快，用于形成初步看法，行为改变并不持久</li>
</ul>
<h3 id="说服的要素"><a href="#说服的要素" class="headerlink" title="说服的要素"></a>说服的要素</h3><p>说服主要由4个部分组成：</p>
<ol>
<li>传达者</li>
<li>信息内容</li>
<li>传递途径</li>
<li>听众</li>
</ol>
<p>影响说服的因素实在很多，需要针对上述组成部分分开讨论和研究。</p>
<h4 id="传达者"><a href="#传达者" class="headerlink" title="传达者"></a>传达者</h4><p>传达者可以影响说服的效果主要体现在下面一些方面。</p>
<p><strong>可信度</strong></p>
<p>信源的可信度对说服效果有积极影响。然而存在<strong>睡眠者效应</strong>，即人们容易遗忘信源或信源和信息联系之后的延滞性说服。体现在，信源可信度对说服起到的帮助会随着时间流逝而消退，相反那些可信度低的人影响力则会随着时间流逝而增加。</p>
<ul>
<li><strong>可知觉的专家性</strong>，可以通过传达公众赞同的观点、被公认的学识渊博者引介以及自信的表达方式达到</li>
<li><strong>可知觉的信赖性</strong>，包括直视质疑者、听起来不像在说服自己、站在自身利益对立面（如一个自私的人突然间为社会奉献）等方式。同时，<strong>较快的语速</strong>也可以增加发言人的可信度。这是因为除了给人自信的暗示外，较快的语速通常也无法留给听众思考和留给质疑者发问。</li>
</ul>
<p><strong>吸引力和偏好</strong></p>
<p>传达者的个人魅力也很重要。个人偏好可以让我们乐于接受传达者的观点，或在事后引发积极的联想。比如当论点来自一个漂亮的人时，往往具有更大的影响力。</p>
<p>但同时，就像我们选择牙膏、桌游游戏一样，我们也倾向于相信那些和我们<strong>相似的人</strong>。Goethals和Nelson发现，<strong>当主题偏重主观偏好时，相似性影响力更大；主题偏重客观偏好时，可信度影响力更大</strong>。所以，在预测明天的天气上，我们并不会相信我们的朋友而是天气预报员。</p>
<h4 id="信息内容"><a href="#信息内容" class="headerlink" title="信息内容"></a>信息内容</h4><p>信息内容同样有许多维度可以衡量。</p>
<p><strong>理性or感性</strong></p>
<p><strong>听众教育程度较高或善于思辨或积极参与时，更容易接受理性信息说服；反之更容易接受感性信息说服。</strong>如果个体的初始态度来自情感，那么就更易受感性论点说服；反之，理性的论点就更有效。同时，新的态度形成需要比上次更多的信息。</p>
<ul>
<li>信息和<strong>好消息</strong>联系在一起时，说服力更强。它会让个体做决定时更冲动，更多依赖外周线索。比如，很多消费品广告都会尽量营造出快乐的氛围</li>
<li>能<strong>唤起恐怖效应</strong>的形象化消息，同样会起到充分的反馈。恐惧程度越高，回应越多。负面信息会使人们知觉相关积极行为的规范性。比如要求在烟草广告上明确展示让人不适的图片。同时，唤起恐惧心理后，需要<strong>同时告诉一个解决的方法</strong>，这样才会更有效。否则，人们可能会否定这个信息。</li>
</ul>
<p><strong>差异程度</strong></p>
<p>传达让人不舒服的信息会引起质疑。而论点在人们可接受范围内时，他们更具有开放性。差异大小对可信度影响来自两个方面：</p>
<ul>
<li><strong>传达者可信度</strong>，可信度很高时，信息接收者会接受一个较大差异的论点。比如专家对文献的解释</li>
<li><strong>信息接受者的参与程度</strong>，积极参与者能够接收的观点范围较小。</li>
</ul>
<p><strong>单方面or双方面</strong></p>
<p>即仅从论点角度还是相反两个角度。这取决于听众：</p>
<ul>
<li>单方面论证对已持赞同态度的人更有说服力；双方面论证对持反对态度的人更有效</li>
<li>对相反观点有所了解的人，会更易接收双方面论证。那些聪明的人听到单方面论证时，会认为信息传递者存在偏见。所以许多政客面向对政治有所了解的团体演讲时，会对对立观点加以回应。</li>
</ul>
<p><strong>首因or近因</strong></p>
<p><strong>首因效应</strong>很普遍，即最先出现的信息更具说服力，类似沉锚效应、皮格马列翁效应。近因是指，对发生较近的记忆更信服。</p>
<ul>
<li>信息接连出现、且听众听过后有反应时间时，首因效应更明显</li>
<li>信息出现时间是分离的，且要求听众听完第二个意见后立即判断时，近因效应更明显</li>
</ul>
<h4 id="沟通渠道"><a href="#沟通渠道" class="headerlink" title="沟通渠道"></a>沟通渠道</h4><p>我们做出行动时，会将行为背后隐藏的观念放大。相对应的，以经验为基础的态度更自信、稳定。</p>
<p><strong>主动or被动接受</strong></p>
<p>通常来说，被动接受消息对于说服几乎是无效的。但是不总是如此，比如在总统大大选时，花钱更多的候选人赢得的选票也更多。</p>
<p>这里有一个规则：<strong>随着观点熟悉程度和重要性的增加，被动说服的影响力会越来越小</strong>。</p>
<p><strong>媒介</strong></p>
<p>需要承认的是，对于我们最主要的影响来自<strong>和他人的解除</strong>而不是传媒。课堂外的人际关系对学生的身心成熟有重要的影响。但这也不代表媒体对个人没有影响。卡茨（Katz，1957）观察到，多数媒体影响都通过<strong>沟通的两步流程</strong>，即从媒体到有影响力的人、再到普通群众。即使那些没看过电视的孩子，也会因为身边那些看过孩子的人间接受到电视广告的影响。</p>
<p><strong>媒体越接近生活，信息就越具有说服力</strong>。即现场&gt;录像&gt;录音&gt;文字。但是，文字形式的信息通常具有最好的<strong>理解和回忆</strong>效果。所以，<strong>当信息难以理解时，其说服效果按媒体排序，刚好是和上面相反的</strong>。因为信息较难时，文字媒介可以让接收者把握理解节奏，同时避免外周因素（环境音、画面）影响。</p>
<h4 id="听众"><a href="#听众" class="headerlink" title="听众"></a>听众</h4><p>自尊水平低的人理解信息慢，难以说服；自尊水平高的人理解信息后坚持己见，也难以说服。水平适中的人最易受到影响。</p>
<p><strong>年龄</strong></p>
<p>在听众年龄上，有两种理论，<em>生命周期理论</em>和<em>生活时代理论</em>。研究者发现，从现象上看，实际情况更符合后者，即人们的态度较少随年龄发生变化。</p>
<p>十几、二十几岁的年轻人形成的态度会在长期内保持稳定。在此间的经历也可以给个体留下深刻和持久的印象，从而给人格定型。</p>
<p><strong>他们在想什么</strong></p>
<p>说服过程的关键不在信息主体，而在它激发个体的思维方式。</p>
<ul>
<li><strong>预先警示</strong>会提升说服的困难，尤其是在听众积极参与观点时。他们会准备好抵御，面对可能出现的质疑。</li>
<li><strong>分心会减少辩驳</strong>，注意力被别的东西转移并阻碍反驳时，言语的说服效果会增加。尤其当信息简单时。下次可以在和对象吵架时试试这招。</li>
<li><strong>不积极参与的听众使用外周线索</strong>。思辨能力强和积极参与者的<strong>认知需求</strong>较强，喜欢走中心途径。而相反情况下，会走外周途径。当信息看起来无关紧要时，外周线索更为明显。</li>
</ul>
<p>佩蒂、卡乔波等人通过多个实验研究发现了激发人们思考，引导人们走中心途径的方法：</p>
<ul>
<li>使用反问（老师很喜欢使用）</li>
<li>使用多个演说者</li>
<li>让人们感到自己<strong>有责任</strong>评价和传达信息</li>
<li>使用放松的姿态</li>
<li>重复信息以吸引人们的注意力</li>
</ul>
<p><strong>对于强有力的信息，激励思考可以增加说服力，并减小微弱信息的说服力</strong>。</p>
<h3 id="邪教如何洗脑"><a href="#邪教如何洗脑" class="headerlink" title="邪教如何洗脑"></a>邪教如何洗脑</h3><p>类似人民圣殿、统一教团、天堂之门等邪教利用了说服的一些特性蛊惑教众危害社会。</p>
<ul>
<li>态度决定行为。邪教领导者通过重复的行动准则和仪式让教众内化行为，成为有责任感的拥护者。在一开始利用登门槛效应逐步减少人们的抵抗</li>
<li>增强说服力：一个具有个人魅力的领导者；生动、感性的信息；年轻的或处于人生转折点的听众。</li>
</ul>
<h4 id="团体效应"><a href="#团体效应" class="headerlink" title="团体效应"></a>团体效应</h4><p>邪教组织通常会将成员和其原先的社会关系隔离开，达到“社会鼻塞”的程度。在只和组织内部的成员发生联系的情况下，逐步滋生偏执和妄想。同时，由于邪教切断了新成员和老朋友的联系，他们往往会感到孤立无援，从而花时间融入新团体。</p>
<p>狂热的自助组织也具有这样的特征，组织具有很强的凝聚力，有激进极端的思想，对成员的行为影响深刻。有意思的是，心理治疗的一些情境也和此类似：</p>
<ul>
<li>相互信任的社会支持</li>
<li>专业知识和希望</li>
<li>独特的信念和解释个体困难的新视角</li>
<li>一系列的仪式和学习体验</li>
</ul>
<h3 id="如何抗拒说服"><a href="#如何抗拒说服" class="headerlink" title="如何抗拒说服"></a>如何抗拒说服</h3><p>说服有好有坏，合适的技巧可以帮助我们避免令人生厌的说服。</p>
<h4 id="加强个人承诺"><a href="#加强个人承诺" class="headerlink" title="加强个人承诺"></a>加强个人承诺</h4><p><strong>温和</strong>的攻击人们的立场可以激励人们更相信自己的立场，比如在辩论赛中见到的那样。</p>
<ul>
<li>一方面，攻击强度不足以驳倒他人时，会激发人们以更极端的方式维护信仰的立场</li>
<li>另一方面，我们会感到愤怒，且在驳倒他人时会获得较高的自我肯定感</li>
</ul>
<p><strong>态度免疫</strong>就是利用这一点实现的。先让人们接受观点的小小挑战作为预防针，会增加他们抵制更强烈攻击的能力。适当的辩论是抵制说服的最佳途径。态度<strong>免疫计划</strong>已经被应用在现实生活中，实验发现适当的挑战可以降低孩子的吸烟率和增强孩子对广告的抵抗能力。另外，态度免疫也可以用来抵制邪教和洗脑的不良影响。</p>
<p>另一方面，这也预示着，<strong>效果不佳的说服还不如没有</strong>。那些曾经拒绝过戒烟劝说的人更可能对以后的所有劝说具有抵抗力，因为效果不佳的劝说引起了他们的防御心理。</p>
<h2 id="群体影响"><a href="#群体影响" class="headerlink" title="群体影响"></a>群体影响</h2><p>群体影响个体，个体也会影响群体。</p>
<p>首先我们要明确群体的概念，对此，肖和特纳提出了两种判定方式：</p>
<ul>
<li>群体之间存在互动并会相互影响</li>
<li>群体成员把群体内的人视作“我们”而不是“他们”</li>
</ul>
<p>这一张主要考察群体的三种影响（<em>社会助长</em>、<em>社会懈怠</em>、<em>去个性化</em>），之后再讨论社会影响的三个典型例子（<em>群体极化</em>、<em>群体思维</em>、<em>少数派影响</em>）。</p>
<h3 id="社会助长：他人在场影响"><a href="#社会助长：他人在场影响" class="headerlink" title="社会助长：他人在场影响"></a>社会助长：他人在场影响</h3><p>他人在场有些时候会提高人的作业水平（比如一些简单工作），有时候会降低人的水平（比如表演杂技）。对此扎伊翁科（Robert Zajonc）用一个简单的理论给出了解释：</p>
<p>他人在场引起唤起，<strong>唤起能够增强任何优势反应的倾向</strong>。</p>
<p>所谓“优势”反应即大概率的反应。对于简单任务正确反应概率较高，唤起的是正确反应；对于复杂任务，唤起增强的是错误反应，因此他人在场时表现更差。</p>
<p>由于运动员所表现的都是熟练掌握的技能，从而有观众在场时，往往能激励人们的表现出最佳水平。这也是主场有优势的一定原因。</p>
<h4 id="拥挤现象"><a href="#拥挤现象" class="headerlink" title="拥挤现象"></a>拥挤现象</h4><p>他人的影响效应会随人数增加而递增。在完成有挑战性的任务时，众多支持者在场可能会引起个体做出更差的表现。</p>
<p>“处在人群中”对个体的积极和消极反应都会增强。人们坐得很近时，友善的人更受欢迎，而不友善的人更令人讨厌。我们坐得更近时，更容易注意到别人并融入他们的氛围之中。<strong>拥挤也会增强唤起状态</strong>，待在拥挤房间的被试心率更快、血压也更高。同样的学生人数，在拥挤环境下（小房间）上课比在宽松环境下（大房间）上课更活跃。</p>
<h4 id="为何会有唤起"><a href="#为何会有唤起" class="headerlink" title="为何会有唤起"></a>为何会有唤起</h4><p>对于为何人们会产生唤起，有研究者发现了以下三个可能原因：</p>
<ul>
<li><strong>评价顾忌</strong>，即人们认为受在场者的评价，这会激发并提高他们的优势反应。这也可以解释下面两个行为。另外受评引发的自我意识也会干扰我们熟练掌握的自动化行为。<ul>
<li>当与比自己优秀一些的人共事时，人们的表现更好</li>
<li>高层领导的唤起状态会随着无关痛痒的人加入而降低</li>
</ul>
</li>
<li><strong>分心</strong>，当我们注意他人和注意任务间存在矛盾时，认知系统负载过大，从而引起唤起</li>
<li><strong>纯粹在场</strong>，非人类动物身上的唤起现象也很普遍。只需要他人在场就会引起唤起作用。在许多写字楼中的开放式办公区意在利用他人在场增加个体的工作效率。</li>
</ul>
<h3 id="社会懈怠：减少努力"><a href="#社会懈怠：减少努力" class="headerlink" title="社会懈怠：减少努力"></a>社会懈怠：减少努力</h3><p>社会助长通常发生在人们为<strong>个人目标</strong>努力时。当大家在为共同目标努力，且个人努力难以衡量时，人们的努力会减少，即社会懈怠。</p>
<ul>
<li>6个人尽力叫喊的喧闹声不如1个人的3倍响</li>
<li>团体拔河时，个体努力程度从只有个人单独时的一半</li>
</ul>
<p>在群体条件下，人们会受到搭群体便车的诱惑，随着群体规模增大，个体付出的努力也在减少。这种现象在<strong>增强个体评价顾忌</strong>时有所减少。</p>
<ul>
<li>激励小组成员的一种方式是个体成绩可识别化</li>
<li>集体公社时农民的工作效率远不如承包制下农民们的效率</li>
</ul>
<p>在有些情况下，群体目标还是能起到激励的作用：</p>
<ul>
<li>群体目标极具吸引力，且需要每个人尽力去做</li>
<li>任务具有挑战性、引人入胜的特点</li>
<li>群体内认同度极高，如小组内都会好朋友而非陌生人</li>
<li>维持群体较小的规模</li>
</ul>
<p>集体主义下的社会懈怠要弱于个体主义社会，女性的社会懈怠也不如男性强烈</p>
<h3 id="去个性化：失去自我"><a href="#去个性化：失去自我" class="headerlink" title="去个性化：失去自我"></a>去个性化：失去自我</h3><p>群体情境有时会使人失去自我觉知能力，导致丧失自我和自我约束（正如《乌合之众》中指出的）。</p>
<p>群体能引发人们的唤起状态，当群体能扩散和分摊责任时，常规的约束就会变小，人们的行为就会从普通的失态到社会暴力。另外，群体可以产生出一种兴奋感，这种比个体更强大的力量对个体很有吸引力，在某些情境下，人们可以抛弃道德约束、忘却个人身份，顺从社会规则，即去个性化。</p>
<p>群体在引起唤起时，还在某种程度使<strong>个体身份模糊化</strong>，当人群规模较小且曝于日光下时，往往不至那么狂热。群体规模越大，成员越有可能失去较多自我意识，而受群体意识裹挟。这种匿名性还会引起更激进的行动。</p>
<ul>
<li>网络的匿名性使得激进型言论更多</li>
<li>大部分孩子因群体掩盖、匿名性（未被人发现）去个性化时，会更出格</li>
<li>匿名的袭击者表现出更严重的袭击行为</li>
<li>遮掩个人特征的身体彩绘会让部落斗士更暴力</li>
</ul>
<p>对此要指出，群体的去个性化不光只有负面作用，匿名性使人们自我意识减弱，群体意识增强，<strong>更容易对情境线索和暗示做出回应</strong>，不论线索是消极还是积极的。</p>
<p>群体表现出攻击性之前常常会发生引发人们唤起和分散注意力的事件，如合唱、跳舞。当人们看到别人和自己做出同样行为时，会对自己做出冲动性的举动产生自我强化的愉悦感。有些时候，我们甚至会主动寻找去个性化的群体体验：跳广场舞、群体交流、快闪等。我们会从中体验强烈的积极情感和与他人亲密无间的关系。</p>
<h4 id="自我意识弱化"><a href="#自我意识弱化" class="headerlink" title="自我意识弱化"></a>自我意识弱化</h4><p>自我意识淡薄、去个性化的人更不自控，更可能不顾及价值观就行动，对情境的反应也更强烈。相反，自我意识强烈的人更不易受环境影响。</p>
<p>自我觉察是去个性化的对立面，在镜子前或摄像机前的人，会表现得更加自控，从而在情境中表现出更高的言行一致性。</p>
<p>喝酒等情境会降低个体的自我觉察；镜子、摄像机、明亮的光线、很大的姓名标签、沉思、个性化着装、家等情境都可以降低个体的去个性化。父母在孩子参加聚会时，也都会说：“玩得开心，还有要记住你的身份”。</p>
<p>享受欢乐时，保持自我觉察，保持自我个性不被去个性化。</p>
<h3 id="群体极化：观点强化"><a href="#群体极化：观点强化" class="headerlink" title="群体极化：观点强化"></a>群体极化：观点强化</h3><p><strong>群体讨论通常会强化成员最初的观点</strong>。群体观点有时更冒险，有时则更谨慎。</p>
<p>日常生活有许多群体极化的例子：</p>
<ul>
<li>男孩群体和女孩群体的性别隔离会加强他们最初的中度性别差异</li>
<li>大学生群体间的差异会随着时间推移扩大化</li>
<li>社区内，想法相似的人会渐渐聚集起来，并使它们共有的倾向加强。犯罪团伙就是这样形成的。</li>
<li>恐怖组织就是从拥有相同不满情绪的人聚集起来开始形成的</li>
<li>媒介的增多和社会分隔使人们更容易与相同目的的人集合在一起，现今的互联网会加速这个过程</li>
</ul>
<p>对于极化有两种解释：一种是<strong>信息影响</strong>，群体中个人的观点也会加入讨论，互相补充，互相激励，在相似的观点不断重复后，人们就会逐渐认同这些观点；另一种是<strong>规范影响</strong>，<strong>社会比较</strong>理论提出，人类希望能对自己的能力和观点进行评价，需要通过和他人比较来达成，我们经常被“参照群体”的人们说服。在发现身边的人意见都与自己类似时，我们会表现得比以前的意向更胜一筹。（上面的解释很像从众中的两种解释原因）。在规范影响的形成过程中，会有一个<strong>人众无知</strong>的阶段，即人们不清楚他人的观点都害怕迈出第一步。社会比较会影响价值判断（他是个什么样的人），对事实判断影响则较弱（他做了什么事）。</p>
<h3 id="群体思维：好决策-amp-坏决策"><a href="#群体思维：好决策-amp-坏决策" class="headerlink" title="群体思维：好决策&amp;坏决策"></a>群体思维：好决策&amp;坏决策</h3><p>人们为了维护群体和睦而压制异议，即<strong>群体思维</strong>。友善的、有凝聚力的、有一个支配性领导的群体较容易拥有群体思维。群体思维会<em>高估群体的力量和权利</em>：</p>
<ul>
<li>无懈可击的错觉，如珍珠港事件</li>
<li>对群体道义无可置疑</li>
<li>合理化群体决策，即使决策时发动与他国的战争</li>
<li>对对手的刻板印象</li>
</ul>
<p>群体也会<em>追求一致性</em>：</p>
<ul>
<li>从众压力，群体成员会抵制对群体设想、计划提出猜疑的人</li>
<li>自我审查，即压制自己的疑虑</li>
<li>一致同意错觉</li>
<li>心理防御，群体成员为了保护群体，让质疑群体的信息不对群体造成干扰</li>
</ul>
<p>群体思维很容易导致错误的决策。也不是所有群体都会滋生群体思维，安全而团结的群体会为成员提供自由氛围来提出异议。另外，也有措施可以避免群体思维：</p>
<ul>
<li>公平，不偏向任何立场</li>
<li>鼓励批判性的分析</li>
<li>将群体拆分小组，再重组讨论不同意见</li>
<li>欢迎局外人的批评和意见</li>
</ul>
<p>头脑风暴也利用上面的方法激发创造性的想法。在运用中，人们发现庞大团体的头脑风暴是低效的。先进行群体头脑风暴再进行个人头脑风暴、让小组成员通过书写交流可以促进群体头脑风暴。</p>
<h3 id="少数派影响"><a href="#少数派影响" class="headerlink" title="少数派影响"></a>少数派影响</h3><p>个体并不是完全受群体影响，也能反过来影响群体。正如从众、说服一样。少数派受以下几个重要因素影响：</p>
<ul>
<li><strong>一致性</strong>，坚定自我立场的少数派更有影响力。尽管这个过程会比较痛苦</li>
<li><strong>自信</strong>，明显的自我支持会促使多数派重新考虑他们的立场</li>
<li><strong>从多数派叛离</strong>，从多数派投奔来的少数派更具说服力，并可能产生滚雪球效应</li>
</ul>
<p>领导分两种类型：<em>任务型</em>和<em>社会型</em>。任务型领导具有支配性，可以睿智地发出命令很好地完成工作；社会型领导通常具有民主风格，可以接纳团队成员的意见。如果有机会在决策中发言，人们会对决策结果表现更积极，因此看重群体感受并为成就感到骄傲的人会在民主领导下蓬勃发展。</p>
<p>具有领导气质的人大多是外向的、充满活力的、正直的、易于相处的、情绪稳定和自信的个体。他们通常可以赢得信任，并鼓舞其他人追随自己。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/07/30/productive-vs-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/07/30/productive-vs-code/" class="post-title-link" itemprop="url">Productive VS Code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-07-30 22:30:54 / 修改时间：23:32:57" itemprop="dateCreated datePublished" datetime="2019-07-30T22:30:54+08:00">2019-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/07/30/productive-vs-code/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/30/productive-vs-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks">Visual Studio Code Tips and Tricks</a></p>
</blockquote>
<p>这里介绍一些能提高VS Code产率的方法。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/interactive_playground.png"></p>
<p>欢迎页右下角提供Interactive playground（在命令面板里的<strong>Help &gt; Interactive Playground</strong>）。里面提供了VS Code一些关键特性的快速介绍。比如：</p>
<ul>
<li>多光标编辑</li>
<li>行操作<ul>
<li>整行向上、下移动<code>Option + up/down</code></li>
<li>整行向上、下复制<code>Shift + Option + up/down</code></li>
<li>删除整行<code>Shift + Cmd + K</code></li>
<li>注释整行<code>Cmd + /</code></li>
</ul>
</li>
<li>重构<ul>
<li>重命名：光标处<code>F2</code>，修改后自动同步相关位置</li>
<li>选中语句 -&gt; <code>Cmd + .</code> -&gt; 选择重构方式</li>
</ul>
</li>
<li>格式化文档：<code>Cmd K + Cmd F</code>或者<code>Shift + Option + F</code></li>
<li>折叠<ul>
<li>折叠<code>Option + Cmd + [</code>，展开<code>Option + Cmd + ]</code></li>
<li>折叠所有<code>Cmd K + Cmd 0</code>，展开所有<code>Cmd K + Cmd J</code></li>
</ul>
</li>
<li>代码片段：见代码片段一节</li>
<li>Emmet：见Emmet一节</li>
</ul>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="指令面板"><a href="#指令面板" class="headerlink" title="指令面板"></a>指令面板</h3><p>快捷键<code>Shift + Cmd + P</code>。里面的常见命令都有快捷键提示。</p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/KeyboardReferenceSheet.png"></p>
<h3 id="快速打开文件"><a href="#快速打开文件" class="headerlink" title="快速打开文件"></a>快速打开文件</h3><p>快捷键<code>Cmd + P</code>。点击打开文件，点击右方向键打开不会关闭当前面板。</p>
<h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p><code>Shift + Cmd + M</code></p>
<h3 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h3><p><code>Cmd K + M</code></p>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>打开指令面板，安装<code>code</code>命令。</p>
<p><img src="https://code.visualstudio.com/assets/docs/setup/mac/shell-Cmd.png"></p>
<p>常见命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># open code with current directory</span></span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the current directory in the most recently used code window</span></span><br><span class="line">code -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># change the language</span></span><br><span class="line">code --locale=es</span><br><span class="line"></span><br><span class="line"><span class="comment"># open diff editor</span></span><br><span class="line">code --diff &lt;file1&gt; &lt;file2&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定义编辑器"><a href="#自定义编辑器" class="headerlink" title="自定义编辑器"></a>自定义编辑器</h2><p><code>Cmd + ,</code>，打开编辑器编辑配置。也可以</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><code>Cmd + Shift + X</code>，利用插件增强你的开发体验和生产率。</p>
<h2 id="文件及目录"><a href="#文件及目录" class="headerlink" title="文件及目录"></a>文件及目录</h2><ul>
<li>内置terminal，<code>Ctrl + </code> &#96;或View -&gt; Terminal或命令面板里输入View: Toggle integrated terminal。<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/integrated-terminal">深度阅读</a></li>
<li>自动保存，<code>setting.json</code>中设置<code>&quot;files.autoSave&quot;: &quot;afterDelay&quot;</code></li>
<li>toggle侧边栏，<code>Cmd + B</code></li>
<li>专注模式，<code>Cmd K + Z</code></li>
<li>分栏，<code>Cmd + \</code>，使用<code>Cmd + 1</code>, <code>Cmd + 2</code>等切换</li>
<li>关闭当前tab，<code>Cmd + W</code></li>
<li>浏览历史<ul>
<li>全部历史，<code>Ctrl + Tab</code>按住选择</li>
<li>回退，<code>Ctrl + -</code></li>
<li>前进，<code>Ctrl + Shift + -</code></li>
</ul>
</li>
</ul>
<h2 id="高效编辑"><a href="#高效编辑" class="headerlink" title="高效编辑"></a>高效编辑</h2><h3 id="多光标"><a href="#多光标" class="headerlink" title="多光标"></a>多光标</h3><ul>
<li><code>Cmd + Click</code>可以多光标操作</li>
<li><code>Cmd + Shift + L</code>可以在所有选中单词的末尾多光标操作</li>
<li><code>Cmd + D</code>选中当前单词<br><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/add_cursor_current_selection.gif"></li>
</ul>
<h3 id="盒式选中"><a href="#盒式选中" class="headerlink" title="盒式选中"></a>盒式选中</h3><p><code>Shift + Alt + 拖拽</code></p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/column-select.gif"></p>
<h3 id="选中当前行"><a href="#选中当前行" class="headerlink" title="选中当前行"></a>选中当前行</h3><p><code>Cmd + L</code></p>
<h3 id="快速滚动"><a href="#快速滚动" class="headerlink" title="快速滚动"></a>快速滚动</h3><p><code>Alt + 滚动</code>可以达到x5速度的滚动</p>
<h3 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h3><p>行向上&#x2F;下复制&#x2F;剪切，见[基础]一节里的介绍</p>
<h3 id="层级选中"><a href="#层级选中" class="headerlink" title="层级选中"></a>层级选中</h3><p><code>Ctrl + Shift + Cmd + left/right</code>可以扩大&#x2F;缩小当前选择范围</p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/shrink_expand_selection.gif"></p>
<h3 id="Goto-Symbol"><a href="#Goto-Symbol" class="headerlink" title="Goto Symbol"></a>Goto Symbol</h3><ul>
<li><code>Shift + Cmd + O</code>当前文件下选择符号名，输入<code>@:</code>可以进行分类</li>
<li><code>Shift + Cmd + T</code>当前工作区下选择符号名</li>
</ul>
<h3 id="Goto特定行"><a href="#Goto特定行" class="headerlink" title="Goto特定行"></a>Goto特定行</h3><p><code>Ctrl + G</code></p>
<h3 id="trim行尾空格"><a href="#trim行尾空格" class="headerlink" title="trim行尾空格"></a>trim行尾空格</h3><p><code>Cmd K + Cmd X</code></p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/trim_whitespace.gif"></p>
<h3 id="Markdown预览"><a href="#Markdown预览" class="headerlink" title="Markdown预览"></a>Markdown预览</h3><ul>
<li><code>Cmd + Shift + V</code></li>
<li>实时预览<code>Cmd K + V</code></li>
</ul>
<h2 id="代码联想"><a href="#代码联想" class="headerlink" title="代码联想"></a>代码联想</h2><ul>
<li>查看定义，<code>F12</code>或<code>Option + Click</code><ul>
<li>查看定义（不切换上下文）<code>Option + F12</code></li>
</ul>
</li>
<li>查看引用（不切换上下文），<code>Shift + F12</code>，查看整个项目引用<code>Shift + Option + F12</code></li>
<li>重命名，<code>F2</code></li>
<li>搜索替换，<code>Cmd + F</code>，<code>Cmd + Shift + F</code></li>
</ul>
<h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h3><p>VS Code支持<a target="_blank" rel="noopener" href="https://docs.emmet.io/">Emmet</a>风格书写HTML代码。完整的Emmet语法参考<a target="_blank" rel="noopener" href="https://docs.emmet.io/cheat-sheet/">这里</a>。</p>
<h2 id="Code-Snippet"><a href="#Code-Snippet" class="headerlink" title="Code Snippet"></a>Code Snippet</h2><p><img src="https://code.visualstudio.com/assets/docs/editor/userdefinedsnippets/ajax-snippet.gif"></p>
<p>Code Snippet即能让你更容易复用的代码模板，如for循环，if语句等。在代码联想时，可以自动帮你补全，开启<code>&quot;editor.tabCompletion&quot;: &quot;on&quot;</code>配置时，也可以使用Tab键补全。</p>
<p>在VS Code Marketplace中有许多snippets拓展。搜索”xxx snippet”多半你能找到已有的snippet拓展。</p>
<p>书写自己的snippet可以参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_create-your-own-snippets">官方文档</a>。</p>
<h2 id="Git集成"><a href="#Git集成" class="headerlink" title="Git集成"></a>Git集成</h2><p><code>Shift + Ctrl + G</code>打开。</p>
<ul>
<li>支持Side by side和Inline view两种diff模式。</li>
<li>左下角快捷切换分支<br><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/switch_branches.gif"></li>
<li>手动添加文件、解决冲突</li>
</ul>
<p>更多参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_git-integration">Git integration</a>一节。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在命令面板中输入”Debug”查看相关命令。更多查看<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_debugging">Debugging</a>一节</p>
<h2 id="脚本任务"><a href="#脚本任务" class="headerlink" title="脚本任务"></a>脚本任务</h2><p>参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_task-runner">Task Runner</a>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/29/">29</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">961k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:42</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

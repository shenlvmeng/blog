<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/24/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/24/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/24/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">438</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/03/18/how-to-construct-css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2017/03/18/how-to-construct-css/" class="post-title-link" itemprop="url">BEM和CSS方法论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-03-18 16:49:06 / 修改时间：18:23:58" itemprop="dateCreated datePublished" datetime="2017-03-18T16:49:06+08:00">2017-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/03/18/how-to-construct-css/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/18/how-to-construct-css/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>CSS是一种“奇怪”的编程语言，用来描述网页的样式。使用起来很简单，却由于自身的缺陷（只有全局作用域、没有模块化）使得它很难像真正的编程语言那样，有软件工程的办法适用。</p>
<h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p><a target="_blank" rel="noopener" href="https://en.bem.info/">BEM</a>是一个方法论，是一套使用CSS的惯例和约定，用于写出更具有维护性和重用性的CSS代码。BEM由<a target="_blank" rel="noopener" href="https://yandex.com/company/">Yandex</a>公司提出，目前已被广泛采用。它和其他的CSS的规范如<a target="_blank" rel="noopener" href="http://oocss.org/">OOCSS</a>，<a target="_blank" rel="noopener" href="http://smacss.com/">SMACSS</a>并不冲突。它们都用来提高CSS文件的可维护性。</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p><strong>BEM</strong>的三个字母分别代表块（<strong>block</strong>）、元素（<strong>element</strong>）、修饰符（<strong>modifier</strong>）。根据<a target="_blank" rel="noopener" href="http://getbem.com/introduction/">官网</a>的介绍：</p>
<ul>
<li><code>Block</code>代表一个独立的抽象的组件</li>
<li><code>Element</code>代表依附于<code>Block</code>的后代，用来形成一个完整的<code>block</code></li>
<li><code>Modifier</code>代表<code>Block</code>或是<code>Element</code>的不同状态或版本，用来改变默认样式</li>
</ul>
<p>另外：</p>
<ul>
<li><strong>不要使用文档的层级结构</strong></li>
<li><strong>在标签嵌套时，只使用一层嵌套</strong>，通过class名标注标签</li>
</ul>
<p>其中<code>Element</code>命名时在<code>Block</code>后添加两个短横线<code>--</code>，<code>Modifier</code>在<code>Block</code>后添加两个下划线<code>__</code>。<strong>所有的CSS均绑定到标签的class上</strong>，确保样式的重用性。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block__element</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block--modifier</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>之所以采用两个短划线和下划线，是为了让用户自定义的块命名中可以含有单个短划线和下划线。</p>
<p>下面是官网的样例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form form--theme-xmas form--simple&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form__input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;form__submit form__submit--disabled&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form--theme-xmas</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form--simple</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__input</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__submit</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__submit--disabled</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>BEM正如上面介绍的那样，只是一套规范。在使用的时候会感觉类名有些冗长和奇怪。不过它带来的好处是很有价值的。</p>
<p>另外，<strong>没有必要在每个地方都使用BEM规范</strong>。对于独立的一条CSS样式，写成BEM格式的写法并没有必要。对于考虑使用BEM的人来讲，可能最重要的是从哪里到哪里使用BEM。</p>
<h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>写CSS代码很简单，但是写出可维护的CSS代码比其他语言就要更难了。因此，大牛们提出了OOCSS、SMACSS这样的<strong>设计模式</strong>来让事情更容易。OOCSS（Object Oriented CSS）即面向对象的CSS，它的关键在于创建在页面中创建模块化可重用的对象（HTML和CSS的结合体）。</p>
<p>根据OOCSS之父Nicole Sullivan的说法，OOCSS重点在于：</p>
<ol>
<li>独立文档结构与样式</li>
<li>独立文档容器和内容</li>
</ol>
<p>使用容易理解的话来说，就是从HTML结构上解脱出来，增加CSS class的重复利用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;nav--main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子里，业务代码经常会将CSS选择器写成<code>nav ul li a</code>这样的写法。这么做过渡依赖原有的HTML文档结构。原有的文档结构改变时，CSS就必须跟着重构。因此，建议直接给<code>a</code>标签绑定class，或写成<code>nav--main a</code>的写法。</p>
<p>第二，减少使用id<strong>作为CSS的选择器</strong>。尽量使用class，类似<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>中的概念，抽出重复的部分，定义在一个class中。像下面这样，定义基本的类<code>button</code>，并通过<code>button-default</code>和<code>button-primary</code>来拓展基本类。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;button button-default&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;button button-primary&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结一下，OOCSS的优势在于它可以减少CSS的代码减少加载时间（当然的），<strong>语义化的类名</strong>增强逻辑性和SEO，CSS样式可以轻松拓展，</p>
<p>缺点在于它适合大型网站的开发，在小型项目中似乎用不到这种<em>40米的长刀</em>，同时没有巧妙地使用，创建的组件会适得其反增加，增加维护难度。</p>
<h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p><a target="_blank" rel="noopener" href="https://smacss.com/">SMACSS</a>(读作”smacks”)全称为Scalable and Modular Architecture for CSS。它也是CSS的框架规范之一，目标是让”<strong>keep CSS more organized and more structured, leading to code that is easier to build and easier to maintain（作者Jonathan Snook语）</strong>“</p>
<p>SMACSS使用了一套5个类别来划分CSS，这种组织和结构规范了CSS写法，提高了CSS使用效率。</p>
<ul>
<li><strong>Base rules</strong> 类似与<code>reset.css</code>和<code>normalize.css</code>的效果，为文档的标签设置默认样式，<strong>应该只包含单独的标签选择器</strong></li>
<li><strong>Layout rules</strong> 将文档分成诸如header，article，footer这样的各个部分，为布局中的每个部分设置样式</li>
<li><strong>Module rules</strong> 页面中可重用部分的样式，在layout中出现多次，使用时避免出现标签选择器</li>
<li><strong>State rules</strong> 用于描述element的不同状态，和基本规则组合使用。</li>
<li><strong>Theme rules</strong> 类似与“皮肤”的概念，更改整个网站的主题。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="https://github.com/css-modules/css-modules">CSS Modules</a>和上面的思路要来的不大一样。它着眼于解决作用域和模块依赖的问题，采取的做法是重写class名。在React，Vue中每个组件中的CSS样式就做了这样的处理，保证的模块间的CSS文件不相冲突。</p>
<p>在通过JavaScript绑定到特定class的标签上时，也造成了CSS维护的不变。必要的时候可以为HTML标签赋予专为JavaScript使用的类名。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav--main__item js-nav--main__item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>whatever<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS是一门看起来很简单的语言，但是它的简单性也提升了工程中的使用难度。为了增强它的可用性。许多名为”xxxCSS”的方法论和机制等被发明，类似Sass，SCSS，Compass，Less，stylus，BEM，SMACSS，OOCSS，ACSS，CCSS等。在使用CSS时，可以尝试使用上面的规范，遵守一些<a target="_blank" rel="noopener" href="http://cssguidelin.es/">法则</a>，以写出更pure的代码。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="http://getbem.com/">BEM</a></li>
<li><a target="_blank" rel="noopener" href="https://smacss.com/book">SMACSS Book</a></li>
<li><a target="_blank" rel="noopener" href="http://www.w3cplus.com/css/oocss-concept">OOCSS——概念篇</a></li>
<li><a target="_blank" rel="noopener" href="http://www.w3cplus.com/css/css-sass-scss-compass-less-bem-smacss-oocss-acss-ccss-wtfss.html">CSS, Sass, SCSS, Compass, Less,BEM, SMACSS, OOCSS, ACSS, CCSS, WTFSS?</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000388784">编写可维护的CSS</a>(翻译自<a target="_blank" rel="noopener" href="http://cssguidelin.es/">CSS Guildelines</a>)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/css-modules/css-modules">CSS Modules</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/03/13/js-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2017/03/13/js-object/" class="post-title-link" itemprop="url">JavaScript中的对象和继承</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-13 16:53:39" itemprop="dateCreated datePublished" datetime="2017-03-13T16:53:39+08:00">2017-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-05 15:54:18" itemprop="dateModified" datetime="2023-02-05T15:54:18+08:00">2023-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/03/13/js-object/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/13/js-object/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>对象：无序属性的集合，其属性可以包含基本值、对象或者函数</p>
<footer><strong>ECMA-262</strong></footer></blockquote>

<p>JavaScript中的<strong>对象</strong>和其他OO（Object-Oriented，面向对象）语言不大相同。它没有类的概念。所以根据ECMAScript的定义，对象无非就是一组键值对，类似于散列（Hash）表的概念，其中的值可以是基本类型也可以是对象或函数。</p>
<p>一个常见的对象像下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Stu</span> = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Stu</span>.<span class="property">name</span> = <span class="string">&#x27;shenlvmeng&#x27;</span>;</span><br><span class="line"><span class="title class_">Stu</span>.<span class="property">age</span>  = <span class="number">23</span>;</span><br><span class="line"><span class="title class_">Stu</span>.<span class="property">school</span> = <span class="string">&#x27;BUPT&#x27;</span>;</span><br><span class="line"><span class="title class_">Stu</span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接使用字面量</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Stu</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;shenlvmeng&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;BUPT&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><p>对象<strong>属性（property）</strong>是实现JavaScript引擎用的，由两对方括号包裹，表示是内部值，如[[Enumerable]]。ECMAScript中目前分两种属性：<em>数据属性</em>和<em>访问器属性</em>。</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul>
<li><code>[[Configurable]]</code>: 表示能否通过<code>delete</code>删除属性，能否修改属性。默认为true。</li>
<li><code>[[Enumerable]]</code>: 能否通过<code>for-in</code>语句循环返回属性。默认为true。</li>
<li><code>[[Writable]]</code>: 如同字面意思，能否修改属性的值。</li>
<li><code>[[Value]]</code>: 属性的数据值。</li>
</ul>
<p>数据属性可以直接通过字面量来定义。可以通过ECMAScript 5中<code>Object.defineProperty()</code>方法修改对象默认属性。方法接受三个参数：属性所在对象，属性名，和一个描述符对象。其中描述符对象的属性必须是上述4个属性的子集。值得注意的是，<em>修改<code>configurable</code>为false后，将无法将其变为true。</em>此时，只能修改<code>writable</code>和<code>value</code>。</p>
<p>在使用<code>Object.defineProperty()</code>创建新属性时，若不指定，前三项的属性默认均为<strong>false</strong>。</p>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性不包含数据值（即<code>value</code>），<strong>取而代之</strong>的是getter和setter两个函数。不过它们也不是必须的。</p>
<ul>
<li><code>[[Configurable]]</code>: 表示能否通过<code>delete</code>删除属性，能否修改属性。默认为true。</li>
<li><code>[[Enumerable]]</code>: 能否通过<code>for-in</code>语句循环返回属性。默认为true。</li>
<li><code>[[Get]]</code>: 读取属性时调用的函数，默认为undefined</li>
<li><code>[[Set]]</code>: 写入属性时调用的函数，默认为undefined</li>
</ul>
<p>访问器属性不能直接定义。必须使用<code>Object.defineProperty()</code>方法定义。未指定getter或setter时，<strong>意味着属性不可读或不可写</strong>。强制读写时，在严格模式下会抛出错误，非严格模式下会返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;&#x27;</span>,  <span class="comment">//`_`表示只能通过方法访问</span></span><br><span class="line">    <span class="attr">nickname</span>: <span class="string">&#x27;酱&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nickname</span> = newValue + <span class="string">&#x27;酱&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>访问器属性实际上使得<strong>数据劫持</strong>得以实现，即在存取属性值时执行预定义的操作。Vue的数据绑定就是这么来实现的（具体的实现方式见另外的博文）。不过支持<code>Object.defineProperty()</code>方法的浏览器需要IE9+，Firefox4+，Safari5+，Opera12+，Chrome。在这个方法前，通常使用两个非规范的方法<code>__defineGetter__()</code>和<code>__defineSetter__()</code>，它们是对象的prototype中的的方法。</p>
<div class="tip">IE8其实也实现了`Object.defineProperty()`方法，不过存在诸多限制，只能对DOM对象使用。
</div>

<p>ECMAScript 5还定义了一个<code>Object.defineProperties()</code>方法，用于为对象定义多个属性。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person, &#123;</span><br><span class="line">    <span class="attr">_name</span>: &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;shenlvmeng&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">nickname</span>: &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;shenlvmeng酱&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>; &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newName</span>) &#123; <span class="variable language_">this</span>.<span class="property">_name</span> = newName; <span class="variable language_">this</span>.<span class="property">nickname</span> = newName + <span class="string">&#x27;酱&#x27;</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p><code>Object.getOwnPropertyDescriptor()</code>方法可以读取指定对象属性的描述符。如果属性是数据属性，则返回对象包含configurable, enumerable, writable, value；如果属性是访问器属性，则返回对象包括configurable, enumerable, get, set。支持这个方法的浏览器包括IE9+，Firefox4+，Safari5+，Opera12+，Chrome。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>最简单的创建方法是通过Object构造函数和字面量的形式，如第一段代码里展示的那样。不过很显然，这么做有点蠢。在创建大量对象的时候，会产生成吨的重复代码。于是就产生了下面这些工程手段。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>既然会产生重复代码，那么将这些重复代码封装成函数不就行了么。工厂模式就这么出现了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span> (name, age, school) &#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//用字面量的形式亦可</span></span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">school</span> = school;</span><br><span class="line">    o.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; say hi.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line">p1.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>这么做解决了创建相似对象的问题，不过并没解决对象识别的问题。而且可以复用的函数创建了很多次。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象，从而解决了对象识别的问题。上面的例子用构造函数模式重写如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age, school) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">school</span> = school;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; say hi.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line">p1.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>通过构造函数创建实例时，需要使用<code>new</code>操作符。创建的步骤如下：</p>
<ol>
<li>创建一个空对象</li>
<li>将构造函数的作用域(this)赋给空对象</li>
<li>执行函数代码</li>
<li>返回这个对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="property">constructor</span> == <span class="title class_">Person</span> <span class="comment">//true</span></span><br><span class="line">p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>     <span class="comment">//true</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;weii&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line">p1.<span class="property">constructor</span> == p2.<span class="property">constructor</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>返回对象会自带constructor属性，指向构造函数本身。可以用来区分对象类型。不过使用instanceof操作符要更可靠些。因为构造函数本身也是函数，只是用来构造对象而已。为了和其他函数区分开，<strong>通常命名首字母使用大写字母</strong>。这么做是为了避免一个问题：当不使用<code>new</code>操作符调用构造函数时，函数作用域并不会指向新创建的函数，因此this实际上是进入函数时的全局作用域，从而会污染全局作用域。</p>
<p>可以看到一个问题，使用构造函数模式并未解决函数复用的目标，同样的函数创建了许多次，通过<code>p1.sayHi == p2.sayHi //false</code>即可发现。为了复用函数，可以把函数放在构造函数外。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age, school) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">school</span> = school;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHi</span> = sayHi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; say hi.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做却又带来了副作用，全局作用域中定义的函数，实际上只能被函数调用。且不同对象的方法作为全局函数混杂在一起，封装性很差劲。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型（prototype）的设计解决了这个大问题。每个函数都有一个<code>prototype</code>属性。<strong>这个属性是一个指针，指向一个对象，包含由该函数构造对象共享的属性和方法</strong>。从而，不必在构造函数中定义所有实例共有的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> () &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;shenlvmeng&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">school</span> = <span class="string">&#x27;BUPT&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; say hi.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p><strong>无论何时</strong>，只要创建了一个新函数，就会相应的为该函数创建一个<code>prototype</code>属性，指向该函数的原型对象。默认情况下，所有原型对象都会有一个<code>constructor</code>属性指向<code>prototype</code>属性所在函数。</p>
<p>创建自定义的构造函数时，原型对象默认只会有<code>constructor</code>属性，其他的方法都继承自<code>Object</code>。在调用构造函数创建对象实例后，实例的内部都有一个指针<code>[[prototype]]</code>指向构造函数的原型对象。这个指针是内部的，但在FF，Safari，Chrome中，有<code>__proto__</code>属性可以访问。</p>
<p>是不是听起来有点晕，下面的图（来自红宝书）形象地说明了上面这些关系。</p>
<p><img src="/blog/images/prototype-1.jpg"></p>
<p>虽然无法访问到<code>[[prototype]]</code>属性，但是可以通过prototype的<code>isPrototypeOf()</code>方法确认对象和原型的对应关系，或ES5中的<code>Object.prototype()</code>得到<code>[[prototype]]</code>的值。</p>
<p>代码在尝试读取对象属性的时候，会先从实例本身属性开始，若找到同名属性，则返回值；如果没有找到，则继续搜索指针指向的原型对象。例如，因为原型对象中包含<code>constructor</code>属性，所以实际上对象实例也都可以访问到constructor这个属性。在为对象实例添加属性时，这个属性会<strong>屏蔽</strong>（不是<strong>覆盖</strong>）原型对象中的同名属性。通过对象的<code>hasOwnProperty()</code>方法，可以检测属性来自实例还是原型对象。</p>
<h4 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h4><p><code>in</code>操作有两种使用方法，单独使用和配合<code>for-in</code>循环使用。前者在对象可以访问给定属性时返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> p1); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> p1.<span class="property">name</span>;</span><br><span class="line"><span class="title function_">alert</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> p1); <span class="comment">//true name属性来自原型</span></span><br></pre></td></tr></table></figure>

<p>for-in循环可以访问所有对象可以访问的、可枚举（enumerable）的属性。既包含实例自身属性，也包含原型中的属性。下面是个简单的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> body) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop + <span class="string">&#x27;: &#x27;</span> + body[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用最新的<code>Object.keys()</code>可以获取所有键名，使用<code>Object.getOwnPropertyNames()</code>方法可以返回所有实例属性，而不论是否可枚举。</p>
<h4 id="重写prototype"><a href="#重写prototype" class="headerlink" title="重写prototype"></a>重写prototype</h4><p>上面原型模式里一个一个属性为<code>prototype</code>赋值的方法略显重复，可以直接通过对象字面量的形式重写整个原型对象。但是需要注意的是，重写后的原型对象中的<code>constructor</code>属性继承自Object。此时只能通过<code>instanceof</code>操作符确定对象类型了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> () &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;shenlvmeng&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;BUPT&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; says hi.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为在原型中查找值是一次搜索的过程，我们对原型对象所做的修改都会立即在对象中体现出来。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>原型对象中的所有属性和方法都在实例中共享，这在某些场景下可能并不是我们想要的。比如，不同的<code>Person</code>间应该总有些自己的属性。这些应该在构造函数中体现出来。</p>
<h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>如上面所说，将实例的属性放在构造函数中，将共有属性和方法放在原型对象中，可以最大程度减少无谓的内存占用。因此，这也是目前使用最多的创建自定义类型的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age, school) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">school</span> = school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;weii&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(p1.<span class="property">sayHi</span> == p2.<span class="property">sayHi</span>);</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>寄生构造函数和稳妥构造函数在有些时候也用来构造对象。前者仅仅将创建对象的代码封装起来，通过<code>new</code>操作符调用，内部不使用<code>this</code>。这种情况下，对象和构造函数实际上没有关系，因此不能使用instanceof操作符确定类型。</p>
<p>稳妥构造函数有Douglas Crockford提出，利用了闭包的特点，保证了内部数据的安全性和封装性。函数内部没有公共属性，也不引用this对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age, school) &#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(name + <span class="string">&#x27; says hi.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title class_">Person</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;BUPT&#x27;</span>);</span><br><span class="line">p1.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>传统面向对象语言支持继承接口和继承实现。前者只继承签名，实现接口；后者继承实现的方法。ECMAScript只支持后者（ECMAScript中没有函数签名）。其实现主要利用原型链。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>ECMAScript中最基本的继承方式，它的思想在于通过原型让一个自定义类型用于另一个类型的属性和方法。具体实现上，只用将一个对象实例作为另一个对象的原型对象即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span> (name) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Subtype</span> (age) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现继承</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>);</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Subtype</span>(<span class="number">23</span>);</span><br><span class="line">o.<span class="title function_">sayAge</span>();</span><br></pre></td></tr></table></figure>

<p>上面的关键一步就是将父类的实例赋给子类的<code>prototype</code>，从而子类的所有实例可以共享父类的所有属性和方法。在上面的步骤中，<code>SubType</code>默认的原型被替换为<code>SuperType</code>的实例，所以实际上，<code>SubType</code>的<code>constructor</code>属性成为了<code>SuperType</code>。这是因为，再找不到属性或方法时，搜索过程会一步一步向原型链末端前进，直到Object。</p>
<p>下面是SuperType和SubType构造函数以及原型对象间的关系。</p>
<p><img src="/blog/images/prototype-2.jpg"></p>
<p>可以发现，使用原型链的一个问题是，父类的实例属性变成了子类的原型属性，分享在子类所有实例间。很显然是不合理的。第二，创建子类型时，为超类构造函数传递的参数将作为原型对象影响整个子类对象实例。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>这种方法的思路是，在子类构造函数调用父类的构造函数，并将执行环境绑定在子类环境中。这样可以方便地向父类构造函数中添加自己的参数而不影响其他的子类实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span> (newFriend) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Caley&#x27;</span>].<span class="title function_">push</span>(newFriend);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span> (newFriend) &#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, newFriend);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newFriend</span> = newFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;Dude&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(o.<span class="property">friends</span>);    <span class="comment">//[Alice, Bob, Caley, Dude]</span></span><br><span class="line"><span class="title function_">alert</span>(o.<span class="property">newFriend</span>);  <span class="comment">//Dude</span></span><br></pre></td></tr></table></figure>
<p>这么做的缺点也很明显，函数的定义都需要在构造函数中重新写一遍。因此，这种技术很少单独使用。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承发挥了上面两者的长处，通过原型链继承了原型属性和方法，通过构造函数实现对父类实例属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span> (newFriend) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Caley&#x27;</span>].<span class="title function_">push</span>(newFriend);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span> (newFriend) &#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, newFriend);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newFriend</span> = newFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">//修改构造函数，新添新方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">newFriend</span> + <span class="string">&#x27; says hi.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合继承是JavaScript中最常用的集成模式。不过它实际上调用了两次父类的构造函数，因此后面介绍的寄生组合式继承方法又对此进行了优化。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>Douglas CrockFord在2006年提出可以通过原型基于已有对象创建新对象，还不必创建自定义类型。函数大概像下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，本质上，<code>object</code>函数只是对传入的对象<code>o</code>进行了一层<em>浅复制</em>。从而其中的引用类型将会在返回的对象间共享。ECMAScript 5对这种通过对象创建对象的原型式继承方式进行了规范，新增了<code>Object.create()</code>方法。方法接受两个参数，一个作为新对象原型，一个作为新对象新增的额外属性。</p>
<p>寄生式继承模式和原型式继承很类似。它将创建一个仅用来封装继承过程的函数，在函数内部处理增强对象的过程。功能和<code>Object.create()</code>类似。但是这么做不能做到函数复用，从而效率会降低，用在简单的场景下。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>这种模式解决了组合式继承的弊端——调用两次父类构造函数。其中<code>SubType</code>构造函数中的调用作为实例的属性将覆盖原型中的同名属性。寄生组合式继承的关键在于：<strong>不必为了指定子类型的原型而调用父类的构造函数</strong>，我们不过是要一个父类原型的副本而已。因此，可以得到下面这样的基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span> (subtype, supertype) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//或Object.create(superType.prototype)</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = subtype;</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三步分别是创建对象，添加<code>constructor</code>属性，替换子类原型。从而在继承的过程中只调用了1次<code>SuperType</code>函数。同时原型链保持了不变。因此insanceof和isPrototypeOf()可以正常使用。寄生组合式继承是最理想的继承模式。就像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span> (newFriend) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Caley&#x27;</span>].<span class="title function_">push</span>(newFriend);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span> (newFriend) &#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, newFriend);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newFriend</span> = newFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"><span class="comment">//新增新方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">newFriend</span> + <span class="string">&#x27; says hi.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，ECMAScript支持面向对象编程，但没有类和接口的概念。对象和原型的定义和关系比较松散。</p>
<p>在创建对象上，有<strong>工厂模式</strong>、<strong>原型对象</strong>、<strong>构造函数</strong>、<strong>利用闭包</strong>几种方式可选，它们也可以组合使用。</p>
<p>在实现继承上，可以借助原型链、构造函数和寄生组合式的模式实现比较严格的继承，原型式和寄生式模式用于不那么严格的对象间继承。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/03/09/js-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2017/03/09/js-function/" class="post-title-link" itemprop="url">JavaScript中的函数表达式与闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-09 20:43:41" itemprop="dateCreated datePublished" datetime="2017-03-09T20:43:41+08:00">2017-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-03-29 14:37:40" itemprop="dateModified" datetime="2017-03-29T14:37:40+08:00">2017-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/03/09/js-function/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/09/js-function/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是JavaScript中最有特色同时又容易让人困扰的特性。定义函数的方式有两种：函数声明和函数表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (arg0, arg1) &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非IE浏览器中，function都有非标准的name属性，属性值为function后的标识符或表达式的接收变量名。在<strong>函数声明</strong>里有一个重要特征——<strong>函数声明提升（function declaration hoisting）</strong>。这意味着函数声明可以放在调用它的语句后。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>); <span class="comment">// &quot;Hi!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而函数表达式则不能这样使用，因为<strong>变量声明提升</strong>会将函数名提升，下面的代码将导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>();</span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>); <span class="comment">// Error！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确理解函数声明提升将会避免很多潜在的错误，<em>或者干脆养成好习惯——定义在前，调用在后</em>。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数是一个函数通过调用自身得到的。如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个经典的递归阶乘函数。不过当我们不知道函数名或者函数是匿名函数时，可以通过<code>arguments.callee</code>来调用自身。<br><code>argument.callee</code>是一个指向正在执行的函数的指针。</p>
<div class="tip">在ES5的严格模式下，`arguments.callee`特性是禁止使用的。它将影响解释器的优化和运行效率。
</div>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包</strong>几乎是前端面试必考的一个知识点。它的存在是JavaScript中作用域链带来的特性。<strong>闭包</strong>是指有权访问另一个函数<br>作用域中变量的函数。创建闭包最常用的方式就是在函数内部创建另一个函数。就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fatherFunction</span> (propertyName, value) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = object1[propertyName],</span><br><span class="line">            b = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (a + b &gt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在返回的函数中引用了外部函数的变量<code>propertyName</code>和<code>sum</code>。即使这个函数已经返回，只要内部函数还存在，那么这两个变量就仍然可以访问。这就是闭包的直观体现。</p>
<p>解释闭包就要先理解JS中的<em>作用域链</em>。执行环境是JS中的一个关键概念。它定义了变量或函数可以访问的数据。全局执行环境是最外层的执行环境。根据ECMAScript实现宿主的不同，全局执行环境也各不相同。某个执行环境中的代码执行完毕后，环境被销毁，包括其中的所有变量和函数定义。<strong>JS中的每个函数都有自己的执行环境</strong>。执行流进入一个函数时，函数环境就被推入到环境栈中，待执行完毕后出栈。在执行环境中的代码时，会创建变量对象的作用域链，由当前的活动对象到外部环境变量对象一直到全局执行环境中的变量对象。内部环境可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境中的变量和函数。</p>
<p>现在回过头看闭包。在函数执行过程中，为了读取和写入变量值，需要保存整个作用域链。因此，在<code>fatherFunction</code>中创建的匿名函数的作用域链实际上包含了<code>fantherFunction()</code>的活动对象（输入参数和变量）以及全局变量对象。在<code>fatherFunction()</code>返回时，匿名函数的作用域链仍然引用着它的活动对象，使其并不会被销毁，直到匿名函数被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数</span></span><br><span class="line"><span class="keyword">var</span> compare = <span class="title function_">fatherFunction</span>(<span class="string">&quot;value&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">var</span> res = <span class="title function_">compare</span>(&#123;<span class="attr">value</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">value</span>: -<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// 解除匿名函数的引用，释放内存</span></span><br><span class="line">compare = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<div class="tip">由于闭包会携带包含它的函数作用域，过度使用闭包会导致内存占用过多。忘记解除匿名函数引用还会导致内存泄漏。
</div>

<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>闭包可以取得父级函数的变量的<em>最终值</em>，因此配合for循环这样的结构就容易发生意外，就像下面的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindClickFunctions</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> buttons = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="comment">// 让我们假设length是20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = buttons.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        buttons[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数会为所有的按钮绑定点击事件，不过效果却并不像预想中那样，不同的button弹出不同的值。结果是所有的button在点击后弹出的都是20。这是因为所有的匿名函数都使用着同一个外部函数的活动对象。可以通过在创建一层闭包来达到预期的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindClickFunctions</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> buttons = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = buttons.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        buttons[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在每层循环中创建了一个匿名函数，匿名函数包含一个输入参数<code>i</code>，再分别保存在内部函数的作用域链中，就可以使闭包间引用的i互不干扰了。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>JavaScript中是没有块级作用域的。不过可以利用匿名函数的作用域模拟一个块级作用域出来。在其中定义的私有变量也不必担心与其他作用域的变量名相冲突。这种用法很常用于最外层的封装，用于隐藏代码中的变量，在一定程度上保证安全。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">&quot;You can see me, but you cannot touch me.&quot;</span></span><br><span class="line">    <span class="title function_">alert</span>(foo);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>同样的，JavaScript中是没有私有成员的概念的。但是，利用闭包可以制造出私有变量。原理是，利用函数作用域隐藏其中的变量甚至输入参数，通过返回的闭包操作这些“私有”变量。如下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stu</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;Shenlvmeng&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(stu.<span class="title function_">getName</span>());</span><br><span class="line">stu.<span class="title function_">setName</span>(<span class="string">&quot;Weii&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(stu.<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure>
<p>这里只是一个很简单的展示，红宝书中还介绍了模块模式和增强模块模式，利用闭包的特点实现了单例的构造和特权方法。下面对上面的<code>Stu</code>函数进行改造，可以使得所有通过<code>Stu()</code>构造的对象都有相同的公有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Stu</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Stu</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Stu</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&#x27;shenlvmeng&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(stu1.<span class="title function_">getName</span>());</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&#x27;weii&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(stu2.<span class="title function_">getName</span>());		<span class="comment">// &quot;weii&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(stu1.<span class="title function_">getName</span>());		<span class="comment">// &quot;weii&quot;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/03/06/dom-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2017/03/06/dom-1/" class="post-title-link" itemprop="url">HTML中的DOM 1级模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-06 11:26:29" itemprop="dateCreated datePublished" datetime="2017-03-06T11:26:29+08:00">2017-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-03-29 14:37:46" itemprop="dateModified" datetime="2017-03-29T14:37:46+08:00">2017-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/03/06/dom-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/06/dom-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>DOM（文档对象模型）</strong>是针对HTML和XML文档的一个API，描绘了层次化的节点树。开发者可以借助DOM对页面的某一部分进行添加、移除、修改。DOM来源于网景和微软提出的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_HTML">DHTML</a>。1998年10月，DOM 1级规范称为W3C的标准，为文档查询和改动提供了接口。各大主流浏览器都完善地实现了DOM。</p>
<hr>
<p>DOM把HTML和XML文档描述成一个多层节点构成的结构。每个节点有都有自己的特点、数据和方法。</p>
<p><strong>文档节点</strong>是每个文档的根节点。HTML中<code>&lt;html&gt;</code>元素是文档节点<em>唯一</em>的子节点，又称为<strong>文档元素</strong>。每一个标签都通过树中的一个节点表示，HTML元素表示为元素节点，特性通过特性节点表示，文档表示为文档节点，如此这样，总共有12中节点类型。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>DOM 1级中定义了Node类型。JavaScript中的所有节点类型都继承于Node类型。每个节点都有一个<strong>nodeType</strong>属性。常用的取值如下：</p>
<ul>
<li>Node.ELEMENT_NODE(1)</li>
<li>Node.ATTRIBUTE_NODE(2)</li>
<li>Node.TEXT_NODE(3)</li>
<li>Node.COMMENT_NODE(8)</li>
<li>Node.DOCUMENT_NODE(9)</li>
<li>Node.DOCUMENT_TYPE_NODE(10)</li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11)</li>
</ul>
<p>为了确保浏览器兼容性，建议还是将nodeType属性和数字值进行比较，减少使用常量。因为IE没有公开Node类型的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>) &#123; <span class="comment">// 元素节点</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;This is an element node.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了nodeType，节点类型还有<strong>nodeName</strong>和<strong>nodeValue</strong>两个属性。它们的取值取决于节点的类型。后面的介绍中也会提到。</p>
<h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>在父子关系上，每个节点有一个<code>childNodes</code>属性，保存着<code>NodeList</code>对象。这个对象有<code>length</code>属性，也可以通过方括号访问其中的值，也可以通过<code>item()</code>方法访问，但它并不是Array的实例。且DOM结构的变化会实时地反映到这个<code>NodeList</code>对象中。<em>减少使用NodeList可以避免它带来的时延</em>。</p>
<p>使用<code>firstChild</code>和<code>lastChild</code>属性可以分别访问到列表中第一个和最后一个节点。同时，每个节点都有一个parentNode属性，指向文档树的父节点。</p>
<p>在兄弟关系上，使用<code>nextSibling</code>和<code>previousSibling</code>分别可以访问到下一个和上一个兄弟节点。<code>hasChildNodes()</code>在节点包含多个子节点时返回true。</p>
<p>最后，所有节点都有<code>ownerDocument</code>属性，指向整个文档的文档节点。</p>
<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><p><code>appendChild</code>和<code>insertBefore</code>分别用于在childNodes末尾和某位前插入节点。并返回插入的DOM节点。需要注意的是，<em>如果插入的节点来自于DOM中，则节点会从原来的位置删除</em>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode);</span><br><span class="line"><span class="keyword">var</span> anotherNode  = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>); <span class="comment">// 插入到最后一位</span></span><br><span class="line">anotherNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>); <span class="comment">// 插入到第二位</span></span><br></pre></td></tr></table></figure>
<p><code>replaceChild</code>用于替换节点，<code>cloneChild</code>用于复制节点，cloneChild方法接受一个布尔值参数，表示是否执行深复制。在参数为true时执行深复制，否则执行浅复制。</p>
<div class="tip">需要留意的是，`cloneChild`不会复制DOM节点中的JavaScript属性，如事件处理程序。IE则会复制事件处理程序。为了保证一致性，建议在复制前移除事件处理程序。
</div>

<p>最后，节点的<code>normalize</code>方法可以删除节点后代中的空文本节点，合并相邻的文本节点。</p>
<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>JavaScript中用<code>Document</code>类型表示文档，浏览器中的<code>document</code>表示整个页面。它是<code>window</code>对象的一个属性。因此可以作为全局对象来访问。</p>
<p>它的nodeType为9，nodeName为<code>&quot;#document&quot;</code>，子节点可以是一个DocumentType或Element类型的节点。在HTML中可以通过<code>documentElement</code>属性便捷地得到子节点<code>&lt;html&gt;</code>。所有浏览器都支持这个属性。<code>document.body</code>属性也都被支持。</p>
<p>除了<code>&lt;html&gt;</code>，另一个可能的子节点是<code>DocumentType</code>，即<code>&lt;!DOCTYPE&gt;</code>标签。浏览器对它的支持差异很大。同样的还有<code>&lt;html&gt;</code>元素外的注释。</p>
<p>document还有下面4个独特的HTML属性：</p>
<ul>
<li><code>title</code>包含网页的标题，属性的修改直接对应<code>&lt;title&gt;</code>元素</li>
<li><code>URL</code>表示页面的URL，<strong>只读</strong></li>
<li><code>domain</code>表示页面的域名，可修改</li>
<li><code>referer</code>保存链接到当前页面的URL，<strong>只读</strong></li>
</ul>
<p>其中修改domain可以用来访问同一父级域名下的iframe中的资源。</p>
<div class="tip">为了保证安全，域名修改只能由“紧绷”变“松散”，而不能反过来。
</div>

<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>DOM 1级标准只有<code>getElementById()</code>，<code>getElementsByTagName()</code>和<code>getElementsByName()</code>三种方法。具体功能不必再提。它们返回的是一个<code>HTMLCollection</code>对象。这个对象和<code>NodeList</code>很类似。同样可以通过方括号访问其中的子元素。不过<code>HTMLCollection</code>额外提供<code>namedItem()</code>方法，通过<code>name</code>属性值访问其中的子元素。</p>
<p>除此以外，<code>document</code>对象还有一个特殊的集合，它们也都是<code>HTMLCollection</code>对象。如<code>document.anchors</code>，<code>document.forms</code>，<code>document.imgs</code>，<code>document.links</code>。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>document.implementation</code>属性用来检测浏览器对DOM实现的程度，它有一个<code>hasFeature()</code>。</p>
<p><code>write()</code>、<code>writeln()</code>、<code>open()</code>、<code>close()</code>方法可以将输出流写入到网页中。</p>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>除了<code>document</code>外，Element类型应该是HTML中最常用的类型了。它的nodeType为1，nodeName为元素的标签名，<code>tagName</code>属性也可以用来访问元素标签名。</p>
<p>所有HTML元素都由HTMLElement的子类型表示。所有的HTML元素都具有下面的一些标准特性：</p>
<ul>
<li><code>id</code>：元素的唯一标识符</li>
<li><code>title</code>：有关元素的附加说明信息</li>
<li><code>lang</code>：元素的语言代码</li>
<li><code>dir</code>：语言的方向</li>
<li><code>className</code>：与元素的class对应</li>
</ul>
<p>这些都可以通过访问元素的属性得到。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">title</span>=<span class="string">&quot;text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>元素的信息可以通过下面的方式得到，同样，这些属性可以直接赋予新值来修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">class</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">title</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">lang</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">dir</span>);</span><br></pre></td></tr></table></figure>

<p><em>未完待续</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/03/01/js-type-and-equal-judgement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2017/03/01/js-type-and-equal-judgement/" class="post-title-link" itemprop="url">JavaScript类型与类型转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-01 12:06:13" itemprop="dateCreated datePublished" datetime="2017-03-01T12:06:13+08:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-03-29 14:35:02" itemprop="dateModified" datetime="2017-03-29T14:35:02+08:00">2017-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/03/01/js-type-and-equal-judgement/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/01/js-type-and-equal-judgement/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。</p>
<footer><strong>Nicolas C.Zakas </strong><cite>--JavaScript高级程序设计</cite></footer></blockquote>
<p>由于JavaScript是一种松散类型的语言，即变量在使用时，并不需要事先知道它的类型。因此不同变量间的比较往往要作类型转换，这也是一些常见quiz的由来。<br>比如下面的一道面试题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请写出下面语句的输出结果</span></span><br><span class="line"><span class="keyword">if</span> ([]) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);               <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);               <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> ([] == <span class="literal">true</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);       <span class="comment">// 无</span></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125; == <span class="literal">true</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)；      <span class="comment">// 无</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">NaN</span> == <span class="title class_">NaN</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)        <span class="comment">// 无</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;5&quot;</span> == <span class="number">5</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)          <span class="comment">// 7</span></span><br><span class="line"><span class="comment">//下面的结果你能写出来么</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] + &#123;&#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; + []); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; - []); <span class="comment">// -0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] - &#123;&#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] + []); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] - []); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; + &#123;&#125;); <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; - &#123;&#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">//下面的呢</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="comment">// &quot;function&quot;</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>   <span class="comment">// &quot;true&quot;</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>怎么样？是不是有点晕，下面我们一部分一部分地来解释JavaScript中一些类型和相等相关的“潜规则”。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>让我们先从JavaScript的数据类型开始。JavaScript中<em>只有</em>5种基本类型和引用类型。其中5种基本类型分别是：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Number</li>
<li>Boolean</li>
<li>String</li>
</ul>
<p>除此之外只有1种引用类型——Object，Object本质上是由一组无序的键值对组成。5种基本类型是按值访问的，引用类型Object是按引用访问的。</p>
<p>可以使用typeof操作符监测变量的基本类型。*它可以判断变量是否为除null的其他5种基本类型以及function类型。除此之外都会返回”object”*。之所以null的typeof结果也为”object”，是因为null实际上表示引用指向空对象。</p>
<p>使用instanceof可以判断引用类型的具体值。使用方法类似于A instanceof B的形式。当B为“Object”时，表达式永远返回true。因为根据规定，所有引用类型的值都是Object的实例。</p>
<p>下面是几个例子。通过instanceof操作符可以很方便地区分空数组和空对象（当然还有Object.prototype.toString.call()和[].concat()两种方法。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/w+/g</span> <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="to-Boolean类型"><a href="#to-Boolean类型" class="headerlink" title="to Boolean类型"></a>to Boolean类型</h3><p>Boolean类型是ECMAScript中使用最多的类型之一。类型只有true和false两个字面量。<b>true不一定等于1，false也不一定等于0</b>.可以通过调用Boolean()函数将其他类型转型为Boolean类型。规则如下：</p>
<ul>
<li>String类型：非空字符串&#x3D;&gt;true，空字符串&#x3D;&gt;false</li>
<li>Number类型：非零数字（包括Inifity）&#x3D;&gt;true, 0和NaN&#x3D;&gt;false</li>
<li>Object类型：任何对象&#x3D;&gt;true, null&#x3D;&gt;false</li>
<li>Undefined：false</li>
</ul>
<p>在使用if()语句或三元操作符等情况要求Boolean类型时，括号内的表达式将会自动使用Boolean()函数转换为布尔类型。</p>
<h3 id="to-String类型"><a href="#to-String类型" class="headerlink" title="to String类型"></a>to String类型</h3><p>有两种方法可以将值转为字符串，一种是使用几乎所有值都有的toString方法，对于null和undefined使用另一种——String()函数。</p>
<p>前者适用于除null和undefined外的所有值，甚至String本身（返回一个自身的副本）。有些toString()方法接收一个基数作为参数（如Number）对Object使用toString方法时，会根据对象内toString的定义决定。</p>
<ul>
<li>Array返回逗号隔开的不包括外侧中括号的字符串</li>
<li>Function返回Function定义的字符串</li>
<li>普通Object返回”[object Object]”</li>
<li>null和undefined分别返回”null”和”undefined”</li>
</ul>
<h3 id="to-Number类型"><a href="#to-Number类型" class="headerlink" title="to Number类型"></a>to Number类型</h3><p>可以使用Number(), parseInt()和parseFloat()三个函数做强制转换。转换到Number类型的规则要更好理解些。</p>
<ul>
<li>是Boolean类型时，true和false分别转换到1和0</li>
<li>数字类型时，返回本身</li>
<li>null时返回0</li>
<li>undefined时返回NaN</li>
<li>对字符串使用类似于parseInt和parseFloat类似的方法（可以识别0x这样的进制前缀<b>甚至Infinity这样的字符串</b>）</li>
<li>对象使用valueOf()方法，再使用之前的规则；如果结果是NaN，再使用toString()方法作转换</li>
</ul>
<h2 id="类型转换场景"><a href="#类型转换场景" class="headerlink" title="类型转换场景"></a>类型转换场景</h2><h3 id="一元加减"><a href="#一元加减" class="headerlink" title="一元加减"></a>一元加减</h3><p>一元加减只需对操作数强制转换到Number类型。向下面这样的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 = +s1; <span class="comment">// 1</span></span><br><span class="line">s2 = +s2; <span class="comment">// 1.1</span></span><br><span class="line">s3 = -s3; <span class="comment">// NaN</span></span><br><span class="line">b = +b;   <span class="comment">// 0</span></span><br><span class="line">f = +f;	  <span class="comment">// 1.1</span></span><br><span class="line">o = -o;	  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>ECMAScript中规定的加减法这两个操作符有一些特殊行为，不仅处理数值的加减，还处理字符串的加减。因此转换规则还有些复杂。</p>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>优先做数值加减，无法完成时做字符串拼接。两个操作数都是<b>数值</b>时，执行常规的加法计算。</p>
<ul>
<li>一个操作数为NaN时，返回NaN</li>
<li>Inifity + -Inifity，返回NaN</li>
<li>+0 加 -0，返回+0</li>
</ul>
<p>只要有一个操作数为<b>字符串</b>类型，应用下面规则：</p>
<ul>
<li>两个都是字符串时，则将它们拼接起来。</li>
<li>一个是字符串时，先将另一个转换为字符串</li>
</ul>
<p>布尔值和null以及undefined在另一个操作数是数值类型时转换为<b>数值类型</b>，反之转换为<b>字符串类型</b>。<br>一个操作数为对象时，转换为<b>字符串类型</b>。</p>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>与加法类似，除了数值相减减法也需要做一些类型转换。但是和加法不一样的是，<em>减法返回的一定是Number类型</em>。</p>
<ul>
<li>一个数值为NaN时，结果为NaN</li>
<li>同号的Infinity相减返回NaN（如Infinity - Infinity），异号的Infinity相减等于第一个操作数</li>
<li>除了-0减+0返回-0，其余0间相减均返回+0</li>
<li>操作数出现字符串、布尔值、null、undefined时，做Number转换再进行数值减法</li>
<li>对象先尝试用valueOf方法获得对象数值，若无此方法则调用toString方法，并转换得到的字符串。</li>
</ul>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符即大于（&gt;）、小于（&lt;）、大于等于（&gt;&#x3D;）和小于等于（&lt;&#x3D;）。在操作数并非纯数值时，ECMAScript也会进行数据转换或一些奇怪的操作。</p>
<ul>
<li>两个操作数都是数值时，进行数值比较</li>
<li>两个操作数都是字符串时，按照对应字符编码顺序比较</li>
<li>一个操作数是数值时，转换另一个为数值再比较</li>
<li>一个操作数是对象时，优先使用valueOf方法比较数值，没有该方法时再使用toString方法</li>
<li>任何数和NaN比较都会返回false</li>
</ul>
<h2 id="相等和全等"><a href="#相等和全等" class="headerlink" title="相等和全等"></a>相等和全等</h2><p>相等和全等用于确认两个变量是否相等。对此ECMAScript提供两组操作符：-相等-和-全等-。相等先转换类型后比较，全等仅比较不转换类型。由于情况较多较复杂，这里单独列一节。</p>
<p>ECMAScript中相等操作符为&#x3D;&#x3D;。不相等操作符为!&#x3D;。它们都会先强制转型变量再相互比较。转换规则如下：</p>
<ul>
<li>先将<b>布尔值</b>转换为数值，false转换为0，true转换为1</li>
<li><b>字符串</b>和<b>数值</b>比较时，将字符串转换为数值</li>
<li>两个操作数都是<b>对象</b>时，判断它们是否指向同一个对象（只比较引用）</li>
<li>只有一个操作数是<b>对象</b>时，调用valueOf()或toString()方法获得基本类型值</li>
<li><b>null</b>和<b>undefined</b>是相等的</li>
<li><b>null</b>和<b>undefined</b>在比较时不会被转换</li>
<li>NaN出现时，相等操作符返回false</li>
</ul>
<p>全等操作符为&#x3D;&#x3D;&#x3D;，对象的不全等操作符为!&#x3D;&#x3D;。它们不会转换变量类型，相比较类型后比较值。因此行为更容易预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/blog/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/30/">30</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">27:55</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/11/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">152</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">469</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/07/26/social-psychology-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/07/26/social-psychology-part-1/" class="post-title-link" itemprop="url">社会心理学 Part 1 - 导论 & 社会思维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-26 00:53:15" itemprop="dateCreated datePublished" datetime="2019-07-26T00:53:15+08:00">2019-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-02 21:48:50" itemprop="dateModified" datetime="2019-11-02T21:48:50+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/07/26/social-psychology-part-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/26/social-psychology-part-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/08/07/social-psychology-part-2/">社会心理学 Part 2 - 社会影响</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/09/24/social-psychology-part-3/">社会心理学 Part 3 - 社会关系</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/11/02/social-psychology-part-4/">社会心理学 Part 4 - 应用</a></p>
</blockquote>
<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>什么是社会心理学？社会心理学研究：</p>
<ul>
<li>人们如何看待他人（社会思维）</li>
<li>人们如何影响他人（社会影响）</li>
<li>人们如何相互关联（社会关系）</li>
</ul>
<p>类似经济学等其他人文社科，社会心理学亦有些基于上面几方面的<strong>重要观点</strong>：</p>
<ul>
<li>我们个人构建起社会现实</li>
<li>我们天生具有的社会直觉是强大的，但有些时候是危险的</li>
<li>社会影响塑造行为，比如我们渴望彼此之间建立关联、渴望归属感、渴望得到他人的良好评价</li>
<li>个人态度和性格倾向塑造行为</li>
<li>社会行为同样也是生物性行为，我们是社会、心理、生物的共同产物</li>
</ul>
<p>社会心理学不同于社会学：</p>
<ul>
<li>社会学研究<strong>团体</strong>，社会心理学研究<strong>个人</strong></li>
<li>社会学较难控制研究因素来做实验，社会心理学则可以控制变量来模拟实验</li>
</ul>
<p>社会心理学不同于人格心理学：</p>
<ul>
<li>人格心理学研究<strong>个体间差异</strong>，社会心理学研究个体的<strong>社会因素</strong></li>
<li>人格心理学历史悠久，有诸多大师；社会心理学则比较年轻</li>
</ul>
<p>另外不论是心理学还是别的学科，都是对一个事实的不同表述，每个学科都需要一些公设作为基础，它们之间没有高下之分。</p>
<h3 id="价值观对研究的影响"><a href="#价值观对研究的影响" class="headerlink" title="价值观对研究的影响"></a>价值观对研究的影响</h3><p>直接影响来自于：课题选择、投身人群、实验目标等等方面。间接影响来自于：</p>
<ul>
<li>科学具有<strong>主观性</strong>，心理学则更是如此</li>
<li>研究者在做<strong>价值判断</strong>时会受到个人价值观的影响</li>
<li>当讨论从<strong>是什么</strong>变成<strong>怎么样</strong>时，就会把价值观纳入讨论之中</li>
</ul>
<p>另外，特别澄清一个误解：<strong>社会心理学不过是常识而已嘛</strong>。社会心理学的结论往往简单易懂且贴近生活，所以会给人一种<strong>事后聪明型偏见</strong>。主要因为下面两点：</p>
<ul>
<li>心理学的高级结论往往正着说、反着说都有道理；就像谚语，比如“魔高一尺道高一丈”和“道高一尺魔高一丈”听起来都对</li>
<li>事先得知结论然后去理解和通过努力发现结论完全不是一回事；当你有上述偏见时，尝试把两个相反结论放在一起做个选择题就知道了困难程度了</li>
</ul>
<h3 id="如何研究"><a href="#如何研究" class="headerlink" title="如何研究"></a>如何研究</h3><p>好的假设：1）为研究指出方向；2）探测新的研究领域；3）具有应用价值。</p>
<p>好的理论：1）能对大范围观察结果做总结；2）对我们证明修改理论、进行新探索、指出可能应用方向给出清晰的预测</p>
<p>研究方法主要分为两种：<strong>相关研究</strong>和<strong>实验研究</strong>。</p>
<ul>
<li>相关研究发生在<strong>真实情景</strong>中，易于进行，只能发现<strong>相关性</strong>，因为无法控制变量，因而无法证明因果性<ul>
<li>对实验对象要足够有代表性（<strong>随机抽样</strong>）</li>
<li>认真组织问题，因为问题的<strong>顺序</strong>、<strong>选项编制</strong>、<strong>措辞</strong>都会影响被试的反应</li>
</ul>
</li>
<li>实验研究通过在<strong>实验室</strong>控制自变量，从而探寻<strong>因果性</strong><ul>
<li>同样需要随机分配 + 施加不同外在条件保证额外因素的干扰消除</li>
<li>需要自设实验情景，有时会面临伦理道德问题</li>
</ul>
</li>
</ul>
<h2 id="社会思维"><a href="#社会思维" class="headerlink" title="社会思维"></a>社会思维</h2><h3 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h3><p>这一章主要讨论人们如何评价、认识自己，如何维持自尊，社会思维如何产生等问题。</p>
<p><strong>焦点效应</strong>使我们高估自己的突出程度，从而产生<strong>透明度错觉</strong>（实际注意我们的人比我们认为的少）。</p>
<h4 id="自我概念"><a href="#自我概念" class="headerlink" title="自我概念"></a>自我概念</h4><p>自我的部分是自我概念的基础，<strong>自我图式</strong>是我们组织自己所在世界的心理模板。<strong>自我参照效应</strong>让我们更好地以自我为中心组织记忆。同时，自我概念还包括我们<strong>想象中的自我</strong>。</p>
<p>社会的部分同样扮演了很重要的角色。包括以下几点：</p>
<ul>
<li>我们在社会中扮演的角色</li>
<li>社会同一性，即你身边的社会群体，诸如民族、信仰、性别等</li>
<li>社会比较</li>
<li>成功和失败经验。用积极的信息提高自尊会激发个体做出更大成就，全力以赴并取得了成功会使人感到更加自信有力。<strong>自尊不仅来自告诉孩子他们有多棒，还要让他们通过辛苦努力获得成功</strong></li>
<li>其他人的评价。与我们自我概念有关的是我们<em>觉得</em>他们如何评价我们，而不是他们实际上如何评价我们。自尊，是我们对他人如何评价我们的监控并作出相应反应的心理学尺度</li>
</ul>
<p>自我受文化影响也很深。西方更盛行<strong>个人主义</strong>，赞美那些依靠自己的人。在亚洲、非洲、南美洲地区的文化则更重视<strong>集体主义</strong>，这些文化中的人们更多自我批评，而较少自我肯定。个人主义更容易观察到事物本质，集体主义更容易观察到事物间的联系。<strong>一个具有相互依赖自我的人会有更强烈的归属感</strong>。对于偏重个人主义的个体，积极情绪来自于效能感、出众和骄傲；来自集体主义的个体，积极情绪伴随着社会交往——亲密感、友好和尊重。</p>
<p>自我认识上，我们存在着一些天然的缺陷。</p>
<ul>
<li>我们会错误地<strong>解释</strong>我们的行为，行为相关的思想先于行动时，人们会感觉是按意愿做出这样行动的。</li>
<li>我们会错误地<strong>预测他人和自己的行为</strong>，实验中发现人们预测别人的行为比预测自己的更为准确</li>
<li>我们会错误地<strong>预测自己的感受</strong><ul>
<li>一方面，人们很难预测自己未来情绪的强度和持续时间，比如预测自己谈恋爱、收到礼物、赢得比赛等后的感觉，又比如饥饿的人会错估自己的食量，且具有更高的购物冲动。这一点上可以粗略地总结为<strong>错误地想要得到某些东西</strong>。研究显示，好消息的情绪消失比自己预期的要快。</li>
<li>另一方面，人们会高估消极情绪事件的持久性影响，以及过高地预期自己的痛苦。实际上，生理上和心理上人都具有强大的恢复能力</li>
</ul>
</li>
</ul>
<p>最后一点，人们在<strong>自我分析</strong>时，对一些原因并不显著的行为往往很难分析出原因。换句话说，我们对思维的<strong>结果</strong>比对思维的<strong>过程</strong>了解的更多。这带来两个结论：</p>
<ul>
<li>心理学研究中，<strong>自我报告通常靠不住</strong></li>
<li>日常生活中，人们分析或解释其经验的真实性无法保证报告准确性</li>
</ul>
<h4 id="自我效能-amp-自尊"><a href="#自我效能-amp-自尊" class="headerlink" title="自我效能 &amp; 自尊"></a>自我效能 &amp; 自尊</h4><p><em>自我效能</em>即<strong>对自己能力、效率的乐观信念会获得更大回报</strong>。这种态度让你积极面对外界变化。心态上，自我效能高的人会认为身边发生的事“是受自己努力和技巧支配的”，而自我效能低的人会认为“是受外界力量支配的”。</p>
<p>人在对所做的事或他人对自己做的事失去控制时，会产生不愉快的压力情绪。长此以往会产生<strong>习得性无助</strong>，降低个体的抗挫能力。反之促进个体控制可以真正增强个体健康和幸福感。但是“过度的自由”也会降低幸福感，比如拥有一些无法反悔的事会让人心理更好受。</p>
<p><em>自尊</em>是我们全面的自我评价。高自尊的人在自尊面临挑战时，会非常敌对。自尊带来的摩擦发生在熟人之间，比如兄弟姐妹、朋友。把自尊建立在良好的自我感觉，而不是分数、外貌、金钱和别人评价基础上的人，会一直感到状态良好。</p>
<h4 id="自我服务偏见"><a href="#自我服务偏见" class="headerlink" title="自我服务偏见"></a>自我服务偏见</h4><p>我们加工和自我相关的信息时，会出现一种潜在偏见，即<strong>自我服务偏见</strong>。</p>
<ul>
<li>我们把成功归于内部原因，失败归于外部因素</li>
<li>我们总将成功与自我联系在一起，以保持良好的自我形象。因此，大多数人认为“今天的我比昨天更完善”</li>
<li>我们认为自己比平均水平好，尤其是<strong>主观行为维度</strong>，如品德。教育也无法消除这种自我服务偏见。</li>
<li>我们认为自己擅长的事情是更重要的，以此维持我们的自我形象</li>
<li>绝大多数人<strong>盲目乐观</strong>，而较少居安思危</li>
<li><strong>虚假普遍性</strong>和<strong>虚假独特性</strong>。即过高估计他人对自我观点的认同程度和把我们的成功、才智、品德看成超乎寻常。比如人们自己的生活变化时，可能会认为整个世界也在发生变化</li>
</ul>
<p>总结来看，<strong>自我服务归因</strong>、<strong>自我恭维的比较</strong>、<strong>盲目乐观</strong>以及<strong>虚假普遍性</strong>是自我服务偏见的根源。这一机制有助于我们抵制抑郁，却会引起对他人、自己的错误评价，包括对自己所在群体的评价，从而带来群体冲突。</p>
<h4 id="自我展示"><a href="#自我展示" class="headerlink" title="自我展示"></a>自我展示</h4><p>人们对外展示的自我和真实的自我是不同的。最常出现的是<strong>虚伪的谦虚</strong>，比如对自我成就自传式的解释，这在匿名自我评价上就消失了，这种表浅的谦虚只是为了表现谦虚而不是内心的真实感受，这也能避免“获胜后的危险”。</p>
<p>人们为了减少失败结果的影响，可能会故意地<strong>自我妨碍</strong>，以维持对自己能力的信任，比如考试前不好好复习。</p>
<p>作为一种社会性动物，人们总是在向周围的观众表演。在熟悉的环境下，不需要意识参与就能完成。而在陌生环境里，比如和陌生异性聊天或参加一场宴会，我们就能确切地意识到营造形象的过程。在自我展示的程度上，有两种极端——行骗专家式的高自我监控和我行我素的第自我监控。更多人处在两个极端之间。尽管在集体主义国家，自我展示被抑制。但是<strong>自我美化</strong>依旧存在。</p>
<h3 id="社会信念和判断"><a href="#社会信念和判断" class="headerlink" title="社会信念和判断"></a>社会信念和判断</h3><h4 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h4><p>人类天生想让整个世界合乎情理，至少能被自己解释。因而带来自然而然地对他人行为的<strong>归因</strong>。</p>
<p>归因即<strong>探索行为的因果关系</strong>，比如“你不回我电话是因为你不关心我了！”。根据海德（Heider）始创的<em>归因理论</em>，归因分为两种：</p>
<ul>
<li>内因：<strong>性格归因</strong>，如“你不爱我了！”</li>
<li>外因：<strong>情境性归因</strong>，如“我在打游戏”</li>
</ul>
<p>伴随我们的归因天性，我们内置一些归因天赋：</p>
<ul>
<li>特质推断：不寻常的行为让我们更了解这个人</li>
<li>常识性归因：<em>共同反应</em>（个体经常表现这种行为吗），<em>区别性</em>（不同情境下行为不同吗），<em>一致性</em>（别人也这样吗）共同作用得出结论</li>
</ul>
<h4 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h4><p>遗憾的是，我们的归因天赋不完美的。李·罗斯发现个体在归因他人行为时，会低估情境因素的作用影响，而<strong>高估个人特质的影响</strong>。这种倾向即<strong>基本归因错误</strong>。当归因涉及个人利益时，这种错误更为明显。即使我们事先知道有情境因素存在，依旧会有这种错误。比如，我们会认为电影中反派的饰演者就是本人的真实反应，我们会认为考官或出题者会更聪明。类似地，如果某个人自己所持的观点被其他人反复表达，他也会认为其他人确实也持有这种观点。</p>
<p>应用在日常生活中，解释<strong>他人行为</strong>时，我们会犯基本归因错误，而对于自己的行为，我们却通常用情境因素解释。我们通常用描述行为、反应的词句解释自己，涉及到他人时，更经常用“他怎么怎么样”来描述。</p>
<p>基本归因错误可以来自于许多原因：</p>
<ul>
<li><strong>行动者和观察者身处位置不同</strong>。作为观察者时，解释他人行为会更多聚焦在突出的行为人身上，从而易于忽略情境影响；相反，作为行动者本身时，自我和环境融为一体，观察联想时就会对情境因素更加敏感。</li>
<li><strong>聚焦观点偏见</strong>，即人们会更多关注被聚焦的个体，支持其观点。如观看聚焦犯人录像的观众几乎百分百认为犯人有罪，而观看聚焦审讯员录像的观众则会认为犯人是被迫认罪的。</li>
<li><strong>观点是随时变化的</strong>，回顾自己记忆时，会分配情境更多权重，近期行为更多归因情境，远期行为更多归因个人性质。比如Bob下周邀请我参加生日和2年后邀请归因是不同的</li>
<li><strong>自我觉知</strong>，注意力集中在自己身上时，更多归因自我特质而非特性。对于他人，<strong>越缺乏在不同情境下观察行为的机会，就越容易将行为归因他人人格，尤其是陌生人</strong>，对于我们很熟悉且在多种环境相处过的人，我们会对环境更加敏感。</li>
<li><strong>文化差异</strong>，集体主义更多归因情境，如“体制有问题”；个人主义更多归因个人特质</li>
</ul>
<p>基本归因错误的原理很可能是，<strong>评价情境对他人的影响比归因个人特质要更花脑力</strong>，即将行为归因个体内在而非环境是种有效率的行为，且有些场景下归因个人特质确实是有效的。</p>
<p>研究归因错误是很有价值的。因为对于他人行为归因的不同会直接影响我们对他们的印象和感受，正如上面的“你不爱我了！”和“我在打游戏”。了解了这些，在日常生活中解释行为的时候，就更能以批判性的思维看待自己和他人的评价。</p>
<h4 id="社会知觉和社会记忆"><a href="#社会知觉和社会记忆" class="headerlink" title="社会知觉和社会记忆"></a>社会知觉和社会记忆</h4><p><strong>先入为主</strong> —— <strong>我们的预期会引导我们对信息的知觉和解释</strong>。比如，球迷们总认为裁判偏袒另一方。人总是主观的，事实上告诉我你从哪里看到了偏见，我甚至能获得有关你所持态度的线索。类似地，对于观点模糊的混合型信息，对立观点双方都会吸收信息并同化为支持自己，从而更坚定自己的观点。书中给出了一个例子——一个面无表情的男人面孔，在告诉你他是个慈善家和告诉你他是个纳粹分子时，你会对脸做出不同的认识。</p>
<p>事实就在那里，但我们的思维却积极地解释它，并根据不同的解释做出不同的行为。</p>
<p>解释的过程也会左右他人对我们的知觉，<strong>当我们说某人好话或坏话时，人们也会试图将那些特质和我们联系在一起</strong>。</p>
<p><strong>信念固着</strong></p>
<p><strong>一旦人们为错误的信息建立了理论基础，就很难再让他们否定这条错误的信息</strong>。建立理论基础的解释是人自然做出的，在解释形成后，会独立于最初推论出它的信息而存在。因此即使在信息被推翻后，被试依旧坚持自己归纳出的解释。这给我们一个启示：我们越是极力证明我们的理论和解释是正确的，我们就对挑战自己信念的信息越闭塞。</p>
<p>从进化学的角度看，这种归纳可以减轻理解负担；但是这个收益的代价是：我们成为自己思维方式的囚徒。实验发现，<strong>解释相反的观点</strong>可以减轻信念固着对我们思维的固有影响。</p>
<p><strong>记忆重构</strong></p>
<blockquote>
<p>记忆与读书不同，它更像根据不连贯的笔记片段写一本书 —— John F. Kihlstrom, 1994</p>
</blockquote>
<p>我们的记忆不像一个储物箱，需要什么可以直接取出。我们会无意识地修正和重构我们的回忆。</p>
<ul>
<li>一些细小的令人愉快的事件会让回忆比实际所经历的美好得多。一些不愉快或无聊的事情会被最小化，似乎消失在记忆里。这在旅行回忆中最为常见。（很像是大脑记忆机制的趋利避害）</li>
<li>我们会改变同其他人关系的回忆，当记忆模糊时，当下的感觉会主导我们的回忆</li>
<li>我们会重构过去行为的回忆，从而体现出“事后聪明式的偏差”。比如，当初要是怎么怎么样就好了。同时，回忆会变得更符合我们现在的观点</li>
<li>一些暗示会影响回忆的结果（<strong>误导信息效应</strong>）</li>
</ul>
<p>整体来看，记忆的提取更像一个复杂的相互关联的过程。极易受上下文（如暗示、引导）影响，context不同，记忆启动的画面就不同。</p>
<h4 id="直觉和判断"><a href="#直觉和判断" class="headerlink" title="直觉和判断"></a>直觉和判断</h4><p>实验表明，<strong>无意识控制我们大多数行为</strong>，对绝大多数人来说，其日常生活不是由有意识的目标和经过深思熟虑的选择决定的，而是受内部心理过程的控制。比如在食物中看到虫子会感到恶心，跳舞时肢体动作的选择等等。我们意识小部分是受控制的，大部分是自动化的（冲动的、无需努力的、无意识的）。</p>
<ul>
<li>情绪反应是即时的，简单的喜欢、不喜欢、恐惧通常不涉及分析的过程。这些是伴随基因而来的。</li>
<li>人在领域内拥有足够多专业知识时，可以依赖直觉获得问题答案，如下棋、写代码。高手通常会察觉到新手看不到的pattern。</li>
<li>我们对事实、名字、过去经验的记忆是外显的，而对技能、条件特征的记忆是内隐的</li>
</ul>
<p>看起来，我们的控制意识处理着最重要、最新鲜是事件，而把日常事情分配给其他系统处理。然而，直觉抑或说是无意识过程并没有想象中那么敏锐。比如事后聪明式判断。这些即错觉思维。</p>
<p><strong>过度自信</strong></p>
<p>过度自信现象会影响我们对目前知识的评价和对未来行为的预测。讽刺的是，能力不足会促进过度自信倾向，对能力的认识也是需要能力的。这种现象不是个别的：</p>
<ul>
<li>计划者通常会低估工程所需时间和精力</li>
<li>投资专家都认为他们能够取得超过股市平均回报率的业绩</li>
<li>过度自信优势会带来浩劫，如越战</li>
</ul>
<p><strong>验证性偏见</strong>：人们往往会寻找支持自己信念的信息，而非尝试证明自己的直觉不成立。因为这么做有助于个人证实自己意象。</p>
<p>有两种降低过度自信的方法：<strong>即时反馈</strong>，比如天气预报；<strong>设想自己判断可能出错的原因</strong>。同时考虑到过度自信的普遍性，我们也需要对别人独断性的陈述保持谨慎。</p>
<p><strong>心理捷径</strong></p>
<p>我们的认知系统在进化中形成了专门的心理捷径，让我们很容易就能形成印象，作出决定和生成解释。但这也会带来一些错误。</p>
<ul>
<li><strong>代表性直觉</strong>，对某个事物进行评价时，在直觉的引导下，将其与某一类典型的心理表征进行比较。比如，告诉你一个人朝九晚五，很可能认为他是公务员；告诉你一个人996修福报，你很可能认为他是程序员。这会让我们忽略其他重要信息。</li>
<li><strong>易得性直觉</strong>，我们会优先从记忆中取出现成易得的信息做判断。比如，那些鲜明容易形象化的事件，如容易形象化症状的疾病，与那些较难形象化的疾病相比，被认为更易发生。再比如，那些小说、电影、电视中的虚构情节会给人留下印象，甚至也会影响我们随后的判断。如，我们认为飞机不如汽车安全。这会让我们过度重视生动鲜明的例证。</li>
<li><strong>反事实思维</strong>，容易想象的事件会影响我们对负罪、遗憾、挫败和宽慰的体验。比如我们队以一分之差输掉（赢得）比赛，相比差距20分，我们会感到更大的遗憾（宽慰）。铜牌会比银牌获得者更高兴。<strong>事件本身越重要，反事实思维强度就越大</strong>，如在酒驾中失去亲人会带来莫大的遗憾感。尽管如此，<strong>绝大部分人对已做事情的悔恨比没有做的事情的会很要小</strong>。对于已做事情，人们会更多可能感到歉意。</li>
</ul>
<p><strong>关联错觉</strong></p>
<p>当我们期待发生某种重要联系时，会知觉到<strong>错觉相关</strong>，如吃巧克力会让我这一天更幸运。我们相信事件存在相关时，会更可能注意并回忆某些支持性的证据（幸存者效应）。</p>
<p>将随机事件知觉为有联系的倾向会让人产生<strong>控制错觉</strong>，即<strong>认为各种随机事件受自己影响</strong>。赌博中很常见，掷骰子希望点数较小时，出手会相对轻柔，希望点数较大时，出手相对较重。同时，由于<strong>趋均数回归</strong>，即随机现象会在期望附近上下波动的存在，在上一次或上几次偏离期望较远时，下一次更可能回归到期望附近。所以，<strong>当我们处在一个最低水平时，任何尝试行为看起来似乎都是有效的</strong>。这会让老师误认为自己的辅导生效了，或者看心理治疗书籍拯救了偶然的低迷情绪。</p>
<p><strong>情绪影响判断</strong></p>
<p>个体在乐观和意抑郁的情绪下，对世界的知觉不同。因为，我们的情绪会将与其相关的经验带入头脑并给我们的所见所闻着色。情绪对简单、自动化的思维影响比复杂、有意控制的思维要小。即我们思考越多，思维就越受情绪侵染。</p>
<h4 id="自我实现预言"><a href="#自我实现预言" class="headerlink" title="自我实现预言"></a>自我实现预言</h4><p>我们的社会信念和判断会影响我们的感觉和行动，由此改变自己的现实，这种观念引导我们以证实自己的方式行动即<strong>自我实现预言</strong>。老师认为学生是否有天赋，就会带来自我实现预言的现象。有趣的是，学生认为老师出色和有趣也会带来自我实现。推广来看，恋人之间也有这种现象。相反，一旦形成错误的社会信念，就可能引发他人做出某些行为反应以支持这些信念，即<strong>行为确证</strong>。</p>
<p>确认他人期望的倾向具有局限性，且个体预先告知他人其期望时，可能会引起他人做出行动去克服期望。在采访中，对记者态度不明确的受访者会更经常硬核采访者期望。</p>
<p>整体来看，<strong>对于高效判断的偏向是直觉难以避免误判</strong>，我们直觉思维的缺陷是我们对复杂信息简化加工的心理捷径的副产品。这种直觉有时会让我们进入歧途，但大多数时候确实可以帮助我们做出高效迅速的决定。在有些职业里，需要考虑到这点。比如记者就需要了解如何避免上面这些认知偏见。</p>
<h3 id="行为和态度"><a href="#行为和态度" class="headerlink" title="行为和态度"></a>行为和态度</h3><p>人的态度和行为具有什么关系呢？</p>
<p>ABC：感觉（affect）、行为倾向（behavior tendency）、认知（cognition）三种相互影响</p>
<h4 id="态度决定行为？"><a href="#态度决定行为？" class="headerlink" title="态度决定行为？"></a>态度决定行为？</h4><blockquote>
<p>我们精通并擅长为自己的行为寻找原因，但却非常不善于做我们已找到原因的事 —— Abelson 1972</p>
</blockquote>
<p>社会心理学家最初认为态度和行为并没有明显关联。</p>
<ul>
<li>学生对于作弊的态度和他们实际作弊行为几乎没有关联</li>
<li><strong>道德伪善</strong>：表现出有道德水准，但实际上拒绝付出任何代价</li>
</ul>
<p>因此，寄希望于改变态度来改变行为通常会以失败告终。</p>
<p>而后，社会心理学家发现行为和我们的态度不同是因为有其他因素的影响：</p>
<ul>
<li>外在表现受制于外部因素的影响，比如记名投票和匿名投票结果通常不同。为了避免外部因素的影响，可以使用<strong>伪途径法</strong>，类似“测谎仪”或看起来像“测谎仪”的东西</li>
<li>长期观察个体行为、个体的通常行为，态度对于行为的预测会更明显</li>
<li>测量的态度和行为直接相关时，态度确实可以预测行为</li>
</ul>
<p>在行为是自发做出时，态度会潜在地起作用。当我们思考自己态度时，态度才会影响我们的行为。让人自我觉知或者本身自我意识感强的人，言行的一致性会更高。</p>
<p>总结来看，在限制条件的场景下，态度可以决定行为：</p>
<ul>
<li>其他因素最小化</li>
<li>态度针对具体行为</li>
<li>我们能清除意识到态度</li>
</ul>
<h4 id="行为如何影响态度"><a href="#行为如何影响态度" class="headerlink" title="行为如何影响态度"></a>行为如何影响态度</h4><blockquote>
<p>我们会逐步相信我们坚持的东西</p>
</blockquote>
<p>下面一些现象都说明着，行为能影响态度，形成信念，被人所接受</p>
<ul>
<li><strong>角色扮演</strong>，扮演一种新的社会角色时，起初我们可能会觉得虚假，但很快就能适应（融入角色、融入环境）。比如演员们入戏。</li>
<li><strong>语言变成信念</strong>，当一个人的话没有可以信服的外在解释时，语言就会变成信念。<strong>我们倾向于根据听众调整说话内容</strong>，并在说过之后相信歪曲的信息</li>
<li><strong>登门槛现象</strong>，即<strong>想让人帮大忙第一个有效策略是先请他们帮个小忙</strong>。当人们<em>承诺</em>公众行为并且认为这些行为是自觉作出时，他们会坚信自己的所作所为。商家的<strong>低价法策略</strong>就是利用了这一点。已经进行的行为会说服自己。</li>
<li>邪恶的行为会侵蚀人的良心，通常导致攻击者贬抑受害者，以此为行为正当性辩护</li>
<li>对他人的积极行为会增强对那个人的好感度，下次希望别人对自己有好感时，可以尝试引导别人对自己表露出积极行为</li>
<li>我们会相信自己所坚持的所作所为，即使行为是受外在推动。政治仪式就是一个例子：唱国歌，参加演习。</li>
</ul>
<h4 id="行为为何会影响态度"><a href="#行为为何会影响态度" class="headerlink" title="行为为何会影响态度"></a>行为为何会影响态度</h4><p>有三个理论：<strong>自我展示：印象管理</strong>、<strong>自我辩解：认知不协调</strong>和<strong>自我知觉</strong>。</p>
<p><strong>自我展示</strong>认为人们行为改变的态度实际上是人们想给别人留下好印象，毕竟没有人愿意看起来自我矛盾。</p>
<p><strong>自我辩解</strong></p>
<p><strong>认知不协调</strong>理论由费斯汀格（Leon Festinger）提出。它认为两种想法或认知在心理上不一致时，我们就会感到失调（即紧张）。因此我们要保持行为和认知间的一致性。理论主要用来解释态度和行为间的矛盾关系。</p>
<p>在此基础上，有个有趣的发现是，在行为的<strong>理由不足</strong>时，人们会更可能感到不舒服，因此要更相信自己的所作所为。这带来的应用有：</p>
<ul>
<li>温和地告诫不能为他们的所作所为（比如打扫房间）提供充分理由，孩子更可能将行为内化为合理且自发的。</li>
<li><strong>如果我们觉得要对自己行为负责时（而不是为了应付命令），我们的态度就会依从行为</strong>。鼓励和诱导好的行为可以激发孩子内化正确的态度</li>
</ul>
<p>另外，当做出重要决策时，我们经常会过高评价自己的选择，而贬低放弃的选择，以此减少不协调程度。从而很轻易地带来决定——变成——信念。比如，当我们决定机票在1000元以下就坐飞机时，我们已经在想象坐飞机时的情景，机票涨到1000元以上时，我们很可能仍然会选择坐飞机。</p>
<p><strong>自我知觉</strong></p>
<p><strong>自我知觉理论</strong>由贝姆（Daryl Bem）提出，它假设我们在态度还<strong>摇摆不定</strong>时，会处在局外人的态度观察自己，从而通过行动<strong>揭露</strong>自己的态度。比如，第二天要考试，前一天翻来覆去睡不着，我发现我失眠了，我意识到我很焦虑。</p>
<p>我们的表情和情态可以放大自我知觉，比如在害怕的时候哼一首愉快的小曲也许真有帮助。模仿别人表情和情态时，我们更能体验到别人的感受。实际上，我们在和他人交流时，通常通过保持行动、姿势等一致而让彼此感到和蔼可亲，从而造成<em>情绪传染</em>的效果。面部表情甚至也会影响我们的态度。比如在听取观点时，被要求保持点头姿势的人更容易同意此观点。</p>
<p>由于我们通过观察周围情境来解释自己的行为，自我知觉理论推导出一个结论：<strong>不必要的报酬会带来隐性的代价</strong>。给人们报酬让他们做自己喜欢的事会让他们将行为归因于报酬，从而削弱他们的自我知觉，即<strong>过度合理化效应</strong>。更准确地说：</p>
<ul>
<li>如果报酬和赞赏是针对人们的成就，则会增加个体的内部动机</li>
<li>如果报酬是为了控制人们，而且人们也相信了是报酬导致了努力，那么会降低个体对工作的内在兴趣</li>
</ul>
<p>因此，要<strong>适当地</strong>给予报酬：提供充分的理由，基于报酬和赞赏。抑或，反其道而行之，削减一些行为，比如寓言故事里说的，花钱让小孩制造噪音，再逐渐减少报酬，从而让小孩不再制造麻烦。</p>
<p><strong>理论对比</strong></p>
<p>认知不协调主要用来处理<strong>言行不一致</strong>的情况。言行不一致，不协调激活时，还会伴随排汗量增加、心率加快等生理表现，因为它会威胁到我们对自我价值的积极体验。自我知觉较弱的人，不协调感也会较弱。</p>
<p>自我知觉理论主要用在没有自我矛盾，态度并未完全形成时，它可以很好解释态度如何伴随行动形成和明确。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>要想养成习惯，那就去付诸行动。 —— 埃皮克提图</p>
</blockquote>
<blockquote>
<p>没有反应就没有接受，没有相关表达就不会产生印象</p>
</blockquote>
<p>行为可以改变态度。我们用语言去解释某事时，会记得更牢。当你想形成某种态度时，不妨用行动去塑造。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/29/quantum-physics-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/29/quantum-physics-history/" class="post-title-link" itemprop="url">量子物理简史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-29 00:46:44" itemprop="dateCreated datePublished" datetime="2019-06-29T00:46:44+08:00">2019-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-07-06 20:53:12" itemprop="dateModified" datetime="2019-07-06T20:53:12+08:00">2019-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%85%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">故事</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/29/quantum-physics-history/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/29/quantum-physics-history/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>全文摘录于<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25742211/">《上帝掷骰子吗？》</a>，看完回味之余，觉得有必要整理下量子物理发展过程中比较重要的瞬间和那些颠覆认知的概念。</p>
</blockquote>
<h2 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h2><p>光是什么？自古以来科学家众说纷纭，但大体分为微粒说和波动说两派。最初微粒说以<strong>直线传播</strong>和<strong>反射</strong>作为依据；波动说借<strong>衍射</strong>发展起来，但是人们认为光是种<strong>纵波</strong>，所以必须借助<strong>光以太</strong>这种虚无缥缈的物质而存在。</p>
<p>17世纪，格里马第认为颜色是因为光波频率不同引起，并得到<strong>胡克</strong>支持；牛顿在1672年完成光的色散试验后，认为光的复合和分解是不同颜色微粒的混合和分开，光是一种粒子，受到胡克和波义耳的批评后与胡克交恶。而后惠更斯引入<strong>波前</strong>的概念，以波动学的角度成功推导出光的反射和折射定律。而后牛顿环被发现，可以很轻松地被惠更斯的理论证明，自此波动说占据上风。</p>
<p>1704年，胡克死后次年，牛顿出版《光学》一书，以粒子说的角度分析了光的种种实验现象，并将之与自己的力学体系结合在一起。那时的牛顿出版了《数学原理》，且是微积分的发明人（尽管和莱布尼兹有争议），同时在政府担任要职，风头无二。从此，<em>第一次波粒之争</em>中微粒说以压倒性优势盖过波动说，大获全胜。</p>
<p>1804年，托马斯·杨在他的《自然哲学讲义》中描述他所做的<strong>光的双缝干涉</strong>实验，干涉形成的明暗条纹可以很好地被波动说解释。在发现无法更好解释时，微粒说以马吕斯在1809年发现的光偏振反驳。1819年，菲涅尔采用波动说很好地解释了光的衍射，泊松将之应用到圆盘衍射时，发现推导出阴影中心会出现一个亮斑，即<strong>泊松亮斑</strong>，并被阿拉果实验验证。同时，为了解释光的偏振，菲涅尔认为光是一种横波，而非纵波，并在1821年成功从理论中推导出偏振现象。最后1850年，傅科实验测量出光在水中的速度小于真空，从而奠定了波动说在<em>第二次波粒之争</em>中的胜局。</p>
<p>波动说并非没有弱点，因为光这种“横波”的传播速度如此之快，它的介质“以太”一定坚硬无比，但是一粒小小的灰尘就可以阻挡光的传播，这似乎又是匪夷所思的。波动说的解释是以太是稀薄且静止的。虽然有些牵强，但随着1856、1861、1865年麦克斯韦三篇电磁理论的论文发表，麦克斯韦预言光是电磁波的一种。1887年被赫兹的实验证实。自此波动说一统天下，此时的物理，经典力学、经典电动力学和经典热力学构成了经典物理的三大支柱，在当时看来，一切物理现象都在人们的控制之中，这个世界的所有基本原理都已经被发现。</p>
<h2 id="乌云"><a href="#乌云" class="headerlink" title="乌云"></a>乌云</h2><p>黄金时代的喜悦没有维持太久，而后一些科学发现让科学家感受到不详的预兆：</p>
<ul>
<li>1895年，伦琴发现X射线</li>
<li>1896年，贝克勒尔发现铀元素的放射性</li>
<li>1897年，居里夫人和她的丈夫研究了放射性，并发现了其它放射性元素</li>
<li>同年，J.J. 汤姆逊在研究阴极射线时发现电子</li>
<li>1899年，卢瑟福发现元素嬗变</li>
</ul>
<blockquote>
<p>The beauty and clearness of the dynamical theory, which asserts heat and light to be modes of motion, is at persent obscured by two clouds</p>
</blockquote>
<p>1900年，在开尔文的一次演讲中第一次提到“乌云”一词，其中提到的两朵乌云分别是：</p>
<ul>
<li>1881、1886年，迈克尔逊-莫雷实验否定了以太的存在</li>
<li>经典物理在黑体辐射研究中的困境</li>
</ul>
<p>前者导致了相对论的诞生，后者催生了量子论。</p>
<p>在黑体辐射中的困境是，针对能量分布和温度以及波长的关系，维恩得出的分布公式和瑞利金斯公式分别在长短波方面贴合实验结论。1900年，普朗克凑出了普朗克黑体公式，能完美符合各个波长上的实验结果。</p>
<p>在尝试使用经典物理学推出这个公式失败后，普朗克<strong>不得不</strong>做出这样的假定：<strong>能量在发射和吸收时，不是连续不断的，而是分成一份一份的</strong>。对于能量的最小单位，普朗克称为“能量子”，而后被称为量子（quantum）。量子的能量等于普朗克常数乘以辐射频率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E=hν</span><br></pre></td></tr></table></figure>

<p>那一年，普朗克42岁。</p>
<h2 id="玻尔的原子模型"><a href="#玻尔的原子模型" class="headerlink" title="玻尔的原子模型"></a>玻尔的原子模型</h2><p>在光电效应中，人们发现对于特定金属，能不能打出电子之和光的<strong>频率</strong>有关，而打出电子的多少才和光强有关。特定频率的光打出的电子能量是有一个上限的，这个上限和光强并没有关系。</p>
<p>普朗克1900年的论文发表之初，并没有得到学术界甚至他自己的重视。1905年，爱因斯坦发展了普朗克量子化的思想。提出组成光的能量存在最小单位，称为“光量子”（light quanta），而后被简称为光子（photon）。光是以量子形式吸收能量，是一个瞬时作用，没有累积概念，光子的能量大小只与光频率有关。</p>
<p>1905年爱因斯坦的这篇论文同样并没有受到认同，因为光量子的概念和当时已尘埃落定波动说并不贴合。而后密立根的实验和康普顿研究X射线被自由电子散射时，很好地证明了爱因斯坦的观点。在1910年，索尔维赞助的第一次索尔维会议中，大家对骚动的量子理论莫衷一是。</p>
<p>1912年，考入剑桥的玻尔投入了卢瑟福的门下，这时卢瑟福正为它提出的原子行星模型苦恼。行星模型相对J.J.汤姆逊的枣糕模型更符合α射线轰击金箔的实验，但仍然说明不了为何电子可以稳定地围绕原子核运转。</p>
<p>玻尔受到巴尔末在1885年发现的氢原子谱线公式启发，提出了电子的能级和跃迁的概念。电子只能在特定能级上维持，在能级间跃迁时吸收或释放能量。玻尔的理论可以很好地推导出巴尔末公式，这系列论文发表于1913年。</p>
<p>玻尔模型提出伊始，得到了广泛地实验支持，同时预言了一些新的谱线存在，并很快得到证实。玻尔模型的能级假设十分具有量子化色彩。引入相对论和假定电子具有更多量子数后玻尔-索末菲模型也能成功解释塞曼效应和斯塔克效应（氢原子谱线受电磁场的影响）。通过这个模型，可以推导出一个原子的化学性质和它的最外层电子数相关，从而表现出一定的规律性，这也为周期表的存在提供了理论基础。为了解释电子为何能自发分层，泡利提出“泡利不相容原理”：同一层能容纳的电子数是有限的。</p>
<p>玻尔的量子化模型相对传统的麦克斯韦电磁体系走得实在太远，模型假设电子的能级、轨道是量子化的，但并没有解释为什么，总让人感受到不安稳。同时玻尔体系只能解释只有一个核外电子的原子模型。电子的跃迁时机，模型也无法解释，看似是完全随机的。</p>
<p>20世纪初，德布罗意在他的博士论文中提出，伴随电子运动的有一个超光速的相波，即德布罗意波。凭此论文德布罗意获得了1929年的诺贝尔物理学奖。德布罗意预言的德布罗意波而后被戴维逊和G.P.汤姆逊实验证实。这似乎又掀起了波动说和微粒说的战争。同时，玻色-爱因斯坦统计方法把光子视为不可分割的一种粒子，成功推导出普朗克的黑体辐射公式。波动说和微粒说似乎哪一种都不是、哪一种又都是。</p>
<p>1924年，玻尔、克喇默斯和斯雷特联名发表BKS理论，放弃了光量子假设，试图在波和粒子间建立一种对应，收效并不明显。</p>
<h2 id="决定论？"><a href="#决定论？" class="headerlink" title="决定论？"></a>决定论？</h2><p>在玻尔提出玻尔模型的时候，海森堡受邀前去哥本哈根工作，此时正是1924年，尝试统一微粒说和波动说的BKS理论提出不久，就被实验否定，光量子是实实在在的东西，而非只有统计意义。1925年4月，海森堡结束哥本哈根访问回到哥廷根后，使用矩阵的思路分析原子的运动模型。</p>
<p>海森堡从实验中观测到的，能够实实在在感受到的能级差出发，采用矩阵作为数学工具，将之运用在经典动力学公式中去，把玻尔-索末菲模型旧的量子条件改造成由矩阵推出的公式，进而可以很容易推导出原子能级和辐射频率。在和波恩和约尔当的合作下，海森堡发布《论量子力学》和《论量子力学II》。新体系马上获得巨大成功，矩阵力学在此基础上得到发展。受到海森堡矩阵启发，狄拉克借助泊松括号用更简单的方式相同的理论。乌伦贝克和古兹密特提出自旋模型，并得到矩阵力学支持。海森堡的模型将玻尔模型的范围推广至更广的范围（氦原子）。</p>
<p>1925年，薛定谔受到德布罗意启发，将电子看做德布罗意波，用一个波动方程去表示，从经典的哈密顿-雅克比方程出发，利用变分法和德布罗意公式求出了一个非相对论波动方程，即薛定谔波动方程。通过求解这个方程，可以很轻松地理解电子为何只能在特定能级运行。1926年1到6月，薛定谔一连发表多篇论文，并证明了经典力学知识波动力学的一种特殊表现。</p>
<p>尽管两派互不服气，但是薛定谔、泡利、玻尔等人证明这两种理论在数学上是等价的。在狄拉克的努力下，矩阵力学和波动力学作为一种理论的不同形式体现出来。前者更像微粒说，后者更像波动说。</p>
<p>我们观察下双缝干涉实验。对于波动说，在双缝时，电子可以很好地由薛定谔波动方程去描述，但是若此时关闭了一条缝，实验结果也就变成了一条缝而不是一片区域，电子所在的波到达缝时发生了什么呢。对于微粒说，电子穿过哪条缝似乎是完全随机，不可预期的，同时每个电子穿过狭缝时，是不可能知道狭缝间有多宽，甚至无法知道还存在其他狭缝，那么狭缝背后的干涉条纹的规律性怎么解释呢？更有意思的现象是，如果我们在每条狭缝上安装测量仪器，我们可以发现，每次只能在一条狭缝时测量到电子，但同时干涉条纹会随着测量行为而消失。</p>
<h2 id="哥本哈根解释"><a href="#哥本哈根解释" class="headerlink" title="哥本哈根解释"></a>哥本哈根解释</h2><p>上面提到的现象，似乎隐隐地体现出测量行为对理论表现的影响。海森堡在1927年反复思考矩阵运算中<code>p × q ≠ q × p</code>的特性，如果我们把p和q分别看做观测得到的结果，似乎说明，我们不可能同时观察得到p和q。原因是，观察本身就会影响我们对另一个物理量的测量。经过一阵计算，海森堡得出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">△p × △q &gt; h/4π</span><br></pre></td></tr></table></figure>

<p>△p和△q分别代表对p和对q的测量误差。对其中一种的精确都会影响对另一种的粗略。这个理论被称为不确定性原理，抑或测不准原理。这个误差并不来自于测量仪器，而是在理论上就不可实现，就像永动机。p和q叫做共轭量，动量和位置就是一对共轭量。能量和时间也是一种共轭量，这意味着，对时间的精确会意味能量的模糊，在确定的某一刻，能量甚至可以凭借不确定性凭空出现，，由于质能本质相同，所以每时每刻我们的真空都在“沸腾着”，“幽灵”物质凭空涨落。</p>
<p>在看到海森堡的论文后，玻尔意识到，不确定性原理是具有普遍意义的，它“以一种极为漂亮的手法”显示了不确定性如何应用在量子论中。不确定性建立在波和粒子的双重基础上，<strong>对于粒子属性的了解越多，对于波属性就了解的越少</strong>。</p>
<p>现在回头想一下那个问题：电子究竟是粒子还是波。玻尔认为：</p>
<p>任何时候我们观察电子，它只能表现出一种属性，要么粒子要么是波。但是作为整体来看，它表现出波粒二象性。如果你一定要问，电子<strong>本来</strong>是什么？我只能说我一点也不关心它本来是什么，我只关心我们能“观测”到它是什么。举个例子，我们对大自然的理解实际上都建立在我们观察到它是什么，它本质上是什么对我们没有意义（类似“白马非马”诡辩）。对于电子的观察方式不同，它的表现方式就不同，一旦观察方式确定了，电子就只能以一种特定的形式存在。</p>
<p>这就是玻尔的互补原理。它和波恩的概率解释、海森堡的不确定性三者构成了量子论“哥本哈根解释”的核心。 影响着人们对宇宙的根本认识。</p>
<p>回头再看对电子干涉实验的讨论，观察干涉条纹也好，在狭缝安装仪器也好都是不同的观察方式，得到的结果自然不同。谈论任何物理量都是没有意义的，除非你首先描述测量这个物理量的方式。再说的明确一点，一个物理量如果无法测量，那它就是没有意义的。换言之，不存在一个客观绝对的世界，唯一存在的就是我们能够观察到的世界。</p>
<p>这种解释把观测者和外部宇宙结合在了一起，即不存在一个观测者能独立之外的宇宙。这听上去似乎有点形而上学了。</p>
<p>这个解释当然并不完善，比如在你不观测时，电子以概率波的形式存在于空间，而只要你观察，它的波函数就会随机坍缩到某个具体位置。对此，哥本哈根的解释是，不观测时，对电子的讨论没有意义，只有数学可以描述——波函数，而在观测时才具有实在的意义。</p>
<h2 id="薛定谔的猫"><a href="#薛定谔的猫" class="headerlink" title="薛定谔的猫"></a>薛定谔的猫</h2><p>对于哥本哈根解释，许多科学家是并不能信服的，其中就包括笃信确定论和因果论的爱因斯坦。爱因斯坦认为，观察导致坍缩这一点暗示了某种超距作用，而这是和相对论相违背的。在1927年第五届索尔维会议上，爱因斯坦和玻尔展开了激烈的论战，以玻尔获胜告终。</p>
<p>三年后的第六届索尔维会议，爱因斯坦提出光箱实验反驳海森堡的不确定性原理，被玻尔通过广义相对论的红移效应完美解释。人们似乎感到，上帝真的掷骰子。</p>
<p>1933年，爱因斯坦和他的两个同事波多尔斯基、罗森共同提出“ERP佯谬”（名字来自三个首字母），试图说明量子论是不完备的。下面是一种简化了的版本：</p>
<p>我们想象一个自旋为0的大粒子衰变成两个小粒子，向相反两个方向飞去，两者的自旋方向必定相反。只要我们部去观察，每个例子自旋便都处在上&#x2F;下两种概率的叠加态中，但我们只有观察其中一个例子，如A是上旋，那么B必定是下旋，可问题是B如何在A坍缩至上旋时，一定坍缩为下旋呢？</p>
<p>量子论的解释里面，观察后，例子A坍缩至上旋完全是概率现象，是在被观测一刻才有的意义，粒子B在此刻也会根据A的决定作出相应的坍缩。这个信号是怎么传递的。</p>
<p>玻尔解释说，在观察前，并不存在两个分裂的粒子，它们是一个整体，只能用波函数去描述。所以不存在超光速的信息传递。有意思的是，ERP佯谬是可以被实验证明的。后面也会提到。</p>
<p>相对爱因斯坦的思维实验，薛定谔的实验要更易理解和更出名。在他1935年《量子力学的现状》的第5节。薛定谔描述了著名的“薛定谔的猫”的实验。既然量子效应的匪夷所思还能让人容忍，那就把它放大到宏观世界里。</p>
<p>它设想了一个不透明的箱子，有一个处于衰变和不衰变叠加态的原子，只要原子衰变，就会激发一系列的连锁反应，打破箱子里的毒气瓶，从而杀死箱子里的猫。在量子论的解释里，只要我们不打开箱子，原子处于只能用波函数描述的叠加态中，此时猫也只能处于死和活的概率波叠加态中。这恐怕很难被接受。</p>
<p>那么我们把猫换成人呢？如果他能在纸上写下在箱子内的感受，他会这么认为吗？当然不会，他会坚定的认为自己从头到尾活得好好地，抑或是感觉不太妙。这是因为他作为观察者在箱子内不断观察自己的状态，不停地出发自己的波函数坍缩。</p>
<p>难道人和猫有区别吗？换句话说，难道因为人有能力“测量”自己存活与否（换句话说就是人有“意识”），而猫不能，所以人能让自己的概率波坍缩，而猫只能任由自己停留在死或生的概率波函数中？</p>
<p>真是匪夷所思。</p>
<h2 id="坍缩和平行宇宙"><a href="#坍缩和平行宇宙" class="headerlink" title="坍缩和平行宇宙"></a>坍缩和平行宇宙</h2><p>冯·诺依曼指出使用仪器观测和人来观察并无区别，仪器本身也是由不确定的粒子组成，使用仪器观察只不过把粒子的叠加态转移到了仪器上<strong>，无限复归</strong>，直到人意识的参与。为了避免过于唯心的讨论，恐怕要探究下“意识”究竟是什么。</p>
<p>首先，意识并不是实际的物质存在，它基于我们的大脑而存在，有种观点认为：<strong>意识是组成原子群的一种“组合模式”</strong>，照这么推论一个人的意识理论上是完全可以复制和粘贴的。同时，由于模式才是本质，那么意识的载体并不重要，我们人类的肉体作为意识载体存在完全只是一种选项。意识也可以依附在机器上存在，它不过是输入输出间极为复杂的一种算法加上复杂的数据结构而已。关于意识的更多探讨，可以阅读罗杰·彭罗斯的《皇帝新脑》（原文推荐）</p>
<p>1979年，约翰·惠勒进行了一次<strong>延迟选择实验</strong>，他通过巧妙地设置半透镜的角度使得，在终点处观察者能否观测到光子直接影响光子在起点半透镜的选择。换句话说，观察者决定了光子的历史。推广而言，我们的观测行为本身参与了宇宙的创造过程。这实际上是加强版的<strong>人择原理</strong>。人择原理说，我们存在这个事实本身，决定了宇宙的某些性质是这样而不是那样的。<strong>参与性宇宙</strong>则表明，我们的存在不仅影响了宇宙的性质，甚至参与并创造了宇宙和它的历史。我们选择了宇宙，宇宙又创造了我们。</p>
<p>坍缩这个概念玄之又玄，于是有科学家提出了其他解释。比如艾弗莱特1954年提出了MWI（多世界解释）。按照艾弗莱特的说法，电子穿过双缝后，整个世界本身成为两个独立的叠加，我们观察到电子穿过左缝或右缝，是因为我们碰巧处在对应的分裂出来的宇宙中。<strong>量子过程产生的一切可能都会对应一个实际的宇宙，只不过大多数宇宙中，没有智能生物来提出问题</strong>。多世界解释又被称为平行宇宙。艾弗莱特假定任何孤立系统都必须严格按薛定谔方程演化。虽然宇宙只有一个波函数，但是这个宇宙态矢量十分复杂，它存在于高维甚至无限维的希尔伯特空间中。我们处在的每个世界不过是“真实”矢量在某个方向上的投影。</p>
<p>既然世界是叠加态的，电子也是叠加态的。那为何处在宏观世界的我们从未感受到量子尺度的叠加态呢？</p>
<p>退相干理论的提出尝试回答这个问题。理论提出，我们只谈论微观物体时，牵涉的粒子数很少，模拟它的希尔伯特空间维度自然也较低。但一旦牵扯到仪器或我们本人观察时，我们就引入了一个极为复杂的态矢量和维度极高的希尔伯特空间。这样，在低维空间相干的两个世界在此时被退相干，变得毫无联系，从而让我们感受不到彼此。量子叠加态的在宏观层面的瓦解正是退相干的直接后果。</p>
<p>退相干的提出让我们摆脱了对“观测”，“意识”的哲学讨论。让我们再次可以抽身于环境之外世界。宇宙重新成为唯一的主宰，人和观测者只是它的一部分。但是，为了解释电子行为而把整个宇宙拖下水的做法也受到一些质疑。</p>
<p>“量子自杀”实验在20世纪80年代提出，它实际上是薛定谔的猫的真人版，实验假设把猫换成人。对于哥本哈根解释，伴随原子衰变概率，有一半可能人活着，一半可能人死掉。MWI则认为，一个世界里的你活着，另一个世界的你死掉。然而，多宇宙预言：<strong>永远都会有一个“你”活着</strong>。其中活着的宇宙对你来说才是有意义的。那么为了验证MWI假说是否正确，那么只要做实验的人一直活着就可以了。如果假设成立，不论概率多么低，活着的你必定存在。对一直选择活着分支的你来说，你是“永生”的。这也就是说，如果MWI成立，那么对于某人来说，他无论如何自杀都不会死！因为按照MWI，在每个量子过程中都有两个世界分裂出来，这么多世界中必定包含你活着的那个。那么从该人的视角看，他怎么死都死不了。这就是从“量子自杀”中推出的“量子永生”。推广来看，总存在一些量子效应，使人不会衰老，那么，从主观意义上看，只要一个人有意识，那么他就必定永生。</p>
<h2 id="量子计算机和其他解释"><a href="#量子计算机和其他解释" class="headerlink" title="量子计算机和其他解释"></a>量子计算机和其他解释</h2><p>在量子理论中，一个量子不仅有0或1的可能，还可以表示0和1的叠加态。原来n个bit可以表示的信息，使用量子后可以表示2 ^ nbit。1985年，德义奇证明，量子计算机无法实现超越算法的任务，意味着它只能做普通图灵机能做的。但是计算同样的任务时，它能做的更快。量子计算机进行的是并行计算。当10bits的信息在处理时，量子计算机实际上在操作2 ^ 10 &#x3D; 1024种状态。由于量子态纠缠很容易退相干，目前量子计算机进展有限。</p>
<p>有意思的是，哥本哈根解释和MWI对于量子计算机的算力有着不同的解释。MWI解释里，在n bits的信息处理时，存在着2 ^ n个宇宙的计算机在计算并最后汇总。哥本哈根解释认为，在观测（输出结果）前，宇宙中存在着2 ^ n个叠加的计算机在干活。两种听起来都挺不可思议的。</p>
<p>无论哥本哈根还是MWI在叠加态上的解释都离常识较远。按照德布罗意的思路，有一个导波造成了量子看似的随机性。量子论中一些随机的表现实际上我们不够了解的原因，有一些不可见的变量没有考虑进去才导致了系统的不可预知。一旦把这些额外的变量考虑进去，整个系统又变成完备、确定、可预测的。这种“隐变量理论”在1932年被冯·诺依曼的论文证明不存在。</p>
<p>1952年，大卫·玻姆发现冯·诺依曼推导中的假设存在漏洞，并重新使用“量子势”建立起新的隐变量理论。量子势称，粒子周围散发着一种势场，这种势弥漫在整个宇宙中，每时每刻对环境了如指掌。在电子向双缝进发时，势场会提前发现双缝存在并指导电子的行为。在观测时，测量仪器首先与势场相互作用，这会使电子发生一些微妙的变化。玻姆的理论虽然可以解释量子力学中的现象。恢复了世界实在性（世界可以独立在之外观察）、决定性（现象可预测）的同时但是破坏了定域性（不能存在超距的因果关系）。</p>
<p>1963年，贝尔发展了ERP佯谬，提出和定域性、实在性等价的贝尔不等式。而后在1982年，被阿斯派克特实验证明，粒子间存在违背贝尔不等式，即违背定域性、实在性的行为。而后又被一系列实验验证。说明我们宇宙并不存在定域实在性，即要么选择“观察者”，要么选择“超距信号作用”。</p>
<p>这次爱因斯坦输了，“上帝真得掷骰子”。</p>
<p>除了上面提到的哥本哈根、MWI和隐变量，还有许多别的解释：</p>
<ul>
<li><strong>系综解释</strong>：我们的世界不存在单个的事件，每一个预测都只能是平均的，针对整个集合的。系综说，不要深究具体某个事件的意义，而且我们也不解释单个事件，不确定性在这里只是统计极限。这种解释并没有分析“坍缩”这个难题，只是简单将之踢出了体系之外</li>
<li><strong>GRW理论</strong>（命名取自三个提出者的姓名首字母），理论认为不论宏观还是微观系统，都不可能严格意义上孤立，即与外界毫不相干。它们总是与外界发生交流，受一些随机过程影响，比如位置从弥漫的叠加态变成比较精确的准确位置。但是这种情况出现的概率太低，几乎要等很久很久才会出现一次（按照他们的估计约为）。我们称这种过程为“<strong>自发定域</strong>”。尽管微观粒子自发定域如此之难，但是组成宏观物体的粒子数的量级很高，所以宏观物体内每秒发生着成千上万次自发定域。同时，由于系统内的粒子间相互纠缠，少数几个粒子的自发定域会引起多米诺效应，从而让宏观物体一直处于定域状态。这种定域时间很短，所以我们没法感觉到叠加态（近日耶鲁大学有一篇类似的论文疑似发现了定域、抑或坍缩的发生过程确实是有时间的）。但是GRW解释中抛弃了能量守恒定律，另一方面，如果自发定域的时间和参与的粒子数有关，我们完全有能力安排只用小数量级的粒子去观测，如银离子，这时叠加态维持时间在GRW解释中应该会很久。</li>
<li><strong>退相干历史</strong>，根据这种解释，现实是唯一的，历史是叠加的，“精细历史”间是相关的，但我们并不关心精细历史，我们只关心能观测到的粗略历史。随着历史树向上粗略化，不同历史间退相干。</li>
</ul>
<h2 id="大统一与超弦"><a href="#大统一与超弦" class="headerlink" title="大统一与超弦"></a>大统一与超弦</h2><p>宇宙中存在4种力：</p>
<ul>
<li>引力</li>
<li>电磁力</li>
<li>强相互作用力</li>
<li>弱相互作用力</li>
</ul>
<p>20世纪60年代，弱作用力与电磁力统一成交换“中间玻色子”的力，而后量子色动力学（QCD）尝试统一强作用力。1968年，意大利物理学家韦尼基亚诺通过欧拉β函数提出韦尼基亚诺模型，并被南部阳一郎、萨斯金、尼尔森用来描述粒子，并发展出弦论。但根据弦论推导，我们的时空需要是26维的，因此并不受科学界欢迎。1971年，施瓦兹和雷蒙引入超对称思想，把26维简化为10维，之后施瓦兹和格林完成弦论和超对称结合，得到“超弦”。1982年，通过计算发现，超信理论可以很好地解释引力。1984年，两人发现，在理论自洽下的一些有限情况里，不仅可以包容规范场理论，还能包容粒子的标准模型。从而让超弦理论一炮而红。理论认为，我们生活在一个10维空间里，但是其中6个维度是紧紧蜷缩起来的。当我们把观察尺度降低到普朗克空间尺度上，会发现时空中的一个“点”，实际上是个6维空间，其中6个维度不停扰动，造成了全部的量子不确定性。</p>
<p>1995年，爱德华·威顿在超弦年会上统一了不同耦合常数下的5种弦论，这种统一理论成为“M理论”。目前，超弦理论仍在持续探索之中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/25/dart-best-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/25/dart-best-practice/" class="post-title-link" itemprop="url">Dart快速入门 效率篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-06-25 00:51:28 / 修改时间：00:54:59" itemprop="dateCreated datePublished" datetime="2019-06-25T00:51:28+08:00">2019-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/25/dart-best-practice/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/25/dart-best-practice/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考自<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/effective-dart">Effective Dart</a>，截至2019&#x2F;06&#x2F;12</p>
</blockquote>
<h2 id="通用原则"><a href="#通用原则" class="headerlink" title="通用原则"></a>通用原则</h2><p>类似其他编程语言，有下面两点注意事项：</p>
<ul>
<li>Be consistent, 统一风格</li>
<li>Be brief, 保持精简，DRY</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>指南以下面的关键词开头：</p>
<ul>
<li><strong>要</strong>，一定遵守，下面没有前缀的就是以此开头</li>
<li><strong>不要</strong>，这么做不是个好主意</li>
<li><strong>推荐</strong>，应该遵守，当不遵守时确保有合理理由</li>
<li><strong>避免</strong>，和上面相反，除非有足够好的理由，否则不应该这么做</li>
<li><strong>考虑</strong>，根据实际情况而定</li>
</ul>
<p>同时会提到下面这些客体：</p>
<ul>
<li><strong>库成员</strong>，顶级变量、getter、setter、函数</li>
<li><strong>类成员</strong>，类变量、getter、setter、函数</li>
<li><strong>成员</strong>，库成员或类成员</li>
<li><strong>变量</strong></li>
<li><strong>属性</strong>，类中的成员变量、getter、setter，顶级变量、getter、setter</li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>类名用UpperCamelCase风格</li>
<li>库和文件名用lowercase_with_underscores风格</li>
<li>导入前缀用lowercase_with_underscores风格<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:javascript_utils/javascript_utils.dart&#x27;</span> <span class="keyword">as</span> js_utils;</span><br></pre></td></tr></table></figure></li>
<li>其他标识符使用lowerCamelCase风格</li>
<li><strong>推荐</strong>使用lowerCamelCase风格命名常量<ul>
<li>原因：CAPS_STYLE可读性差&#x2F;可能会用于final变量&#x2F;和枚举不搭</li>
</ul>
</li>
<li>把超过2个字母的缩略词当做一般单词来做首字母大写<ul>
<li>原因：提高可读性</li>
</ul>
</li>
<li><strong>不要</strong>在标识符前加前缀<ul>
<li>举例：<code>kTimes</code></li>
</ul>
</li>
</ul>
<h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><ul>
<li>把”dart:”导入语句放在最前</li>
<li>把”package:”放在相对导入前</li>
<li><strong>推荐</strong>把第三方”package:”导入放在其他语句前</li>
<li>export语句放在最后</li>
<li>按字母序排序</li>
</ul>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><ul>
<li>使用dartfmt帮你美化</li>
<li><strong>考虑</strong>让你的代码更容易美化</li>
<li><strong>避免</strong>每行超过80字符</li>
<li>所有控制结构都使用大括号<ul>
<li>只有if语句写成1行时可以省略</li>
</ul>
</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>使用句子的形式表达注释</li>
<li>用单行注释符表达注释</li>
</ul>
<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><ul>
<li>用<code>///</code>表达文档注释</li>
<li><strong>推荐</strong>为公开API书写注释</li>
<li><strong>考虑</strong>为私有API书写注释</li>
<li>用一句话为文档注释开头</li>
<li>类似git commit message，第一行后空出一行独立成段</li>
<li>去掉能从上下文直接读出的冗余信息</li>
<li><strong>推荐</strong>使用第三人称动词开头表示函数、方法注释</li>
<li><strong>推荐</strong>使用名词短语开头表示变量、成员、getter、setter注释</li>
<li><strong>推荐</strong>使用名词短语开头表示库、类型注释</li>
<li><strong>考虑</strong>在注释中添加示例代码</li>
<li>在注释中用<code>[]</code>方括号引用作用域里的标识符</li>
<li>使用简短平实的语言描述参数、返回值和异常</li>
<li>在注解（annotation）前添加注释</li>
</ul>
<h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p>Dart允许在comment中使用Markdown格式。</p>
<ul>
<li><strong>避免</strong>滥用markdown</li>
<li><strong>避免</strong>使用html格式化文本</li>
<li><strong>推荐</strong>使用反引号（```）格式化代码</li>
</ul>
<h4 id="行文"><a href="#行文" class="headerlink" title="行文"></a>行文</h4><ul>
<li><strong>推荐</strong>简洁清晰</li>
<li><strong>避免</strong>使用缩写和首字母缩略词</li>
<li><strong>推荐</strong>使用“this”而不是“the”来引用实例成员</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>下面的规则是书写Dart代码时需要知道的指导原则，尤其是维护你类库的人。</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><ul>
<li><p>出于历史原因，Dart允许通过<code>part of</code>的方式使用库的一部分文件，使用时通过路径而不是变量名引用</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> my_library;</span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">part</span> of <span class="string">&quot;../../my_library.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">part</span> of my_library</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要从库的<code>src</code>文件夹下引用代码</p>
</li>
<li><p><strong>推荐</strong>使用相对路径应用库，但是不要跨<code>src</code>文件夹引用</p>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>在长字符串场景下，使用邻接字符串而不是“+”链接<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line">raiseAlarm(</span><br><span class="line">    <span class="string">&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27;</span></span><br><span class="line">    <span class="string">&#x27;parts are overrun by martians. Unclear which are which.&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>推荐</strong>使用插值构造字符串</li>
<li><strong>避免</strong>在插值中使用多余的大括号（对于简单的变量）</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li>尽可能使用字面量形式定义集合，必要时提供泛型类型即可<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">var</span> points = [];</span><br><span class="line"><span class="keyword">var</span> userMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">var</span> userMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure></li>
<li>不使用length属性判断集合是否为空，Dart提供了<code>isEmpty</code>和<code>isNotEmpty</code></li>
<li><strong>考虑</strong>使用高阶函数来明确表达你的意图<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aquaticNames = animals</span><br><span class="line">    .where((animal) =&gt; animal.isAquatic)</span><br><span class="line">    .map((animal) =&gt; animal.name);</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>在<code>Iterable.forEach()</code>中使用函数声明，Dart里的<code>for-in</code>循环可以很好完成该工作，当然函数本身已经定义好除外。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> person <span class="keyword">in</span> people) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">people.forEach(<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure></li>
<li>使用<code>iterable.toList</code>替代<code>List.from</code>，只在改变list类型时使用<code>List.from</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a List&lt;int&gt;:</span></span><br><span class="line"><span class="keyword">var</span> iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints &quot;List&lt;int&gt;&quot;:</span></span><br><span class="line"><span class="built_in">print</span>(iterable.toList().runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints &quot;List&lt;dynamic&gt;&quot;:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">List</span>.from(iterable).runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use it with a type</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4</span>]; <span class="comment">// List&lt;num&gt;.</span></span><br><span class="line">numbers.removeAt(<span class="number">1</span>); <span class="comment">// Now it only contains integers.</span></span><br><span class="line"><span class="keyword">var</span> ints = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.from(numbers);</span><br></pre></td></tr></table></figure></li>
<li>使用高级的<code>whereType</code>方法从collection中过滤出特定类型元素<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> ints = objects.whereType&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li>有类似用法时，不使用<code>cast()</code>方法<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuff = &lt;<span class="built_in">dynamic</span>&gt;[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="keyword">var</span> ints = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.from(stuff);</span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">var</span> ints = stuff.toList().cast&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>使用<code>cast()</code>方法，用该方法可能更慢且更有风险，通常情况下有下面一些备选方案<ul>
<li>创建有正确类型的list</li>
<li>使用每个集合元素时进行casting操作<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="keyword">void</span> printEvens(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objects) &#123;</span><br><span class="line">  <span class="comment">// We happen to know the list only contains ints.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> objects) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((n <span class="keyword">as</span> <span class="built_in">int</span>).isEven) <span class="built_in">print</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">void</span> printEvens(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objects) &#123;</span><br><span class="line">  <span class="comment">// We happen to know the list only contains ints.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> objects.cast&lt;<span class="built_in">int</span>&gt;()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n.isEven) <span class="built_in">print</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>真正想要强制类型转换时，使用附加类型的<code>List.from</code></li>
</ul>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>使用函数声明形式命名有名函数（不要使用lambda表达式）</li>
<li>当有有名函数可以完成任务时，不要创建lambda表达式<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line">names.forEach(<span class="built_in">print</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line">names.forEach((name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>使用<code>=</code>分隔入参和它的默认值</li>
<li>不要显式地使用<code>null</code>作为默认值（直接不指定即可）<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> error([<span class="built_in">String</span> message]) &#123;</span><br><span class="line">  stderr.write(message ?? <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>不要显式地使用null初始化变量（语言保证了行为可靠性，不需要再显式设置成null）</li>
<li>不要存储computed value（即可以推算出的值） ，减少冗余信息，保证数据唯一可信源，使用getter和setter去动态推导出它们</li>
<li><strong>考虑</strong>忽略局部变量的类型，Dart有强大的静态分析工具帮你推断类型。</li>
</ul>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><ul>
<li>不要创建没必要的getter和setter</li>
<li><strong>推荐</strong>使用final限定只读属性</li>
<li><strong>考虑</strong>使用<code>=&gt;</code>实现只有单一返回语句的函数，对于多行语句建议还是老老实实使用花括号<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> width =&gt; right - left;</span><br><span class="line"><span class="built_in">bool</span> ready(<span class="built_in">num</span> time) =&gt; minTime == <span class="keyword">null</span> || minTime &lt;= time;</span><br><span class="line">containsValue(<span class="built_in">String</span> value) =&gt; getValues().contains(value);</span><br></pre></td></tr></table></figure></li>
<li>不要使用<code>this.</code>访问成员，除非遇到变量冲突<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    update(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> update(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> update(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尽可能地在定义变量时初始化该值</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>尽可能使用更简洁的初始化形式<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要在初始化形式中定义类型</li>
<li>使用<code>;</code>代替<code>&#123;&#125;</code>表示空方法<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要使用可选的<code>new</code>来返回一个对象<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(<span class="string">&#x27;Increment&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      Text(<span class="string">&#x27;Click!&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要无谓地使用<code>const</code>（基本上const可能出现在所有你能使用<code>new</code>的地方），因为有些语境已经隐式包含了const语义<ul>
<li>字面量集合</li>
<li>const构造函数调用</li>
<li>metadata注解</li>
<li>switch的每一个case</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li>不要在<code>on</code>以外的语句中丢弃错误，因为在没有<code>on</code>限定时，catch会捕获<em>所有</em>异常</li>
<li>要只在编程错误时抛出Error的异常</li>
<li>不要显式地捕获Error及其子类</li>
<li>使用<code>rethrow</code>重新抛出异常</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li><strong>推荐</strong>使用<code>async</code>和<code>await</code>提升你的异步代码可读性</li>
<li>只在必要的时候使用<code>async</code><ul>
<li>代码块中使用了<code>await</code></li>
<li>希望返回一个Future</li>
<li>希望更方便地处理异步中出现的Error</li>
<li>异步事件发生具有先后顺序</li>
</ul>
</li>
<li><strong>考虑</strong>使用高阶函数处理stream</li>
<li><strong>避免</strong>直接使用<code>Completer</code></li>
<li>用<code>Future&lt;T&gt;</code>而不是<code>T</code>判断<code>FutureOr&lt;T&gt;</code>的具体类型</li>
</ul>
<h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>使用一致的术语</li>
<li><strong>避免</strong>缩写，只使用广为人知的缩写</li>
<li><strong>推荐</strong>把描述中心词放在最后</li>
<li><strong>考虑</strong>尽量让代码看起来像普通的句子</li>
<li><strong>推荐</strong>使用名词短语命名非布尔类型的成员或变量</li>
<li><strong>推荐</strong>使用非命令式短语命名布尔类型成员或变量<ul>
<li>比如配合be动词的不同时态，<code>isEnabled</code>, <code>hasShown</code>等</li>
<li>配合助动词，比如<code>hasChildren</code>, <code>canSave</code></li>
</ul>
</li>
<li>有可能的情况下，<strong>考虑</strong>省去上一种情况里的动词</li>
<li><strong>推荐</strong>使用正向含义的布尔类型变量&#x2F;方法名</li>
<li><strong>推荐</strong>使用命令式动词命名带有副作用的函数和方法</li>
<li><strong>考虑</strong>使用名词短语或非命令式动词命名返回数据为主要功能的方法或函数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.elementAt(<span class="number">3</span>)</span><br><span class="line">string.codeUnitAt(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>考虑</strong>使用命令式动词表示你需要对方法所做工作有所关心</li>
<li><strong>避免</strong>使用<em>get</em>开头的命名，它通常能用getter代替</li>
<li><strong>推荐</strong>使用<code>to___()</code>来命名类型转换</li>
<li><strong>推荐</strong>使用<code>as___()</code>来命名类型快照</li>
<li><strong>避免</strong>在命名中使用方法、函数的入参</li>
<li>使用助记符命名类型参数<ul>
<li><code>E</code>代表集合元素</li>
<li><code>K</code>和<code>V</code>代表key和value</li>
<li><code>R</code>代表return type</li>
<li><code>T</code>, <code>S</code>和<code>U</code>命名单一通用且上下文表意清晰的泛型</li>
<li>除上面情况外，可以使用完整词汇作为泛型类型名</li>
</ul>
</li>
</ul>
<h4 id="库-1"><a href="#库-1" class="headerlink" title="库"></a>库</h4><p>下划线开头的成员表示成员是私有的，这个特性是内置在Dart语言中的。</p>
<ul>
<li><strong>推荐</strong>使用私有声明，未用<code>_</code>开头的库中的公开声明、顶级定义表示其他库可以访问这些成员，同时也会受到库实现契约的约束。</li>
<li><strong>考虑</strong>在同一个库内定义多个类，这样便于在类之间共享私有变量</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>Dart是纯OOP的语言，它的所有对象都是类实例。当然不像Java，Dart也允许你定义顶级的变量、函数…</p>
<ul>
<li><strong>避免</strong>定义一个函数就可以实现的只有一个实现方法的抽象类<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Predicate&lt;E&gt; = <span class="built_in">bool</span> <span class="built_in">Function</span>(E element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> test(E element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>定义只有静态成员的类，可以使用顶级变量、函数更方便地实现等价效果。当然，如果变量属于一个组，可以这么实现</li>
<li><strong>避免</strong>不必要地定义子类</li>
<li><strong>避免</strong>实现一个不作为接口的类</li>
<li><strong>避免</strong>mixin不设计用作mixin的类</li>
<li>在你的类支持拓展时，定义好文档</li>
<li>在你的类作为接口存在时，定义好文档</li>
<li>在你的类作为mixin存在时，定义好文档</li>
</ul>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><strong>考虑</strong>在类支持的情况下，让构造函数成为const</li>
</ul>
<h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><ul>
<li><strong>考虑</strong>尽可能地把成员变量和顶级变量定义为final类型</li>
<li>使用setter和getter定义computed value</li>
<li>不要使用没有getter的setter</li>
<li><strong>避免</strong>在返回bool，double，int，num的方法里返回null</li>
<li><strong>避免</strong>在方法中返回this，只为了串联调用函数</li>
</ul>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>Dart中的类型可以帮助使用者理解你API中的静态类型设计，它分两种：类型注解和类型参数。前一种放在变量名前注解变量类型，后一种作为泛型参数传入。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">String</span> parameter) &#123;</span><br><span class="line">  <span class="built_in">bool</span> result = parameter.length == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; ints = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>在未指定类型时，Dart会从上下文自动推断或者使用缺省的<code>dynamic</code>类型。</p>
<p>简言之，Dart提供了强大的类型推导简化了你声明类型的负担，但同时不声明类型会降低API的可读性，下面一些guideline帮你在两点间找到一个平衡。</p>
<ul>
<li><strong>推荐</strong>对于类型表意不清晰的public属性和顶级变量使用类型注解<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">bool</span>&gt; install(PackageId id, <span class="built_in">String</span> destination) =&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> screenWidth = <span class="number">640</span>; <span class="comment">// Inferred as int.</span></span><br></pre></td></tr></table></figure></li>
<li><strong>考虑</strong>对于类型表意不清晰的private属性添加类型注解</li>
<li><strong>避免</strong>为局部变量添加类型注解，如果你需要静态类型提供的便利，可以借助<code>is</code>限制变量类型</li>
<li><strong>避免</strong>在方法表达式上使用类型，考虑到方法表达式通常作为方法入参，类型可以自动推断，不需要类型注解</li>
<li><strong>避免</strong>冗余的泛型和类型注解<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good case</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; things = <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; things = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li>在不希望使用Dart推断的类型时，使用类型注解</li>
<li><strong>推荐</strong>使用显示的dynamic代替Dart推断失败回退的dynamic</li>
<li><strong>推荐</strong>在Function类型注解中添加函数类型签名</li>
<li>不要为setter指定返回值</li>
<li>使用新式的typeof判断类型<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Comparison&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T, T);</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Object</code>代替<code>dynamic</code>表示可以接受任何对象</li>
<li>使用<code>Future&lt;void&gt;</code>作为无返回值的异步函数返回类型</li>
<li>不使用<code>FutureOr&lt;T&gt;</code>作为返回值</li>
</ul>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>避免</strong>位置参数作为可选布尔参数，这样可读性比较差<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad case</span></span><br><span class="line"><span class="keyword">new</span> Task(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Task(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">new</span> ListBox(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Button(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good case</span></span><br></pre></td></tr></table></figure></li>
<li><strong>避免</strong>将用户想忽略的参数放在位置可选参数的前列</li>
<li><strong>避免</strong>使用强制的无意义的参数<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad case</span></span><br><span class="line">string.substring(start, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></li>
<li>使用<strong>左闭右开</strong>区间表示两个参数代表的范围</li>
</ul>
<h4 id="相同判断"><a href="#相同判断" class="headerlink" title="相同判断"></a>相同判断</h4><ul>
<li>覆写<code>==</code>的同时覆写<code>hashCode</code>，默认的哈希函数实现了恒等式哈希。<strong>任何两个相等的两个对象必须具有相同的哈希值</strong>。</li>
<li><code>==</code>需要遵循数学的相等规则<ul>
<li>自反，a &#x3D;&#x3D; a</li>
<li>对称，a &#x3D;&#x3D; b &#x3D;&gt; b &#x3D;&#x3D; a</li>
<li>传递，a &#x3D;&#x3D; b &amp;&amp; b &#x3D;&#x3D; c &#x3D;&gt; a &#x3D;&#x3D; c</li>
</ul>
</li>
<li><strong>避免</strong>为可变对象自定义相等函数，<code>hashCode</code>函数会增加你的工作量</li>
<li>不要在自定义<code>==</code>中判断null，Dart也已经替你做了这部分工作</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/16/dart-lang-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/16/dart-lang-intro/" class="post-title-link" itemprop="url">Dart快速入门 语法篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-06-16 00:13:19 / 修改时间：00:17:49" itemprop="dateCreated datePublished" datetime="2019-06-16T00:13:19+08:00">2019-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/16/dart-lang-intro/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/16/dart-lang-intro/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义个方法。</span></span><br><span class="line">printNumber(<span class="built_in">num</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>.&#x27;</span>); <span class="comment">// 在控制台打印内容。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是程序执行的入口。</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 定义并初始化一个变量。</span></span><br><span class="line">  printNumber(number); <span class="comment">// 调用一个方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注释：<code>//</code>或<code>/* ... */</code>，同其他主流语言</li>
<li>类型：num、String、int、bool等</li>
<li>字面量：42，’Hello world!’</li>
<li>函数：类似<code>print()</code>的形式</li>
<li>字符串插值</li>
<li>入口方法：<code>main</code></li>
</ul>
<h2 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念"></a>基本理念</h2><ul>
<li><strong>所有可以用变量引用的都是对象，每个对象都是一个类的实例</strong>，例如数字、方法、null，<strong>所有对象都继承Object类</strong></li>
<li>Dart是<strong>强类型语言</strong>。但是不强制使用类型标注，因为它可以通过推导得到变量类型。在你明确不希望有类型时，使用<code>dynamic</code>关键字表示动态类型</li>
<li>Dart支持泛型，比如<code>List&lt;int&gt;</code></li>
<li>Dart支持顶级方法<code>main()</code>，支持类的静态方法、实例方法，也可以在函数内使用函数</li>
<li>类似地，Dart支持全局变量、局部变量和在类中定义的成员变量</li>
<li>Dart<strong>没有</strong>public、protected、private的区分，如果标识符以<code>_</code>开头，那么该标识符就是私有的</li>
<li>Dart的变量名只能以<strong>下划线和字母</strong>开头，后跟<strong>字符或数字</strong></li>
<li>Dart区分语句块和表达式，只有表达式有值。</li>
</ul>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>分为三类：</p>
<ul>
<li>对于只在特定上下文环境下生效的<strong>上下文关键字</strong>，可以用作标识符</li>
<li>对于<strong>内置标识符</strong>，为了便于移植JavaScript代码到Dart，这些关键字不可用作类或类型名或import的前缀</li>
<li>其他关键字为保留字</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Dart&#x27;</span>;</span><br><span class="line">Dynamic name = <span class="string">&#x27;Dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据<em>基本理念</em>，变量都是存储值的引用。使用<code>var</code>修饰时，变量类型会自动推导；也可以显示声明变量类型，或者使用<code>dynamic</code>关键字表示变量可能有多种类型。</p>
<p>任何没有初始化的变量默认值都为null。</p>
<p>常量使用<code>final</code>或<code>const</code>（实例变量只能用<code>final</code>）。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> title = <span class="string">&#x27;FE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> percent = <span class="number">0.314</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span>[];</span><br><span class="line"><span class="keyword">const</span> baz = []; <span class="comment">// 和上面一个效果</span></span><br></pre></td></tr></table></figure>

<ul>
<li>final变量只能赋值一次，const变量是编译时常量。</li>
<li><code>const</code>除了用来定义不变量，还可以用来创建不变的值，以及定义创建常量的构造函数。在这么用时可以省略构造过程，像上面的baz变量一样</li>
</ul>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists (也被称之为 arrays)</li>
<li>maps</li>
<li>runes (用于在字符串中表示 Unicode 字符)</li>
<li>symbols</li>
</ul>
<p>再次重申，Dart中变量都是一个对象，所以你都可以使用构造函数来初始化。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>有<code>int</code>和<code>double</code>两种类型。提供了原生操作符和<code>abs()</code>等常用函数，整数和浮点数的字面量初始化类似js。</p>
<p>字符串和数字互转：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(onePointOne == <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">&#x27;3.14&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Dart的字符串是UTF-16编码的字符序列。可以使用单引号或双引号创建。字符串中用<code>$&#123;expr&#125;</code>的语法使用表达式，**如果表达式是一个标识符，可以省去<code>&#123;&#125;</code>**，对<code>&#123;&#125;</code>内的表达式，Dart使用<code>toString()</code>方法转成字符串使用。</p>
<p>使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>表示多行字符串。使用<code>r&#39;&#39;</code>表示纯字符串。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>布尔类型有两个字面量值，<code>true</code>和<code>false</code>。和JavaScript不同的是，在<code>if</code>语句等使用bool类型的地方，<strong>只有<code>true</code>被认为是true，其余所有值都是false</strong>。这也是为了避免JavaScript中判断true、false时坑爹的地方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;JS prints this line.&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Dart in production mode prints this line.&#x27;</span>);</span><br><span class="line">  <span class="comment">// However, in checked mode, if (1) throws an</span></span><br><span class="line">  <span class="comment">// exception because 1 is not boolean.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List的字面量写法和JavaScript一样。Dart会做类型推导，在元素类型不一致时报错。你可以使用const语句定义一个不变的List对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>2.3后，Dart支持<code>...</code>解构操作符，以及对空列表兼容的<code>...?</code>。同时支持collection if和collection for语法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = [</span><br><span class="line">  <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Furniture&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Plants&#x27;</span>,</span><br><span class="line">  <span class="keyword">if</span> (promoActive) <span class="string">&#x27;Outlet&#x27;</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> listOfInts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> listOfStrings = [</span><br><span class="line">  <span class="string">&#x27;#0&#x27;</span>,</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> listOfInts) <span class="string">&#x27;#<span class="subst">$i</span>&#x27;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>2.2版本后支持</p>
</blockquote>
<p>一组元素唯一的无序列表。字面量写法类似数学中集合的定义方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> halogens = &#123;<span class="string">&#x27;fluorine&#x27;</span>, <span class="string">&#x27;chlorine&#x27;</span>, <span class="string">&#x27;bromine&#x27;</span>, <span class="string">&#x27;iodine&#x27;</span>, <span class="string">&#x27;astatine&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用构造函数的方式创建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line">elements.add(<span class="string">&#x27;fluorine&#x27;</span>);</span><br><span class="line">elements.addAll(halogens);</span><br></pre></td></tr></table></figure>

<p>类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>表达键值对数据，每个键只出现一次，且<strong>可以是任意类型</strong>。类似Set，可以使用字面量和构造函数两种方式构造。使用字面量时，Dart会做类型推导。</p>
<p>Map的设置和JavaScript类似，另外类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>
<h3 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h3><p>Dart用Rune类型表示UTF-32的字符，如emoji等。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>用来代表Dart中声明的操作符或标识符，可以在标识符前添加<code>#</code>获取标识符的Symbol对象。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>类似JavaScript，Dart中的Function也是对象并具有Function类型。推荐使用显式类型声明方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dart支持箭头函数。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数分两种：命名参数、位置参数。</p>
<p>命名参数使用<code>param: value</code>指定，在调用时使用<code>&#123;param1, param2&#125;</code>的形式传递参数。支持在参数前添加<code>@required</code>表示参数必选。</p>
<p>位置参数使用<code>[]</code>包裹方法参数，使用时不传参数即可。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>定义方法时，可以使用<code>=</code>定义可选参数的默认值。否则默认值为null。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>每个应用都需要有顶级的<code>main()</code>函数作为入口，返回值void类型，并且有可选的<code>List&lt;String&gt;</code>参数（用于解析命令行输入的参数数据）。如</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">&quot;#sample_text_id&quot;</span>)</span><br><span class="line">    ..text = <span class="string">&quot;Click me!&quot;</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>..</code>语法为级联调用，表示在一个对象上执行多个操作。</p>
</blockquote>
<h3 id="第一公民"><a href="#第一公民" class="headerlink" title="第一公民"></a>第一公民</h3><p>类似JavaScript，Dart中Function可以作为参数、返回值、变量、对象使用。同样也有匿名函数可以使用，区别是箭头后是语句块时，不使用箭头，只在之后是表达式时使用箭头。</p>
<h3 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h3><p>Dart是静态作用域，即变量的作用域在写代码时就确定了，作用域层级即大括号的层级。</p>
<p>类似JavaScript，Dart的闭包意味着方法可以封闭其作用域内的变量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Returns a function that adds [addBy] to the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">function&#x27;s argument.</span></span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// Create a function that adds 2.</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function that adds 4.</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>所有函数<strong>必须返回一个值</strong>，否则默认<code>return null</code>。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li><code>~/</code>返回取整截断的商</li>
<li>使用<code>==</code>判断相等性<ul>
<li>会调用左侧对象的<code>==</code>方法，和后面的对象对比</li>
</ul>
</li>
<li>类型转换：<ul>
<li><code>as</code>，类型转换，类似typescript中的as</li>
<li><code>is</code> 判断对象是否是指定类型</li>
<li><code>is!</code> 判断对象是否不是指定类型</li>
</ul>
</li>
<li><code>??=</code>在value不是null时赋值给变量</li>
<li><code>expr1 ?? expr2</code>表示如果expr1是非null则返回其值，否则执行expr2并返回</li>
<li><code>..</code> 级联操作符，表示在一个对象上连续调用多个函数以及访问成员变量，可以嵌套</li>
<li><code>?.</code>和<code>.</code>类似，但是在左侧操作对象为null时返回null<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>for循环中，Dart会自动捕获当时的index索引值，避免JavaScript中问题。对interable的对象可以使用<code>forEach()</code>方法遍历，对List、Set还支持<code>for-in</code>形式的遍历</li>
<li><code>switch</code>中的每个case（除了空case）都必须有<code>break</code></li>
<li><code>assert</code>在检查模式下会被跳过</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>和JavaScript中的异常类似。</p>
<p>不一样的是，可以使用<code>on</code>或<code>catch</code>捕获异常，可以通过<code>rethrow</code>在其中重新抛出异常。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>构造方式类似ES6中引入JavaScript Class。</li>
<li>用成员方式声明的类变量在定义时初始化，也就是在构造函数前</li>
<li>可以使用Object的runtimeType属性来判断实例的类型</li>
<li>使用const关键字结合构造函数可以构造出不可变的对象实例</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>使用和类名同名的方法作为构造函数（或者使用<em>命名构造函数</em>）。因为把构造函数参数赋值给实例变量的场景太常见了，Dart提供了下面的语法糖。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用命名构造函数实现多个构造函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    y = json[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类不会从父类继承构造函数</strong>，在未定义构造函数时，会有一个默认构造函数，这个函数没有参数，且会调起父类的没有参数的构造函数。</p>
<p>在有初始化参数列表（initializer list）的情况下，初始化参数列表在父类构造函数前执行。</p>
<ol>
<li>初始化参数列表</li>
<li>父类无参构造函数</li>
<li>子类无参构造函数</li>
</ol>
<p>父类没有无参构造函数时，需要手动调用父类的其他构造函数。</p>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>在执行父类构造函数前，可以初始化实例参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initializer list sets instance variables before</span></span><br><span class="line">  <span class="comment">// the constructor body runs.</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">        y = jsonMap[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在冒号右边用逗号隔开初始化表达式。注意：等号右边无法访问<code>this</code>。</p>
<h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>重定向构造函数没有代码，<strong>在构造函数声明后</strong>，用冒号调用其他构造函数</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果类支持提供状态不变的对象，需要定义一个<code>const</code>构造函数，且所有类变量都要是<code>final</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>当你的构造函数不需要返回新对象，而从其他地方获取时（如缓存），使用工厂构造函数。**工厂构造函数内无法访问<code>this</code>**。调用时方式和普通构造函数等同。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>类方法可以访问<code>this</code>，另外对于类对象的每个属性都有隐含的getter和setter（final除外）。也可以显式使用<code>get</code>和<code>set</code>定义getter和setter的行为。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Dart使用<code>extends</code>继承，用<code>super</code>指代父类，用<code>@overide</code>注解重载操作。</li>
<li>Dart中有抽象类&#x2F;抽象方法，设计和使用类似Java的抽象类&#x2F;抽象方法。如果你希望抽象类可实例化，可以定义一个工厂工造函数。</li>
<li>每个类都隐式的定义了一个包含所有实例成员的接口，通过使用<code>implement</code>实现若干其他类的API（不包括构造函数）</li>
<li>可以重载一些操作符，如<code>+</code>, <code>-</code>, <code>[]</code>, <code>&gt;&gt;</code>等，实现在特定类上的特定表现</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Overrides + (a + b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Overrides - (a - b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是，Dart提供<code>noSuchMethod()</code>方法，在访问不存在的类实例或方法时被调用。如果没有填写，默认使用Object的同名方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@proxy</span><br><span class="line">class A &#123;</span><br><span class="line">  void noSuchMethod(Invocation inv) &#123;</span><br><span class="line">     print(&#x27;You tried to use a non-existent member: &#x27; +</span><br><span class="line">        &#x27;$&#123;inv.memberName&#125;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是特殊的类，使用<code>enum</code>关键字定义。每个枚举值都有index属性的<code>getter</code>函数，枚举的<code>values</code>常量可以返回所有枚举值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>

<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>Dart中提供了<strong>多类继承</strong>中重用类代码的mixin，用<code>with</code>结合mixin类实现，这种类没有构造函数。除非你想像正常类一样使用mixin，否则使用<code>mixin</code>关键字。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当限制mixin只在特定类中使用时，结合<code>on</code>让mixin也能调用父类方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类变量、函数"><a href="#类变量、函数" class="headerlink" title="类变量、函数"></a>类变量、函数</h3><p>使用<code>static</code>前缀修饰，表示类级别的变量、函数。类变量只在第一次使用时初始化。静态方法无法访问this。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型的两个动机：</p>
<ul>
<li>有助于IDE、环境、同事帮你定位问题和代码自动生成</li>
<li>减少重复代码</li>
</ul>
<p>List和Map的泛型定义类似C++风格。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>: <span class="string">&#x27;Homepage&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>: <span class="string">&#x27;Hints for web robots&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>: <span class="string">&#x27;We are people, not machines&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">var</span> views = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在泛型中使用<code>extends</code>可以限制泛型的具体类型。在1.21之后，Dart支持泛型函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>使用<code>import</code>和<code>library</code>引入和导出模块。<code>_</code>开头的标识符只在库内部可见。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:mylib/mylib.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:utils/utils.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;  <span class="comment">// 指定库前缀，避免重名</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo; <span class="comment">// 部分导入</span></span><br></pre></td></tr></table></figure>

<p><code>dart:</code>开头代表内置库，<code>package:</code>开头代表外部库。外部库使用<code>pub</code>包管理器管理。</p>
<h3 id="懒加载库"><a href="#懒加载库" class="headerlink" title="懒加载库"></a>懒加载库</h3><p>懒加载即在使用时再加载库，如优化app启动时间，加载很可能用不到的功能。</p>
<p>加载时使用<code>deferred as</code>导入，使用<code>loadLibrary()</code>方法加载。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:deferred/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p>Dart中返回<code>Future</code>和<code>Stream</code>的方法都是异步的，意味着设置好耗时操作（I&#x2F;O）后就返回。类似ES7中的<code>await</code>和<code>async</code>，你也可以像组织同步代码一样组织你的异步代码。</p>
<p>Dart中声明异步方法是<strong>在函数名后加入async</strong>，这类方法返回一个<code>Future</code>对象，了解JS中<code>Promise</code>的同学可以很快理解Future是做什么的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something else.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回值是Stream时，使用<code>await for</code>的形式接收Stream中的数据。另外别忘了用<code>async</code>修饰外界函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>惰性生产数据，类似ES6中的<code>function*</code>。Dart提供两种类型：</p>
<ul>
<li>同步：返回Iterator</li>
<li>异步：返回Stream</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可调用的类"><a href="#可调用的类" class="headerlink" title="可调用的类"></a>可调用的类</h2><p>类中实现了<code>call()</code>方法时，类实例可以当做方法调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">wf(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类似typescript中的interface定义，Dart可以借助<code>typedef</code>进行一些更复杂的类型判断。typedef只是类型别名的一种说法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare); <span class="comment">// True!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>使用元数据给代码添加额外信息，也能便于文档自动生成。</p>
<ul>
<li><code>@deprecated</code></li>
<li><code>@override</code></li>
<li><code>@proxy</code></li>
</ul>
<p>你还可以自定义自己的元数据注解：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;todo.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@todo</span>(<span class="string">&#x27;seth&#x27;</span>, <span class="string">&#x27;make this do something&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行，<code>//</code></li>
<li>多行，<code>/**/</code></li>
<li>文档注释， <code>///</code>开头，或<code>/**</code>开头，<code>*/</code>结束</li>
</ul>
<p>遵守规范的注释风格会有助于文档自动生成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/05/28/the-pragmatic-programmer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/05/28/the-pragmatic-programmer/" class="post-title-link" itemprop="url">《程序员修炼之道》 —— 从小工到专家</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-28 23:55:53" itemprop="dateCreated datePublished" datetime="2019-05-28T23:55:53+08:00">2019-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-29 01:42:03" itemprop="dateModified" datetime="2019-05-29T01:42:03+08:00">2019-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/05/28/the-pragmatic-programmer/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/05/28/the-pragmatic-programmer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《程序员修炼之道》这个书名实际上不如原版《The Pragmatic Programmer： From Journeyman to Master》来得更清晰明了。此书第一版写于1999年，我看的是11年的版本，但还是透流露着不少世纪初的观念和视野。除开一部分观点认识的过时，书中绝大多数观点都四溢着国外互联网行业的工作风格和流程，和国内凶猛生长、一把梭就是干的风格各有不同，甚至我感觉国内IT，尤其是互联网企业里的工作流更加讲求实效。尽管和读之前的预期不大一样，里面许多经验还是很有借鉴意义，比如正交性、不要依赖巧合等等。</p>
<p>书中内容在项目管理、编程哲学、以及编程过程的各个方面都有涉及，在这些方面上更加深入的探讨，书的最后也推荐了继续阅读的材料。下面就各章节的关键观点加以整理。</p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>关于本书的读法：</p>
<ul>
<li>能不能让正确原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志</li>
<li>要能内化书中提到的各个小提示，不实践的话，是不会有太大收获的</li>
<li><strong>思考，你的工作</strong>，多思考</li>
</ul>
<h2 id="实效哲学"><a href="#实效哲学" class="headerlink" title="实效哲学"></a>实效哲学</h2><ul>
<li><strong>对你的源码负责</strong></li>
<li><strong>不要容忍破窗</strong>，它们会增大你软件的熵（这个也是要结合实际情况看的）</li>
<li><strong>记住大图景</strong>，注意方向是否有误，不要光低头做事</li>
<li><strong>知道在何时打住</strong>，你不可能做到完美</li>
<li><strong>定期为你的知识资产投资</strong>，就像经济投资一样<ul>
<li>定期投资</li>
<li>多元化</li>
<li>管理风险，不要把所有技术放在一个篮子里</li>
<li>低买高卖，能看清形势</li>
</ul>
</li>
<li>为此，你需要<ul>
<li><strong>每年至少学习一种新语言</strong></li>
<li><strong>每季度阅读一本技术书籍</strong></li>
<li>也要阅读非技术书籍</li>
</ul>
</li>
<li><strong>批判地思考你读到和听到的</strong></li>
<li><strong>如何表达自己很重要</strong>，这会增加你的影响力<ul>
<li>你想让谁知道</li>
<li>你想让他们知道什么</li>
<li>他们是否感兴趣</li>
<li>他们需要知道细节么</li>
<li>如何促使他们与你交流</li>
</ul>
</li>
</ul>
<h2 id="实效途径"><a href="#实效途径" class="headerlink" title="实效途径"></a>实效途径</h2><ul>
<li><strong>DRY，不要重复自己</strong><ul>
<li>强加的重复 &#x3D;&gt; 使用自动生成，减少是信息冗知识</li>
<li>无意的重复 &#x3D;&gt; 优良的设计</li>
<li>无耐心的重复 &#x3D;&gt; 考虑长远</li>
<li>开发者间的重复 &#x3D;&gt; 加强组内交流，制定代码规范，<strong>制造更容易复用的环境</strong></li>
</ul>
</li>
<li><strong>减少无关事物的影响</strong>，非正交 &#x3D;&gt; 次级效应 &#x3D;&gt; 补偿行为 &#x3D;&gt; 经验依赖<ul>
<li>好处：提高生产率（促进复用）、降低风险（风险隔离，易测试）</li>
<li>分层设计、抽象和接口约定</li>
<li>避免使用全局变量</li>
<li>考虑使用库的代码侵入性</li>
<li>文档和认同正交性</li>
</ul>
</li>
<li><em>不存在最终决策</em>，当需求变动频繁的时候，不仅要思考程序架构如何适应这种变动，也要反思是否是设计者没想清楚到底要做什么</li>
<li><strong>使用曳光弹找到目标</strong>，即MVP + 快速迭代 + 即时的反馈<ul>
<li>逐步逼近，摸着石头过河</li>
<li>曳光弹模式永远包含着一个可用的软件版本</li>
</ul>
</li>
<li><strong>原型和便笺</strong>，使用原型去表达和快速验证项目的可行性</li>
<li><strong>靠近问题领域编程</strong><ul>
<li>使用DSL（Domain Specified Language）</li>
</ul>
</li>
<li><strong>估算，以避免意外</strong>，主要用来估计工期、分析风险<ul>
<li>适当地降低估算速度，慎重思考隐藏的风险</li>
</ul>
</li>
</ul>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><p>工具成为双手和大脑的延伸，优秀的工具可以放大你的才干。</p>
<ul>
<li><strong>纯文本以其自解释能力几乎可以永久保存</strong>，XML、JSON就是利用此成为通用的数据表现形式</li>
<li><strong>利用shell的力量</strong>，它是自动化任务避不开的工具</li>
<li><strong>要能烂熟地使用你的编辑器</strong>、<strong>要使用高级的编辑器</strong>，由于你的所有开发工作都建立在它上面，做好这两点可以节省你大量时间<ul>
<li>反思一下，在用你的编辑器时，你有遇到过到比较繁琐的操作吗？</li>
<li>是因为你不会高级使用方式，还是编辑器本身不支持？</li>
</ul>
</li>
<li><em>总是使用源码控制</em>（这一点早已成为共识）</li>
<li>调试，debug<ul>
<li><strong>通常认为匪夷所思的bug，都来自健忘、自大和愚蠢</strong></li>
<li>QA角色的重要性之一：帮助复现、找到规律性</li>
<li>橡皮鸭调试法</li>
<li><strong>二分查找法</strong></li>
<li>如果bug来自某人的错误假设，那么需要清除团队其他人的相同误解</li>
</ul>
</li>
<li><strong>学习一种文本操纵语言或工具</strong>，例如awk，sed，处理数据和结果时一定能用上</li>
<li><strong>编写代码生成器</strong><ul>
<li>开发者手动触发，如模板代码</li>
<li>程序自动出发，如scheme to idl，idl to code</li>
</ul>
</li>
</ul>
<h2 id="偏执编程"><a href="#偏执编程" class="headerlink" title="偏执编程"></a>偏执编程</h2><ul>
<li><strong>通过合约设计</strong>，约定好接口，合作方基于接口开发<ul>
<li>强类型语言更容易实现这一点</li>
</ul>
</li>
<li><strong>早崩溃</strong>，这在需要编译的软件开发上比较科学，对于web应用来说却不是这样</li>
<li><strong>使用断言确保某事不会发生</strong>，减少预设条件代理的隐藏bug<ul>
<li>不要滥用断言</li>
</ul>
</li>
<li><strong>只在异常处用异常</strong></li>
<li><strong>一定记住释放请求的资源</strong>，如内存、句柄等，可以通过封装统一的资源类实现自动的资源释放</li>
</ul>
<h2 id="时间的魔力"><a href="#时间的魔力" class="headerlink" title="时间的魔力"></a>时间的魔力</h2><ul>
<li><strong>德墨忒尔法则</strong>，使模块间的依赖减少到最小<ul>
<li>物理解耦</li>
</ul>
</li>
<li><strong>要配置不要hardcode</strong>，使用元数据动态描述你的程序<ul>
<li><strong>抽象放进代码，细节放进元数据</strong></li>
</ul>
</li>
<li>时间耦合：考虑并发和事件的发生顺序<ul>
<li>在异步代码中，总考虑并发</li>
</ul>
</li>
<li>一些GUI的设计模式<ul>
<li>发布订阅</li>
<li>MVC</li>
</ul>
</li>
<li><strong>基于规则&#x2F;规则集的黑板系统</strong><ul>
<li>黑板给出统一接口</li>
<li>耦合方通过调用黑板接口避免耦合</li>
<li>黑板通过规则给出输出</li>
</ul>
</li>
</ul>
<h2 id="编码时"><a href="#编码时" class="headerlink" title="编码时"></a>编码时</h2><ul>
<li><strong>不要靠巧合编程</strong><ul>
<li>改动要有文档沉淀</li>
<li>只依靠文档中记录的行为</li>
<li>把你的假设记入文档</li>
</ul>
</li>
<li><strong>在大数据量时</strong>，考虑算法数量级<ul>
<li>兼顾效率和可读性</li>
</ul>
</li>
<li><strong>早重构，常重构</strong>，代码是业务设计的近似同构体，常重构才能保证代码完美贴合需求设计<ul>
<li>重构和功能开发分开进行</li>
<li>重构一定要有测试</li>
</ul>
</li>
<li>优秀的代码不是看新增了多少行，而是看删除了多少行</li>
<li>编写易于测试的代码<ul>
<li>测试你的软件，否则你的用户会代你做测试</li>
</ul>
</li>
</ul>
<h2 id="项目开始前"><a href="#项目开始前" class="headerlink" title="项目开始前"></a>项目开始前</h2><blockquote>
<p>完美，不是在没有什么需要增加，而是在没有什么需要去掉的时候达到的。</p>
</blockquote>
<ul>
<li>去挖掘需求，思考用户做特定事情的原因，和如何去做的方式，<strong>让需求成为一种一般性的陈述</strong><ul>
<li><strong>制作需求文档时的一大危险是太过具体，好的需求文档会保持抽象</strong></li>
<li>经常性复盘</li>
<li>鼓励文档分享和交流</li>
</ul>
</li>
<li><strong>巧妙解决看似不能解决的难题</strong>，关键要找到<strong>真正的约束</strong>，去思考<ul>
<li>有更容易的方法么</li>
<li>你是在解决真正的问题，还是被外围的技术问题转移了注意力</li>
<li>这件事为什么是一个问题</li>
<li>是什么让它难以解决</li>
<li>它必须这么做么</li>
<li>它必须完成么</li>
</ul>
</li>
<li><strong>准备好再开始，但不要让它成为你懈怠的借口</strong></li>
<li><strong>不要成为方法学的奴隶</strong></li>
</ul>
<h2 id="实效项目"><a href="#实效项目" class="headerlink" title="实效项目"></a>实效项目</h2><ul>
<li>团队建设<ul>
<li>不留破窗户（考验leader的管理能力）</li>
<li>经常性的复盘和例会</li>
<li>减少团队成员分工的冗余</li>
<li>自动化项目流程 &#x3D;&gt; 效率工程团队开发内部工具</li>
<li>制造context，给成员足够空间</li>
</ul>
</li>
<li><strong>不要使用手动流程</strong>，它不可控且难以复制<ul>
<li>shell、crontab</li>
<li>CI和自动化持续集成</li>
<li>代码生成</li>
<li>自动化测试</li>
<li>代码review和源码版本控制流程</li>
</ul>
</li>
<li><strong>常测试，早测试，自动化测试</strong><ul>
<li>单元测试&#x2F;集成测试&#x2F;压力测试&#x2F;回归测试</li>
<li><strong>测试状态覆盖，而不是代码覆盖</strong>，代码覆盖率提供的意义有限</li>
</ul>
</li>
<li>关于如何生产文本<ul>
<li>所有文档都是代码的反映</li>
<li>源码注释应该去把项目里那些难以描述、容易忘记、不能记录在其他地方的东西记载下来</li>
<li>比无意义的名称更糟糕的是<strong>有误导性</strong>的名称</li>
<li>除非有程序或人工维护，否则任何形式的文档都只是<strong>快照</strong></li>
</ul>
</li>
<li><strong>温和地超出用户期望</strong>，如<ul>
<li>友好的新手指引</li>
<li>快捷键</li>
<li>自动化安装</li>
</ul>
</li>
<li><strong>自豪地为你的作品签名</strong></li>
</ul>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li>《人月神话》</li>
<li>《Unix编程艺术》</li>
<li>《Effective C++》</li>
<li>《集市与大教堂》</li>
</ul>
<p><em>–END–</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/blog/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:45</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

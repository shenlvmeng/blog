<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Be sharp, my friend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Shenlvmeng&#39;s Blog">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/page/11/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="Be sharp, my friend.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shenlvmeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Shenlvmeng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">155</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">476</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/08/07/social-psychology-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/08/07/social-psychology-part-2/" class="post-title-link" itemprop="url">社会心理学 Part 2 - 社会影响</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-07 00:13:53" itemprop="dateCreated datePublished" datetime="2019-08-07T00:13:53+08:00">2019-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-02 21:49:03" itemprop="dateModified" datetime="2019-11-02T21:49:03+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/08/07/social-psychology-part-2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/07/social-psychology-part-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/07/26/social-psychology-part-1/">社会心理学 Part 1 - 导论 &amp; 社会思维</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/09/24/social-psychology-part-3/">社会心理学 Part 3 - 社会关系</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/11/02/social-psychology-part-4/">社会心理学 Part 4 - 应用</a></p>
</blockquote>
<p>这部分主要讨论社会给个人的影响。</p>
<h2 id="基因、文化和性别"><a href="#基因、文化和性别" class="headerlink" title="基因、文化和性别"></a>基因、文化和性别</h2><h3 id="基因和文化的影响"><a href="#基因和文化的影响" class="headerlink" title="基因和文化的影响"></a>基因和文化的影响</h3><ul>
<li>进化观点：强调人类的联系、相似性</li>
<li>文化观点：强调人类的多样性</li>
</ul>
<p>自然选择过程决定了我们的许多共性特征。<strong>进化心理学</strong>即基于此研究自然如何影响那些适应特定环境的生理特征，以及有利于基因存活和延续的心里特征和社会行为。</p>
<p>在共有生理基础上，<strong>文化</strong>赋予人类以多样性。文化更强调人类的适应性。我们的大多数行为都是受社会影响的。当与来自不同文化背景的人一起工作、生活时，会更容易理解文化如何影响我们和文化间的差异性。文化中会自然形成强迫人们遵从传统的社会行为的期待，即社会<strong>规范</strong>。<strong>私人空间</strong>是一种我们自己与他人间维持润滑和缓冲的空间，不同个体间需求的私人空间也不同。</p>
<p>文化除了差异性，还具有内在的统一性，比如对乱伦的限制，对战犯的处理上。而且罗杰·布朗提出，人和人之间不仅会形成某种等级地位，在和地位较高的人说话时，语气往往更尊敬（就像和陌生人说话一样），而和地位较低的人则像和熟人聊天，进而可以推出：</p>
<ol>
<li>强调沟通的形式不仅反映社会距离也反映社会地位</li>
<li><strong>亲密关系往往由较高地位的人控制</strong>。地位更高的人是亲密关系发展的制定者。比如开会发言、约会吃饭。</li>
</ol>
<h4 id="社会角色"><a href="#社会角色" class="headerlink" title="社会角色"></a>社会角色</h4><ul>
<li>社会角色比角色扮演者本身有更长久的生命力。</li>
<li>一种社会角色伴随的是<strong>一系列</strong>的社会规范</li>
<li>社会角色具有强大的影响力，我们倾向于接纳自己的角色</li>
</ul>
<p>在实验中，地位更高的人认为自己更应该受到优待，且具有更高的能力，尽管地位是实验分配的。相反，较低下的社会角色会主动削弱自己的自我效能感，自我赋能可以打破这种困境。</p>
<p>角色互换可以帮助人们更好地理解对方，毕竟，<strong>人类大部分的冲突和争论都源自人们过于关注自己的意见而非寻找问题的正确答案</strong>。</p>
<h3 id="性别相似性和差异性"><a href="#性别相似性和差异性" class="headerlink" title="性别相似性和差异性"></a>性别相似性和差异性</h3><p>对于个体意识以及社会关系而言，种族和性别是最重要的两个维度。对性别差异上的研究不能被用来验证偏见和加深刻板印象。男性和女性有很多性别上的不同：</p>
<ul>
<li>男性有更多神经元，女性有更多神经连接</li>
<li>男性更有独立性，女性更具联系性。女性比男性更注重亲密关系。女性更易用<strong>关系性</strong>的词汇描述自己，乐于接受他人帮助，体验更多和关系相关的情感，努力使关系更协调；男性在谈话时常常关注任务和大群体的关系。<ul>
<li>工作上，男性更倾向于看重报酬、提升机会、挑战和权力，而女性更看重合理时间安排、私人关系、帮助他人的机会，如护士、教师</li>
<li>女性在家庭上会花更多时间照顾孩子和老人，<strong>相互支持感</strong>对女性的婚姻满意度是极为关键的</li>
<li>女性比男性更可能为他人的经历产生、表现出<strong>共情</strong>的反应。有一种解释是，女性具有更强的理解他人情绪的能力。</li>
<li>女性在记忆面部特征和其他外部特征上更为出色，非言语表达情绪的能力也很出色。男人在传达愤怒上更明显。</li>
</ul>
</li>
<li>几乎所有社会，都是男性处于统治地位。<ul>
<li>男性比女性更关心社会统治问题</li>
<li>男性交流的方式可以加强他们的社会权力，在没有界定领导角色的场景下，男性倾向于<strong>指示性</strong>的领导方式，女性倾向于<strong>民主化</strong>的方式</li>
<li>男性比女性更强调胜利、超期和控制他人，同样也更爱冒险。</li>
<li>男性的谈话方式可以反映他们对独立的关注，而女性更注重关系</li>
</ul>
</li>
<li>男性承认自己比女性有更多攻击行为。有研究显示，女性苏沪会发起更多攻击行为，但是男性更容易造成伤害</li>
<li>性特征<ul>
<li>男性比女性更可能发生性活动</li>
<li>男性进行更多性幻想，态度也更开放，而且试图寻找更多性伴侣，更容易引发性唤醒，更多要求性爱，很少拒绝性爱，且更偏爱形式各异的性爱</li>
<li>人类学家唐纳德·西蒙指出，“在世界各地，性都被理解成为女性所拥有的，男性想得到的东西”</li>
<li>在185个国家的调查中发现，男人越稀有，女性怀孕的比率就越高。而当女人稀少时，女性性行为的市场价值就会提升，她们会要求更高的价格</li>
<li>性幻想上，女性更注重感情</li>
</ul>
</li>
</ul>
<p>进化和文化交织地影响着性别行为。</p>
<h4 id="进化对性别行为的影响"><a href="#进化对性别行为的影响" class="headerlink" title="进化对性别行为的影响"></a>进化对性别行为的影响</h4><p>两性在后天可养成的行为上，如果面临相同的适应挑战，会趋向相同。而在约会、婚配、繁殖行为等天生行为上会存在差异。由于自然会选择那些有助于基因遗传的特性，所以我们天生就追求那些增加基因遗传性的生活方式。从而：</p>
<ul>
<li>女性会更加小心考察男性的身体健康和资源状况，谨慎处理自己的繁殖机会。男性则需要和他人竞争，以便把自己的基因遗传下去。简言之，男性寻求更广泛的繁殖、女性寻求更明智的繁殖</li>
<li>男性偏爱有生殖力旺盛外表特征的女性，而女性偏爱有财产和地位这些能为后代提供足够保护和抚养的男性</li>
</ul>
<p>在人进入中年和老年时，男女性会渐渐趋同，女性变得独断自信，而男性可能更好共情更少支配他人。一方面是激素的影响减弱，另一方面是社会期待对个体的限制减弱。</p>
<h4 id="文化对性别行为的影响"><a href="#文化对性别行为的影响" class="headerlink" title="文化对性别行为的影响"></a>文化对性别行为的影响</h4><p>文化是大群体共享的代代相传的“共同假设”。文化对不同性别的期待界定了性别角色。在实验中，男女性都趋向于让自己的表现和对方的性别角色期望相符合。由于文化的地域性和年代性，不同地区和年代下的性别角色也是在变化的。总体上讲，男女的性别角色已经没有以前那么大了。</p>
<p>在文化的代代相传上，<strong>教养论</strong>认为，父母抚养孩子的方式决定孩子成为什么样的人。因为孩子会接受父母的很多价值观。而后在一些调查研究中发现，孩子的人格差异受<strong>同伴的影响</strong>更大。孩子通常从更大的孩子身上学习，直到那些和父母同一代的年轻人。总结来说，</p>
<ul>
<li>父母一代对孩子一代的联系是松散的，文化的传承是间接的，孩子受同伴影响更多</li>
<li>不过父母可以决定孩子身边的同伴，如学校、社区</li>
</ul>
<p>整体来看，生物因素和文化因素交互影响我们的态度和行为。与此同时，人是具有主观能动性的，人本身具有改变自己态度和行为的能力。</p>
<ul>
<li>同一种社会情境付不同人有不同的影响</li>
<li>人们可以选择自己所处的情境</li>
<li>人们能创造自己的环境</li>
</ul>
<h2 id="从众"><a href="#从众" class="headerlink" title="从众"></a>从众</h2><h3 id="什么是从众"><a href="#什么是从众" class="headerlink" title="什么是从众"></a>什么是从众</h3><p><strong>从众</strong>是指根据他人而做出的行为或信念的改变，有三种形态：</p>
<ul>
<li>顺从，为了得到奖励或避免惩罚</li>
<li>服从，通过明确命令引起的顺从行为</li>
<li>接纳，真诚的内在的从众行为</li>
</ul>
<h3 id="从众的经典研究"><a href="#从众的经典研究" class="headerlink" title="从众的经典研究"></a>从众的经典研究</h3><p>这里介绍三例影响较大的经典研究：</p>
<ul>
<li>谢里夫的规范形成研究（社会传染）</li>
<li>阿施的群体压力研究（社会压力）</li>
<li>米尔格拉姆的服从实验</li>
</ul>
<p>它们分别从三个不同角度研究了在外界压力逐步增大的情境下，我们的从众行为是怎样形成和表现的。</p>
<h4 id="谢里夫的规范形成研究"><a href="#谢里夫的规范形成研究" class="headerlink" title="谢里夫的规范形成研究"></a>谢里夫的规范形成研究</h4><p>Muzafer Sheriff研究了在暗示下，个体是怎样形成群体规范的。通过一个巧妙的关于光点似动现象的实验，谢里夫发现了个体的<strong>易受暗示</strong>性。我们对现实的看法未必来自我们自己的观点。一个人的咳嗽、笑或打呵欠会引起周围人的效仿，即社会传染效应。</p>
<p>这种暗示还会在更大范围内传递。如自杀事件的报道会引起自杀率的轻微上升，报道得越厉害，增加得就越多。一方面因为青少年是易感人群，容易模仿；另一方面是在暗示的作用下，我们不能透过现象寻找本质原因。“群体癔症”也是因为社会传染而引起的集体妄想表现。</p>
<h4 id="阿施的群体压力研究"><a href="#阿施的群体压力研究" class="headerlink" title="阿施的群体压力研究"></a>阿施的群体压力研究</h4><p>谢里夫的实验针对的是模糊的现实场景，而阿施则通过同谋实验者为被试制造出“刻意”的社会压力，研究此时的从众行为。具体表现为让被试一个一个回答简单问题，在前面的同谋者都赞同明显错误答案时，研究发现有一小部分人在不安和内心冲突后赞同了明显错误的答案。</p>
<h4 id="米尔格拉姆的服从实验"><a href="#米尔格拉姆的服从实验" class="headerlink" title="米尔格拉姆的服从实验"></a>米尔格拉姆的服从实验</h4><p>阿施的群体压力实验距离现实较远，社会压力并没有强迫个体服从。米尔格拉姆通过实验研究在社会压力直接强迫个体时，从众行为是如何表现的。具体表现为，邀请同谋扮演学习者和被试扮演教师，隔离开学子和和教师，让教师考察学习者，并在学习者给出错误答案时，在研究者的要求下提升点击学习者的电压。电压从15伏到450伏（当然电击是假的，学习者的痛苦反应也只是录音）。</p>
<p>被试的所有人都认为在135伏左右会不服从研究者的命令。实际上，有65%的被试进行实验一直到450伏，而不顾学习者的“哭喊”和“抗议”。实验结论在发表后，被质疑是否具有伦理问题，让被试在实验后质疑自我。对此米尔格拉姆解释实验结束后，会告诉被试真相，在事后回访时也只有1%的被试表示很遗憾。</p>
<h3 id="服从行为的影响因素"><a href="#服从行为的影响因素" class="headerlink" title="服从行为的影响因素"></a>服从行为的影响因素</h3><h4 id="受害者的情感距离"><a href="#受害者的情感距离" class="headerlink" title="受害者的情感距离"></a>受害者的情感距离</h4><p>米尔格拉姆的被试在无法看到和听到学习者（同样学习者也看不到被试）时，其行动表现出的同情最少，相反在实验中可以听到抗议，甚至可以看到被试时，完全服从的比例有所下降。</p>
<p><strong>我们很容易贬低远离自己或失去个性的人</strong>。甚至对于巨大大灾难，人们也会无动于衷。</p>
<ul>
<li><strong>火车轨道困境</strong>中，人们对于绑在火车道上的单个人的同情要甚于火车道上的一群人</li>
<li><strong>人们对于个性化的人是最富有同情心的</strong>，这就是为什么人们通常用令人感动的照片赋予饥饿人群、动物权利、新生儿以个性化</li>
<li>同样，如果对受害者个性化，无辜的受害者会博得更多同情。一个误落矿井的男孩是一条鲜活的生命，而一场核战争的牺牲者只是一个数字</li>
</ul>
<h4 id="权威的接近和合法性"><a href="#权威的接近和合法性" class="headerlink" title="权威的接近和合法性"></a>权威的接近和合法性</h4><p>米尔格拉姆的实验中发现，要求命令的发出者在<strong>空间距离的接近性会增加服从度</strong>。当命令通过电话发出时，服从度有较大下降。同时<strong>权威必须要具有合法性</strong>，当研究者告知仪器可以自动进行实验，换作另外一个人代替他发出命令时，被试中出现了反叛的现象。</p>
<h4 id="权威机构和释放效应"><a href="#权威机构和释放效应" class="headerlink" title="权威机构和释放效应"></a>权威机构和释放效应</h4><ul>
<li><strong>机构声望能增加命令的合法性</strong>。实验在耶鲁大学进行和在普通城市的普通办公楼进行时，完全服从的比例有所下降。</li>
<li>尽管群体在被直接强迫时会有从众表现，但当有参与者接二连三地表示反对和不满时，<strong>释放效应</strong>会引起对命令的强烈反抗</li>
</ul>
<h3 id="从众研究的反思"><a href="#从众研究的反思" class="headerlink" title="从众研究的反思"></a>从众研究的反思</h3><ul>
<li>当外界影响超过内在信仰，个人知觉被淹没时，态度便无法决定行为。强有力的社会压力（命令）会超越力量较弱的因素（受害者的抗争）。可怕的是，结合之前提到的<strong>登门槛现象</strong>，当电压一点点增大时，被试早已降低了态度和行为的不协调感，内化了行为的合法性，很容易接受之前被强迫的命令。即<strong>顺从滋生接纳</strong>。施暴者会在暴力一点点升级时，贬低被害者以减轻负罪感，而慢慢从命令的执行者变成冷漠的杀人机器。</li>
<li><strong>社会情境具有极大的影响力</strong>，它虽然没有明文规定，但指导着公众行为。比如，米尔格拉姆在要求学生主动要求乘坐地铁的乘客让座时，有过半人都让了座，而同时学生也发现要这样做真得很难。情境有时会诱使普通人赞同谬误或向邪恶屈服。当人们分散分工时，邪恶似乎更容易进行。</li>
<li>人们对罪恶的执行者存在<strong>基本归因错误</strong>，误认为他们本来就是内心邪恶的人。从而忽视了邪恶行为的产生原因主要来自外在环境，我们离他们其实并不远。普通人，可以心中并没有任何仇恨，只是做本职工作，也可以成为可怕破坏性行动的执行者。善良的人们有时也会堕落，而且他们会对自己不道德的行为进行合理化归因。</li>
</ul>
<h3 id="从众行为的影响因素"><a href="#从众行为的影响因素" class="headerlink" title="从众行为的影响因素"></a>从众行为的影响因素</h3><ul>
<li>任务难度：在阿施的社会压力实验中，<strong>任务判断非常困难或让被试感觉无法胜任时</strong>，从中比率会升高。</li>
<li>群体规模：在实验室实验中，群体规模增加到5个人的过程中，从众行为会极大提升，但大于5个人时，从众程度增加便不明显，甚至有所下降。<strong>多个小群体</strong>的一致意见会使观点更可信</li>
<li>群体一致性：群体一致性被破坏时，群体的社会影响力会下降。这也是为什么<strong>当你能找到和你立场一致的人时，你为某件事站出来就容易得多</strong>。同时，观察到其他人的异议时，即使这种异议时错误的、和自己矛盾的，也会增强我们自己独立性</li>
<li>群体凝聚力：群体外的人提出的“少数派观点”对我们的影响小于我们群体内“少数派观点”对我们的影响。一个群体的<strong>凝聚力</strong>越强，对成员的影响力就越大。</li>
<li>地位：<strong>我们会避免与地位低的或被自己嘲笑的人意见一致</strong>，而更向地位高的人靠拢。这里的地位高低完全由我们自己的观察决定。</li>
<li>公开反映：与面对群体比，在私人空间里，我们更容易坚持自己的信仰</li>
<li>事前承诺：<strong>个体一旦对自己的立场作出了公开承诺，就很少屈服于社会压力</strong>。公开的承诺会让人无法后退</li>
</ul>
<h3 id="从众原因和差异性"><a href="#从众原因和差异性" class="headerlink" title="从众原因和差异性"></a>从众原因和差异性</h3><p>主要来自两种影响：</p>
<ul>
<li><strong>规范影响</strong>，避免被群体拒绝，避免受到不合规范的惩罚。有时，高昂的代价会迫使人们支持自己不相信的东西，或至少压制自己的反对意见。即<strong>我们想得到他人的喜爱和赞赏</strong>。</li>
<li><strong>信息影响</strong>，他人的反应会影响我们对模糊情境的解释，和群体保持一致会使人们更容易证实自己的决策树正确的。即<strong>我们想要做出正确的行为</strong></li>
</ul>
<p>个性和文化能判断从众行为对个体的影响程度。就个性来讲，几乎是和环境一起影响着人们的从众行为。而文化中，在不同时不同地对人们从众行为的指示也是不一样的。</p>
<h3 id="从众行为的抵制"><a href="#从众行为的抵制" class="headerlink" title="从众行为的抵制"></a>从众行为的抵制</h3><h4 id="逆反"><a href="#逆反" class="headerlink" title="逆反"></a>逆反</h4><p>个体非常看重自己的自由感和自我效能感时，如果社会压力很明显，以至于<strong>威胁到个体自由感</strong>时，会引起个体反抗。逆反，即人们采取行动保护自己的自由感。努力限制自由会引起“反从众”，比如可以用来解释性胁迫。</p>
<h4 id="坚持独特性"><a href="#坚持独特性" class="headerlink" title="坚持独特性"></a>坚持独特性</h4><p><strong>个体认为自己是独特的，且这种独特感是中等程度时</strong>，会产生良好的自我感觉。因此，我们都在努力保持<strong>一定程度</strong>的独特性，这也是潮流多变的原因。在实验中，那些听到其他人发表观点和自己相同的人，反而会改变自己的观点来维护自己的独特性。</p>
<p>把自己看成独特的个体也会出现在“自发性自我概念中”，即上一篇提到的“虚假独特性”。自我介绍时，我们会倾向于描述自己较独特的一面。有种解释是，<strong>只有这样，个体与众不同时，个体才会意识到自我存在</strong>。更进一步，我们不仅追求与众不同，还追求正确方向上的独特性，即<strong>好于众人</strong>。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>极致的个体主义里，不把任何事情归功于任何人，也不期望从任何人那里得到什么，孤立地看待自己的习惯，好像整个命运掌握在自己手里。相反，集体主义中，学生通常穿着校服避免个性，显示团结一致，抑制个体的冲突以求融洽相处。</p>
<p>可能求同存异是一种折中的更好的融合，平衡自己的独立性需要和社会关系需要，私密性和社会性，个体性和同一性。</p>
<h2 id="说服"><a href="#说服" class="headerlink" title="说服"></a>说服</h2><p>说服也是社会对我们的一种常见影响，在生活中，说服几乎无处不在。对个人而言，说服有利有弊，主要由信息背后的目的和包含的内容决定，我们称好的说服为“教育”，不好的说服为“洗脑”。有人认为文化塑造是从上而下的，有一部分中坚分子控制着信息观念的传播。</p>
<p>说服，即个体从知晓信息到做出行动的过程。在对人的作用上，主要分为两种途径：</p>
<ul>
<li><strong>中心途径</strong>，当人们能全面系统地对某个问题进行思考时，关注论据合理性时，更多使用中心途径。即<strong>知晓-&gt;理解-&gt;相信-&gt;记住-&gt;行动</strong>。比如电脑等数码产品的广告</li>
<li><strong>外周途径</strong>，当人们忙于其他事情或不关注论据本身时，更多使用外周途径。这时，人们不会关心论据是否让人信服，而会“跟着感觉走”。比如饮料、烟草广告。</li>
</ul>
<p>相比之下：</p>
<ul>
<li>中心途径需要人详细分析论据，需要时间，往往能形成更持久的行为改变</li>
<li>外周途径通常基于启发性规则（如相信专家），形成较快，用于形成初步看法，行为改变并不持久</li>
</ul>
<h3 id="说服的要素"><a href="#说服的要素" class="headerlink" title="说服的要素"></a>说服的要素</h3><p>说服主要由4个部分组成：</p>
<ol>
<li>传达者</li>
<li>信息内容</li>
<li>传递途径</li>
<li>听众</li>
</ol>
<p>影响说服的因素实在很多，需要针对上述组成部分分开讨论和研究。</p>
<h4 id="传达者"><a href="#传达者" class="headerlink" title="传达者"></a>传达者</h4><p>传达者可以影响说服的效果主要体现在下面一些方面。</p>
<p><strong>可信度</strong></p>
<p>信源的可信度对说服效果有积极影响。然而存在<strong>睡眠者效应</strong>，即人们容易遗忘信源或信源和信息联系之后的延滞性说服。体现在，信源可信度对说服起到的帮助会随着时间流逝而消退，相反那些可信度低的人影响力则会随着时间流逝而增加。</p>
<ul>
<li><strong>可知觉的专家性</strong>，可以通过传达公众赞同的观点、被公认的学识渊博者引介以及自信的表达方式达到</li>
<li><strong>可知觉的信赖性</strong>，包括直视质疑者、听起来不像在说服自己、站在自身利益对立面（如一个自私的人突然间为社会奉献）等方式。同时，<strong>较快的语速</strong>也可以增加发言人的可信度。这是因为除了给人自信的暗示外，较快的语速通常也无法留给听众思考和留给质疑者发问。</li>
</ul>
<p><strong>吸引力和偏好</strong></p>
<p>传达者的个人魅力也很重要。个人偏好可以让我们乐于接受传达者的观点，或在事后引发积极的联想。比如当论点来自一个漂亮的人时，往往具有更大的影响力。</p>
<p>但同时，就像我们选择牙膏、桌游游戏一样，我们也倾向于相信那些和我们<strong>相似的人</strong>。Goethals和Nelson发现，<strong>当主题偏重主观偏好时，相似性影响力更大；主题偏重客观偏好时，可信度影响力更大</strong>。所以，在预测明天的天气上，我们并不会相信我们的朋友而是天气预报员。</p>
<h4 id="信息内容"><a href="#信息内容" class="headerlink" title="信息内容"></a>信息内容</h4><p>信息内容同样有许多维度可以衡量。</p>
<p><strong>理性or感性</strong></p>
<p><strong>听众教育程度较高或善于思辨或积极参与时，更容易接受理性信息说服；反之更容易接受感性信息说服。</strong>如果个体的初始态度来自情感，那么就更易受感性论点说服；反之，理性的论点就更有效。同时，新的态度形成需要比上次更多的信息。</p>
<ul>
<li>信息和<strong>好消息</strong>联系在一起时，说服力更强。它会让个体做决定时更冲动，更多依赖外周线索。比如，很多消费品广告都会尽量营造出快乐的氛围</li>
<li>能<strong>唤起恐怖效应</strong>的形象化消息，同样会起到充分的反馈。恐惧程度越高，回应越多。负面信息会使人们知觉相关积极行为的规范性。比如要求在烟草广告上明确展示让人不适的图片。同时，唤起恐惧心理后，需要<strong>同时告诉一个解决的方法</strong>，这样才会更有效。否则，人们可能会否定这个信息。</li>
</ul>
<p><strong>差异程度</strong></p>
<p>传达让人不舒服的信息会引起质疑。而论点在人们可接受范围内时，他们更具有开放性。差异大小对可信度影响来自两个方面：</p>
<ul>
<li><strong>传达者可信度</strong>，可信度很高时，信息接收者会接受一个较大差异的论点。比如专家对文献的解释</li>
<li><strong>信息接受者的参与程度</strong>，积极参与者能够接收的观点范围较小。</li>
</ul>
<p><strong>单方面or双方面</strong></p>
<p>即仅从论点角度还是相反两个角度。这取决于听众：</p>
<ul>
<li>单方面论证对已持赞同态度的人更有说服力；双方面论证对持反对态度的人更有效</li>
<li>对相反观点有所了解的人，会更易接收双方面论证。那些聪明的人听到单方面论证时，会认为信息传递者存在偏见。所以许多政客面向对政治有所了解的团体演讲时，会对对立观点加以回应。</li>
</ul>
<p><strong>首因or近因</strong></p>
<p><strong>首因效应</strong>很普遍，即最先出现的信息更具说服力，类似沉锚效应、皮格马列翁效应。近因是指，对发生较近的记忆更信服。</p>
<ul>
<li>信息接连出现、且听众听过后有反应时间时，首因效应更明显</li>
<li>信息出现时间是分离的，且要求听众听完第二个意见后立即判断时，近因效应更明显</li>
</ul>
<h4 id="沟通渠道"><a href="#沟通渠道" class="headerlink" title="沟通渠道"></a>沟通渠道</h4><p>我们做出行动时，会将行为背后隐藏的观念放大。相对应的，以经验为基础的态度更自信、稳定。</p>
<p><strong>主动or被动接受</strong></p>
<p>通常来说，被动接受消息对于说服几乎是无效的。但是不总是如此，比如在总统大大选时，花钱更多的候选人赢得的选票也更多。</p>
<p>这里有一个规则：<strong>随着观点熟悉程度和重要性的增加，被动说服的影响力会越来越小</strong>。</p>
<p><strong>媒介</strong></p>
<p>需要承认的是，对于我们最主要的影响来自<strong>和他人的解除</strong>而不是传媒。课堂外的人际关系对学生的身心成熟有重要的影响。但这也不代表媒体对个人没有影响。卡茨（Katz，1957）观察到，多数媒体影响都通过<strong>沟通的两步流程</strong>，即从媒体到有影响力的人、再到普通群众。即使那些没看过电视的孩子，也会因为身边那些看过孩子的人间接受到电视广告的影响。</p>
<p><strong>媒体越接近生活，信息就越具有说服力</strong>。即现场&gt;录像&gt;录音&gt;文字。但是，文字形式的信息通常具有最好的<strong>理解和回忆</strong>效果。所以，<strong>当信息难以理解时，其说服效果按媒体排序，刚好是和上面相反的</strong>。因为信息较难时，文字媒介可以让接收者把握理解节奏，同时避免外周因素（环境音、画面）影响。</p>
<h4 id="听众"><a href="#听众" class="headerlink" title="听众"></a>听众</h4><p>自尊水平低的人理解信息慢，难以说服；自尊水平高的人理解信息后坚持己见，也难以说服。水平适中的人最易受到影响。</p>
<p><strong>年龄</strong></p>
<p>在听众年龄上，有两种理论，<em>生命周期理论</em>和<em>生活时代理论</em>。研究者发现，从现象上看，实际情况更符合后者，即人们的态度较少随年龄发生变化。</p>
<p>十几、二十几岁的年轻人形成的态度会在长期内保持稳定。在此间的经历也可以给个体留下深刻和持久的印象，从而给人格定型。</p>
<p><strong>他们在想什么</strong></p>
<p>说服过程的关键不在信息主体，而在它激发个体的思维方式。</p>
<ul>
<li><strong>预先警示</strong>会提升说服的困难，尤其是在听众积极参与观点时。他们会准备好抵御，面对可能出现的质疑。</li>
<li><strong>分心会减少辩驳</strong>，注意力被别的东西转移并阻碍反驳时，言语的说服效果会增加。尤其当信息简单时。下次可以在和对象吵架时试试这招。</li>
<li><strong>不积极参与的听众使用外周线索</strong>。思辨能力强和积极参与者的<strong>认知需求</strong>较强，喜欢走中心途径。而相反情况下，会走外周途径。当信息看起来无关紧要时，外周线索更为明显。</li>
</ul>
<p>佩蒂、卡乔波等人通过多个实验研究发现了激发人们思考，引导人们走中心途径的方法：</p>
<ul>
<li>使用反问（老师很喜欢使用）</li>
<li>使用多个演说者</li>
<li>让人们感到自己<strong>有责任</strong>评价和传达信息</li>
<li>使用放松的姿态</li>
<li>重复信息以吸引人们的注意力</li>
</ul>
<p><strong>对于强有力的信息，激励思考可以增加说服力，并减小微弱信息的说服力</strong>。</p>
<h3 id="邪教如何洗脑"><a href="#邪教如何洗脑" class="headerlink" title="邪教如何洗脑"></a>邪教如何洗脑</h3><p>类似人民圣殿、统一教团、天堂之门等邪教利用了说服的一些特性蛊惑教众危害社会。</p>
<ul>
<li>态度决定行为。邪教领导者通过重复的行动准则和仪式让教众内化行为，成为有责任感的拥护者。在一开始利用登门槛效应逐步减少人们的抵抗</li>
<li>增强说服力：一个具有个人魅力的领导者；生动、感性的信息；年轻的或处于人生转折点的听众。</li>
</ul>
<h4 id="团体效应"><a href="#团体效应" class="headerlink" title="团体效应"></a>团体效应</h4><p>邪教组织通常会将成员和其原先的社会关系隔离开，达到“社会鼻塞”的程度。在只和组织内部的成员发生联系的情况下，逐步滋生偏执和妄想。同时，由于邪教切断了新成员和老朋友的联系，他们往往会感到孤立无援，从而花时间融入新团体。</p>
<p>狂热的自助组织也具有这样的特征，组织具有很强的凝聚力，有激进极端的思想，对成员的行为影响深刻。有意思的是，心理治疗的一些情境也和此类似：</p>
<ul>
<li>相互信任的社会支持</li>
<li>专业知识和希望</li>
<li>独特的信念和解释个体困难的新视角</li>
<li>一系列的仪式和学习体验</li>
</ul>
<h3 id="如何抗拒说服"><a href="#如何抗拒说服" class="headerlink" title="如何抗拒说服"></a>如何抗拒说服</h3><p>说服有好有坏，合适的技巧可以帮助我们避免令人生厌的说服。</p>
<h4 id="加强个人承诺"><a href="#加强个人承诺" class="headerlink" title="加强个人承诺"></a>加强个人承诺</h4><p><strong>温和</strong>的攻击人们的立场可以激励人们更相信自己的立场，比如在辩论赛中见到的那样。</p>
<ul>
<li>一方面，攻击强度不足以驳倒他人时，会激发人们以更极端的方式维护信仰的立场</li>
<li>另一方面，我们会感到愤怒，且在驳倒他人时会获得较高的自我肯定感</li>
</ul>
<p><strong>态度免疫</strong>就是利用这一点实现的。先让人们接受观点的小小挑战作为预防针，会增加他们抵制更强烈攻击的能力。适当的辩论是抵制说服的最佳途径。态度<strong>免疫计划</strong>已经被应用在现实生活中，实验发现适当的挑战可以降低孩子的吸烟率和增强孩子对广告的抵抗能力。另外，态度免疫也可以用来抵制邪教和洗脑的不良影响。</p>
<p>另一方面，这也预示着，<strong>效果不佳的说服还不如没有</strong>。那些曾经拒绝过戒烟劝说的人更可能对以后的所有劝说具有抵抗力，因为效果不佳的劝说引起了他们的防御心理。</p>
<h2 id="群体影响"><a href="#群体影响" class="headerlink" title="群体影响"></a>群体影响</h2><p>群体影响个体，个体也会影响群体。</p>
<p>首先我们要明确群体的概念，对此，肖和特纳提出了两种判定方式：</p>
<ul>
<li>群体之间存在互动并会相互影响</li>
<li>群体成员把群体内的人视作“我们”而不是“他们”</li>
</ul>
<p>这一张主要考察群体的三种影响（<em>社会助长</em>、<em>社会懈怠</em>、<em>去个性化</em>），之后再讨论社会影响的三个典型例子（<em>群体极化</em>、<em>群体思维</em>、<em>少数派影响</em>）。</p>
<h3 id="社会助长：他人在场影响"><a href="#社会助长：他人在场影响" class="headerlink" title="社会助长：他人在场影响"></a>社会助长：他人在场影响</h3><p>他人在场有些时候会提高人的作业水平（比如一些简单工作），有时候会降低人的水平（比如表演杂技）。对此扎伊翁科（Robert Zajonc）用一个简单的理论给出了解释：</p>
<p>他人在场引起唤起，<strong>唤起能够增强任何优势反应的倾向</strong>。</p>
<p>所谓“优势”反应即大概率的反应。对于简单任务正确反应概率较高，唤起的是正确反应；对于复杂任务，唤起增强的是错误反应，因此他人在场时表现更差。</p>
<p>由于运动员所表现的都是熟练掌握的技能，从而有观众在场时，往往能激励人们的表现出最佳水平。这也是主场有优势的一定原因。</p>
<h4 id="拥挤现象"><a href="#拥挤现象" class="headerlink" title="拥挤现象"></a>拥挤现象</h4><p>他人的影响效应会随人数增加而递增。在完成有挑战性的任务时，众多支持者在场可能会引起个体做出更差的表现。</p>
<p>“处在人群中”对个体的积极和消极反应都会增强。人们坐得很近时，友善的人更受欢迎，而不友善的人更令人讨厌。我们坐得更近时，更容易注意到别人并融入他们的氛围之中。<strong>拥挤也会增强唤起状态</strong>，待在拥挤房间的被试心率更快、血压也更高。同样的学生人数，在拥挤环境下（小房间）上课比在宽松环境下（大房间）上课更活跃。</p>
<h4 id="为何会有唤起"><a href="#为何会有唤起" class="headerlink" title="为何会有唤起"></a>为何会有唤起</h4><p>对于为何人们会产生唤起，有研究者发现了以下三个可能原因：</p>
<ul>
<li><strong>评价顾忌</strong>，即人们认为受在场者的评价，这会激发并提高他们的优势反应。这也可以解释下面两个行为。另外受评引发的自我意识也会干扰我们熟练掌握的自动化行为。<ul>
<li>当与比自己优秀一些的人共事时，人们的表现更好</li>
<li>高层领导的唤起状态会随着无关痛痒的人加入而降低</li>
</ul>
</li>
<li><strong>分心</strong>，当我们注意他人和注意任务间存在矛盾时，认知系统负载过大，从而引起唤起</li>
<li><strong>纯粹在场</strong>，非人类动物身上的唤起现象也很普遍。只需要他人在场就会引起唤起作用。在许多写字楼中的开放式办公区意在利用他人在场增加个体的工作效率。</li>
</ul>
<h3 id="社会懈怠：减少努力"><a href="#社会懈怠：减少努力" class="headerlink" title="社会懈怠：减少努力"></a>社会懈怠：减少努力</h3><p>社会助长通常发生在人们为<strong>个人目标</strong>努力时。当大家在为共同目标努力，且个人努力难以衡量时，人们的努力会减少，即社会懈怠。</p>
<ul>
<li>6个人尽力叫喊的喧闹声不如1个人的3倍响</li>
<li>团体拔河时，个体努力程度从只有个人单独时的一半</li>
</ul>
<p>在群体条件下，人们会受到搭群体便车的诱惑，随着群体规模增大，个体付出的努力也在减少。这种现象在<strong>增强个体评价顾忌</strong>时有所减少。</p>
<ul>
<li>激励小组成员的一种方式是个体成绩可识别化</li>
<li>集体公社时农民的工作效率远不如承包制下农民们的效率</li>
</ul>
<p>在有些情况下，群体目标还是能起到激励的作用：</p>
<ul>
<li>群体目标极具吸引力，且需要每个人尽力去做</li>
<li>任务具有挑战性、引人入胜的特点</li>
<li>群体内认同度极高，如小组内都会好朋友而非陌生人</li>
<li>维持群体较小的规模</li>
</ul>
<p>集体主义下的社会懈怠要弱于个体主义社会，女性的社会懈怠也不如男性强烈</p>
<h3 id="去个性化：失去自我"><a href="#去个性化：失去自我" class="headerlink" title="去个性化：失去自我"></a>去个性化：失去自我</h3><p>群体情境有时会使人失去自我觉知能力，导致丧失自我和自我约束（正如《乌合之众》中指出的）。</p>
<p>群体能引发人们的唤起状态，当群体能扩散和分摊责任时，常规的约束就会变小，人们的行为就会从普通的失态到社会暴力。另外，群体可以产生出一种兴奋感，这种比个体更强大的力量对个体很有吸引力，在某些情境下，人们可以抛弃道德约束、忘却个人身份，顺从社会规则，即去个性化。</p>
<p>群体在引起唤起时，还在某种程度使<strong>个体身份模糊化</strong>，当人群规模较小且曝于日光下时，往往不至那么狂热。群体规模越大，成员越有可能失去较多自我意识，而受群体意识裹挟。这种匿名性还会引起更激进的行动。</p>
<ul>
<li>网络的匿名性使得激进型言论更多</li>
<li>大部分孩子因群体掩盖、匿名性（未被人发现）去个性化时，会更出格</li>
<li>匿名的袭击者表现出更严重的袭击行为</li>
<li>遮掩个人特征的身体彩绘会让部落斗士更暴力</li>
</ul>
<p>对此要指出，群体的去个性化不光只有负面作用，匿名性使人们自我意识减弱，群体意识增强，<strong>更容易对情境线索和暗示做出回应</strong>，不论线索是消极还是积极的。</p>
<p>群体表现出攻击性之前常常会发生引发人们唤起和分散注意力的事件，如合唱、跳舞。当人们看到别人和自己做出同样行为时，会对自己做出冲动性的举动产生自我强化的愉悦感。有些时候，我们甚至会主动寻找去个性化的群体体验：跳广场舞、群体交流、快闪等。我们会从中体验强烈的积极情感和与他人亲密无间的关系。</p>
<h4 id="自我意识弱化"><a href="#自我意识弱化" class="headerlink" title="自我意识弱化"></a>自我意识弱化</h4><p>自我意识淡薄、去个性化的人更不自控，更可能不顾及价值观就行动，对情境的反应也更强烈。相反，自我意识强烈的人更不易受环境影响。</p>
<p>自我觉察是去个性化的对立面，在镜子前或摄像机前的人，会表现得更加自控，从而在情境中表现出更高的言行一致性。</p>
<p>喝酒等情境会降低个体的自我觉察；镜子、摄像机、明亮的光线、很大的姓名标签、沉思、个性化着装、家等情境都可以降低个体的去个性化。父母在孩子参加聚会时，也都会说：“玩得开心，还有要记住你的身份”。</p>
<p>享受欢乐时，保持自我觉察，保持自我个性不被去个性化。</p>
<h3 id="群体极化：观点强化"><a href="#群体极化：观点强化" class="headerlink" title="群体极化：观点强化"></a>群体极化：观点强化</h3><p><strong>群体讨论通常会强化成员最初的观点</strong>。群体观点有时更冒险，有时则更谨慎。</p>
<p>日常生活有许多群体极化的例子：</p>
<ul>
<li>男孩群体和女孩群体的性别隔离会加强他们最初的中度性别差异</li>
<li>大学生群体间的差异会随着时间推移扩大化</li>
<li>社区内，想法相似的人会渐渐聚集起来，并使它们共有的倾向加强。犯罪团伙就是这样形成的。</li>
<li>恐怖组织就是从拥有相同不满情绪的人聚集起来开始形成的</li>
<li>媒介的增多和社会分隔使人们更容易与相同目的的人集合在一起，现今的互联网会加速这个过程</li>
</ul>
<p>对于极化有两种解释：一种是<strong>信息影响</strong>，群体中个人的观点也会加入讨论，互相补充，互相激励，在相似的观点不断重复后，人们就会逐渐认同这些观点；另一种是<strong>规范影响</strong>，<strong>社会比较</strong>理论提出，人类希望能对自己的能力和观点进行评价，需要通过和他人比较来达成，我们经常被“参照群体”的人们说服。在发现身边的人意见都与自己类似时，我们会表现得比以前的意向更胜一筹。（上面的解释很像从众中的两种解释原因）。在规范影响的形成过程中，会有一个<strong>人众无知</strong>的阶段，即人们不清楚他人的观点都害怕迈出第一步。社会比较会影响价值判断（他是个什么样的人），对事实判断影响则较弱（他做了什么事）。</p>
<h3 id="群体思维：好决策-amp-坏决策"><a href="#群体思维：好决策-amp-坏决策" class="headerlink" title="群体思维：好决策&amp;坏决策"></a>群体思维：好决策&amp;坏决策</h3><p>人们为了维护群体和睦而压制异议，即<strong>群体思维</strong>。友善的、有凝聚力的、有一个支配性领导的群体较容易拥有群体思维。群体思维会<em>高估群体的力量和权利</em>：</p>
<ul>
<li>无懈可击的错觉，如珍珠港事件</li>
<li>对群体道义无可置疑</li>
<li>合理化群体决策，即使决策时发动与他国的战争</li>
<li>对对手的刻板印象</li>
</ul>
<p>群体也会<em>追求一致性</em>：</p>
<ul>
<li>从众压力，群体成员会抵制对群体设想、计划提出猜疑的人</li>
<li>自我审查，即压制自己的疑虑</li>
<li>一致同意错觉</li>
<li>心理防御，群体成员为了保护群体，让质疑群体的信息不对群体造成干扰</li>
</ul>
<p>群体思维很容易导致错误的决策。也不是所有群体都会滋生群体思维，安全而团结的群体会为成员提供自由氛围来提出异议。另外，也有措施可以避免群体思维：</p>
<ul>
<li>公平，不偏向任何立场</li>
<li>鼓励批判性的分析</li>
<li>将群体拆分小组，再重组讨论不同意见</li>
<li>欢迎局外人的批评和意见</li>
</ul>
<p>头脑风暴也利用上面的方法激发创造性的想法。在运用中，人们发现庞大团体的头脑风暴是低效的。先进行群体头脑风暴再进行个人头脑风暴、让小组成员通过书写交流可以促进群体头脑风暴。</p>
<h3 id="少数派影响"><a href="#少数派影响" class="headerlink" title="少数派影响"></a>少数派影响</h3><p>个体并不是完全受群体影响，也能反过来影响群体。正如从众、说服一样。少数派受以下几个重要因素影响：</p>
<ul>
<li><strong>一致性</strong>，坚定自我立场的少数派更有影响力。尽管这个过程会比较痛苦</li>
<li><strong>自信</strong>，明显的自我支持会促使多数派重新考虑他们的立场</li>
<li><strong>从多数派叛离</strong>，从多数派投奔来的少数派更具说服力，并可能产生滚雪球效应</li>
</ul>
<p>领导分两种类型：<em>任务型</em>和<em>社会型</em>。任务型领导具有支配性，可以睿智地发出命令很好地完成工作；社会型领导通常具有民主风格，可以接纳团队成员的意见。如果有机会在决策中发言，人们会对决策结果表现更积极，因此看重群体感受并为成就感到骄傲的人会在民主领导下蓬勃发展。</p>
<p>具有领导气质的人大多是外向的、充满活力的、正直的、易于相处的、情绪稳定和自信的个体。他们通常可以赢得信任，并鼓舞其他人追随自己。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/07/30/productive-vs-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/07/30/productive-vs-code/" class="post-title-link" itemprop="url">Productive VS Code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-07-30 22:30:54 / 修改时间：23:32:57" itemprop="dateCreated datePublished" datetime="2019-07-30T22:30:54+08:00">2019-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">工程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/07/30/productive-vs-code/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/30/productive-vs-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks">Visual Studio Code Tips and Tricks</a></p>
</blockquote>
<p>这里介绍一些能提高VS Code产率的方法。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/interactive_playground.png"></p>
<p>欢迎页右下角提供Interactive playground（在命令面板里的<strong>Help &gt; Interactive Playground</strong>）。里面提供了VS Code一些关键特性的快速介绍。比如：</p>
<ul>
<li>多光标编辑</li>
<li>行操作<ul>
<li>整行向上、下移动<code>Option + up/down</code></li>
<li>整行向上、下复制<code>Shift + Option + up/down</code></li>
<li>删除整行<code>Shift + Cmd + K</code></li>
<li>注释整行<code>Cmd + /</code></li>
</ul>
</li>
<li>重构<ul>
<li>重命名：光标处<code>F2</code>，修改后自动同步相关位置</li>
<li>选中语句 -&gt; <code>Cmd + .</code> -&gt; 选择重构方式</li>
</ul>
</li>
<li>格式化文档：<code>Cmd K + Cmd F</code>或者<code>Shift + Option + F</code></li>
<li>折叠<ul>
<li>折叠<code>Option + Cmd + [</code>，展开<code>Option + Cmd + ]</code></li>
<li>折叠所有<code>Cmd K + Cmd 0</code>，展开所有<code>Cmd K + Cmd J</code></li>
</ul>
</li>
<li>代码片段：见代码片段一节</li>
<li>Emmet：见Emmet一节</li>
</ul>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="指令面板"><a href="#指令面板" class="headerlink" title="指令面板"></a>指令面板</h3><p>快捷键<code>Shift + Cmd + P</code>。里面的常见命令都有快捷键提示。</p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/KeyboardReferenceSheet.png"></p>
<h3 id="快速打开文件"><a href="#快速打开文件" class="headerlink" title="快速打开文件"></a>快速打开文件</h3><p>快捷键<code>Cmd + P</code>。点击打开文件，点击右方向键打开不会关闭当前面板。</p>
<h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p><code>Shift + Cmd + M</code></p>
<h3 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h3><p><code>Cmd K + M</code></p>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>打开指令面板，安装<code>code</code>命令。</p>
<p><img src="https://code.visualstudio.com/assets/docs/setup/mac/shell-Cmd.png"></p>
<p>常见命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># open code with current directory</span></span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the current directory in the most recently used code window</span></span><br><span class="line">code -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># change the language</span></span><br><span class="line">code --locale=es</span><br><span class="line"></span><br><span class="line"><span class="comment"># open diff editor</span></span><br><span class="line">code --diff &lt;file1&gt; &lt;file2&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定义编辑器"><a href="#自定义编辑器" class="headerlink" title="自定义编辑器"></a>自定义编辑器</h2><p><code>Cmd + ,</code>，打开编辑器编辑配置。也可以</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><code>Cmd + Shift + X</code>，利用插件增强你的开发体验和生产率。</p>
<h2 id="文件及目录"><a href="#文件及目录" class="headerlink" title="文件及目录"></a>文件及目录</h2><ul>
<li>内置terminal，<code>Ctrl + </code> &#96;或View -&gt; Terminal或命令面板里输入View: Toggle integrated terminal。<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/integrated-terminal">深度阅读</a></li>
<li>自动保存，<code>setting.json</code>中设置<code>&quot;files.autoSave&quot;: &quot;afterDelay&quot;</code></li>
<li>toggle侧边栏，<code>Cmd + B</code></li>
<li>专注模式，<code>Cmd K + Z</code></li>
<li>分栏，<code>Cmd + \</code>，使用<code>Cmd + 1</code>, <code>Cmd + 2</code>等切换</li>
<li>关闭当前tab，<code>Cmd + W</code></li>
<li>浏览历史<ul>
<li>全部历史，<code>Ctrl + Tab</code>按住选择</li>
<li>回退，<code>Ctrl + -</code></li>
<li>前进，<code>Ctrl + Shift + -</code></li>
</ul>
</li>
</ul>
<h2 id="高效编辑"><a href="#高效编辑" class="headerlink" title="高效编辑"></a>高效编辑</h2><h3 id="多光标"><a href="#多光标" class="headerlink" title="多光标"></a>多光标</h3><ul>
<li><code>Cmd + Click</code>可以多光标操作</li>
<li><code>Cmd + Shift + L</code>可以在所有选中单词的末尾多光标操作</li>
<li><code>Cmd + D</code>选中当前单词<br><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/add_cursor_current_selection.gif"></li>
</ul>
<h3 id="盒式选中"><a href="#盒式选中" class="headerlink" title="盒式选中"></a>盒式选中</h3><p><code>Shift + Alt + 拖拽</code></p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/column-select.gif"></p>
<h3 id="选中当前行"><a href="#选中当前行" class="headerlink" title="选中当前行"></a>选中当前行</h3><p><code>Cmd + L</code></p>
<h3 id="快速滚动"><a href="#快速滚动" class="headerlink" title="快速滚动"></a>快速滚动</h3><p><code>Alt + 滚动</code>可以达到x5速度的滚动</p>
<h3 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h3><p>行向上&#x2F;下复制&#x2F;剪切，见[基础]一节里的介绍</p>
<h3 id="层级选中"><a href="#层级选中" class="headerlink" title="层级选中"></a>层级选中</h3><p><code>Ctrl + Shift + Cmd + left/right</code>可以扩大&#x2F;缩小当前选择范围</p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/shrink_expand_selection.gif"></p>
<h3 id="Goto-Symbol"><a href="#Goto-Symbol" class="headerlink" title="Goto Symbol"></a>Goto Symbol</h3><ul>
<li><code>Shift + Cmd + O</code>当前文件下选择符号名，输入<code>@:</code>可以进行分类</li>
<li><code>Shift + Cmd + T</code>当前工作区下选择符号名</li>
</ul>
<h3 id="Goto特定行"><a href="#Goto特定行" class="headerlink" title="Goto特定行"></a>Goto特定行</h3><p><code>Ctrl + G</code></p>
<h3 id="trim行尾空格"><a href="#trim行尾空格" class="headerlink" title="trim行尾空格"></a>trim行尾空格</h3><p><code>Cmd K + Cmd X</code></p>
<p><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/trim_whitespace.gif"></p>
<h3 id="Markdown预览"><a href="#Markdown预览" class="headerlink" title="Markdown预览"></a>Markdown预览</h3><ul>
<li><code>Cmd + Shift + V</code></li>
<li>实时预览<code>Cmd K + V</code></li>
</ul>
<h2 id="代码联想"><a href="#代码联想" class="headerlink" title="代码联想"></a>代码联想</h2><ul>
<li>查看定义，<code>F12</code>或<code>Option + Click</code><ul>
<li>查看定义（不切换上下文）<code>Option + F12</code></li>
</ul>
</li>
<li>查看引用（不切换上下文），<code>Shift + F12</code>，查看整个项目引用<code>Shift + Option + F12</code></li>
<li>重命名，<code>F2</code></li>
<li>搜索替换，<code>Cmd + F</code>，<code>Cmd + Shift + F</code></li>
</ul>
<h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h3><p>VS Code支持<a target="_blank" rel="noopener" href="https://docs.emmet.io/">Emmet</a>风格书写HTML代码。完整的Emmet语法参考<a target="_blank" rel="noopener" href="https://docs.emmet.io/cheat-sheet/">这里</a>。</p>
<h2 id="Code-Snippet"><a href="#Code-Snippet" class="headerlink" title="Code Snippet"></a>Code Snippet</h2><p><img src="https://code.visualstudio.com/assets/docs/editor/userdefinedsnippets/ajax-snippet.gif"></p>
<p>Code Snippet即能让你更容易复用的代码模板，如for循环，if语句等。在代码联想时，可以自动帮你补全，开启<code>&quot;editor.tabCompletion&quot;: &quot;on&quot;</code>配置时，也可以使用Tab键补全。</p>
<p>在VS Code Marketplace中有许多snippets拓展。搜索”xxx snippet”多半你能找到已有的snippet拓展。</p>
<p>书写自己的snippet可以参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_create-your-own-snippets">官方文档</a>。</p>
<h2 id="Git集成"><a href="#Git集成" class="headerlink" title="Git集成"></a>Git集成</h2><p><code>Shift + Ctrl + G</code>打开。</p>
<ul>
<li>支持Side by side和Inline view两种diff模式。</li>
<li>左下角快捷切换分支<br><img src="https://code.visualstudio.com/assets/docs/getstarted/tips-and-tricks/switch_branches.gif"></li>
<li>手动添加文件、解决冲突</li>
</ul>
<p>更多参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_git-integration">Git integration</a>一节。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在命令面板中输入”Debug”查看相关命令。更多查看<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_debugging">Debugging</a>一节</p>
<h2 id="脚本任务"><a href="#脚本任务" class="headerlink" title="脚本任务"></a>脚本任务</h2><p>参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_task-runner">Task Runner</a>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/07/28/typescript-restudy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/07/28/typescript-restudy/" class="post-title-link" itemprop="url">TypeScript再学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-07-28 22:23:01 / 修改时间：22:23:59" itemprop="dateCreated datePublished" datetime="2019-07-28T22:23:01+08:00">2019-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/07/28/typescript-restudy/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/28/typescript-restudy/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>尽管项目中已经用上了TypeScript，但是主要场景下对TS的高级特性设计较少，再看过<a target="_blank" rel="noopener" href="https://github.com/LeetCode-OpenSource/hire/blob/master/typescript_zh.md">leetcode</a>面试题后，觉得自己的了解程度还远远不够。于是参考<a target="_blank" rel="noopener" href="https://github.com/basarat/typescript-book/">《TypeScript Deep Dive》</a>这本开源书（<a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/">中文版</a>）开始再学习</p>
</blockquote>
<blockquote>
<p>TypeScript Playground: <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/play/">http://www.typescriptlang.org/play/</a></p>
</blockquote>
<h2 id="TypeScript项目"><a href="#TypeScript项目" class="headerlink" title="TypeScript项目"></a>TypeScript项目</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>TS的编译过程主要通过<code>tsconfig.json</code>文件来配置（当然你也可以通过命令行的方式指定）。TS有些自己的默认配置，你也可以在<code>complierOptions</code>下自定义你的配置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span>                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span>            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span>                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="attr">&quot;sourceRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="attr">&quot;mapRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSources&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>TS有几种不同的编译方式：</p>
<ul>
<li>运行<code>tsc</code>，自动定位当前目录下tsconfig.json</li>
<li>运行<code>tsc -p [your path]</code>，手动指定config路径</li>
<li>运行<code>tsc -w</code>进入观测模式，在文件更改时自动重新编译</li>
</ul>
<p>你可以通过不同方式指定要编译的文件：</p>
<ul>
<li><code>files</code>直接指定要编译的文件</li>
<li><code>include</code>指定包含的文件</li>
<li><code>exclude</code>指定排除的文件</li>
</ul>
<p>配置值可以是glob格式。</p>
<h3 id="声明空间"><a href="#声明空间" class="headerlink" title="声明空间"></a>声明空间</h3><p>TypeScript中有两种声明空间：<strong>类型声明空间</strong>和<strong>变量声明空间</strong>。前者只能用作类型注解，后者可以用来当做变量使用。</p>
<h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><p>TS中有多种模块系统选项：</p>
<ul>
<li>AMD：仅在浏览器端使用</li>
<li>SystemJS：已被ES模块替代</li>
<li>ES模块：当前的支持有限</li>
<li>CommonJS：当前比较好的一个选择</li>
</ul>
<p>一般在工程中使用ES模块语法，模块选项使用CommonJS。TS中对类型也可以同样适用import和export。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>通常情况由<code>moduleResolution</code>选项指定。这个选项在<code>tsconfig.json</code>中声明。在声明<code>module: commonjs</code>时，<code>moduleResolution</code>自动指定为<code>node</code>。</p>
<p>导入路径分两种：</p>
<ul>
<li>相对路径，使用<code>./</code>或是<code>../</code>与文件、文件夹名称组成</li>
<li>动态路径，TS模块解析将会模仿<a target="_blank" rel="noopener" href="https://nodejs.org/api/modules.html#modules_all_together">Node模块解析规则</a>，即去当前目录、所有父目录的node_modules下寻找对应路径模块</li>
</ul>
<p>如果你本身对node下的模块查找很熟悉，那么恭喜，你已经掌握了TS的模块查找。</p>
<h4 id="global-d-ts"><a href="#global-d-ts" class="headerlink" title="global.d.ts"></a><code>global.d.ts</code></h4><p>在项目中可以通过<code>declare module &#39;somepath&#39; &#123;&#125;</code>的方式声明一个全局模块，这样的一个<code>global.d.ts</code>是声明全局类型的好地方。从js迁移到ts的项目通常需要一个这样的声明</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>TypeScript下可以使用<code>namespace</code>拆分变量的命名空间。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"><span class="title class_">Logger</span>.<span class="title function_">log</span>(<span class="string">&#x27;A message&#x27;</span>);</span><br><span class="line"><span class="title class_">Logger</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>namespace</code>支持嵌套定义，在<strong>快速演示</strong>和<strong>移植旧的JavaScript</strong></p>
<h3 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h3><p>在使用ES的动态导入功能时，为了保证TS在转换代码时保留<code>import()</code>语句，<code>tsconfig.json</code>中的<code>module</code>需要是<code>esnext</code>。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><p>包括JS的<strong>原始类型</strong>：</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>object</code></li>
<li>其他基本类型</li>
</ul>
<p><strong>数组类型</strong>在元素类型后追加<code>[]</code>实现。<strong>键值对</strong>类型使用<code>&#123;[key: string]: any&#125;</code>实现。</p>
<p>你可以使用<code>interface</code>封装自己的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">school</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">postcode</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">tags</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">        <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，对于临时的类型需要。可以直接使用<strong>内联</strong>的方式注解类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;CEO&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h4><p>除了上面的基本类型，还有一些常用的特殊类型。</p>
<p><strong>any</strong>意味着任意类型，<code>any</code>类型可以兼容任何TypeScript中的类型。因此：</p>
<ul>
<li>任意类型都可以赋值给<code>any</code></li>
<li><code>any</code>也可以赋值给任意类型</li>
</ul>
<p>初学者在从JavaScript迁移到TypeScript时，通常要借助<code>any</code>的帮助。但实际上使用<code>any</code>就代表告诉TypeScript编译器不要进行任何类型检查。</p>
<p>在<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-0-rc-2/">TypeScript 3.0</a>特性中，出现了和<code>any</code>类似的<code>unknown</code>关键字。但是后者是type safe的.</p>
<ul>
<li>任何类型都可以赋值给<code>unknown</code></li>
<li><code>unknown</code>在类型检查后才能赋值给任意类型</li>
</ul>
<p>另外在设置编译属性<code>strictNullChecks</code>为<code>false</code>时，字面量<code>null</code>和<code>undefined</code>也可以赋值给任意类型变量。</p>
<p><code>void</code>用来表示一个函数没有返回值，<code>never</code>表示不会发生的类型。例如抛出错误的函数、死循环函数的返回值类型、以及字面量空数组的元素类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArr = []; <span class="comment">// never[]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func</span>: <span class="built_in">never</span> = (<span class="function">() =&gt;</span> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Throw an error&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><code>never</code>类型间可以相互赋值，但不能和其他类型相互赋值。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>计算机算法在对封装类型操作时，往往不依赖于元素类型，这种情况下使用泛型描述，TypeScript会帮助推断元素类型，保证类型安全。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reverse&lt;T&gt;(<span class="attr">items</span>: T[]): T[] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">reverse</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">res1[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// Error</span></span><br><span class="line">res1[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h4 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h4><p><strong>交叉类型</strong>，写作<code>A &amp; B</code>，表示同时具有<code>A</code>和<code>B</code>两种类型的属性，新类型的对象可以使用A或者B的功能。</p>
<p><strong>联合类型</strong>，写作<code>A | B</code>，表示是<code>A</code>或<code>B</code>其中一种类型，较常用在入参的内联描述中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T, U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">res</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span> = &#123;&#125;;</span></span><br><span class="line"><span class="language-xml">    return &#123;</span></span><br><span class="line"><span class="language-xml">        ...first,</span></span><br><span class="line"><span class="language-xml">        ...second</span></span><br><span class="line"><span class="language-xml">    &#125;;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">function batchOperate(id: string | string[]) &#123;</span></span><br><span class="line"><span class="language-xml">    operate([].concat(id));</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>元组类型</strong>，这不是一种新类型，它用来描述不同类型元素的集合，就像宽容的JS数组一样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: user = [<span class="string">&#x27;John&#x27;</span>, <span class="number">32</span>];</span><br><span class="line"><span class="keyword">const</span> [userName, age] = userInfo;</span><br></pre></td></tr></table></figure>

<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>除开interface，还有<code>type</code>可以更快捷地定义类型别名。在结合上述高级属性使用时，类型别名<code>type</code>会是不错的选择。对比<code>interface</code>和<code>type</code>:</p>
<ul>
<li>使用<code>interface</code>定义基本的层级结构，它可以和<code>implements</code>以及<code>extends</code>配合使用</li>
<li>在需要的类型不需要从头构造，而是从已有类型推导出来时，使用<code>type</code>，它更像是给这些computed type一个语义化的名字</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是常见的组织互斥的一组常量的方式。TypeScript中用<code>enum</code>关键字表示。默认的枚举是<strong>数字类型</strong>的，即使用数字作为索引值；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> col = <span class="title class_">Color</span>.<span class="property">Red</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> anotherCol = <span class="title class_">Color</span>[<span class="number">0</span>]; <span class="comment">// &#x27;Red&#x27;</span></span><br><span class="line">col = <span class="number">0</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>在使用数字类型时，枚举值可以用数字代替。默认情况下，枚举值<strong>从0开始</strong>，当然可以用<code> = 1</code>修改默认的枚举值。下面有一个枚举值和标记的组合用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AnimalFlags</span> &#123;</span><br><span class="line">  <span class="title class_">None</span>        = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">HasClaws</span>    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">CanFly</span>      = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">EatsFish</span>    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Endangered</span>  = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">flags</span>: <span class="title class_">AnimalFlags</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的<code>Animal</code>的<code>flags</code>做位运算时可以非常方便地完成布尔代数的一些操作。</p>
<p>另外，枚举类型的值可以通过赋值成为字符串类型。在使用常量枚举时，TypeScript会将所有出现枚举的位置都替换成内联的常量，而不需要查找枚举变量，从而提高性能提升。</p>
<h3 id="从JavaScript中迁移"><a href="#从JavaScript中迁移" class="headerlink" title="从JavaScript中迁移"></a>从JavaScript中迁移</h3><p>总的来说有下面几步：</p>
<p>Step1：添加<code>tsconfig.json</code>文件。</p>
<p>Step2：修改文件拓展名为<code>ts</code>，使用<code>any</code>避免干扰你主要工作的报错，记得在之后规范</p>
<p>Step3：写新的TypeScript代码，减少<code>any</code>使用</p>
<p>Step4：回头为你的老代码添加类型</p>
<p>Step5：为你的第三方库引用类型声明，绝大多数优秀的JS库都已经有人帮忙写好<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">类型声明</a>了</p>
<p>Step6：对于那些没有声明的第三方库，需要你自己书写类型声明或者<code>declare module yourmodule</code>一劳永逸</p>
<p>上面提到的类型声明，即DefinitelyTyped通过npm包的方式引入，包有固定前缀<code>@types</code>。</p>
<p>有些类型声明的引入会带来全局scope的定义，可以通过在<code>tsconfig.json</code>里配置<code>types</code>来限制引入的声明文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;jquery&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h3><p>通过<code>declare</code>关键字告诉TypeScript，你正在表述其他位置已经存在的全局变量。强烈建议把所有的声都放在以<code>.d.ts</code>结尾的文件名的文件内。环境声明不会被编译成代码。</p>
<p>在这样的模块、变量、类型声明文件里，<code>interface</code>是最常见的。用户代码中可以用类实现这些接口。但是请记住，<code>interface</code>旨在声明JavaScript中可能存在的数据结构。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>; <span class="comment">// New member</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPoint</span> <span class="keyword">implements</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ERROR : missing member `z`</span></span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lib-d-ts"><a href="#lib-d-ts" class="headerlink" title="lib.d.ts"></a><code>lib.d.ts</code></h3><p>为了便于你能快速开始书写类型检查的代码，TypeScript自带了BOM的变量声明（包含window、document、math等）位于<code>lib.d.ts</code>中。你可以在你的项目下添加<code>global.d.ts</code>，对已有的全局变量做自己的拓展。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DateConstructor</span> &#123;</span><br><span class="line">    <span class="title function_">lastDay</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">foo</span>();</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">lastDay</span>()</span><br></pre></td></tr></table></figure>

<p>你在自己定义的<code>global.d.ts</code>中可以通过拓展global，修改全局空间内的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">endsWith</span>(<span class="attr">suffix</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h4><ul>
<li>指定<code>--noLib</code>可以排除TypeScript自动引入的<code>lib.d.ts</code>，这通常出现在<ul>
<li>运行JavaScript的环境和标准浏览器相距甚远</li>
<li>你希望严格控制全局变量的使用</li>
</ul>
</li>
<li>指定<code>--lib</code>可以对编译环境进行细粒度控制引入的包类型<ul>
<li>tsc中，<code>tsc --target es5 --lib dom,es6</code></li>
<li>也可以在<code>tsconfig.json</code>中声明<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dom&quot;</span><span class="punctuation">,</span> <span class="string">&quot;es6&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>如果没有指定<code>--lib</code>，TypeScript会根据当前编译选项中的<code>target</code>导入默认库。</p>
<ul>
<li><code>--target</code>为es5时，导入es5、dom、scriptdom</li>
<li><code>--target</code>为es6时，导入es6、dom、dom.iterable、scripthost</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数注解可以使用内联或<code>interface</code>的方式。通常编译器可以根据代码自动推断函数的返回类型。函数入参的可选参数通过类型注解前的<code>?</code>说明。另外，TypeScript允许你<strong>声明</strong>函数重载，注意，这里只是声明，重载需要自己实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adult</span>(<span class="params">itself: human</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adult</span>(<span class="params">itself: human, mate: human, children: human[]</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adult</span>(<span class="params">itself: human, mate?: human, children?: human[]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!mate) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; itself &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    itself,</span><br><span class="line">    mate,</span><br><span class="line">    <span class="attr">children</span>: children || []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">adult</span>(yourself, anotherGuy); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h4 id="可调用的"><a href="#可调用的" class="headerlink" title="可调用的"></a>可调用的</h4><p>可以用类型别名或接口表示可调用的类型。函数重载和构造函数定义都可以在其中实现。使用<code>new</code>作为前缀后，需要使用<code>new</code>关键字去调用这个函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Overloaded</span> &#123;</span><br><span class="line">  (<span class="attr">foo</span>: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span>;</span><br><span class="line">  <span class="function">(<span class="params">foo: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ConstructorFunc</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用箭头函数作内联函数注解，但这种时候无法表示重载。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="function">(<span class="params">bar: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="params">bar</span> =&gt;</span> bar.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>

<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>字面量 + 联合类型构成TS中常用的字面量类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Seasons</span> = <span class="string">&#x27;spring&#x27;</span> | <span class="string">&#x27;summer&#x27;</span> | <span class="string">&#x27;autumn&#x27;</span> | <span class="string">&#x27;winter&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> binary = <span class="number">0</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> bools = <span class="literal">true</span> | <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>很多时候字面量类型会通过<code>keyof</code>一个键值对的形式来构造。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建字符串列表映射至 `K: V` 的函数</span></span><br><span class="line"><span class="keyword">function</span> strEnum&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">o</span>: <span class="title class_">Array</span>&lt;T&gt;): &#123; [K <span class="keyword">in</span> T]: K &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> o.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, key</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = key;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;, <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 K: V</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Direction</span> = <span class="title function_">strEnum</span>([<span class="string">&#x27;North&#x27;</span>, <span class="string">&#x27;South&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = keyof <span class="keyword">typeof</span> <span class="title class_">Direction</span>;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>TypeScript有自己的类型推断，但是允许你使用<strong>类型断言</strong>去覆盖。通过<code>as Something</code>或<code>&lt;Something&gt;</code>的方式。但是后者接近JSX语法，所以更多使用前者。</p>
<p>断言是编译时的，为编译器提供分析代码的方法。TypeScript在进行类型断言时，会判断源类型<code>S</code>是否是目标类型<code>T</code>的子集，若不是则不能成功断言。</p>
<h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>使用JS中<code>typeof</code>和<code>instanceof</code>可以帮助TypeScript推导出条件语句内的变量类型。使用<code>in</code>操作符，也可以帮助TypeScript判断类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">q: A | B</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> q) &#123;</span><br><span class="line">    <span class="comment">// q: A</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// q: B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在联合类型中，如果有类型使用字面量，TypeScript甚至可以通过判断字面量确定变量类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">arg: Foo | Bar</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.<span class="property">kind</span> === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">foo</span>); <span class="comment">// ok</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">bar</span>); <span class="comment">// Error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 一定是 Bar</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">foo</span>); <span class="comment">// Error</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">bar</span>); <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，弥补JS中plain object没有<code>instanceof</code>或<code>typeof</code>自我检查的漏洞。TypeScript提供了<code>is</code>允许自定义类型判断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅仅是一个 interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">common</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">common</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自己定义的类型保护！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFoo</span>(<span class="params">arg: Foo | Bar</span>): arg is <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (arg <span class="keyword">as</span> <span class="title class_">Foo</span>).<span class="property">foo</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>TypeScript可以根据一些规则推断出变量类型：</p>
<ul>
<li>定义变量</li>
<li>函数返回</li>
<li>赋值</li>
<li>结构化（数组元素、对象属性）</li>
<li>解构</li>
</ul>
<p>在推断不出类型或使用第三方JS库时，类型会被判定为<code>any</code>。开启编译选项<code>noImplicitAny</code>可以避免这种问题。</p>
<h3 id="类型兼容"><a href="#类型兼容" class="headerlink" title="类型兼容"></a>类型兼容</h3><ul>
<li>结构化：只要对象结构匹配，名称无关紧要</li>
<li>多态性：子类实例可以复制给基类实例，相反则不行</li>
<li>函数<ul>
<li>返回类型：数据较多的可以赋值给数据较少的</li>
<li>入参：入参较少的可以赋值给入参较多的</li>
<li>可选参数、Rest参数：可以相互赋值（可选和必选仅在<code>strictNullChecks</code>选中时相互兼容）</li>
<li>入参类型：父类子类相互兼容（牺牲安全性确保便利性）</li>
</ul>
</li>
<li>枚举：和数字类型兼容、不同枚举间不兼容</li>
<li>类：仅比较<strong>实例成员和实例方法</strong>，不比较构造函数和静态成员，<code>private</code>和<code>protected</code>成员必须来自相同的类</li>
<li>泛型：泛型对兼容性没有影响（这可能会带来一些潜在问题）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Poin2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">iTakePoint2D</span> = (<span class="params">point: Point2D</span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">iTakePoint3D</span> = (<span class="params">point: Point3D</span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">iTakePoint3D = iTakePoint2D; <span class="comment">// ok, 这是合理的</span></span><br><span class="line">iTakePoint2D = iTakePoint3D; <span class="comment">// also ok，为什么？</span></span><br></pre></td></tr></table></figure>

<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>用<code>readonly</code>标记接口属性，表示预期不可修改。获取使用<code>Readonly</code>封装一个泛型<code>T</code>，表示泛型内的属性均不可修改。同样地，你可以为索引签名声明<code>readonly</code>，表示所有索引元素均不可修改。还有些情况下，如果属性配置了<code>getter</code>，但没有<code>setter</code>也会被认为是只读的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readonly</code>和<code>const</code>的主要不同在于，前者用来修改属性，后者用于变量。</p>
<h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><p>索引即数组或键值对的索引。TypeScript中索引类型只能是<code>string</code>或<code>number</code>类型。这意味着，也可以使用字面量类型作为索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Index</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FromIndex</span> = &#123; [k <span class="keyword">in</span> <span class="title class_">Index</span>]?: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">good</span>: <span class="title class_">FromIndex</span> = &#123; <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>在一些特殊场景下，可以同时支持<code>string</code>和<code>number</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ArrStr</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 必须包括所用成员类型</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 字符串索引类型的子级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流动的类型"><a href="#流动的类型" class="headerlink" title="流动的类型"></a>流动的类型</h3><p><code>typeof</code>可以捕获变量、类成员类型。使用<code>typeof</code>在捕获一个字符串字面量时，得到的类型是字面量类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>: <span class="keyword">typeof</span> foo; <span class="comment">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获字符串的类型与值</span></span><br><span class="line"><span class="keyword">const</span> faz = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个捕获的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">baz</span>: <span class="keyword">typeof</span> faz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar 仅能被赋值 &#x27;Hello World&#x27;</span></span><br><span class="line">baz = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// ok</span></span><br><span class="line">baz = <span class="string">&#x27;anything else&#x27;</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>使用<code>keyof</code>捕获一个类型的键。</p>
<h3 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType</h3><p>在对象字面量方法的类型定义上声明<code>ThisType()</code>可以修改发放内<code>this</code>的类型，这常被用在<code>this</code>值被重新绑定的情况。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="bind的隐患"><a href="#bind的隐患" class="headerlink" title="bind的隐患"></a><code>bind</code>的隐患</h3><p>在<code>lib.d.ts</code>中，对<code>bind</code>的定义如下:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">bind</span>(<span class="attr">thisArg</span>: <span class="built_in">any</span>, ...<span class="attr">argArray</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<p>由于返回值是<code>any</code>类型，意味着bind返回的函数将失去类型检查（最新的TS 3.2已经优化了这个问题）。</p>
<h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>用一系列箭头表示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; <span class="function">(<span class="params">y: <span class="built_in">number</span></span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">123</span>)(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分应用</span></span><br><span class="line"><span class="keyword">let</span> add123 = <span class="title function_">add</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fully apply the function</span></span><br><span class="line"><span class="title function_">add123</span>(<span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><ul>
<li>使用继承而不是<code>as</code>来实现泛型实例化</li>
<li>使用<code>as</code>来初始化对象字面量的空对象</li>
<li>尝试使用类组织代码</li>
<li>小心使用<code>setter</code>，不要牺牲代码可读性</li>
<li>在参数名可以很好提高可读性、入参很多时，考虑让函数接受一个对象参数</li>
</ul>
<h3 id="Reflect-Metadata"><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h3><p>Reflect Metadata是ES7的提案，用于在声明时添加和读取元数据。Reflect Metadata的API可以用于类或类属性上，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;inClass&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;inMethod&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">hello</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;inClass&#x27;</span>, <span class="title class_">Test</span>)); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;inMethod&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Test</span>(), <span class="string">&#x27;hello&#x27;</span>)); <span class="comment">// &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因此可以通过<code>Reflect.getMetadata</code>的API来获取类相关的元数据。</p>
<h4 id="自定义metadatakey"><a href="#自定义metadatakey" class="headerlink" title="自定义metadatakey"></a>自定义<code>metadatakey</code></h4><p>可以定义自己的reflect metadata。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classDecorator</span>(<span class="params"></span>): <span class="title class_">ClassDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在类上定义元数据，key 为 `classMetaData`，value 为 `a`</span></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&#x27;classMetaData&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">methodDecorator</span>(<span class="params"></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在类的原型属性 &#x27;someMethod&#x27; 上定义元数据，key 为 `methodMetaData`，value 为 `b`</span></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&#x27;methodMetaData&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@classDecorator</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">  <span class="meta">@methodDecorator</span>()</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;classMetaData&#x27;</span>, <span class="title class_">SomeClass</span>); <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;methodMetaData&#x27;</span>, <span class="keyword">new</span> <span class="title class_">SomeClass</span>(), <span class="string">&#x27;someMethod&#x27;</span>); <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以借助Reflect Metadata的这个特点，实现诸如控制反转、依赖注入、装饰器等功能。</p>
<h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="attr">X</span>: Y</span><br></pre></td></tr></table></figure>

<p>TypeScript 2.8的一个<a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/pull/21496">PR</a>里第一次提到条件类型。条件类型主要规则如下：</p>
<ul>
<li>上式表示<strong>T如果可以赋值给U</strong>，返回类型<code>X</code>，否则返回<code>Y</code></li>
<li>在<code>U</code>中出现<code>infer</code>时，TypeScript会去推断<code>infer</code>后的类型变量（假设是<code>V</code>），如果<code>V</code>出在协变位置，则返回<code>V</code>所有可能性的联合类型，如果<code>V</code>出现在逆变位置，则返回<code>V</code>所有可能性的交叉类型（参考：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变</a>）</li>
</ul>
<h4 id="分布条件类型"><a href="#分布条件类型" class="headerlink" title="分布条件类型"></a>分布条件类型</h4><p>在检查类型（<code>extends</code>前的类型参数）是原始类型（即没有被泛型等封装）时，称为分布条件类型（Distributive conditional types）。在实例化为实际类型时，联合类型会被拆分开。</p>
<p>例如，<code>T</code>实例化为<code>A | B | C</code>时，<code>T extends U ? X : Y</code>会被解析成<code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionPropertyNames</span>&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="title class_">Function</span> ? K : <span class="built_in">never</span> &#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionProperties</span>&lt;T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">FunctionPropertyNames</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonFunctionPropertyNames</span>&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="built_in">never</span> : K &#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonFunctionProperties</span>&lt;T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">NonFunctionPropertyNames</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">subparts</span>: <span class="title class_">Part</span>[];</span><br><span class="line">    <span class="title function_">updatePart</span>(<span class="attr">newName</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T40</span> = <span class="title class_">FunctionPropertyNames</span>&lt;<span class="title class_">Part</span>&gt;;  <span class="comment">// &quot;updatePart&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T41</span> = <span class="title class_">NonFunctionPropertyNames</span>&lt;<span class="title class_">Part</span>&gt;;  <span class="comment">// &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T42</span> = <span class="title class_">FunctionProperties</span>&lt;<span class="title class_">Part</span>&gt;;  <span class="comment">// &#123; updatePart(newName: string): void &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T43</span> = <span class="title class_">NonFunctionProperties</span>&lt;<span class="title class_">Part</span>&gt;;  <span class="comment">// &#123; id: number, name: string, subparts: Part[] &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="infer"><a href="#infer" class="headerlink" title="infer"></a><code>infer</code></h4><p>如上文所说，<code>infer</code>最初出现是用来表示<code>extends</code>条件语句中待推断的类型。下文中若T满足<code>(param: infer P) =&gt; any</code>类型，则推出<code>P</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParamType</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">param</span>: infer P) =&gt; <span class="built_in">any</span> ? P : T;</span><br></pre></td></tr></table></figure>

<p><code>infer</code>有下面一些常规使用场景。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer P ? P : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数的入参或实例类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Constructor</span> = <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InstanceType</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>联合<code>infer</code>和分布条件类型，可以实现一些骚操作，如tuple、intersection、union之间的转换。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tupleToIntersection&lt;T&gt; = T[<span class="built_in">number</span>]；</span><br><span class="line"><span class="keyword">type</span> unionToIntersection&lt;T&gt; = (T <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">(<span class="params">k: T</span>) =&gt;</span> <span class="built_in">void</span> : <span class="built_in">never</span>) <span class="keyword">extends</span> (<span class="function">(<span class="params">k: infer R</span>) =&gt;</span> <span class="built_in">void</span>) ? R : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>如原文列的<a target="_blank" rel="noopener" href="https://github.com/LeetCode-OpenSource/hire/blob/master/typescript_zh.md">LeetCode TypeScript面试题</a>。借助强大的条件类型和<code>infer</code>就能实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  payload?: T;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预期的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = &#123;</span><br><span class="line">  asyncMethod&lt;T, U&gt;(<span class="attr">input</span>: T): <span class="title class_">Action</span>&lt;U&gt;;</span><br><span class="line">  syncMethod&lt;T, U&gt;(<span class="attr">action</span>: T): <span class="title class_">Action</span>&lt;U&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">  asyncMethod&lt;T, U&gt;(<span class="attr">input</span>: <span class="title class_">Promise</span>&lt;T&gt;): <span class="title class_">Promise</span>&lt;<span class="title class_">Action</span>&lt;U&gt;&gt;;</span><br><span class="line">  syncMethod&lt;T, U&gt;(<span class="attr">action</span>: <span class="title class_">Action</span>&lt;T&gt;): <span class="title class_">Action</span>&lt;U&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FuncNames</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="title class_">Function</span> ? K : <span class="built_in">never</span></span><br><span class="line">&#125;[keyof T]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FuncProperties</span>&lt;T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">FuncNames</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnPackedParams</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer R&gt; ? R :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;infer R&gt; ? R : T;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnPackedReturn</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer R&gt; ? R : T;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnPackedFunction</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">params</span>: infer U) =&gt; infer R ? <span class="function">(<span class="params">params: UnPackedParams&lt;U&gt;</span>) =&gt;</span> <span class="title class_">UnPackedReturn</span>&lt;R&gt; : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Resolve</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="title class_">UnPackedFunction</span>&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Connect 的类型，让 connected 的类型变成预期的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Connect</span> = <span class="function">(<span class="params"><span class="variable language_">module</span>: Module</span>) =&gt;</span> <span class="title class_">Resolve</span>&lt;<span class="title class_">FuncProperties</span>&lt;<span class="title class_">Module</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript编译原理"><a href="#TypeScript编译原理" class="headerlink" title="TypeScript编译原理"></a>TypeScript编译原理</h2><blockquote>
<p>这部分内容较为简要。</p>
</blockquote>
<p>编译器源文件位于<code>src/compiler</code>下，主要由以下部分组成：</p>
<ul>
<li>扫描器 Scanner</li>
<li>解析器 Parser</li>
<li>绑定器 Binder</li>
<li>检查器 Checker</li>
<li>发射器 Emitter</li>
</ul>
<p>处理流程分下面几步：</p>
<ul>
<li><code>Source --扫描器--&gt; Token流</code></li>
<li><code>Token流 --解析器--&gt; AST(抽象语法树)</code></li>
<li><code>AST --绑定器--&gt; Symbols</code></li>
<li><code>AST + 符号 --检查器--&gt; 类型验证</code></li>
<li><code>AST + 检查器 --发射器--&gt; JavaScript代码</code></li>
</ul>
<h3 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h3><ul>
<li><code>core.ts</code> TypeScript编译器使用的核心工具集</li>
<li><code>types.ts</code> 包含整个编译器使用的关键数据结构和接口</li>
<li><code>system.ts</code> 控制编译器和操作系统的所有交互</li>
</ul>
<h3 id="程序与抽象语法树"><a href="#程序与抽象语法树" class="headerlink" title="程序与抽象语法树"></a>程序与抽象语法树</h3><p>这里的“程序”指一个“编译上下文”。它包含SourceFile和编译选项。TypeScript有API获取SourceFile列表，每个SourceFile都是一棵抽象语法树的根节点。</p>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>节点（Node）是AST的基本组成单位。Node有一些关键成员：</p>
<ul>
<li><code>TextRange</code> 标识节点在源文件的起止位置</li>
<li><code>parent?: Node</code> 标识节点在AST中的父节点</li>
<li>标志（flags）和修饰符（modifier）等有助于节点遍历的成员</li>
</ul>
<p>下面有一些常用工具函数的用法：</p>
<ul>
<li><code>ts.forEachChild</code> 用来访问任一节点的所有子节点。这个函数会根据每个节点的<code>node.kind</code>判断node类型，然后再在子节点上调用cbNode。</li>
<li><code>ts.SyntaxKind</code>是一个节点类型的常量枚举，用以表示不同的语法树节点</li>
<li><code>ts.getLeadingCommentRanges</code>和<code>ts.getTrailingCommentRanges</code>分别获取给定位置第一个换行符到token和之前的注释范围。</li>
<li><code>ts.getStart</code>和<code>ts.getFullStart</code>分别获取一个token文本开始位置和上一个重要token开始扫描的位置</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">SyntaxKind</span> &#123;</span><br><span class="line">    <span class="title class_">Unknown</span>,</span><br><span class="line">    <span class="title class_">EndOfFileToken</span>,</span><br><span class="line">    <span class="title class_">SingleLineCommentTrivia</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扫描器与解析器"><a href="#扫描器与解析器" class="headerlink" title="扫描器与解析器"></a>扫描器与解析器</h3><p>扫描器用于读取文本，并转换为Token流。扫描器由解析器（<code>parser.ts</code>）创建，为了避免创建扫描器的开销。<code>parser.ts</code>创建的扫描器是单例。</p>
<p>扫描器<code>scanner.ts</code>本身提供API给出扫描过程中的各种信息。尽管解析器创建的扫描器是单例，你仍可以使用<code>createScanner</code>创建自己的扫描器，并调用<code>setText</code>、<code>setTextPos</code>随意扫描文件的不同位置。</p>
<p>解析器由程序经由<code>CompilerHost</code>创建，<code>CompileHost</code>通过<code>getSourceFile</code>准备好待编译文件，再交由解析器处理。解析器根据内部扫描器得到的Token构造一个SourceFile下的语法树。</p>
<p>解析器使用<code>parseSourceFileWorker</code>和<code>parseStatements</code>创建根节点和其余节点。具体解析每种节点的过程写在<code>parseXxx</code>中。</p>
<h3 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h3><p>绑定器主要职责是创建<em>符号</em>（Symbol）。符号将AST的声明节点和其他声明连接到相同实体上。绑定器会在检查器内被调用，检查器又被程序调用。</p>
<p>绑定器有几个重要函数：</p>
<ul>
<li><code>bindSourceFile</code>，检查<code>file.locals</code>是否定义，没有则交给内部函数<code>bind</code>处理。<code>bindSourceFile</code>内部还定义了许多别的内部变量，通过闭包被其他内部函数使用</li>
<li><code>bind</code>处理任意节点绑定，先分配<code>node.parent</code>，在交给<code>bindWorker</code>做主要工作，之后调用<code>bindChildren</code>执行子节点的绑定</li>
<li><code>bindWorker</code>根据节点类型，委托工作给特定的<code>bindXXX</code>函数完成。在<code>bindXXX</code>内最常用的是<code>createSymbol</code>函数</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSymbol</span>(<span class="params">flags: SymbolFlags, name: <span class="built_in">string</span></span>): <span class="title class_">Symbol</span> &#123;</span><br><span class="line">  symbolCount++;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(flags, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定器会调用<code>addDeclarationToSymbol</code>绑定一个节点到符号，并把节点添加成符号的一个声明。声明就是一个有可选名字的节点。</p>
<h3 id="检查器与发射器"><a href="#检查器与发射器" class="headerlink" title="检查器与发射器"></a>检查器与发射器</h3><p>检查器由程序初始化。在发射器中，类型检查在<code>getDiagnostics</code>中发生，函数被调用时会返回一个<code>EmitResolver</code>。这是一个<code>createTypeChecker</code>的本地函数集合。</p>
<p>TypeScript有两个发射器，<code>emitter.ts</code>完成TS到JavaScript，<code>declarationEmitter.ts</code>为<code>.ts</code>创建声明文件(<code>.d.ts</code>)。</p>
<p>程序（Program）通过<code>emit</code>函数，把工作委托给<code>emitter.ts</code>的<code>emitFiles</code>函数。<code>emitFiles</code>中借助<code>emitJavaScript</code>完成主要工作，</p>
<p><code>emitJavaScript</code>中有大量内部函数，之后借给<code>emitSourceFile</code>发射文本，该函数设置<code>currentSourceFile</code>后交给本地的<code>emit</code>函数处理。在<code>emitJavaScriptWorker</code>中会根据不同符号类型调用不同发射器处理。在<code>emitJavaScript</code>的过程中，<code>initializeEmitterWithSourceMaps</code>使用带有sourceMap的版本覆盖部分本地函数，使大多数发射器代码无需考虑SourceMap。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="类型系统的行为"><a href="#类型系统的行为" class="headerlink" title="类型系统的行为"></a>类型系统的行为</h3><p>首先有几个需要格外说明的：</p>
<ul>
<li>TypeScript使用<strong>结构化类型</strong>，即类型间的成员类型兼容即类型兼容。</li>
<li>TypeScript的类型时<em>编译时</em>的，在运行时并没有类型信息，无法从反射或元数据中拿到。</li>
</ul>
<p>此外有些常见问题：</p>
<ul>
<li><strong>没有setter的getter并没有体现出只读属性</strong>，这在TypeScript2.0+已修复</li>
<li>更少参数的函数可以赋值给更多参数的函数；返回值更多的函数可以复制给返回值更少的函数</li>
<li>任何类型都可以等价替代没有属性的interface</li>
<li>类型别名只是别名而已，进行类型判断时使用的是别名对应的类型</li>
<li>由于结构化类型，两个不同名但是结构相同的类型，实际上是相互兼容的，有个<a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/202">相关issue</a>，但是尚没有结论</li>
<li>由于TS的类型只存在于编译时，不能用运行时的<code>typeof</code>或<code>instanceof</code>判断类型。同样地，错误的TS类型转化也不会造成运行时的错误</li>
<li>重载的最后一个声明签名对签名本身没有影响，所以为了获得重载本身的行为，需要添加额外的重载</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createLog</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLog</span>(<span class="params">source: <span class="built_in">string</span>, message: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLog</span>(<span class="params">source: <span class="built_in">string</span>, message?: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些常见的Feature-Request"><a href="#一些常见的Feature-Request" class="headerlink" title="一些常见的Feature Request"></a>一些常见的Feature Request</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-optional-chaining">安全的导航操作符</a>，类似<code>a?.b?.c</code>，目前已在tc39的Stage 3阶段，将并入TS的3.7.0版本</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/8">代码压缩</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/212">bind(), call(), apply()返回的函数无类型</a></li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="空类的行为很奇怪"><a href="#空类的行为很奇怪" class="headerlink" title="空类的行为很奇怪"></a>空类的行为很奇怪</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">e</span>: <span class="title class_">Empty</span> = <span class="variable language_">window</span>;</span><br></pre></td></tr></table></figure>

<p>和之前提到的一样，<strong>任何内容都可以赋值给空接口</strong>。所以一般来说，永远不要声明一个没有任何属性的类，对于子类而是如此。</p>
<h4 id="如何比较类"><a href="#如何比较类" class="headerlink" title="如何比较类"></a>如何比较类</h4><p>TypeScript中，类进行结构上的比较，但是对于<code>private</code>和<code>protected</code>属性除外。类在比较时，如果有成员是<code>private</code>或<code>protected</code>，它们必须来自同一个声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alpha</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bravo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Charlie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delta</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Alpha</span>(),</span><br><span class="line">  b = <span class="keyword">new</span> <span class="title class_">Bravo</span>(),</span><br><span class="line">  c = <span class="keyword">new</span> <span class="title class_">Charlie</span>(),</span><br><span class="line">  d = <span class="keyword">new</span> <span class="title class_">Delta</span>();</span><br><span class="line"></span><br><span class="line">a = b; <span class="comment">// OK</span></span><br><span class="line">c = d; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h4 id="class和typeof-class的区别"><a href="#class和typeof-class的区别" class="headerlink" title="class和typeof class的区别"></a><code>class</code>和<code>typeof class</code>的区别</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">x</span>: <span class="title class_">MyClass</span>;</span><br><span class="line"><span class="comment">// Cannot assign &#x27;typeof MyClass&#x27; to MyClass? Huh?</span></span><br><span class="line">x = <span class="title class_">MyClass</span>;</span><br></pre></td></tr></table></figure>

<p>上面混用了类型名和类本身，在JavaScript中，类仅仅是一个函数而已。而在TypeScript中，类名表示类实例的类型。</p>
<h4 id="子类的属性在constructor中会被父类同名属性覆盖"><a href="#子类的属性在constructor中会被父类同名属性覆盖" class="headerlink" title="子类的属性在constructor中会被父类同名属性覆盖"></a>子类的属性在constructor中会被父类同名属性覆盖</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// Default value</span></span><br><span class="line">    myColor = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">myColor</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">     myColor = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints &quot;blue&quot;, expected &quot;red&quot;</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure>

<p>直接原因是在子类constructor中，父类的constructor要先执行。见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43595943/why-are-derived-class-property-values-not-seen-in-the-base-class-constructor">Stack Overflow</a>的解释。</p>
<h4 id="interface和declare-class的区别"><a href="#interface和declare-class的区别" class="headerlink" title="interface和declare class的区别"></a><code>interface</code>和<code>declare class</code>的区别</h4><ul>
<li><code>interface</code>用来声明一种类型，不会生成实际代码。</li>
<li><code>declare class</code>用来描述一个已有类的结构</li>
</ul>
<h4 id="为什么我导入的模块在编译后被删除了"><a href="#为什么我导入的模块在编译后被删除了" class="headerlink" title="为什么我导入的模块在编译后被删除了"></a>为什么我导入的模块在编译后被删除了</h4><p>TypeScript默认导入的模块不包含副作用，所以会移除不用于任何表达式的模块导入。使用<code>import &#39;xxx&#39;;</code>强制导入有副作用的模块。</p>
<h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a><code>tsconfig.json</code></h4><ul>
<li>为什么exclude中的文件仍然会被编译器选中？<ul>
<li>当exclude的文件被其他include文件依赖时，仍然会被包含进来</li>
</ul>
</li>
<li>除了<code>include</code>外，还有没有指定包含文件的方式<ul>
<li><code>files</code>指定文件列表</li>
<li>目录中添加<code>///&lt;reference path=&quot;&quot;&gt;</code>引入</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/07/26/social-psychology-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/07/26/social-psychology-part-1/" class="post-title-link" itemprop="url">社会心理学 Part 1 - 导论 & 社会思维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-26 00:53:15" itemprop="dateCreated datePublished" datetime="2019-07-26T00:53:15+08:00">2019-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-11-02 21:48:50" itemprop="dateModified" datetime="2019-11-02T21:48:50+08:00">2019-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/07/26/social-psychology-part-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/26/social-psychology-part-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考《社会心理学》 David G. Myers 第8版</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/08/07/social-psychology-part-2/">社会心理学 Part 2 - 社会影响</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/09/24/social-psychology-part-3/">社会心理学 Part 3 - 社会关系</a><br><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2019/11/02/social-psychology-part-4/">社会心理学 Part 4 - 应用</a></p>
</blockquote>
<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>什么是社会心理学？社会心理学研究：</p>
<ul>
<li>人们如何看待他人（社会思维）</li>
<li>人们如何影响他人（社会影响）</li>
<li>人们如何相互关联（社会关系）</li>
</ul>
<p>类似经济学等其他人文社科，社会心理学亦有些基于上面几方面的<strong>重要观点</strong>：</p>
<ul>
<li>我们个人构建起社会现实</li>
<li>我们天生具有的社会直觉是强大的，但有些时候是危险的</li>
<li>社会影响塑造行为，比如我们渴望彼此之间建立关联、渴望归属感、渴望得到他人的良好评价</li>
<li>个人态度和性格倾向塑造行为</li>
<li>社会行为同样也是生物性行为，我们是社会、心理、生物的共同产物</li>
</ul>
<p>社会心理学不同于社会学：</p>
<ul>
<li>社会学研究<strong>团体</strong>，社会心理学研究<strong>个人</strong></li>
<li>社会学较难控制研究因素来做实验，社会心理学则可以控制变量来模拟实验</li>
</ul>
<p>社会心理学不同于人格心理学：</p>
<ul>
<li>人格心理学研究<strong>个体间差异</strong>，社会心理学研究个体的<strong>社会因素</strong></li>
<li>人格心理学历史悠久，有诸多大师；社会心理学则比较年轻</li>
</ul>
<p>另外不论是心理学还是别的学科，都是对一个事实的不同表述，每个学科都需要一些公设作为基础，它们之间没有高下之分。</p>
<h3 id="价值观对研究的影响"><a href="#价值观对研究的影响" class="headerlink" title="价值观对研究的影响"></a>价值观对研究的影响</h3><p>直接影响来自于：课题选择、投身人群、实验目标等等方面。间接影响来自于：</p>
<ul>
<li>科学具有<strong>主观性</strong>，心理学则更是如此</li>
<li>研究者在做<strong>价值判断</strong>时会受到个人价值观的影响</li>
<li>当讨论从<strong>是什么</strong>变成<strong>怎么样</strong>时，就会把价值观纳入讨论之中</li>
</ul>
<p>另外，特别澄清一个误解：<strong>社会心理学不过是常识而已嘛</strong>。社会心理学的结论往往简单易懂且贴近生活，所以会给人一种<strong>事后聪明型偏见</strong>。主要因为下面两点：</p>
<ul>
<li>心理学的高级结论往往正着说、反着说都有道理；就像谚语，比如“魔高一尺道高一丈”和“道高一尺魔高一丈”听起来都对</li>
<li>事先得知结论然后去理解和通过努力发现结论完全不是一回事；当你有上述偏见时，尝试把两个相反结论放在一起做个选择题就知道了困难程度了</li>
</ul>
<h3 id="如何研究"><a href="#如何研究" class="headerlink" title="如何研究"></a>如何研究</h3><p>好的假设：1）为研究指出方向；2）探测新的研究领域；3）具有应用价值。</p>
<p>好的理论：1）能对大范围观察结果做总结；2）对我们证明修改理论、进行新探索、指出可能应用方向给出清晰的预测</p>
<p>研究方法主要分为两种：<strong>相关研究</strong>和<strong>实验研究</strong>。</p>
<ul>
<li>相关研究发生在<strong>真实情景</strong>中，易于进行，只能发现<strong>相关性</strong>，因为无法控制变量，因而无法证明因果性<ul>
<li>对实验对象要足够有代表性（<strong>随机抽样</strong>）</li>
<li>认真组织问题，因为问题的<strong>顺序</strong>、<strong>选项编制</strong>、<strong>措辞</strong>都会影响被试的反应</li>
</ul>
</li>
<li>实验研究通过在<strong>实验室</strong>控制自变量，从而探寻<strong>因果性</strong><ul>
<li>同样需要随机分配 + 施加不同外在条件保证额外因素的干扰消除</li>
<li>需要自设实验情景，有时会面临伦理道德问题</li>
</ul>
</li>
</ul>
<h2 id="社会思维"><a href="#社会思维" class="headerlink" title="社会思维"></a>社会思维</h2><h3 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h3><p>这一章主要讨论人们如何评价、认识自己，如何维持自尊，社会思维如何产生等问题。</p>
<p><strong>焦点效应</strong>使我们高估自己的突出程度，从而产生<strong>透明度错觉</strong>（实际注意我们的人比我们认为的少）。</p>
<h4 id="自我概念"><a href="#自我概念" class="headerlink" title="自我概念"></a>自我概念</h4><p>自我的部分是自我概念的基础，<strong>自我图式</strong>是我们组织自己所在世界的心理模板。<strong>自我参照效应</strong>让我们更好地以自我为中心组织记忆。同时，自我概念还包括我们<strong>想象中的自我</strong>。</p>
<p>社会的部分同样扮演了很重要的角色。包括以下几点：</p>
<ul>
<li>我们在社会中扮演的角色</li>
<li>社会同一性，即你身边的社会群体，诸如民族、信仰、性别等</li>
<li>社会比较</li>
<li>成功和失败经验。用积极的信息提高自尊会激发个体做出更大成就，全力以赴并取得了成功会使人感到更加自信有力。<strong>自尊不仅来自告诉孩子他们有多棒，还要让他们通过辛苦努力获得成功</strong></li>
<li>其他人的评价。与我们自我概念有关的是我们<em>觉得</em>他们如何评价我们，而不是他们实际上如何评价我们。自尊，是我们对他人如何评价我们的监控并作出相应反应的心理学尺度</li>
</ul>
<p>自我受文化影响也很深。西方更盛行<strong>个人主义</strong>，赞美那些依靠自己的人。在亚洲、非洲、南美洲地区的文化则更重视<strong>集体主义</strong>，这些文化中的人们更多自我批评，而较少自我肯定。个人主义更容易观察到事物本质，集体主义更容易观察到事物间的联系。<strong>一个具有相互依赖自我的人会有更强烈的归属感</strong>。对于偏重个人主义的个体，积极情绪来自于效能感、出众和骄傲；来自集体主义的个体，积极情绪伴随着社会交往——亲密感、友好和尊重。</p>
<p>自我认识上，我们存在着一些天然的缺陷。</p>
<ul>
<li>我们会错误地<strong>解释</strong>我们的行为，行为相关的思想先于行动时，人们会感觉是按意愿做出这样行动的。</li>
<li>我们会错误地<strong>预测他人和自己的行为</strong>，实验中发现人们预测别人的行为比预测自己的更为准确</li>
<li>我们会错误地<strong>预测自己的感受</strong><ul>
<li>一方面，人们很难预测自己未来情绪的强度和持续时间，比如预测自己谈恋爱、收到礼物、赢得比赛等后的感觉，又比如饥饿的人会错估自己的食量，且具有更高的购物冲动。这一点上可以粗略地总结为<strong>错误地想要得到某些东西</strong>。研究显示，好消息的情绪消失比自己预期的要快。</li>
<li>另一方面，人们会高估消极情绪事件的持久性影响，以及过高地预期自己的痛苦。实际上，生理上和心理上人都具有强大的恢复能力</li>
</ul>
</li>
</ul>
<p>最后一点，人们在<strong>自我分析</strong>时，对一些原因并不显著的行为往往很难分析出原因。换句话说，我们对思维的<strong>结果</strong>比对思维的<strong>过程</strong>了解的更多。这带来两个结论：</p>
<ul>
<li>心理学研究中，<strong>自我报告通常靠不住</strong></li>
<li>日常生活中，人们分析或解释其经验的真实性无法保证报告准确性</li>
</ul>
<h4 id="自我效能-amp-自尊"><a href="#自我效能-amp-自尊" class="headerlink" title="自我效能 &amp; 自尊"></a>自我效能 &amp; 自尊</h4><p><em>自我效能</em>即<strong>对自己能力、效率的乐观信念会获得更大回报</strong>。这种态度让你积极面对外界变化。心态上，自我效能高的人会认为身边发生的事“是受自己努力和技巧支配的”，而自我效能低的人会认为“是受外界力量支配的”。</p>
<p>人在对所做的事或他人对自己做的事失去控制时，会产生不愉快的压力情绪。长此以往会产生<strong>习得性无助</strong>，降低个体的抗挫能力。反之促进个体控制可以真正增强个体健康和幸福感。但是“过度的自由”也会降低幸福感，比如拥有一些无法反悔的事会让人心理更好受。</p>
<p><em>自尊</em>是我们全面的自我评价。高自尊的人在自尊面临挑战时，会非常敌对。自尊带来的摩擦发生在熟人之间，比如兄弟姐妹、朋友。把自尊建立在良好的自我感觉，而不是分数、外貌、金钱和别人评价基础上的人，会一直感到状态良好。</p>
<h4 id="自我服务偏见"><a href="#自我服务偏见" class="headerlink" title="自我服务偏见"></a>自我服务偏见</h4><p>我们加工和自我相关的信息时，会出现一种潜在偏见，即<strong>自我服务偏见</strong>。</p>
<ul>
<li>我们把成功归于内部原因，失败归于外部因素</li>
<li>我们总将成功与自我联系在一起，以保持良好的自我形象。因此，大多数人认为“今天的我比昨天更完善”</li>
<li>我们认为自己比平均水平好，尤其是<strong>主观行为维度</strong>，如品德。教育也无法消除这种自我服务偏见。</li>
<li>我们认为自己擅长的事情是更重要的，以此维持我们的自我形象</li>
<li>绝大多数人<strong>盲目乐观</strong>，而较少居安思危</li>
<li><strong>虚假普遍性</strong>和<strong>虚假独特性</strong>。即过高估计他人对自我观点的认同程度和把我们的成功、才智、品德看成超乎寻常。比如人们自己的生活变化时，可能会认为整个世界也在发生变化</li>
</ul>
<p>总结来看，<strong>自我服务归因</strong>、<strong>自我恭维的比较</strong>、<strong>盲目乐观</strong>以及<strong>虚假普遍性</strong>是自我服务偏见的根源。这一机制有助于我们抵制抑郁，却会引起对他人、自己的错误评价，包括对自己所在群体的评价，从而带来群体冲突。</p>
<h4 id="自我展示"><a href="#自我展示" class="headerlink" title="自我展示"></a>自我展示</h4><p>人们对外展示的自我和真实的自我是不同的。最常出现的是<strong>虚伪的谦虚</strong>，比如对自我成就自传式的解释，这在匿名自我评价上就消失了，这种表浅的谦虚只是为了表现谦虚而不是内心的真实感受，这也能避免“获胜后的危险”。</p>
<p>人们为了减少失败结果的影响，可能会故意地<strong>自我妨碍</strong>，以维持对自己能力的信任，比如考试前不好好复习。</p>
<p>作为一种社会性动物，人们总是在向周围的观众表演。在熟悉的环境下，不需要意识参与就能完成。而在陌生环境里，比如和陌生异性聊天或参加一场宴会，我们就能确切地意识到营造形象的过程。在自我展示的程度上，有两种极端——行骗专家式的高自我监控和我行我素的第自我监控。更多人处在两个极端之间。尽管在集体主义国家，自我展示被抑制。但是<strong>自我美化</strong>依旧存在。</p>
<h3 id="社会信念和判断"><a href="#社会信念和判断" class="headerlink" title="社会信念和判断"></a>社会信念和判断</h3><h4 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h4><p>人类天生想让整个世界合乎情理，至少能被自己解释。因而带来自然而然地对他人行为的<strong>归因</strong>。</p>
<p>归因即<strong>探索行为的因果关系</strong>，比如“你不回我电话是因为你不关心我了！”。根据海德（Heider）始创的<em>归因理论</em>，归因分为两种：</p>
<ul>
<li>内因：<strong>性格归因</strong>，如“你不爱我了！”</li>
<li>外因：<strong>情境性归因</strong>，如“我在打游戏”</li>
</ul>
<p>伴随我们的归因天性，我们内置一些归因天赋：</p>
<ul>
<li>特质推断：不寻常的行为让我们更了解这个人</li>
<li>常识性归因：<em>共同反应</em>（个体经常表现这种行为吗），<em>区别性</em>（不同情境下行为不同吗），<em>一致性</em>（别人也这样吗）共同作用得出结论</li>
</ul>
<h4 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h4><p>遗憾的是，我们的归因天赋不完美的。李·罗斯发现个体在归因他人行为时，会低估情境因素的作用影响，而<strong>高估个人特质的影响</strong>。这种倾向即<strong>基本归因错误</strong>。当归因涉及个人利益时，这种错误更为明显。即使我们事先知道有情境因素存在，依旧会有这种错误。比如，我们会认为电影中反派的饰演者就是本人的真实反应，我们会认为考官或出题者会更聪明。类似地，如果某个人自己所持的观点被其他人反复表达，他也会认为其他人确实也持有这种观点。</p>
<p>应用在日常生活中，解释<strong>他人行为</strong>时，我们会犯基本归因错误，而对于自己的行为，我们却通常用情境因素解释。我们通常用描述行为、反应的词句解释自己，涉及到他人时，更经常用“他怎么怎么样”来描述。</p>
<p>基本归因错误可以来自于许多原因：</p>
<ul>
<li><strong>行动者和观察者身处位置不同</strong>。作为观察者时，解释他人行为会更多聚焦在突出的行为人身上，从而易于忽略情境影响；相反，作为行动者本身时，自我和环境融为一体，观察联想时就会对情境因素更加敏感。</li>
<li><strong>聚焦观点偏见</strong>，即人们会更多关注被聚焦的个体，支持其观点。如观看聚焦犯人录像的观众几乎百分百认为犯人有罪，而观看聚焦审讯员录像的观众则会认为犯人是被迫认罪的。</li>
<li><strong>观点是随时变化的</strong>，回顾自己记忆时，会分配情境更多权重，近期行为更多归因情境，远期行为更多归因个人性质。比如Bob下周邀请我参加生日和2年后邀请归因是不同的</li>
<li><strong>自我觉知</strong>，注意力集中在自己身上时，更多归因自我特质而非特性。对于他人，<strong>越缺乏在不同情境下观察行为的机会，就越容易将行为归因他人人格，尤其是陌生人</strong>，对于我们很熟悉且在多种环境相处过的人，我们会对环境更加敏感。</li>
<li><strong>文化差异</strong>，集体主义更多归因情境，如“体制有问题”；个人主义更多归因个人特质</li>
</ul>
<p>基本归因错误的原理很可能是，<strong>评价情境对他人的影响比归因个人特质要更花脑力</strong>，即将行为归因个体内在而非环境是种有效率的行为，且有些场景下归因个人特质确实是有效的。</p>
<p>研究归因错误是很有价值的。因为对于他人行为归因的不同会直接影响我们对他们的印象和感受，正如上面的“你不爱我了！”和“我在打游戏”。了解了这些，在日常生活中解释行为的时候，就更能以批判性的思维看待自己和他人的评价。</p>
<h4 id="社会知觉和社会记忆"><a href="#社会知觉和社会记忆" class="headerlink" title="社会知觉和社会记忆"></a>社会知觉和社会记忆</h4><p><strong>先入为主</strong> —— <strong>我们的预期会引导我们对信息的知觉和解释</strong>。比如，球迷们总认为裁判偏袒另一方。人总是主观的，事实上告诉我你从哪里看到了偏见，我甚至能获得有关你所持态度的线索。类似地，对于观点模糊的混合型信息，对立观点双方都会吸收信息并同化为支持自己，从而更坚定自己的观点。书中给出了一个例子——一个面无表情的男人面孔，在告诉你他是个慈善家和告诉你他是个纳粹分子时，你会对脸做出不同的认识。</p>
<p>事实就在那里，但我们的思维却积极地解释它，并根据不同的解释做出不同的行为。</p>
<p>解释的过程也会左右他人对我们的知觉，<strong>当我们说某人好话或坏话时，人们也会试图将那些特质和我们联系在一起</strong>。</p>
<p><strong>信念固着</strong></p>
<p><strong>一旦人们为错误的信息建立了理论基础，就很难再让他们否定这条错误的信息</strong>。建立理论基础的解释是人自然做出的，在解释形成后，会独立于最初推论出它的信息而存在。因此即使在信息被推翻后，被试依旧坚持自己归纳出的解释。这给我们一个启示：我们越是极力证明我们的理论和解释是正确的，我们就对挑战自己信念的信息越闭塞。</p>
<p>从进化学的角度看，这种归纳可以减轻理解负担；但是这个收益的代价是：我们成为自己思维方式的囚徒。实验发现，<strong>解释相反的观点</strong>可以减轻信念固着对我们思维的固有影响。</p>
<p><strong>记忆重构</strong></p>
<blockquote>
<p>记忆与读书不同，它更像根据不连贯的笔记片段写一本书 —— John F. Kihlstrom, 1994</p>
</blockquote>
<p>我们的记忆不像一个储物箱，需要什么可以直接取出。我们会无意识地修正和重构我们的回忆。</p>
<ul>
<li>一些细小的令人愉快的事件会让回忆比实际所经历的美好得多。一些不愉快或无聊的事情会被最小化，似乎消失在记忆里。这在旅行回忆中最为常见。（很像是大脑记忆机制的趋利避害）</li>
<li>我们会改变同其他人关系的回忆，当记忆模糊时，当下的感觉会主导我们的回忆</li>
<li>我们会重构过去行为的回忆，从而体现出“事后聪明式的偏差”。比如，当初要是怎么怎么样就好了。同时，回忆会变得更符合我们现在的观点</li>
<li>一些暗示会影响回忆的结果（<strong>误导信息效应</strong>）</li>
</ul>
<p>整体来看，记忆的提取更像一个复杂的相互关联的过程。极易受上下文（如暗示、引导）影响，context不同，记忆启动的画面就不同。</p>
<h4 id="直觉和判断"><a href="#直觉和判断" class="headerlink" title="直觉和判断"></a>直觉和判断</h4><p>实验表明，<strong>无意识控制我们大多数行为</strong>，对绝大多数人来说，其日常生活不是由有意识的目标和经过深思熟虑的选择决定的，而是受内部心理过程的控制。比如在食物中看到虫子会感到恶心，跳舞时肢体动作的选择等等。我们意识小部分是受控制的，大部分是自动化的（冲动的、无需努力的、无意识的）。</p>
<ul>
<li>情绪反应是即时的，简单的喜欢、不喜欢、恐惧通常不涉及分析的过程。这些是伴随基因而来的。</li>
<li>人在领域内拥有足够多专业知识时，可以依赖直觉获得问题答案，如下棋、写代码。高手通常会察觉到新手看不到的pattern。</li>
<li>我们对事实、名字、过去经验的记忆是外显的，而对技能、条件特征的记忆是内隐的</li>
</ul>
<p>看起来，我们的控制意识处理着最重要、最新鲜是事件，而把日常事情分配给其他系统处理。然而，直觉抑或说是无意识过程并没有想象中那么敏锐。比如事后聪明式判断。这些即错觉思维。</p>
<p><strong>过度自信</strong></p>
<p>过度自信现象会影响我们对目前知识的评价和对未来行为的预测。讽刺的是，能力不足会促进过度自信倾向，对能力的认识也是需要能力的。这种现象不是个别的：</p>
<ul>
<li>计划者通常会低估工程所需时间和精力</li>
<li>投资专家都认为他们能够取得超过股市平均回报率的业绩</li>
<li>过度自信优势会带来浩劫，如越战</li>
</ul>
<p><strong>验证性偏见</strong>：人们往往会寻找支持自己信念的信息，而非尝试证明自己的直觉不成立。因为这么做有助于个人证实自己意象。</p>
<p>有两种降低过度自信的方法：<strong>即时反馈</strong>，比如天气预报；<strong>设想自己判断可能出错的原因</strong>。同时考虑到过度自信的普遍性，我们也需要对别人独断性的陈述保持谨慎。</p>
<p><strong>心理捷径</strong></p>
<p>我们的认知系统在进化中形成了专门的心理捷径，让我们很容易就能形成印象，作出决定和生成解释。但这也会带来一些错误。</p>
<ul>
<li><strong>代表性直觉</strong>，对某个事物进行评价时，在直觉的引导下，将其与某一类典型的心理表征进行比较。比如，告诉你一个人朝九晚五，很可能认为他是公务员；告诉你一个人996修福报，你很可能认为他是程序员。这会让我们忽略其他重要信息。</li>
<li><strong>易得性直觉</strong>，我们会优先从记忆中取出现成易得的信息做判断。比如，那些鲜明容易形象化的事件，如容易形象化症状的疾病，与那些较难形象化的疾病相比，被认为更易发生。再比如，那些小说、电影、电视中的虚构情节会给人留下印象，甚至也会影响我们随后的判断。如，我们认为飞机不如汽车安全。这会让我们过度重视生动鲜明的例证。</li>
<li><strong>反事实思维</strong>，容易想象的事件会影响我们对负罪、遗憾、挫败和宽慰的体验。比如我们队以一分之差输掉（赢得）比赛，相比差距20分，我们会感到更大的遗憾（宽慰）。铜牌会比银牌获得者更高兴。<strong>事件本身越重要，反事实思维强度就越大</strong>，如在酒驾中失去亲人会带来莫大的遗憾感。尽管如此，<strong>绝大部分人对已做事情的悔恨比没有做的事情的会很要小</strong>。对于已做事情，人们会更多可能感到歉意。</li>
</ul>
<p><strong>关联错觉</strong></p>
<p>当我们期待发生某种重要联系时，会知觉到<strong>错觉相关</strong>，如吃巧克力会让我这一天更幸运。我们相信事件存在相关时，会更可能注意并回忆某些支持性的证据（幸存者效应）。</p>
<p>将随机事件知觉为有联系的倾向会让人产生<strong>控制错觉</strong>，即<strong>认为各种随机事件受自己影响</strong>。赌博中很常见，掷骰子希望点数较小时，出手会相对轻柔，希望点数较大时，出手相对较重。同时，由于<strong>趋均数回归</strong>，即随机现象会在期望附近上下波动的存在，在上一次或上几次偏离期望较远时，下一次更可能回归到期望附近。所以，<strong>当我们处在一个最低水平时，任何尝试行为看起来似乎都是有效的</strong>。这会让老师误认为自己的辅导生效了，或者看心理治疗书籍拯救了偶然的低迷情绪。</p>
<p><strong>情绪影响判断</strong></p>
<p>个体在乐观和意抑郁的情绪下，对世界的知觉不同。因为，我们的情绪会将与其相关的经验带入头脑并给我们的所见所闻着色。情绪对简单、自动化的思维影响比复杂、有意控制的思维要小。即我们思考越多，思维就越受情绪侵染。</p>
<h4 id="自我实现预言"><a href="#自我实现预言" class="headerlink" title="自我实现预言"></a>自我实现预言</h4><p>我们的社会信念和判断会影响我们的感觉和行动，由此改变自己的现实，这种观念引导我们以证实自己的方式行动即<strong>自我实现预言</strong>。老师认为学生是否有天赋，就会带来自我实现预言的现象。有趣的是，学生认为老师出色和有趣也会带来自我实现。推广来看，恋人之间也有这种现象。相反，一旦形成错误的社会信念，就可能引发他人做出某些行为反应以支持这些信念，即<strong>行为确证</strong>。</p>
<p>确认他人期望的倾向具有局限性，且个体预先告知他人其期望时，可能会引起他人做出行动去克服期望。在采访中，对记者态度不明确的受访者会更经常硬核采访者期望。</p>
<p>整体来看，<strong>对于高效判断的偏向是直觉难以避免误判</strong>，我们直觉思维的缺陷是我们对复杂信息简化加工的心理捷径的副产品。这种直觉有时会让我们进入歧途，但大多数时候确实可以帮助我们做出高效迅速的决定。在有些职业里，需要考虑到这点。比如记者就需要了解如何避免上面这些认知偏见。</p>
<h3 id="行为和态度"><a href="#行为和态度" class="headerlink" title="行为和态度"></a>行为和态度</h3><p>人的态度和行为具有什么关系呢？</p>
<p>ABC：感觉（affect）、行为倾向（behavior tendency）、认知（cognition）三种相互影响</p>
<h4 id="态度决定行为？"><a href="#态度决定行为？" class="headerlink" title="态度决定行为？"></a>态度决定行为？</h4><blockquote>
<p>我们精通并擅长为自己的行为寻找原因，但却非常不善于做我们已找到原因的事 —— Abelson 1972</p>
</blockquote>
<p>社会心理学家最初认为态度和行为并没有明显关联。</p>
<ul>
<li>学生对于作弊的态度和他们实际作弊行为几乎没有关联</li>
<li><strong>道德伪善</strong>：表现出有道德水准，但实际上拒绝付出任何代价</li>
</ul>
<p>因此，寄希望于改变态度来改变行为通常会以失败告终。</p>
<p>而后，社会心理学家发现行为和我们的态度不同是因为有其他因素的影响：</p>
<ul>
<li>外在表现受制于外部因素的影响，比如记名投票和匿名投票结果通常不同。为了避免外部因素的影响，可以使用<strong>伪途径法</strong>，类似“测谎仪”或看起来像“测谎仪”的东西</li>
<li>长期观察个体行为、个体的通常行为，态度对于行为的预测会更明显</li>
<li>测量的态度和行为直接相关时，态度确实可以预测行为</li>
</ul>
<p>在行为是自发做出时，态度会潜在地起作用。当我们思考自己态度时，态度才会影响我们的行为。让人自我觉知或者本身自我意识感强的人，言行的一致性会更高。</p>
<p>总结来看，在限制条件的场景下，态度可以决定行为：</p>
<ul>
<li>其他因素最小化</li>
<li>态度针对具体行为</li>
<li>我们能清除意识到态度</li>
</ul>
<h4 id="行为如何影响态度"><a href="#行为如何影响态度" class="headerlink" title="行为如何影响态度"></a>行为如何影响态度</h4><blockquote>
<p>我们会逐步相信我们坚持的东西</p>
</blockquote>
<p>下面一些现象都说明着，行为能影响态度，形成信念，被人所接受</p>
<ul>
<li><strong>角色扮演</strong>，扮演一种新的社会角色时，起初我们可能会觉得虚假，但很快就能适应（融入角色、融入环境）。比如演员们入戏。</li>
<li><strong>语言变成信念</strong>，当一个人的话没有可以信服的外在解释时，语言就会变成信念。<strong>我们倾向于根据听众调整说话内容</strong>，并在说过之后相信歪曲的信息</li>
<li><strong>登门槛现象</strong>，即<strong>想让人帮大忙第一个有效策略是先请他们帮个小忙</strong>。当人们<em>承诺</em>公众行为并且认为这些行为是自觉作出时，他们会坚信自己的所作所为。商家的<strong>低价法策略</strong>就是利用了这一点。已经进行的行为会说服自己。</li>
<li>邪恶的行为会侵蚀人的良心，通常导致攻击者贬抑受害者，以此为行为正当性辩护</li>
<li>对他人的积极行为会增强对那个人的好感度，下次希望别人对自己有好感时，可以尝试引导别人对自己表露出积极行为</li>
<li>我们会相信自己所坚持的所作所为，即使行为是受外在推动。政治仪式就是一个例子：唱国歌，参加演习。</li>
</ul>
<h4 id="行为为何会影响态度"><a href="#行为为何会影响态度" class="headerlink" title="行为为何会影响态度"></a>行为为何会影响态度</h4><p>有三个理论：<strong>自我展示：印象管理</strong>、<strong>自我辩解：认知不协调</strong>和<strong>自我知觉</strong>。</p>
<p><strong>自我展示</strong>认为人们行为改变的态度实际上是人们想给别人留下好印象，毕竟没有人愿意看起来自我矛盾。</p>
<p><strong>自我辩解</strong></p>
<p><strong>认知不协调</strong>理论由费斯汀格（Leon Festinger）提出。它认为两种想法或认知在心理上不一致时，我们就会感到失调（即紧张）。因此我们要保持行为和认知间的一致性。理论主要用来解释态度和行为间的矛盾关系。</p>
<p>在此基础上，有个有趣的发现是，在行为的<strong>理由不足</strong>时，人们会更可能感到不舒服，因此要更相信自己的所作所为。这带来的应用有：</p>
<ul>
<li>温和地告诫不能为他们的所作所为（比如打扫房间）提供充分理由，孩子更可能将行为内化为合理且自发的。</li>
<li><strong>如果我们觉得要对自己行为负责时（而不是为了应付命令），我们的态度就会依从行为</strong>。鼓励和诱导好的行为可以激发孩子内化正确的态度</li>
</ul>
<p>另外，当做出重要决策时，我们经常会过高评价自己的选择，而贬低放弃的选择，以此减少不协调程度。从而很轻易地带来决定——变成——信念。比如，当我们决定机票在1000元以下就坐飞机时，我们已经在想象坐飞机时的情景，机票涨到1000元以上时，我们很可能仍然会选择坐飞机。</p>
<p><strong>自我知觉</strong></p>
<p><strong>自我知觉理论</strong>由贝姆（Daryl Bem）提出，它假设我们在态度还<strong>摇摆不定</strong>时，会处在局外人的态度观察自己，从而通过行动<strong>揭露</strong>自己的态度。比如，第二天要考试，前一天翻来覆去睡不着，我发现我失眠了，我意识到我很焦虑。</p>
<p>我们的表情和情态可以放大自我知觉，比如在害怕的时候哼一首愉快的小曲也许真有帮助。模仿别人表情和情态时，我们更能体验到别人的感受。实际上，我们在和他人交流时，通常通过保持行动、姿势等一致而让彼此感到和蔼可亲，从而造成<em>情绪传染</em>的效果。面部表情甚至也会影响我们的态度。比如在听取观点时，被要求保持点头姿势的人更容易同意此观点。</p>
<p>由于我们通过观察周围情境来解释自己的行为，自我知觉理论推导出一个结论：<strong>不必要的报酬会带来隐性的代价</strong>。给人们报酬让他们做自己喜欢的事会让他们将行为归因于报酬，从而削弱他们的自我知觉，即<strong>过度合理化效应</strong>。更准确地说：</p>
<ul>
<li>如果报酬和赞赏是针对人们的成就，则会增加个体的内部动机</li>
<li>如果报酬是为了控制人们，而且人们也相信了是报酬导致了努力，那么会降低个体对工作的内在兴趣</li>
</ul>
<p>因此，要<strong>适当地</strong>给予报酬：提供充分的理由，基于报酬和赞赏。抑或，反其道而行之，削减一些行为，比如寓言故事里说的，花钱让小孩制造噪音，再逐渐减少报酬，从而让小孩不再制造麻烦。</p>
<p><strong>理论对比</strong></p>
<p>认知不协调主要用来处理<strong>言行不一致</strong>的情况。言行不一致，不协调激活时，还会伴随排汗量增加、心率加快等生理表现，因为它会威胁到我们对自我价值的积极体验。自我知觉较弱的人，不协调感也会较弱。</p>
<p>自我知觉理论主要用在没有自我矛盾，态度并未完全形成时，它可以很好解释态度如何伴随行动形成和明确。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>要想养成习惯，那就去付诸行动。 —— 埃皮克提图</p>
</blockquote>
<blockquote>
<p>没有反应就没有接受，没有相关表达就不会产生印象</p>
</blockquote>
<p>行为可以改变态度。我们用语言去解释某事时，会记得更牢。当你想形成某种态度时，不妨用行动去塑造。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/06/29/quantum-physics-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/06/29/quantum-physics-history/" class="post-title-link" itemprop="url">量子物理简史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-29 00:46:44" itemprop="dateCreated datePublished" datetime="2019-06-29T00:46:44+08:00">2019-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-07-06 20:53:12" itemprop="dateModified" datetime="2019-07-06T20:53:12+08:00">2019-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%85%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">故事</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/06/29/quantum-physics-history/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/29/quantum-physics-history/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>全文摘录于<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25742211/">《上帝掷骰子吗？》</a>，看完回味之余，觉得有必要整理下量子物理发展过程中比较重要的瞬间和那些颠覆认知的概念。</p>
</blockquote>
<h2 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h2><p>光是什么？自古以来科学家众说纷纭，但大体分为微粒说和波动说两派。最初微粒说以<strong>直线传播</strong>和<strong>反射</strong>作为依据；波动说借<strong>衍射</strong>发展起来，但是人们认为光是种<strong>纵波</strong>，所以必须借助<strong>光以太</strong>这种虚无缥缈的物质而存在。</p>
<p>17世纪，格里马第认为颜色是因为光波频率不同引起，并得到<strong>胡克</strong>支持；牛顿在1672年完成光的色散试验后，认为光的复合和分解是不同颜色微粒的混合和分开，光是一种粒子，受到胡克和波义耳的批评后与胡克交恶。而后惠更斯引入<strong>波前</strong>的概念，以波动学的角度成功推导出光的反射和折射定律。而后牛顿环被发现，可以很轻松地被惠更斯的理论证明，自此波动说占据上风。</p>
<p>1704年，胡克死后次年，牛顿出版《光学》一书，以粒子说的角度分析了光的种种实验现象，并将之与自己的力学体系结合在一起。那时的牛顿出版了《数学原理》，且是微积分的发明人（尽管和莱布尼兹有争议），同时在政府担任要职，风头无二。从此，<em>第一次波粒之争</em>中微粒说以压倒性优势盖过波动说，大获全胜。</p>
<p>1804年，托马斯·杨在他的《自然哲学讲义》中描述他所做的<strong>光的双缝干涉</strong>实验，干涉形成的明暗条纹可以很好地被波动说解释。在发现无法更好解释时，微粒说以马吕斯在1809年发现的光偏振反驳。1819年，菲涅尔采用波动说很好地解释了光的衍射，泊松将之应用到圆盘衍射时，发现推导出阴影中心会出现一个亮斑，即<strong>泊松亮斑</strong>，并被阿拉果实验验证。同时，为了解释光的偏振，菲涅尔认为光是一种横波，而非纵波，并在1821年成功从理论中推导出偏振现象。最后1850年，傅科实验测量出光在水中的速度小于真空，从而奠定了波动说在<em>第二次波粒之争</em>中的胜局。</p>
<p>波动说并非没有弱点，因为光这种“横波”的传播速度如此之快，它的介质“以太”一定坚硬无比，但是一粒小小的灰尘就可以阻挡光的传播，这似乎又是匪夷所思的。波动说的解释是以太是稀薄且静止的。虽然有些牵强，但随着1856、1861、1865年麦克斯韦三篇电磁理论的论文发表，麦克斯韦预言光是电磁波的一种。1887年被赫兹的实验证实。自此波动说一统天下，此时的物理，经典力学、经典电动力学和经典热力学构成了经典物理的三大支柱，在当时看来，一切物理现象都在人们的控制之中，这个世界的所有基本原理都已经被发现。</p>
<h2 id="乌云"><a href="#乌云" class="headerlink" title="乌云"></a>乌云</h2><p>黄金时代的喜悦没有维持太久，而后一些科学发现让科学家感受到不详的预兆：</p>
<ul>
<li>1895年，伦琴发现X射线</li>
<li>1896年，贝克勒尔发现铀元素的放射性</li>
<li>1897年，居里夫人和她的丈夫研究了放射性，并发现了其它放射性元素</li>
<li>同年，J.J. 汤姆逊在研究阴极射线时发现电子</li>
<li>1899年，卢瑟福发现元素嬗变</li>
</ul>
<blockquote>
<p>The beauty and clearness of the dynamical theory, which asserts heat and light to be modes of motion, is at persent obscured by two clouds</p>
</blockquote>
<p>1900年，在开尔文的一次演讲中第一次提到“乌云”一词，其中提到的两朵乌云分别是：</p>
<ul>
<li>1881、1886年，迈克尔逊-莫雷实验否定了以太的存在</li>
<li>经典物理在黑体辐射研究中的困境</li>
</ul>
<p>前者导致了相对论的诞生，后者催生了量子论。</p>
<p>在黑体辐射中的困境是，针对能量分布和温度以及波长的关系，维恩得出的分布公式和瑞利金斯公式分别在长短波方面贴合实验结论。1900年，普朗克凑出了普朗克黑体公式，能完美符合各个波长上的实验结果。</p>
<p>在尝试使用经典物理学推出这个公式失败后，普朗克<strong>不得不</strong>做出这样的假定：<strong>能量在发射和吸收时，不是连续不断的，而是分成一份一份的</strong>。对于能量的最小单位，普朗克称为“能量子”，而后被称为量子（quantum）。量子的能量等于普朗克常数乘以辐射频率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E=hν</span><br></pre></td></tr></table></figure>

<p>那一年，普朗克42岁。</p>
<h2 id="玻尔的原子模型"><a href="#玻尔的原子模型" class="headerlink" title="玻尔的原子模型"></a>玻尔的原子模型</h2><p>在光电效应中，人们发现对于特定金属，能不能打出电子之和光的<strong>频率</strong>有关，而打出电子的多少才和光强有关。特定频率的光打出的电子能量是有一个上限的，这个上限和光强并没有关系。</p>
<p>普朗克1900年的论文发表之初，并没有得到学术界甚至他自己的重视。1905年，爱因斯坦发展了普朗克量子化的思想。提出组成光的能量存在最小单位，称为“光量子”（light quanta），而后被简称为光子（photon）。光是以量子形式吸收能量，是一个瞬时作用，没有累积概念，光子的能量大小只与光频率有关。</p>
<p>1905年爱因斯坦的这篇论文同样并没有受到认同，因为光量子的概念和当时已尘埃落定波动说并不贴合。而后密立根的实验和康普顿研究X射线被自由电子散射时，很好地证明了爱因斯坦的观点。在1910年，索尔维赞助的第一次索尔维会议中，大家对骚动的量子理论莫衷一是。</p>
<p>1912年，考入剑桥的玻尔投入了卢瑟福的门下，这时卢瑟福正为它提出的原子行星模型苦恼。行星模型相对J.J.汤姆逊的枣糕模型更符合α射线轰击金箔的实验，但仍然说明不了为何电子可以稳定地围绕原子核运转。</p>
<p>玻尔受到巴尔末在1885年发现的氢原子谱线公式启发，提出了电子的能级和跃迁的概念。电子只能在特定能级上维持，在能级间跃迁时吸收或释放能量。玻尔的理论可以很好地推导出巴尔末公式，这系列论文发表于1913年。</p>
<p>玻尔模型提出伊始，得到了广泛地实验支持，同时预言了一些新的谱线存在，并很快得到证实。玻尔模型的能级假设十分具有量子化色彩。引入相对论和假定电子具有更多量子数后玻尔-索末菲模型也能成功解释塞曼效应和斯塔克效应（氢原子谱线受电磁场的影响）。通过这个模型，可以推导出一个原子的化学性质和它的最外层电子数相关，从而表现出一定的规律性，这也为周期表的存在提供了理论基础。为了解释电子为何能自发分层，泡利提出“泡利不相容原理”：同一层能容纳的电子数是有限的。</p>
<p>玻尔的量子化模型相对传统的麦克斯韦电磁体系走得实在太远，模型假设电子的能级、轨道是量子化的，但并没有解释为什么，总让人感受到不安稳。同时玻尔体系只能解释只有一个核外电子的原子模型。电子的跃迁时机，模型也无法解释，看似是完全随机的。</p>
<p>20世纪初，德布罗意在他的博士论文中提出，伴随电子运动的有一个超光速的相波，即德布罗意波。凭此论文德布罗意获得了1929年的诺贝尔物理学奖。德布罗意预言的德布罗意波而后被戴维逊和G.P.汤姆逊实验证实。这似乎又掀起了波动说和微粒说的战争。同时，玻色-爱因斯坦统计方法把光子视为不可分割的一种粒子，成功推导出普朗克的黑体辐射公式。波动说和微粒说似乎哪一种都不是、哪一种又都是。</p>
<p>1924年，玻尔、克喇默斯和斯雷特联名发表BKS理论，放弃了光量子假设，试图在波和粒子间建立一种对应，收效并不明显。</p>
<h2 id="决定论？"><a href="#决定论？" class="headerlink" title="决定论？"></a>决定论？</h2><p>在玻尔提出玻尔模型的时候，海森堡受邀前去哥本哈根工作，此时正是1924年，尝试统一微粒说和波动说的BKS理论提出不久，就被实验否定，光量子是实实在在的东西，而非只有统计意义。1925年4月，海森堡结束哥本哈根访问回到哥廷根后，使用矩阵的思路分析原子的运动模型。</p>
<p>海森堡从实验中观测到的，能够实实在在感受到的能级差出发，采用矩阵作为数学工具，将之运用在经典动力学公式中去，把玻尔-索末菲模型旧的量子条件改造成由矩阵推出的公式，进而可以很容易推导出原子能级和辐射频率。在和波恩和约尔当的合作下，海森堡发布《论量子力学》和《论量子力学II》。新体系马上获得巨大成功，矩阵力学在此基础上得到发展。受到海森堡矩阵启发，狄拉克借助泊松括号用更简单的方式相同的理论。乌伦贝克和古兹密特提出自旋模型，并得到矩阵力学支持。海森堡的模型将玻尔模型的范围推广至更广的范围（氦原子）。</p>
<p>1925年，薛定谔受到德布罗意启发，将电子看做德布罗意波，用一个波动方程去表示，从经典的哈密顿-雅克比方程出发，利用变分法和德布罗意公式求出了一个非相对论波动方程，即薛定谔波动方程。通过求解这个方程，可以很轻松地理解电子为何只能在特定能级运行。1926年1到6月，薛定谔一连发表多篇论文，并证明了经典力学知识波动力学的一种特殊表现。</p>
<p>尽管两派互不服气，但是薛定谔、泡利、玻尔等人证明这两种理论在数学上是等价的。在狄拉克的努力下，矩阵力学和波动力学作为一种理论的不同形式体现出来。前者更像微粒说，后者更像波动说。</p>
<p>我们观察下双缝干涉实验。对于波动说，在双缝时，电子可以很好地由薛定谔波动方程去描述，但是若此时关闭了一条缝，实验结果也就变成了一条缝而不是一片区域，电子所在的波到达缝时发生了什么呢。对于微粒说，电子穿过哪条缝似乎是完全随机，不可预期的，同时每个电子穿过狭缝时，是不可能知道狭缝间有多宽，甚至无法知道还存在其他狭缝，那么狭缝背后的干涉条纹的规律性怎么解释呢？更有意思的现象是，如果我们在每条狭缝上安装测量仪器，我们可以发现，每次只能在一条狭缝时测量到电子，但同时干涉条纹会随着测量行为而消失。</p>
<h2 id="哥本哈根解释"><a href="#哥本哈根解释" class="headerlink" title="哥本哈根解释"></a>哥本哈根解释</h2><p>上面提到的现象，似乎隐隐地体现出测量行为对理论表现的影响。海森堡在1927年反复思考矩阵运算中<code>p × q ≠ q × p</code>的特性，如果我们把p和q分别看做观测得到的结果，似乎说明，我们不可能同时观察得到p和q。原因是，观察本身就会影响我们对另一个物理量的测量。经过一阵计算，海森堡得出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">△p × △q &gt; h/4π</span><br></pre></td></tr></table></figure>

<p>△p和△q分别代表对p和对q的测量误差。对其中一种的精确都会影响对另一种的粗略。这个理论被称为不确定性原理，抑或测不准原理。这个误差并不来自于测量仪器，而是在理论上就不可实现，就像永动机。p和q叫做共轭量，动量和位置就是一对共轭量。能量和时间也是一种共轭量，这意味着，对时间的精确会意味能量的模糊，在确定的某一刻，能量甚至可以凭借不确定性凭空出现，，由于质能本质相同，所以每时每刻我们的真空都在“沸腾着”，“幽灵”物质凭空涨落。</p>
<p>在看到海森堡的论文后，玻尔意识到，不确定性原理是具有普遍意义的，它“以一种极为漂亮的手法”显示了不确定性如何应用在量子论中。不确定性建立在波和粒子的双重基础上，<strong>对于粒子属性的了解越多，对于波属性就了解的越少</strong>。</p>
<p>现在回头想一下那个问题：电子究竟是粒子还是波。玻尔认为：</p>
<p>任何时候我们观察电子，它只能表现出一种属性，要么粒子要么是波。但是作为整体来看，它表现出波粒二象性。如果你一定要问，电子<strong>本来</strong>是什么？我只能说我一点也不关心它本来是什么，我只关心我们能“观测”到它是什么。举个例子，我们对大自然的理解实际上都建立在我们观察到它是什么，它本质上是什么对我们没有意义（类似“白马非马”诡辩）。对于电子的观察方式不同，它的表现方式就不同，一旦观察方式确定了，电子就只能以一种特定的形式存在。</p>
<p>这就是玻尔的互补原理。它和波恩的概率解释、海森堡的不确定性三者构成了量子论“哥本哈根解释”的核心。 影响着人们对宇宙的根本认识。</p>
<p>回头再看对电子干涉实验的讨论，观察干涉条纹也好，在狭缝安装仪器也好都是不同的观察方式，得到的结果自然不同。谈论任何物理量都是没有意义的，除非你首先描述测量这个物理量的方式。再说的明确一点，一个物理量如果无法测量，那它就是没有意义的。换言之，不存在一个客观绝对的世界，唯一存在的就是我们能够观察到的世界。</p>
<p>这种解释把观测者和外部宇宙结合在了一起，即不存在一个观测者能独立之外的宇宙。这听上去似乎有点形而上学了。</p>
<p>这个解释当然并不完善，比如在你不观测时，电子以概率波的形式存在于空间，而只要你观察，它的波函数就会随机坍缩到某个具体位置。对此，哥本哈根的解释是，不观测时，对电子的讨论没有意义，只有数学可以描述——波函数，而在观测时才具有实在的意义。</p>
<h2 id="薛定谔的猫"><a href="#薛定谔的猫" class="headerlink" title="薛定谔的猫"></a>薛定谔的猫</h2><p>对于哥本哈根解释，许多科学家是并不能信服的，其中就包括笃信确定论和因果论的爱因斯坦。爱因斯坦认为，观察导致坍缩这一点暗示了某种超距作用，而这是和相对论相违背的。在1927年第五届索尔维会议上，爱因斯坦和玻尔展开了激烈的论战，以玻尔获胜告终。</p>
<p>三年后的第六届索尔维会议，爱因斯坦提出光箱实验反驳海森堡的不确定性原理，被玻尔通过广义相对论的红移效应完美解释。人们似乎感到，上帝真的掷骰子。</p>
<p>1933年，爱因斯坦和他的两个同事波多尔斯基、罗森共同提出“ERP佯谬”（名字来自三个首字母），试图说明量子论是不完备的。下面是一种简化了的版本：</p>
<p>我们想象一个自旋为0的大粒子衰变成两个小粒子，向相反两个方向飞去，两者的自旋方向必定相反。只要我们部去观察，每个例子自旋便都处在上&#x2F;下两种概率的叠加态中，但我们只有观察其中一个例子，如A是上旋，那么B必定是下旋，可问题是B如何在A坍缩至上旋时，一定坍缩为下旋呢？</p>
<p>量子论的解释里面，观察后，例子A坍缩至上旋完全是概率现象，是在被观测一刻才有的意义，粒子B在此刻也会根据A的决定作出相应的坍缩。这个信号是怎么传递的。</p>
<p>玻尔解释说，在观察前，并不存在两个分裂的粒子，它们是一个整体，只能用波函数去描述。所以不存在超光速的信息传递。有意思的是，ERP佯谬是可以被实验证明的。后面也会提到。</p>
<p>相对爱因斯坦的思维实验，薛定谔的实验要更易理解和更出名。在他1935年《量子力学的现状》的第5节。薛定谔描述了著名的“薛定谔的猫”的实验。既然量子效应的匪夷所思还能让人容忍，那就把它放大到宏观世界里。</p>
<p>它设想了一个不透明的箱子，有一个处于衰变和不衰变叠加态的原子，只要原子衰变，就会激发一系列的连锁反应，打破箱子里的毒气瓶，从而杀死箱子里的猫。在量子论的解释里，只要我们不打开箱子，原子处于只能用波函数描述的叠加态中，此时猫也只能处于死和活的概率波叠加态中。这恐怕很难被接受。</p>
<p>那么我们把猫换成人呢？如果他能在纸上写下在箱子内的感受，他会这么认为吗？当然不会，他会坚定的认为自己从头到尾活得好好地，抑或是感觉不太妙。这是因为他作为观察者在箱子内不断观察自己的状态，不停地出发自己的波函数坍缩。</p>
<p>难道人和猫有区别吗？换句话说，难道因为人有能力“测量”自己存活与否（换句话说就是人有“意识”），而猫不能，所以人能让自己的概率波坍缩，而猫只能任由自己停留在死或生的概率波函数中？</p>
<p>真是匪夷所思。</p>
<h2 id="坍缩和平行宇宙"><a href="#坍缩和平行宇宙" class="headerlink" title="坍缩和平行宇宙"></a>坍缩和平行宇宙</h2><p>冯·诺依曼指出使用仪器观测和人来观察并无区别，仪器本身也是由不确定的粒子组成，使用仪器观察只不过把粒子的叠加态转移到了仪器上<strong>，无限复归</strong>，直到人意识的参与。为了避免过于唯心的讨论，恐怕要探究下“意识”究竟是什么。</p>
<p>首先，意识并不是实际的物质存在，它基于我们的大脑而存在，有种观点认为：<strong>意识是组成原子群的一种“组合模式”</strong>，照这么推论一个人的意识理论上是完全可以复制和粘贴的。同时，由于模式才是本质，那么意识的载体并不重要，我们人类的肉体作为意识载体存在完全只是一种选项。意识也可以依附在机器上存在，它不过是输入输出间极为复杂的一种算法加上复杂的数据结构而已。关于意识的更多探讨，可以阅读罗杰·彭罗斯的《皇帝新脑》（原文推荐）</p>
<p>1979年，约翰·惠勒进行了一次<strong>延迟选择实验</strong>，他通过巧妙地设置半透镜的角度使得，在终点处观察者能否观测到光子直接影响光子在起点半透镜的选择。换句话说，观察者决定了光子的历史。推广而言，我们的观测行为本身参与了宇宙的创造过程。这实际上是加强版的<strong>人择原理</strong>。人择原理说，我们存在这个事实本身，决定了宇宙的某些性质是这样而不是那样的。<strong>参与性宇宙</strong>则表明，我们的存在不仅影响了宇宙的性质，甚至参与并创造了宇宙和它的历史。我们选择了宇宙，宇宙又创造了我们。</p>
<p>坍缩这个概念玄之又玄，于是有科学家提出了其他解释。比如艾弗莱特1954年提出了MWI（多世界解释）。按照艾弗莱特的说法，电子穿过双缝后，整个世界本身成为两个独立的叠加，我们观察到电子穿过左缝或右缝，是因为我们碰巧处在对应的分裂出来的宇宙中。<strong>量子过程产生的一切可能都会对应一个实际的宇宙，只不过大多数宇宙中，没有智能生物来提出问题</strong>。多世界解释又被称为平行宇宙。艾弗莱特假定任何孤立系统都必须严格按薛定谔方程演化。虽然宇宙只有一个波函数，但是这个宇宙态矢量十分复杂，它存在于高维甚至无限维的希尔伯特空间中。我们处在的每个世界不过是“真实”矢量在某个方向上的投影。</p>
<p>既然世界是叠加态的，电子也是叠加态的。那为何处在宏观世界的我们从未感受到量子尺度的叠加态呢？</p>
<p>退相干理论的提出尝试回答这个问题。理论提出，我们只谈论微观物体时，牵涉的粒子数很少，模拟它的希尔伯特空间维度自然也较低。但一旦牵扯到仪器或我们本人观察时，我们就引入了一个极为复杂的态矢量和维度极高的希尔伯特空间。这样，在低维空间相干的两个世界在此时被退相干，变得毫无联系，从而让我们感受不到彼此。量子叠加态的在宏观层面的瓦解正是退相干的直接后果。</p>
<p>退相干的提出让我们摆脱了对“观测”，“意识”的哲学讨论。让我们再次可以抽身于环境之外世界。宇宙重新成为唯一的主宰，人和观测者只是它的一部分。但是，为了解释电子行为而把整个宇宙拖下水的做法也受到一些质疑。</p>
<p>“量子自杀”实验在20世纪80年代提出，它实际上是薛定谔的猫的真人版，实验假设把猫换成人。对于哥本哈根解释，伴随原子衰变概率，有一半可能人活着，一半可能人死掉。MWI则认为，一个世界里的你活着，另一个世界的你死掉。然而，多宇宙预言：<strong>永远都会有一个“你”活着</strong>。其中活着的宇宙对你来说才是有意义的。那么为了验证MWI假说是否正确，那么只要做实验的人一直活着就可以了。如果假设成立，不论概率多么低，活着的你必定存在。对一直选择活着分支的你来说，你是“永生”的。这也就是说，如果MWI成立，那么对于某人来说，他无论如何自杀都不会死！因为按照MWI，在每个量子过程中都有两个世界分裂出来，这么多世界中必定包含你活着的那个。那么从该人的视角看，他怎么死都死不了。这就是从“量子自杀”中推出的“量子永生”。推广来看，总存在一些量子效应，使人不会衰老，那么，从主观意义上看，只要一个人有意识，那么他就必定永生。</p>
<h2 id="量子计算机和其他解释"><a href="#量子计算机和其他解释" class="headerlink" title="量子计算机和其他解释"></a>量子计算机和其他解释</h2><p>在量子理论中，一个量子不仅有0或1的可能，还可以表示0和1的叠加态。原来n个bit可以表示的信息，使用量子后可以表示2 ^ nbit。1985年，德义奇证明，量子计算机无法实现超越算法的任务，意味着它只能做普通图灵机能做的。但是计算同样的任务时，它能做的更快。量子计算机进行的是并行计算。当10bits的信息在处理时，量子计算机实际上在操作2 ^ 10 &#x3D; 1024种状态。由于量子态纠缠很容易退相干，目前量子计算机进展有限。</p>
<p>有意思的是，哥本哈根解释和MWI对于量子计算机的算力有着不同的解释。MWI解释里，在n bits的信息处理时，存在着2 ^ n个宇宙的计算机在计算并最后汇总。哥本哈根解释认为，在观测（输出结果）前，宇宙中存在着2 ^ n个叠加的计算机在干活。两种听起来都挺不可思议的。</p>
<p>无论哥本哈根还是MWI在叠加态上的解释都离常识较远。按照德布罗意的思路，有一个导波造成了量子看似的随机性。量子论中一些随机的表现实际上我们不够了解的原因，有一些不可见的变量没有考虑进去才导致了系统的不可预知。一旦把这些额外的变量考虑进去，整个系统又变成完备、确定、可预测的。这种“隐变量理论”在1932年被冯·诺依曼的论文证明不存在。</p>
<p>1952年，大卫·玻姆发现冯·诺依曼推导中的假设存在漏洞，并重新使用“量子势”建立起新的隐变量理论。量子势称，粒子周围散发着一种势场，这种势弥漫在整个宇宙中，每时每刻对环境了如指掌。在电子向双缝进发时，势场会提前发现双缝存在并指导电子的行为。在观测时，测量仪器首先与势场相互作用，这会使电子发生一些微妙的变化。玻姆的理论虽然可以解释量子力学中的现象。恢复了世界实在性（世界可以独立在之外观察）、决定性（现象可预测）的同时但是破坏了定域性（不能存在超距的因果关系）。</p>
<p>1963年，贝尔发展了ERP佯谬，提出和定域性、实在性等价的贝尔不等式。而后在1982年，被阿斯派克特实验证明，粒子间存在违背贝尔不等式，即违背定域性、实在性的行为。而后又被一系列实验验证。说明我们宇宙并不存在定域实在性，即要么选择“观察者”，要么选择“超距信号作用”。</p>
<p>这次爱因斯坦输了，“上帝真得掷骰子”。</p>
<p>除了上面提到的哥本哈根、MWI和隐变量，还有许多别的解释：</p>
<ul>
<li><strong>系综解释</strong>：我们的世界不存在单个的事件，每一个预测都只能是平均的，针对整个集合的。系综说，不要深究具体某个事件的意义，而且我们也不解释单个事件，不确定性在这里只是统计极限。这种解释并没有分析“坍缩”这个难题，只是简单将之踢出了体系之外</li>
<li><strong>GRW理论</strong>（命名取自三个提出者的姓名首字母），理论认为不论宏观还是微观系统，都不可能严格意义上孤立，即与外界毫不相干。它们总是与外界发生交流，受一些随机过程影响，比如位置从弥漫的叠加态变成比较精确的准确位置。但是这种情况出现的概率太低，几乎要等很久很久才会出现一次（按照他们的估计约为）。我们称这种过程为“<strong>自发定域</strong>”。尽管微观粒子自发定域如此之难，但是组成宏观物体的粒子数的量级很高，所以宏观物体内每秒发生着成千上万次自发定域。同时，由于系统内的粒子间相互纠缠，少数几个粒子的自发定域会引起多米诺效应，从而让宏观物体一直处于定域状态。这种定域时间很短，所以我们没法感觉到叠加态（近日耶鲁大学有一篇类似的论文疑似发现了定域、抑或坍缩的发生过程确实是有时间的）。但是GRW解释中抛弃了能量守恒定律，另一方面，如果自发定域的时间和参与的粒子数有关，我们完全有能力安排只用小数量级的粒子去观测，如银离子，这时叠加态维持时间在GRW解释中应该会很久。</li>
<li><strong>退相干历史</strong>，根据这种解释，现实是唯一的，历史是叠加的，“精细历史”间是相关的，但我们并不关心精细历史，我们只关心能观测到的粗略历史。随着历史树向上粗略化，不同历史间退相干。</li>
</ul>
<h2 id="大统一与超弦"><a href="#大统一与超弦" class="headerlink" title="大统一与超弦"></a>大统一与超弦</h2><p>宇宙中存在4种力：</p>
<ul>
<li>引力</li>
<li>电磁力</li>
<li>强相互作用力</li>
<li>弱相互作用力</li>
</ul>
<p>20世纪60年代，弱作用力与电磁力统一成交换“中间玻色子”的力，而后量子色动力学（QCD）尝试统一强作用力。1968年，意大利物理学家韦尼基亚诺通过欧拉β函数提出韦尼基亚诺模型，并被南部阳一郎、萨斯金、尼尔森用来描述粒子，并发展出弦论。但根据弦论推导，我们的时空需要是26维的，因此并不受科学界欢迎。1971年，施瓦兹和雷蒙引入超对称思想，把26维简化为10维，之后施瓦兹和格林完成弦论和超对称结合，得到“超弦”。1982年，通过计算发现，超信理论可以很好地解释引力。1984年，两人发现，在理论自洽下的一些有限情况里，不仅可以包容规范场理论，还能包容粒子的标准模型。从而让超弦理论一炮而红。理论认为，我们生活在一个10维空间里，但是其中6个维度是紧紧蜷缩起来的。当我们把观察尺度降低到普朗克空间尺度上，会发现时空中的一个“点”，实际上是个6维空间，其中6个维度不停扰动，造成了全部的量子不确定性。</p>
<p>1995年，爱德华·威顿在超弦年会上统一了不同耦合常数下的5种弦论，这种统一理论成为“M理论”。目前，超弦理论仍在持续探索之中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/blog/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">31:15</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

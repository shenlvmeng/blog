<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="intanbuljs是JS语言中最流行的覆盖率采集工具。其前身是个人发起的istanbul项目。日常使用中，经常将相关的CLI工具nyc配合着流行的前端测试框架一起使用，达到在单元&#x2F;集成&#x2F;e2e测试的同时，输出测试覆盖率数据的效果。 当然，你也可以通过babel-plugin-istanbul配合测试框架使用。 和istanbul的对比对于此前对前端测试覆盖率稍有了解了的人来">
<meta property="og:type" content="article">
<meta property="og:title" content="JS代码覆盖率工具instanbuljs及其思路介绍">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="intanbuljs是JS语言中最流行的覆盖率采集工具。其前身是个人发起的istanbul项目。日常使用中，经常将相关的CLI工具nyc配合着流行的前端测试框架一起使用，达到在单元&#x2F;集成&#x2F;e2e测试的同时，输出测试覆盖率数据的效果。 当然，你也可以通过babel-plugin-istanbul配合测试框架使用。 和istanbul的对比对于此前对前端测试覆盖率稍有了解了的人来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/16/JEZ3WV.png">
<meta property="article:published_time" content="2020-04-16T15:51:13.000Z">
<meta property="article:modified_time" content="2020-04-16T16:11:46.711Z">
<meta property="article:author" content="shenlvmeng">
<meta property="article:tag" content="覆盖率">
<meta property="article:tag" content="istanbul">
<meta property="article:tag" content="istanbuljs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/04/16/JEZ3WV.png">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/","path":"2020/04/16/istanbuljs/","title":"JS代码覆盖率工具instanbuljs及其思路介绍"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JS代码覆盖率工具instanbuljs及其思路介绍 | Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Shenlvmeng's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8Cistanbul%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.</span> <span class="nav-text">和istanbul的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9%E5%92%8Chook"><span class="nav-number">2.1.</span> <span class="nav-text">代码插桩和hook</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-lib-instrument"><span class="nav-number">2.1.1.</span> <span class="nav-text">istanbul-lib-instrument</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#createInstrumenter"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">createInstrumenter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#programVisitor"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">programVisitor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#readInitialCoverage"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">readInitialCoverage</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-lib-hook"><span class="nav-number">2.1.2.</span> <span class="nav-text">istanbul-lib-hook</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%B4%E6%8A%A4"><span class="nav-number">2.2.</span> <span class="nav-text">数据维护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">覆盖率数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-lib-coverage"><span class="nav-number">2.2.2.</span> <span class="nav-text">istanbul-lib-coverage</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#createCoverageMap"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">createCoverageMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#createFileCoverage"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">createFileCoverage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#createCoverageSummary"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">createCoverageSummary</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-lib-source-maps"><span class="nav-number">2.2.3.</span> <span class="nav-text">istanbul-lib-source-maps</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8E%E6%8A%A5%E5%91%8A"><span class="nav-number">2.3.</span> <span class="nav-text">可视化与报告</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-lib-report"><span class="nav-number">2.3.1.</span> <span class="nav-text">istanbul-lib-report</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Visitor%E5%92%8CBaseTree"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">Visitor和BaseTree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#istanbul-reports"><span class="nav-number">2.3.2.</span> <span class="nav-text">istanbul-reports</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A"><span class="nav-number">3.</span> <span class="nav-text">更多</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">434</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JS代码覆盖率工具instanbuljs及其思路介绍 | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS代码覆盖率工具instanbuljs及其思路介绍
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-16 23:51:13" itemprop="dateCreated datePublished" datetime="2020-04-16T23:51:13+08:00">2020-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-17 00:11:46" itemprop="dateModified" datetime="2020-04-17T00:11:46+08:00">2020-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/04/16/istanbuljs/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/16/istanbuljs/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://s1.ax1x.com/2020/04/16/JEZ3WV.png" alt="istanbul介绍"></p>
<p><a target="_blank" rel="noopener" href="https://istanbul.js.org/">intanbuljs</a>是JS语言中最流行的覆盖率采集工具。其前身是个人发起的<a target="_blank" rel="noopener" href="https://github.com/gotwarlost/istanbul">istanbul</a>项目。日常使用中，经常将相关的CLI工具<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/nyc">nyc</a>配合着<a target="_blank" rel="noopener" href="https://istanbul.js.org/docs/tutorials/">流行的前端测试框架</a>一起使用，达到在单元&#x2F;集成&#x2F;e2e测试的同时，输出测试覆盖率数据的效果。</p>
<p>当然，你也可以通过<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/babel-plugin-istanbul">babel-plugin-istanbul</a>配合测试框架<a target="_blank" rel="noopener" href="https://istanbul.js.org/docs/tutorials/">使用</a>。</p>
<h2 id="和istanbul的对比"><a href="#和istanbul的对比" class="headerlink" title="和istanbul的对比"></a>和istanbul的对比</h2><p>对于此前对前端测试覆盖率稍有了解了的人来说，可能更熟悉的是旧版的istanbul。istanbuljs在功能上和istanbul没有太大的区别，但在项目组织和实现细节上有着些许不同。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs">istanbuljs</a>使用monorepo组织整个项目，将相对独立的插桩、hook、覆盖率、sourcemap、报告等拆分成多个包独立实现和发版</li>
<li>使用babel实现源代码的AST解析和插桩（instrument）代码的生成</li>
<li>内置支持sourcemap</li>
<li>报告生成上取消了对express的依赖，只在本地产出报告</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于希望借助istanbuljs实现代码覆盖率相关功能的（nyc也基于istanbuljs实现），了解其各个包工作原理将会有所帮助。下面就按功能范畴介绍各个包的实现原理。</p>
<h3 id="代码插桩和hook"><a href="#代码插桩和hook" class="headerlink" title="代码插桩和hook"></a>代码<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)">插桩</a>和hook</h3><p>覆盖率产出建立在<strong>代码插桩</strong>的基础上。根据插桩时机，分为<strong>编译时插桩</strong>和<strong>运行时插桩</strong>。</p>
<ul>
<li><strong>编译时插桩</strong>，即在代码转译过程中插入覆盖率采集代码，产出代码本身即拥有采集能力，譬如babel-plugin-istanbul</li>
<li><strong>运行时插桩</strong>，即产出代码本身不具有采集能力，在运行时通过hook的方式在使用的代码中插入覆盖率采集代码，譬如<code>hookRequire</code></li>
</ul>
<p>不同于使用babel的编译时插桩，运行时插桩需要额外的hook一步。插桩和hook分别由<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-instrument">istanbul-lib-instrument</a>和<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-hook">istanbul-lib-hook</a>实现。</p>
<h4 id="istanbul-lib-instrument"><a href="#istanbul-lib-instrument" class="headerlink" title="istanbul-lib-instrument"></a>istanbul-lib-instrument</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createInstrumenter &#125; <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-instrument&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> instrumenter = <span class="title function_">createInstrumenter</span>(&#123;</span><br><span class="line">    coverageVariable,</span><br><span class="line">    <span class="attr">debug</span>: options &amp;&amp; options.<span class="property">debug</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> transformed = instrumenter.<span class="title function_">instrumentSync</span>(</span><br><span class="line">    code,</span><br><span class="line">    options.<span class="property">filename</span>,</span><br><span class="line">    sourceMap ? sourceMap.<span class="title function_">toObject</span>() : <span class="literal">undefined</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>istanbul-lib-instrument利用babel实现了代码插桩。仓库暴露了3个API：</p>
<h5 id="createInstrumenter"><a href="#createInstrumenter" class="headerlink" title="createInstrumenter"></a><code>createInstrumenter</code></h5><p>最主要的API。以入参作为配置项创建一个<code>Instrumenter</code>实例，配置项如下：</p>
<ul>
<li><code>coverageVariable</code> 覆盖率全局变量名，可选，默认<code>__coverage__</code></li>
<li><code>preserveComments</code> 是否保留注释，可选，默认<code>false</code></li>
<li><code>esModules</code> 是否插桩ES6代码，可选，默认<code>false</code></li>
<li><code>produceSourceMap</code> 是否为插桩前后代码生成sourcemap，可选，默认<code>false</code></li>
<li><code>debug</code> 是否打印详细信息，可选，默认<code>false</code></li>
<li>… 更多配置参见<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-instrument/api.md#parameters-4">文档介绍</a></li>
</ul>
<p>通常使用时，配置项均使用默认值即可。<code>Instrumenter</code>实例有下面几个重要的方法</p>
<p><strong><code>instrumentSync</code></strong></p>
<p>同步插桩代码，支持ES6和ES5，插桩ES6代码时，需要配置项中的<code>esModules</code>为<code>true</code>。解析代码出错时会抛出错误。方法返回插桩后的代码字符串，入参如下：</p>
<ul>
<li><code>code</code> 代码字符串</li>
<li><code>filename</code> 文件名（包含路径）</li>
<li><code>inputSourceMap</code> 用来将当前代码的覆盖率反映射到源文件中的覆盖率，需要是sourcemap格式。</li>
</ul>
<p>在指定了<code>inputSourceMap</code>后，当前文件采集覆盖率时，会附带上传入的这个sourcemap，从而可以结合istanbul-lib-sourcemaps使用。</p>
<p><strong><code>instrument</code></strong></p>
<p>callback风格的插桩，此时抛出错误将通过回调的入参传入，而非直接抛出。插桩的代码也会在回调中传入而非直接返回。需要注意的是，回调的执行和语句的执行在同一个process tick中，而不是异步的。</p>
<p>函数入参即<code>instrumentSync</code>的第三个位置插入函数类型的<code>callback</code>入参。</p>
<p>剩余的两个方法：</p>
<ul>
<li><code>lastFileCoverage</code>，返回最近一次的文件覆盖率对象</li>
<li><code>lastSourceMap</code>，返回最近一次的文件的sourcemap</li>
</ul>
<h5 id="programVisitor"><a href="#programVisitor" class="headerlink" title="programVisitor"></a><code>programVisitor</code></h5><p><code>programVisitor</code>是一个将babel用于插桩的适配器函数，该函数会返回一个具有<code>enter</code>以及<code>exit</code>方法的对象，这两个方法必须应用在<code>Program</code>的enter和exit属性上，实现插桩效果。istanbuljs内部也是通过<code>programVisitor</code>实现的功能。<code>programVisitor</code>内部并不依赖babel的状态，因此也可以用在babel以外的环境。</p>
<p>该函数支持以下入参：</p>
<ul>
<li><code>types</code>，babel-types实例，语法节点类型</li>
<li><code>sourceFilePath</code>，文件路径，可选，默认为<code>unknown.js</code></li>
<li><code>opts</code>，插桩配置项，可以参见<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-instrument/api.md#parameters-4">文档介绍</a></li>
</ul>
<p>在函数内部集中了插桩的细节实现，即对于特定类型语法树节点插入对应逻辑。</p>
<h5 id="readInitialCoverage"><a href="#readInitialCoverage" class="headerlink" title="readInitialCoverage"></a><code>readInitialCoverage</code></h5><p>配合<code>Instrumenter</code>的<code>lastFileCoverage</code>方法使用，读取文件的初始覆盖率。</p>
<p>上面这些API中，最常用和最核心的即<code>instrumentSync</code>方法。在实现上，方法分为下面几步：</p>
<ol>
<li>根据<code>Instrumenter</code>的配置项确定babel的配置项，同时，引入<code>programVisitor</code>作为babel的plugin，指定遍历节点的操作</li>
<li>使用<code>@babel/core</code>的<code>transformSync</code>API，得到生成的代码</li>
<li>更新<code>fileCoverage</code>和<code>sourcemap</code></li>
<li>返回代码</li>
</ol>
<h4 id="istanbul-lib-hook"><a href="#istanbul-lib-hook" class="headerlink" title="istanbul-lib-hook"></a>istanbul-lib-hook</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hookRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-hook&#x27;</span>;</span><br><span class="line"><span class="title function_">hookRequire</span>(matcher, transformer, &#123;</span><br><span class="line">    <span class="attr">verbose</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">postLoadHook</span>: <span class="function">(<span class="params">filename: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>istanbul-lib-hook提供了下面一些API，用来hook JS中对代码的引用，其中后三个API都有对应的unhook API：</p>
<ul>
<li><code>hookRequire</code>，hook了<code>require</code>引入的代码</li>
<li><code>hookCreateScript</code>，hook了<code>vm.createScript</code>引入的代码</li>
<li><code>hookRunInThisContext</code>，hook了<code>vm.runInThisContext</code>引入的代码</li>
<li><code>hookRunInContext</code>，hook了<code>vm.runInContext</code>引入的代码、</li>
</ul>
<p>在其中最常用的是<code>hookRequire</code>，入参如下：</p>
<ul>
<li><code>matcher</code>，函数类型，接收文件的完整路径，返回bool类型，用来判断是否对文件插桩</li>
<li><code>transformer</code>，函数类型，接收代码和文件路径，返回插桩后的代码，可以通过对上面提到的<code>Instrumenter</code>的<code>instrumentSync</code>封装得到</li>
<li><code>options</code>，配置项<ul>
<li><code>verbose</code>，是否打印详细信息</li>
<li><code>postLoadHook</code>，文件hook之后的回调</li>
</ul>
</li>
</ul>
<p><code>hookRequire</code>借助Nodejs的Module加载机制实现，hook了后缀为<code>.js</code>文件的编译过程，在每次<code>require</code>的时候触发。详细的原理可以参见<a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/">这里</a>。唯一的不同是，在istanbuljs中，这一实现被封装在<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/append-transform">append-transform</a>包中实现，来兼容异常情况。实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appendTransform = <span class="built_in">require</span>(<span class="string">&#x27;append-transform&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookRequire</span>(<span class="params">matcher, transformer, options</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="title function_">transformFn</span>(matcher, transformer, options.<span class="property">verbose</span>);</span><br><span class="line">    <span class="keyword">const</span> extensions = options.<span class="property">extensions</span> || [<span class="string">&#x27;.js&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    extensions.<span class="title function_">forEach</span>(<span class="function"><span class="params">ext</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">appendTransform</span>(<span class="function">(<span class="params">code, filename</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">const</span> ret = <span class="title function_">fn</span>(code, filename);</span><br><span class="line">            <span class="keyword">if</span> (postLoadHook) &#123;</span><br><span class="line">                <span class="title function_">postLoadHook</span>(filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret.<span class="property">code</span>;</span><br><span class="line">        &#125;, ext);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据维护"><a href="#数据维护" class="headerlink" title="数据维护"></a>数据维护</h3><p>在代码插桩的基础上，产出的覆盖率数据会积累在全局变量上。在数据可视化和统计结果展示前，还需要将数据封装成更贴近实际场景的形态，便于进行合并、输出、摘要等操作。</p>
<p>这部分工作在<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-coverage">istanbul-lib-coverage</a>中完成。</p>
<h4 id="覆盖率数据结构"><a href="#覆盖率数据结构" class="headerlink" title="覆盖率数据结构"></a>覆盖率数据结构</h4><p>下面是采集到的原始数据的结构定义，这也是istanbul-lib-coverage的基础。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CoverageMapData</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="title class_">FileCoverageData</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FileCoverageData</span> &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">statementMap</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="title class_">Range</span> &#125;;</span><br><span class="line">    <span class="attr">fnMap</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="title class_">FunctionMapping</span> &#125;;</span><br><span class="line">    <span class="attr">branchMap</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="title class_">BranchMapping</span> &#125;;</span><br><span class="line">    <span class="attr">s</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125;;</span><br><span class="line">    <span class="attr">f</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125;;</span><br><span class="line">    <span class="attr">b</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>[] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="attr">line</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">column</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="title class_">Location</span>;</span><br><span class="line">    <span class="attr">end</span>: <span class="title class_">Location</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BranchMapping</span> &#123;</span><br><span class="line">    <span class="attr">loc</span>: <span class="title class_">Range</span>;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">locations</span>: <span class="title class_">Range</span>[];</span><br><span class="line">    <span class="attr">line</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FunctionMapping</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">decl</span>: <span class="title class_">Range</span>;</span><br><span class="line">    <span class="attr">loc</span>: <span class="title class_">Range</span>;</span><br><span class="line">    <span class="attr">line</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="istanbul-lib-coverage"><a href="#istanbul-lib-coverage" class="headerlink" title="istanbul-lib-coverage"></a>istanbul-lib-coverage</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libCoverage <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-coverage&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> map = libCoverage.<span class="title function_">createCoverageMap</span>(globalCoverageVar);</span><br><span class="line"><span class="keyword">const</span> summary = libCoverage.<span class="title function_">createCoverageSummary</span>();</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">merge</span>(otherCoverageMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取摘要</span></span><br><span class="line">map.<span class="title function_">files</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fc = map.<span class="title function_">fileCoverageFor</span>(f);</span><br><span class="line">    <span class="keyword">const</span> s = fc.<span class="title function_">toSummary</span>();</span><br><span class="line">    summary.<span class="title function_">merge</span>(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Global summary&#x27;</span>, summary);</span><br></pre></td></tr></table></figure>

<p>包暴露了3个API, 用来创建封装好的覆盖率数据。</p>
<h5 id="createCoverageMap"><a href="#createCoverageMap" class="headerlink" title="createCoverageMap"></a><code>createCoverageMap</code></h5><p>传入原始数据（<code>CoverageMapData</code>类型）或<code>CoverageMap</code>类型，返回一个<code>CoverageMap</code>类型对象，在覆盖率数据基础上，提供了方法，包含：</p>
<ul>
<li><code>merge</code>，合并另一个<code>CoverageMap</code>对象或数据</li>
<li><code>filter</code>，传入filter函数，删除部分覆盖率数据</li>
<li><code>toJSON</code>，返回原始数据</li>
<li><code>files</code>，返回文件列表</li>
<li><code>fileCoverageFor</code>，返回特定文件的覆盖率</li>
<li><code>addFileCoverage</code>，增加特定文件的覆盖率</li>
<li><code>getCoverageSummary</code>，生成覆盖率摘要数据</li>
</ul>
<p>摘要数据数据结构如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CoverageSummaryData</span> &#123;</span><br><span class="line">    <span class="attr">lines</span>: <span class="title class_">Totals</span>;</span><br><span class="line">    <span class="attr">statements</span>: <span class="title class_">Totals</span>;</span><br><span class="line">    <span class="attr">branches</span>: <span class="title class_">Totals</span>;</span><br><span class="line">    <span class="attr">functions</span>: <span class="title class_">Totals</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Totals</span> &#123;</span><br><span class="line">    <span class="attr">total</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">covered</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">skipped</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">pct</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="createFileCoverage"><a href="#createFileCoverage" class="headerlink" title="createFileCoverage"></a><code>createFileCoverage</code></h5><p>类似<code>createCoverageMap</code>，通过传入原始数据或对象的方式，创建<code>FileCoverage</code>对象。对象有如下方法：</p>
<ul>
<li><code>getLineCoverage</code>，返回每一行的执行次数</li>
<li><code>getUncoveredLines</code>，返回未覆盖的行序号列表</li>
<li><code>getBranchCoverageByLine</code>，获取每个分支按行计算的覆盖率比例</li>
<li><code>toJSON</code>，返回原始数据</li>
<li><code>merge</code>，合并另一个<code>FileCoverage</code>或原始数据</li>
<li><code>computeSimpleTotals</code>，根据输入的属性，计算覆盖率摘要</li>
<li><code>computeBranchTotals</code>，根据分支计算覆盖率摘要</li>
<li><code>resetHits</code>，重置所有已执行的数据</li>
<li><code>toSummary</code>，生成摘要数据</li>
</ul>
<h5 id="createCoverageSummary"><a href="#createCoverageSummary" class="headerlink" title="createCoverageSummary"></a><code>createCoverageSummary</code></h5><p>根据输入数据，创建摘要。方法较简单：</p>
<ul>
<li><code>merge</code>，合并一个摘要数据</li>
<li><code>toJSON</code>，返回原始摘要数据</li>
<li><code>isEmpty</code>，是否为空</li>
</ul>
<p>整体来看istanbul-lib-coverage所做的工作，即按照约定好的格式，将数据组织起来，为可视化输出做了基础。</p>
<h4 id="istanbul-lib-source-maps"><a href="#istanbul-lib-source-maps" class="headerlink" title="istanbul-lib-source-maps"></a>istanbul-lib-source-maps</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSourceMapStore &#125; <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-source-maps&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> libCoverage <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-coverage&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStore = <span class="title function_">createSourceMapStore</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coverageMap = libCoverage.<span class="title function_">createCoverageMap</span>(coverageData);</span><br><span class="line"><span class="keyword">const</span> transformed = <span class="keyword">await</span> mapStore.<span class="title function_">transformCoverage</span>(coverageMap);</span><br><span class="line"><span class="keyword">const</span> transformedCoverage = transformed.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(transformedCoverage);</span><br></pre></td></tr></table></figure>

<p>绝大多数情况下，istanbuljs采集到的都是转译后目标文件的代码覆盖率，这个数据对于开发者来讲意义不大，需要将这里采集到的行列数据反映射到源文件的位置上。内置<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-source-maps">istanbul-lib-source-maps</a>包用来处理这种情况的。</p>
<p>istanbul-lib-source-maps只负责转换代码位置和目录，并不能负责收集代码或文件的sourcemap信息，这一步交给使用者自己实现。就像我们在<code>instrumentSync</code>一节提到的，通过第三个入参<code>inputSourceMap</code>可以产出满足istanbul-lib-source-maps需要的覆盖率数据，从而借助istanbul-lib-source-maps获取到源文件的覆盖率。</p>
<p>这个包本身只暴露<code>createSourceMapStore</code>这一个API，通过传入配置的方式，初始化一个sourcemap的store。配置项如下：</p>
<ul>
<li><code>verbose</code>，是否打印详细信息</li>
<li><code>baseDir</code>，sourcemap文件的基础目录</li>
<li><code>SourceStore</code>，一个<code>SourceStore</code>对象</li>
<li><code>sourceStoreOpts</code>，初始化<code>SourceStore</code>对象的参数列表</li>
</ul>
<p>初始化好的<code>MapStore</code>对象有如下方法：</p>
<ul>
<li><code>registerURL</code>，通过dataURL注册一个sourcemap到store中</li>
<li><code>registerMap</code>，通过sourcemap对象注册一个sourcemap到store中</li>
<li><code>getSourceMapSync</code>，从当前store中获取指定文件的sourcemap</li>
<li><code>addInputSourceMapsSync</code>，为当前覆盖率数据同步添加store中的sourcemap数据</li>
<li><code>sourceFinder</code>，寻找指定文件的源文件路径</li>
<li><code>transformCoverage</code>，利用当前store中的sourcemap信息，将覆盖率对应到源文件上。<strong>覆盖率信息中有<code>inputSourceMap</code>字段时，优先使用<code>inputSourceMap</code>字段里的sourcemap信息</strong></li>
<li><code>dispose</code>，清除store数据</li>
</ul>
<p>包中的其余文件也都基于<code>MapStore</code>实现诸如路径转换，数据转换等工具方法。更多细节，可以参见<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-source-maps">源文件</a>。</p>
<p>使用时，有两种方式：</p>
<ul>
<li>先导入没有sourcemap的覆盖率信息，再逐个注册sourcemap到store中，最后执行<code>transformCoverage</code></li>
<li>直接导入有<code>inputSourceMap</code>信息的覆盖率数据，执行<code>transformCoverage</code></li>
</ul>
<p>可以根据实际场景选择使用方式。例如，nyc中就使用的第2种方式，利用<a target="_blank" rel="noopener" href="https://github.com/thlorenz/convert-source-map">convert-source-map</a>采集到文件内的sourcemap信息，在代码插桩时传入。</p>
<h3 id="可视化与报告"><a href="#可视化与报告" class="headerlink" title="可视化与报告"></a>可视化与报告</h3><p>覆盖率工具的最终目的是向使用者呈现可读的数据样式，通常是以UI或文件的形式。因此，要将上一章中维护好的数据按使用者需求输出。可视化和报告由<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-report">istanbul-lib-report</a>以及<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports">istanbul-reports</a>实现。</p>
<p>其中，前者定义了产出报告的抽象行为，后者实现了各种具体的报告形态。两个包结合在一起使用的方式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libReport <span class="keyword">from</span> <span class="string">&#x27;istanbul-lib-report&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reports <span class="keyword">from</span> <span class="string">&#x27;istanbul-reports&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> coverageMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configWatermarks = &#123;</span><br><span class="line">    <span class="attr">statements</span>: [<span class="number">50</span>, <span class="number">80</span>],</span><br><span class="line">    <span class="attr">functions</span>: [<span class="number">50</span>, <span class="number">80</span>],</span><br><span class="line">    <span class="attr">branches</span>: [<span class="number">50</span>, <span class="number">80</span>],</span><br><span class="line">    <span class="attr">lines</span>: [<span class="number">50</span>, <span class="number">80</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = libReport.<span class="title function_">createContext</span>(&#123;</span><br><span class="line">    <span class="attr">dir</span>: <span class="string">&#x27;report/output/dir&#x27;</span>,</span><br><span class="line">    <span class="comment">// 摘要的生成方式</span></span><br><span class="line">    <span class="comment">// 可以是nested/flat/pkg 默认为&#x27;pkg&#x27;</span></span><br><span class="line">    <span class="attr">defaultSummarizer</span>: <span class="string">&#x27;nested&#x27;</span>,</span><br><span class="line">    <span class="attr">watermarks</span>: configWatermarks,</span><br><span class="line">    coverageMap,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> report = reports.<span class="title function_">create</span>(<span class="string">&#x27;json&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">skipEmpty</span>: configSkipEmpty,</span><br><span class="line">    <span class="attr">skipFull</span>: configSkipFull</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同步操作</span></span><br><span class="line">report.<span class="title function_">execute</span>(context);</span><br></pre></td></tr></table></figure>

<h4 id="istanbul-lib-report"><a href="#istanbul-lib-report" class="headerlink" title="istanbul-lib-report"></a>istanbul-lib-report</h4><p>维护好的覆盖率数据会和具体的文件节点绑定，形成树状数据结构。遍历每个树节点就是产出报告的基本步骤，只不过不同报告格式，遍历节点的操作也不同。istanbul-lib-report中定义了基本的树状结构和遍历规则。</p>
<p>包暴露了3个API，</p>
<ul>
<li><code>createContext</code>，创建一个包含产出报告配置信息context对象</li>
<li><code>getDefaultWatermarks</code>，返回默认的评级指标，默认是0到50到80，分别对应差中好</li>
<li><code>ReportBase</code>，所有报告必须继承的基类</li>
</ul>
<p>其中context和ReportBase是配合实现生成报告的。先来看简单的ReportBase，<code>ReportBase</code>类中简单地描述了管理摘要树的方法和定义了通用的<code>execute</code>方法来生成报告。具体会在istanbul-reports中提到。</p>
<p>再来看Context类。Context入参配置项包含：</p>
<ul>
<li><code>dir</code>，产出报告的目标目录</li>
<li><code>watermarks</code>，评级指标，默认使用0-50-80-100</li>
<li><code>sourceFinder</code>，通过文件路径返回代码的函数，默认为文件读取操作</li>
<li><code>coverageMap</code>，覆盖率数据</li>
<li><code>defaultSummarizer</code>，摘要树生成的风格，有<code>flat</code>,<code>pkg</code>,<code>nested</code>3种选择<ul>
<li><code>flat</code>，所有文件全部打平到1层里，挂载到最近的公共祖先上</li>
<li><code>pkg</code>，所有文件向上追溯1层文件夹，挂载到最近的公共祖先上</li>
<li><code>nested</code>，所有文件向上追溯，直到追溯到最近的公共祖先上</li>
</ul>
</li>
</ul>
<p>构建好的<code>Context</code>有一个<code>writer</code>属性挂载在<code>this</code>和<code>this.data</code>上，它决定了报告的产出形式，目前这个包提供了两种产出形式：<strong>文件</strong>和<strong>字符串</strong>，后者只用在产出XML数据时。其余报告基本都通过文件的形式产出，这也是istanbuljs和istanbul的一大不同。在istanbul中，html可以借助express依赖以HTML响应的形式返回。</p>
<p>文件的输出类定义在<code>file-writer.js</code>中，其中的<code>FileWriter</code>定义了基本的<code>copyFile</code>，<code>writerForDir</code>，<code>writeFile</code>操作用来递归的复制和写入文件。另外在<code>writeFile</code>中，根据目标是否是file，选择使用<code>ConsoleWriter</code>或者<code>FileContentWriter</code>。这两者继承自基本的<code>ContentWriter</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContentWriter</span> &#123;</span><br><span class="line">    <span class="title function_">colorize</span>(<span class="params">str <span class="comment">/*, clazz*/</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">println</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">`<span class="subst">$&#123;str&#125;</span>\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">close</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileContentWriter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ContentWriter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">fd</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fd</span> = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">write</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">writeSync</span>(<span class="variable language_">this</span>.<span class="property">fd</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">        fs.<span class="title function_">closeSync</span>(<span class="variable language_">this</span>.<span class="property">fd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleWriter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ContentWriter</span> &#123;</span><br><span class="line">    <span class="title function_">write</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (capture) &#123;</span><br><span class="line">            output += str;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            process.<span class="property">stdout</span>.<span class="title function_">write</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">colorize</span>(<span class="params">str, clazz</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> colors = &#123;</span><br><span class="line">            <span class="attr">low</span>: <span class="string">&#x27;31;1&#x27;</span>,</span><br><span class="line">            <span class="attr">medium</span>: <span class="string">&#x27;33;1&#x27;</span>,</span><br><span class="line">            <span class="attr">high</span>: <span class="string">&#x27;32;1&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsColor.<span class="property">stdout</span> &amp;&amp; colors[clazz]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`\u001b[<span class="subst">$&#123;colors[clazz]&#125;</span>m<span class="subst">$&#123;str&#125;</span>\u001b[0m`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串的输出类只有<code>XMLWriter</code>，位于<code>xml-writer.js</code>中，在其中定义了xml的开闭标签和缩进操作。</p>
<p>这个Context还有一些方法提供给reports使用：</p>
<ul>
<li><code>getWriter</code>&#x2F;<code>getXMLWriter</code>，返回输出数据的writer</li>
<li><code>getSource</code>，通过<code>sourceFinder</code>寻找源码</li>
<li><code>classForPercent</code>，将评价转化为HTML类名</li>
<li><code>getVisitor</code>，获取一个遍历的vistor对象</li>
<li><code>getTree</code>，根据摘要风格返回一个用于遍历的树，</li>
</ul>
<p>下面具体介绍vistor和tree的概念</p>
<h5 id="Visitor和BaseTree"><a href="#Visitor和BaseTree" class="headerlink" title="Visitor和BaseTree"></a><code>Visitor</code>和<code>BaseTree</code></h5><p><code>Visitor</code>类和<code>BaseNode</code>类定义了遍历和节点的基本操作，其中Visitor使用代理人模式，在构造时传入一个回调函数对象，当<code>visitor</code>对象触发特定事件时，会将当前节点和状态交给回调函数，实现遍历效果。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">delegate</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">delegate</span> = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Start&#x27;</span>, <span class="string">&#x27;End&#x27;</span>, <span class="string">&#x27;Summary&#x27;</span>, <span class="string">&#x27;SummaryEnd&#x27;</span>, <span class="string">&#x27;Detail&#x27;</span>]</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">k</span> =&gt;</span> <span class="string">`on<span class="subst">$&#123;k&#125;</span>`</span>)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Visitor</span>.<span class="property"><span class="keyword">prototype</span></span>, fn, &#123;</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="title function_">value</span>(<span class="params">node, state</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">delegate</span>[fn] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">delegate</span>[fn](node, state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>相对应的<code>BaseNode</code>类定义了用于遍历的<code>visit</code>方法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="title function_">visit</span>(<span class="params">visitor, state</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件夹没有详情，只有摘要</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isSummary</span>()) &#123;</span><br><span class="line">            visitor.<span class="title function_">onSummary</span>(<span class="variable language_">this</span>, state);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visitor.<span class="title function_">onDetail</span>(<span class="variable language_">this</span>, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getChildren</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            child.<span class="title function_">visit</span>(visitor, state);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isSummary</span>()) &#123;</span><br><span class="line">            visitor.<span class="title function_">onSummaryEnd</span>(<span class="variable language_">this</span>, state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>BaseTree</code>中从Root开始遍历即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseTree</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">visit</span>(<span class="params">visitor, state</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(visitor <span class="keyword">instanceof</span> <span class="title class_">Visitor</span>)) &#123;</span><br><span class="line">            visitor = <span class="keyword">new</span> <span class="title class_">Visitor</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">        visitor.<span class="title function_">onStart</span>(<span class="variable language_">this</span>.<span class="title function_">getRoot</span>(), state);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getRoot</span>().<span class="title function_">visit</span>(visitor, state);</span><br><span class="line">        visitor.<span class="title function_">onEnd</span>(<span class="variable language_">this</span>.<span class="title function_">getRoot</span>(), state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的摘要风格形成的树状结构不同，它们都是<code>ReportTree</code>类型，而<code>ReportTree</code>正是继承自<code>BaseTree</code>。<code>ReportTree</code>由继承自<code>BaseNode</code>的<code>ReportNode</code>构建。在<code>ReportNode</code>上定义了和覆盖率或文件操作相关的一些方法，如<code>getFileCoverage</code>，<code>getCoverageSummary</code>等。</p>
<p>一个context内的visitor和tree可以通过<code>getVisitor</code>和<code>getTree</code>得到</p>
<h4 id="istanbul-reports"><a href="#istanbul-reports" class="headerlink" title="istanbul-reports"></a>istanbul-reports</h4><p>istanbul-reports包中定义了种类繁多的导出格式，在入口文件通过指定的配置项选择使用，如上面样例中的<code>const report = reports.create(&#39;json&#39;, &#123;/* ... */&#125;)</code>即使用<code>json/lib/index.js</code>下导出的<code>JsonReport</code>类。istanbul-reports所有格式都基于istanbul-lib-report中基类的定义。这里以简单的json格式为例。</p>
<p>其中定义了对于<code>onStart</code>，<code>onDetail</code>，<code>onEnd</code>的定义和上面<code>BaseNode</code>中介绍的回调函数相对应，在遍历<code>ReportTree</code>的各个阶段被触发，通过context的writer去输出。而writer从<code>ReportBase</code>中可以发现是通过context确定的，在context中默认是filewriter。而遍历是如何执行的呢？</p>
<p>回头看下ReportBase的实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _summarizer = <span class="title class_">Symbol</span>(<span class="string">&#x27;ReportBase.#summarizer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReportBase</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">opts = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[_summarizer] = opts.<span class="property">summarizer</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">execute</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        context.<span class="title function_">getTree</span>(<span class="variable language_">this</span>[_summarizer]).<span class="title function_">visit</span>(<span class="variable language_">this</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>execute</code>中传入context，即可把带有覆盖率信息的树形数据结构交给report代表的visitor遍历，逐个节点地打印出覆盖率报告。</p>
<p>其余类型的报告也是类似的原理。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul>
<li><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/">前端代码覆盖率实时统计方案探索</a></li>
<li><a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2020/04/17/fe-coverage-improve/">前端代码覆盖率实时统计改进方案</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E8%A6%86%E7%9B%96%E7%8E%87/" rel="tag"># 覆盖率</a>
              <a href="/blog/tags/istanbul/" rel="tag"># istanbul</a>
              <a href="/blog/tags/istanbuljs/" rel="tag"># istanbuljs</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2020/04/16/fe-coverage-scheme/" rel="prev" title="前端代码覆盖率实时统计方案探索">
                  <i class="fa fa-chevron-left"></i> 前端代码覆盖率实时统计方案探索
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2020/04/17/fe-coverage-improve/" rel="next" title="前端代码覆盖率实时统计改进方案">
                  前端代码覆盖率实时统计改进方案 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">986k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">27:24</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"测试\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2019/05/28/the-pragmatic-programmer/",
            "url": "http://shenlvmeng.github.com/blog/2019/05/28/the-pragmatic-programmer/",
            "title": "《程序员修炼之道》 —— 从小工到专家",
            "date_published": "2019-05-28T15:55:53.000Z",
            "content_html": "<p>《程序员修炼之道》这个书名实际上不如原版《The Pragmatic Programmer： From Journeyman to Master》来得更清晰明了。此书第一版写于1999年，我看的是11年的版本，但还是透流露着不少世纪初的观念和视野。除开一部分观点认识的过时，书中绝大多数观点都四溢着国外互联网行业的工作风格和流程，和国内凶猛生长、一把梭就是干的风格各有不同，甚至我感觉国内IT，尤其是互联网企业里的工作流更加讲求实效。尽管和读之前的预期不大一样，里面许多经验还是很有借鉴意义，比如正交性、不要依赖巧合等等。</p>\n<p>书中内容在项目管理、编程哲学、以及编程过程的各个方面都有涉及，在这些方面上更加深入的探讨，书的最后也推荐了继续阅读的材料。下面就各章节的关键观点加以整理。</p>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>关于本书的读法：</p>\n<ul>\n<li>能不能让正确原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志</li>\n<li>要能内化书中提到的各个小提示，不实践的话，是不会有太大收获的</li>\n<li><strong>思考，你的工作</strong>，多思考</li>\n</ul>\n<h2 id=\"实效哲学\"><a href=\"#实效哲学\" class=\"headerlink\" title=\"实效哲学\"></a>实效哲学</h2><ul>\n<li><strong>对你的源码负责</strong></li>\n<li><strong>不要容忍破窗</strong>，它们会增大你软件的熵（这个也是要结合实际情况看的）</li>\n<li><strong>记住大图景</strong>，注意方向是否有误，不要光低头做事</li>\n<li><strong>知道在何时打住</strong>，你不可能做到完美</li>\n<li><strong>定期为你的知识资产投资</strong>，就像经济投资一样<ul>\n<li>定期投资</li>\n<li>多元化</li>\n<li>管理风险，不要把所有技术放在一个篮子里</li>\n<li>低买高卖，能看清形势</li>\n</ul>\n</li>\n<li>为此，你需要<ul>\n<li><strong>每年至少学习一种新语言</strong></li>\n<li><strong>每季度阅读一本技术书籍</strong></li>\n<li>也要阅读非技术书籍</li>\n</ul>\n</li>\n<li><strong>批判地思考你读到和听到的</strong></li>\n<li><strong>如何表达自己很重要</strong>，这会增加你的影响力<ul>\n<li>你想让谁知道</li>\n<li>你想让他们知道什么</li>\n<li>他们是否感兴趣</li>\n<li>他们需要知道细节么</li>\n<li>如何促使他们与你交流</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实效途径\"><a href=\"#实效途径\" class=\"headerlink\" title=\"实效途径\"></a>实效途径</h2><ul>\n<li><strong>DRY，不要重复自己</strong><ul>\n<li>强加的重复 &#x3D;&gt; 使用自动生成，减少是信息冗知识</li>\n<li>无意的重复 &#x3D;&gt; 优良的设计</li>\n<li>无耐心的重复 &#x3D;&gt; 考虑长远</li>\n<li>开发者间的重复 &#x3D;&gt; 加强组内交流，制定代码规范，<strong>制造更容易复用的环境</strong></li>\n</ul>\n</li>\n<li><strong>减少无关事物的影响</strong>，非正交 &#x3D;&gt; 次级效应 &#x3D;&gt; 补偿行为 &#x3D;&gt; 经验依赖<ul>\n<li>好处：提高生产率（促进复用）、降低风险（风险隔离，易测试）</li>\n<li>分层设计、抽象和接口约定</li>\n<li>避免使用全局变量</li>\n<li>考虑使用库的代码侵入性</li>\n<li>文档和认同正交性</li>\n</ul>\n</li>\n<li><em>不存在最终决策</em>，当需求变动频繁的时候，不仅要思考程序架构如何适应这种变动，也要反思是否是设计者没想清楚到底要做什么</li>\n<li><strong>使用曳光弹找到目标</strong>，即MVP + 快速迭代 + 即时的反馈<ul>\n<li>逐步逼近，摸着石头过河</li>\n<li>曳光弹模式永远包含着一个可用的软件版本</li>\n</ul>\n</li>\n<li><strong>原型和便笺</strong>，使用原型去表达和快速验证项目的可行性</li>\n<li><strong>靠近问题领域编程</strong><ul>\n<li>使用DSL（Domain Specified Language）</li>\n</ul>\n</li>\n<li><strong>估算，以避免意外</strong>，主要用来估计工期、分析风险<ul>\n<li>适当地降低估算速度，慎重思考隐藏的风险</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本工具\"><a href=\"#基本工具\" class=\"headerlink\" title=\"基本工具\"></a>基本工具</h2><p>工具成为双手和大脑的延伸，优秀的工具可以放大你的才干。</p>\n<ul>\n<li><strong>纯文本以其自解释能力几乎可以永久保存</strong>，XML、JSON就是利用此成为通用的数据表现形式</li>\n<li><strong>利用shell的力量</strong>，它是自动化任务避不开的工具</li>\n<li><strong>要能烂熟地使用你的编辑器</strong>、<strong>要使用高级的编辑器</strong>，由于你的所有开发工作都建立在它上面，做好这两点可以节省你大量时间<ul>\n<li>反思一下，在用你的编辑器时，你有遇到过到比较繁琐的操作吗？</li>\n<li>是因为你不会高级使用方式，还是编辑器本身不支持？</li>\n</ul>\n</li>\n<li><em>总是使用源码控制</em>（这一点早已成为共识）</li>\n<li>调试，debug<ul>\n<li><strong>通常认为匪夷所思的bug，都来自健忘、自大和愚蠢</strong></li>\n<li>QA角色的重要性之一：帮助复现、找到规律性</li>\n<li>橡皮鸭调试法</li>\n<li><strong>二分查找法</strong></li>\n<li>如果bug来自某人的错误假设，那么需要清除团队其他人的相同误解</li>\n</ul>\n</li>\n<li><strong>学习一种文本操纵语言或工具</strong>，例如awk，sed，处理数据和结果时一定能用上</li>\n<li><strong>编写代码生成器</strong><ul>\n<li>开发者手动触发，如模板代码</li>\n<li>程序自动出发，如scheme to idl，idl to code</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"偏执编程\"><a href=\"#偏执编程\" class=\"headerlink\" title=\"偏执编程\"></a>偏执编程</h2><ul>\n<li><strong>通过合约设计</strong>，约定好接口，合作方基于接口开发<ul>\n<li>强类型语言更容易实现这一点</li>\n</ul>\n</li>\n<li><strong>早崩溃</strong>，这在需要编译的软件开发上比较科学，对于web应用来说却不是这样</li>\n<li><strong>使用断言确保某事不会发生</strong>，减少预设条件代理的隐藏bug<ul>\n<li>不要滥用断言</li>\n</ul>\n</li>\n<li><strong>只在异常处用异常</strong></li>\n<li><strong>一定记住释放请求的资源</strong>，如内存、句柄等，可以通过封装统一的资源类实现自动的资源释放</li>\n</ul>\n<h2 id=\"时间的魔力\"><a href=\"#时间的魔力\" class=\"headerlink\" title=\"时间的魔力\"></a>时间的魔力</h2><ul>\n<li><strong>德墨忒尔法则</strong>，使模块间的依赖减少到最小<ul>\n<li>物理解耦</li>\n</ul>\n</li>\n<li><strong>要配置不要hardcode</strong>，使用元数据动态描述你的程序<ul>\n<li><strong>抽象放进代码，细节放进元数据</strong></li>\n</ul>\n</li>\n<li>时间耦合：考虑并发和事件的发生顺序<ul>\n<li>在异步代码中，总考虑并发</li>\n</ul>\n</li>\n<li>一些GUI的设计模式<ul>\n<li>发布订阅</li>\n<li>MVC</li>\n</ul>\n</li>\n<li><strong>基于规则&#x2F;规则集的黑板系统</strong><ul>\n<li>黑板给出统一接口</li>\n<li>耦合方通过调用黑板接口避免耦合</li>\n<li>黑板通过规则给出输出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"编码时\"><a href=\"#编码时\" class=\"headerlink\" title=\"编码时\"></a>编码时</h2><ul>\n<li><strong>不要靠巧合编程</strong><ul>\n<li>改动要有文档沉淀</li>\n<li>只依靠文档中记录的行为</li>\n<li>把你的假设记入文档</li>\n</ul>\n</li>\n<li><strong>在大数据量时</strong>，考虑算法数量级<ul>\n<li>兼顾效率和可读性</li>\n</ul>\n</li>\n<li><strong>早重构，常重构</strong>，代码是业务设计的近似同构体，常重构才能保证代码完美贴合需求设计<ul>\n<li>重构和功能开发分开进行</li>\n<li>重构一定要有测试</li>\n</ul>\n</li>\n<li>优秀的代码不是看新增了多少行，而是看删除了多少行</li>\n<li>编写易于测试的代码<ul>\n<li>测试你的软件，否则你的用户会代你做测试</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"项目开始前\"><a href=\"#项目开始前\" class=\"headerlink\" title=\"项目开始前\"></a>项目开始前</h2><blockquote>\n<p>完美，不是在没有什么需要增加，而是在没有什么需要去掉的时候达到的。</p>\n</blockquote>\n<ul>\n<li>去挖掘需求，思考用户做特定事情的原因，和如何去做的方式，<strong>让需求成为一种一般性的陈述</strong><ul>\n<li><strong>制作需求文档时的一大危险是太过具体，好的需求文档会保持抽象</strong></li>\n<li>经常性复盘</li>\n<li>鼓励文档分享和交流</li>\n</ul>\n</li>\n<li><strong>巧妙解决看似不能解决的难题</strong>，关键要找到<strong>真正的约束</strong>，去思考<ul>\n<li>有更容易的方法么</li>\n<li>你是在解决真正的问题，还是被外围的技术问题转移了注意力</li>\n<li>这件事为什么是一个问题</li>\n<li>是什么让它难以解决</li>\n<li>它必须这么做么</li>\n<li>它必须完成么</li>\n</ul>\n</li>\n<li><strong>准备好再开始，但不要让它成为你懈怠的借口</strong></li>\n<li><strong>不要成为方法学的奴隶</strong></li>\n</ul>\n<h2 id=\"实效项目\"><a href=\"#实效项目\" class=\"headerlink\" title=\"实效项目\"></a>实效项目</h2><ul>\n<li>团队建设<ul>\n<li>不留破窗户（考验leader的管理能力）</li>\n<li>经常性的复盘和例会</li>\n<li>减少团队成员分工的冗余</li>\n<li>自动化项目流程 &#x3D;&gt; 效率工程团队开发内部工具</li>\n<li>制造context，给成员足够空间</li>\n</ul>\n</li>\n<li><strong>不要使用手动流程</strong>，它不可控且难以复制<ul>\n<li>shell、crontab</li>\n<li>CI和自动化持续集成</li>\n<li>代码生成</li>\n<li>自动化测试</li>\n<li>代码review和源码版本控制流程</li>\n</ul>\n</li>\n<li><strong>常测试，早测试，自动化测试</strong><ul>\n<li>单元测试&#x2F;集成测试&#x2F;压力测试&#x2F;回归测试</li>\n<li><strong>测试状态覆盖，而不是代码覆盖</strong>，代码覆盖率提供的意义有限</li>\n</ul>\n</li>\n<li>关于如何生产文本<ul>\n<li>所有文档都是代码的反映</li>\n<li>源码注释应该去把项目里那些难以描述、容易忘记、不能记录在其他地方的东西记载下来</li>\n<li>比无意义的名称更糟糕的是<strong>有误导性</strong>的名称</li>\n<li>除非有程序或人工维护，否则任何形式的文档都只是<strong>快照</strong></li>\n</ul>\n</li>\n<li><strong>温和地超出用户期望</strong>，如<ul>\n<li>友好的新手指引</li>\n<li>快捷键</li>\n<li>自动化安装</li>\n</ul>\n</li>\n<li><strong>自豪地为你的作品签名</strong></li>\n</ul>\n<h2 id=\"更多资源\"><a href=\"#更多资源\" class=\"headerlink\" title=\"更多资源\"></a>更多资源</h2><ul>\n<li>《人月神话》</li>\n<li>《Unix编程艺术》</li>\n<li>《Effective C++》</li>\n<li>《集市与大教堂》</li>\n</ul>\n<p><em>–END–</em></p>\n",
            "tags": [
                "重构",
                "程序设计",
                "实效",
                "测试"
            ]
        }
    ]
}
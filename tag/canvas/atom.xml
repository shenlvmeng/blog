<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;canvas&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2018-06-26T13:09:27.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="2018" />
    <category term="2019" />
    <category term="flag" />
    <category term="2020" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="绘图" />
    <category term="动画" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="DOM" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="架构" />
    <category term="组件" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="形式系统" />
    <category term="不完全性" />
    <category term="隐喻" />
    <category term="哥德尔" />
    <category term="巴赫" />
    <category term="埃舍尔" />
    <category term="济州" />
    <category term="西归浦" />
    <category term="城山" />
    <category term="咸德" />
    <category term="人工智能" />
    <category term="心智" />
    <category term="自指" />
    <category term="图灵" />
    <category term="马列主义" />
    <category term="恩格斯" />
    <category term="家庭" />
    <category term="国家" />
    <category term="阶级" />
    <category term="氏族" />
    <category term="哲学史" />
    <category term="孔子" />
    <category term="老子" />
    <category term="儒家" />
    <category term="道家" />
    <category term="佛教" />
    <category term="禅宗" />
    <category term="理学" />
    <category term="心学" />
    <category term="计算机" />
    <category term="微机原理" />
    <category term="门" />
    <category term="操作系统" />
    <category term="数字电路" />
    <category term="2024" />
    <category term="政府" />
    <category term="经济" />
    <category term="消费" />
    <category term="土地金融" />
    <category term="饮食" />
    <category term="蛋白质" />
    <category term="碳水" />
    <category term="慢性病" />
    <category term="三高" />
    <category term="肿瘤" />
    <category term="启蒙" />
    <category term="社会主义" />
    <category term="当代史" />
    <category term="共产党" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2018/06/26/canvas-flowchart-compare/</id>
        <title>流程图JS实现方案对比</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2018/06/26/canvas-flowchart-compare/"/>
        <content type="html">&lt;p&gt;实现流程图和类流程图的工具主要需要解决&lt;strong&gt;数据 -&amp;gt; 图形&lt;/strong&gt;和&lt;strong&gt;交互&lt;/strong&gt;两方面问题。在实现图形元素时也有canvas，SVG，canvas with DOM，SVG with DOM，DOM with canvas一些实现方式。&lt;/p&gt;
&lt;p&gt;canvas和SVG的实现方式区别比较明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大规模元素、频繁重绘上，canvas完胜&lt;/li&gt;
&lt;li&gt;强调光影效果上，canvas小胜&lt;/li&gt;
&lt;li&gt;强调导出图片上，canvas小胜&lt;/li&gt;
&lt;li&gt;强调元素可交互上，SVG完胜&lt;/li&gt;
&lt;li&gt;强调画图元素可缩放上，SVG完胜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用SVG实现时，元素规模大以及频繁重绘时会出现卡顿现象，在大规模元素场景下交互也会有卡顿。使用canvas实现时，保证流程图元素的可交互性将成为头疼的难题，开发者需要自己模拟浏览器的一部分行为。&lt;/p&gt;
&lt;p&gt;下面是一些流程图实现基础的对比。&lt;/p&gt;
&lt;h2 id=&#34;d3&#34;&gt;&lt;a href=&#34;#d3&#34; class=&#34;headerlink&#34; title=&#34;d3&#34;&gt;&lt;/a&gt;d3&lt;/h2&gt;&lt;p&gt;d3着眼在数据可视化，重点在使用不同layout组织数据，完成可视化。&lt;/p&gt;
&lt;p&gt;d3最初是天然支持SVG的，这点从类jQuery的API也能看出来。d3和canvas的结合上，绘制需要&lt;a href=&#34;https://bl.ocks.org/mbostock/1276463&#34;&gt;额外的data binding&lt;/a&gt;操作，周期性地将虚拟的DOM节点映射到canvas上，重绘得到下一帧画面。要实现canvas可交互的话也需要一些&lt;a href=&#34;https://medium.freecodecamp.org/d3-and-canvas-in-3-steps-8505c8b27444&#34;&gt;hack的手段&lt;/a&gt;。基于d3实现流程图并不划算。&lt;/p&gt;
&lt;h2 id=&#34;zrender&#34;&gt;&lt;a href=&#34;#zrender&#34; class=&#34;headerlink&#34; title=&#34;zrender&#34;&gt;&lt;/a&gt;zrender&lt;/h2&gt;&lt;p&gt;zrender是一个canvas画图的基础库。它并不负责数据的组织和渲染，需要自己完成这一部分工作。但是zrender提供了让canvas可交互的重要功能。&lt;/p&gt;
&lt;p&gt;zrender下，mixin了Eventful特性的元素上可以监听交互事件。Eventful只是为元素提供了类似EventEmitter的功能。真正实现元素可交互的handler。&lt;/p&gt;
&lt;p&gt;handler内会拦截发生在canvas内的&lt;code&gt;click&lt;/code&gt;&amp;#x2F;&lt;code&gt;mousedown&lt;/code&gt;&amp;#x2F;&lt;code&gt;mouseup&lt;/code&gt;&amp;#x2F;&lt;code&gt;mousewheel&lt;/code&gt;&amp;#x2F;&lt;code&gt;dblclick&lt;/code&gt;&amp;#x2F;&lt;code&gt;contextmenu&lt;/code&gt;事件，交予prototype内对应的处理方法处理，handler内有下面几个关键方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mousemove&lt;/code&gt;，监听canvas内mousemove事件，调用&lt;code&gt;findHover&lt;/code&gt;得到当前位置对应的元素，根据情况调用&lt;code&gt;dispatchToElement&lt;/code&gt;方法，分发&lt;code&gt;mouseout&lt;/code&gt;，&lt;code&gt;mouseover&lt;/code&gt;，&lt;code&gt;mousemove&lt;/code&gt;给刚才得到的元素实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatchToElement&lt;/code&gt;，分发事件到对应实例，将事件对象封装，trigger实例的对应事件handler，并通过&lt;code&gt;el.parent&lt;/code&gt;向上冒泡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findHover&lt;/code&gt;，指定x, y坐标寻找该坐标位置的元素。从storage中拿到所有的displayable的list。挨个调用&lt;code&gt;isHover&lt;/code&gt;判断displayable和[x, y]坐标的关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isHover&lt;/code&gt;函数，根据displayable的rectHover属性，即是否使用包围盒检测鼠标进入。调用displayable的&lt;code&gt;rectContain&lt;/code&gt;或&lt;code&gt;contain&lt;/code&gt;检测是否在其中。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;isHover&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;displayable, x, y&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (displayable[displayable.&lt;span class=&#34;property&#34;&gt;rectHover&lt;/span&gt; ? &lt;span class=&#34;string&#34;&gt;&amp;#x27;rectContain&amp;#x27;&lt;/span&gt; : &lt;span class=&#34;string&#34;&gt;&amp;#x27;contain&amp;#x27;&lt;/span&gt;](x, y)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; el = displayable;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; isSilent;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (el) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// If clipped by ancestor.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// &lt;span class=&#34;doctag&#34;&gt;FIXME:&lt;/span&gt; If clipPath has neither stroke nor fill,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// el.clipPath.contain(x, y) will always return false.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (el.&lt;span class=&#34;property&#34;&gt;clipPath&lt;/span&gt; &amp;amp;&amp;amp; !el.&lt;span class=&#34;property&#34;&gt;clipPath&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;contain&lt;/span&gt;(x, y))  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (el.&lt;span class=&#34;property&#34;&gt;silent&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                isSilent = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            el = el.&lt;span class=&#34;property&#34;&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; isSilent ? &lt;span class=&#34;variable constant_&#34;&gt;SILENT&lt;/span&gt; : &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;先简单看下storage，因为zrender里绘制的元素之间没有逻辑关联，因此需要有一个全局存储storage去统一管理加入的Group或Shape。storage的&lt;code&gt;getDisplayList&lt;/code&gt;方法返回所有图形的绘制队列。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;getDisplayList&lt;/span&gt;: &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;update, includeIgnore&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    includeIgnore = includeIgnore || &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (update) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;updateDisplayList&lt;/span&gt;(includeIgnore);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_displayList&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;注：方法中提到的&lt;code&gt;updateDisplayList&lt;/code&gt;用于更新图形的绘制队列，在每次绘制前调用，它会深度优先遍历整个树，更新所有的变换后，根据优先级排序得到新的绘制队列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在displayable的基类中，&lt;code&gt;contain&lt;/code&gt;方法只是单纯调用了&lt;code&gt;rectContain&lt;/code&gt;（子类都有区别于&lt;code&gt;rectContain&lt;/code&gt;的自己的实现）。在&lt;code&gt;rectContain&lt;/code&gt;中，获取到坐标相对于图形的坐标（&lt;code&gt;transformCoordToLocal&lt;/code&gt;）和图形的包围盒（&lt;code&gt;getBoundingRect&lt;/code&gt;）。这里先说简单的&lt;code&gt;RectContain&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;rectContain&lt;/span&gt;: &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;x, y&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; coord = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;transformCoordToLocal&lt;/span&gt;(x, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; rect = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getBoundingRect&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; rect.&lt;span class=&#34;title function_&#34;&gt;contain&lt;/span&gt;(coord[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;], coord[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其中&lt;code&gt;getBoundingRect&lt;/code&gt;是各自类自己实现的。除了个别情况，如Text，形状都基于Path类。在Path的&lt;code&gt;getBoundingRect&lt;/code&gt;中可以看到，path的绘制又额外包装了一层&lt;code&gt;PathProxy&lt;/code&gt;，&lt;code&gt;getBoundingRect&lt;/code&gt;也是使用的&lt;code&gt;PathProxy&lt;/code&gt;的方法。在实现上，PathProxy把绘制路径的操作命令拆分成了命令数组。通过记录每一段子路径上x、y的最大最小值，再将所有这些极值比较得到最后的最值。在PathProxy返回结果后，根据描边粗细得到最终结果。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;getBoundingRect&lt;/span&gt;: &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// _rect变量做缓存用，计算完成后只在重绘时置空，避免重复计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; rect = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_rect&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; style = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;style&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; needsUpdateRect = !rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (needsUpdateRect) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; path = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;path&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!path) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// Create path on demand.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            path = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;path&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;PathProxy&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;__dirtyPath&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            path.&lt;span class=&#34;title function_&#34;&gt;beginPath&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;buildPath&lt;/span&gt;(path, &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;shape&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        rect = path.&lt;span class=&#34;title function_&#34;&gt;getBoundingRect&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_rect&lt;/span&gt; = rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (style.&lt;span class=&#34;title function_&#34;&gt;hasStroke&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// Return rect with stroke&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; rectWithStroke;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;Displayable&lt;/code&gt;继承自&lt;code&gt;Element&lt;/code&gt;，&lt;code&gt;Element&lt;/code&gt;通过mixin得到来自&lt;code&gt;Transformable&lt;/code&gt;中的&lt;code&gt;transformCoordToLocal&lt;/code&gt;方法。这里要说到，zrender中元素和Group都有一个构造时的初始位置，而后的所有变化都是作为transform叠加在元素上的。例如拖拽元素对应的是“原始位置 + transform”而不是一个“新位置”。&lt;/p&gt;
&lt;p&gt;在每次变换后，&lt;code&gt;Transformable&lt;/code&gt;中的&lt;code&gt;updateTransform&lt;/code&gt;方法都会调用，设置自身&lt;code&gt;invTransform&lt;/code&gt;属性为这次变化的逆矩阵。在&lt;code&gt;transformCoordToLocal&lt;/code&gt;中对向量[x, y]应用这个逆矩阵即可得到点相对于当前形状的位置（可以理解成将点逆变换到形状变换前的位置）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;transformableProto.&lt;span class=&#34;property&#34;&gt;updateTransform&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    m = m || matrix.&lt;span class=&#34;title function_&#34;&gt;create&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 保存这个变换矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;transform&lt;/span&gt; = m;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;invTransform&lt;/span&gt; = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;invTransform&lt;/span&gt; || matrix.&lt;span class=&#34;title function_&#34;&gt;create&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    matrix.&lt;span class=&#34;title function_&#34;&gt;invert&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;invTransform&lt;/span&gt;, m);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;transformableProto.&lt;span class=&#34;property&#34;&gt;transformCoordToLocal&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;x, y&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; v2 = [x, y];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; invTransform = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;invTransform&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (invTransform) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        vector.&lt;span class=&#34;title function_&#34;&gt;applyTransform&lt;/span&gt;(v2, v2, invTransform);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;综合这两个方法即可判断点是否在某元素的包围盒中。&lt;/p&gt;
&lt;p&gt;判断&lt;code&gt;contain&lt;/code&gt;时，首先需要满足&lt;code&gt;rectContain&lt;/code&gt;的关系。之后根据描边和填充情况，执行&lt;code&gt;contain/path&lt;/code&gt;下对应的&lt;code&gt;contain&lt;/code&gt;或&lt;code&gt;containStroke&lt;/code&gt;方法。前者实际上是后者stroke为0时的特殊情况。除了path外，可以判断点是否在元素图形内的所有元素在&lt;code&gt;contain&lt;/code&gt;下都有对应文件。基本所有的包含都可以转化为指定闭合路径是否包含指定点的问题。&lt;/p&gt;
&lt;p&gt;zrender利用&lt;a href=&#34;https://en.wikipedia.org/wiki/Point_in_polygon&#34;&gt;PIP&lt;/a&gt;（point-in-polygon）问题&lt;a href=&#34;https://www.quora.com/How-do-I-know-a-point-is-inside-a-closed-curve-or-not#&#34;&gt;winding number&lt;/a&gt;的解法判断点是否在path中；canvas提供的API中也有&lt;code&gt;isPointInPath&lt;/code&gt;和&lt;code&gt;isPointInStroke&lt;/code&gt;，不过只能针对当前的path。&lt;/p&gt;
&lt;p&gt;综上，zrender可以实现canvas内的元素和交互。&lt;/p&gt;
&lt;h2 id=&#34;g6&#34;&gt;&lt;a href=&#34;#g6&#34; class=&#34;headerlink&#34; title=&#34;g6&#34;&gt;&lt;/a&gt;g6&lt;/h2&gt;&lt;p&gt;g6是antv的一部分，是一个canvas实现的展示关系型数据的JS可视化库。使用canvas的原因应该也在展示大量数据和重绘上更流畅。&lt;/p&gt;
&lt;p&gt;使用canvas实现时，g6一样会遇到zrender遇到的实现元素可交互的难题。从处理event的event.js中能看到，关联事件和元素的实现在&lt;code&gt;_getEventObj&lt;/code&gt;处完成，剩下的步骤只是额外的封装操作：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Util&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;each&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;MouseEventTypes&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;params&#34;&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    _events.&lt;span class=&#34;title function_&#34;&gt;push&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Util&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(el, item, &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;params&#34;&gt;ev&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; oldEventObj = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_currentEventObj&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_oldEventObj&lt;/span&gt; = oldEventObj;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;_processEventObj&lt;/span&gt;(ev);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; currentEventObj = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;_currentEventObj&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;_processEventObj&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;ev&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; graph = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;graph&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; canvas = graph.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;_canvas&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; frontCanvas = graph.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;_frontCanvas&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; evObj = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;_getEventObj&lt;/span&gt;(ev, canvas);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; frontEvObj = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;_getEventObj&lt;/span&gt;(ev, frontCanvas);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;_getEventObj&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;ev, canvas&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; graph = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;graph&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; clientX = ev.&lt;span class=&#34;property&#34;&gt;clientX&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; clientY = ev.&lt;span class=&#34;property&#34;&gt;clientY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; canvasPoint = canvas.&lt;span class=&#34;title function_&#34;&gt;getPointByClient&lt;/span&gt;(clientX, clientY);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; point = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;_parsePoint&lt;/span&gt;(canvasPoint.&lt;span class=&#34;property&#34;&gt;x&lt;/span&gt;, canvasPoint.&lt;span class=&#34;property&#34;&gt;y&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 根据pixel ratio做一个转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; shape = canvas.&lt;span class=&#34;title function_&#34;&gt;getShape&lt;/span&gt;(canvasPoint.&lt;span class=&#34;property&#34;&gt;x&lt;/span&gt;, canvasPoint.&lt;span class=&#34;property&#34;&gt;y&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; item = graph.&lt;span class=&#34;title function_&#34;&gt;getItemByShape&lt;/span&gt;(shape);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;p.s. 另说一点，frontCanvas的作用是绘制拖拽状态中的元素和辅助线等信息。&lt;/p&gt;
&lt;p&gt;最关键的方法&lt;code&gt;getPointByClient&lt;/code&gt;和&lt;code&gt;getShape&lt;/code&gt;来自Graph的&lt;code&gt;canvas&lt;/code&gt;属性，这个属性通过‘@antv&amp;#x2F;g’（G2）的canvas构造得来。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; G = &lt;span class=&#34;built_in&#34;&gt;require&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;@antv/g&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Canvas&lt;/span&gt; = G.&lt;span class=&#34;property&#34;&gt;Canvas&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在G2中，Canvas继承自Group，可以认为Canvas本身已经扮演了根节点的角色。Canvas判断坐标对应元素的方法&lt;code&gt;getShape(x,y)&lt;/code&gt;也来自Group。此方法遍历Group下所有元素（包括单个元素或Group），判断点[x, y]是否在范围内：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;find&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;children, x, y&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; i = children.&lt;span class=&#34;property&#34;&gt;length&lt;/span&gt; - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; child = children[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (child.&lt;span class=&#34;property&#34;&gt;__cfg&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;visible&lt;/span&gt; &amp;amp;&amp;amp; child.&lt;span class=&#34;property&#34;&gt;__cfg&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;capture&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 是Group就继续向下寻找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (child.&lt;span class=&#34;property&#34;&gt;isGroup&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        rst = child.&lt;span class=&#34;title function_&#34;&gt;getShape&lt;/span&gt;(x, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (child.&lt;span class=&#34;title function_&#34;&gt;isHit&lt;/span&gt;(x, y)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        rst = child;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (rst) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;关键的&lt;code&gt;child.isHit&lt;/code&gt;方法类似zrender里的&lt;code&gt;contain&lt;/code&gt;方法。区别使用包围盒还是自身范围判断。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;isHit&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;x, y&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; self = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; v = [ x, y, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; ];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    self.&lt;span class=&#34;title function_&#34;&gt;invert&lt;/span&gt;(v); &lt;span class=&#34;comment&#34;&gt;// canvas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (self.&lt;span class=&#34;title function_&#34;&gt;isHitBox&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; box = self.&lt;span class=&#34;title function_&#34;&gt;getBBox&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (box &amp;amp;&amp;amp; !&lt;span class=&#34;title class_&#34;&gt;Inside&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;box&lt;/span&gt;(box.&lt;span class=&#34;property&#34;&gt;minX&lt;/span&gt;, box.&lt;span class=&#34;property&#34;&gt;maxX&lt;/span&gt;, box.&lt;span class=&#34;property&#34;&gt;minY&lt;/span&gt;, box.&lt;span class=&#34;property&#34;&gt;maxY&lt;/span&gt;, v[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;], v[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; clip = self.&lt;span class=&#34;property&#34;&gt;__attrs&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;clip&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (clip) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (clip.&lt;span class=&#34;title function_&#34;&gt;inside&lt;/span&gt;(x, y)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; self.&lt;span class=&#34;title function_&#34;&gt;isPointInPath&lt;/span&gt;(v[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;], v[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; self.&lt;span class=&#34;title function_&#34;&gt;isPointInPath&lt;/span&gt;(v[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;], v[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;使用包围盒时用&lt;code&gt;getBBox()&lt;/code&gt;判断，类似zrender；否则使用&lt;code&gt;isPointInPath&lt;/code&gt;。这点上g2不同，它只对特殊的闭合曲线如圆、矩形、贝塞尔曲线等等进行自己的实现。对一般性的path，直接使用上面提到的canvas的API来判断。&lt;/p&gt;
&lt;h2 id=&#34;processOn&#34;&gt;&lt;a href=&#34;#processOn&#34; class=&#34;headerlink&#34; title=&#34;processOn&#34;&gt;&lt;/a&gt;processOn&lt;/h2&gt;&lt;p&gt;processOn严格意义上是一个产品，类似于在线的visio，编辑很流畅。使用DOM + canvas实现。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM绘制每个元素占位，响应交互&lt;/li&gt;
&lt;li&gt;canvas绘制每个DOM内的图形本身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这么做的好处在有二：1. 天然解决了元素交互的问题；2. 更平滑的元素拖拽效果。&lt;/p&gt;
&lt;p&gt;类似的还有jsPlumb这样的使用SVG的方案，使用SVG的优势体现在交互更容易实现。&lt;/p&gt;
</content>
        <category term="canvas" />
        <category term="流程图" />
        <category term="d3" />
        <category term="g6" />
        <category term="zrender" />
        <category term="processOn" />
        <updated>2018-06-26T13:09:27.000Z</updated>
    </entry>
    <entry>
        <id>http://shenlvmeng.github.com/blog/2018/05/14/canvas-introduction/</id>
        <title>canvas相关介绍</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2018/05/14/canvas-introduction/"/>
        <content type="html">&lt;p&gt;canvas由Apple首先提出，现在已经有非常好的浏览器支持度。它和&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签很像，但是只有&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;两个属性，在未设置时，为300px和150px。canvas类似&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;可以设置替换内容，应对标签本身不被支持的情况。另外，canvas不同于&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;，它必须要有一个&lt;code&gt;&amp;lt;/canvas&amp;gt;&lt;/code&gt;作为闭合标志。&lt;/p&gt;
&lt;p&gt;canvas是一个2D渲染上下文环境（就像webGL是3D渲染上下文环境），在获取到&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;元素后，可以通过其&lt;code&gt;getContext&lt;/code&gt;方法得到渲染上下文和相关功能，通常传入&lt;code&gt;2d&lt;/code&gt;，用来绘制2D图案。&lt;/p&gt;
&lt;h2 id=&#34;形状&#34;&gt;&lt;a href=&#34;#形状&#34; class=&#34;headerlink&#34; title=&#34;形状&#34;&gt;&lt;/a&gt;形状&lt;/h2&gt;&lt;p&gt;&lt;code&gt;canvas.getContext(&amp;#39;2d&amp;#39;)&lt;/code&gt;得到一个CanvasRenderingContext2D对象。剩下的绘制操作都通过调用对象上的API实现。&lt;/p&gt;
&lt;p&gt;canvas的坐标系系统和svg一样，从左上角开始，向右和向下为正，坐标轴单位为像素。下面列出最常见的绘制图形API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fillRect(x, y, width, height)&lt;/code&gt; 绘制矩形&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strokeRect(x, y, width, height)&lt;/code&gt; 绘制矩形边框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clearRect(x, y, width, height)&lt;/code&gt; 擦除矩形范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;path被用来绘制通用曲线，注意&lt;strong&gt;path都是封闭的&lt;/strong&gt;。绘制路径有4步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;beginPath()&lt;/code&gt; 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。&lt;/li&gt;
&lt;li&gt;使用画图命令去画出路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;closePath()&lt;/code&gt; 闭合路径&lt;/li&gt;
&lt;li&gt;&lt;em&gt;可选&lt;/em&gt; &lt;code&gt;fill()&lt;/code&gt; 通过填充路径的内容区域生成实心的图形，使用&lt;code&gt;fill()&lt;/code&gt;时可以不手动闭合路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stroke()&lt;/code&gt;，为路径添加描边&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 样例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;beginPath&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;moveTo&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;75&lt;/span&gt;,&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;lineTo&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;,&lt;span class=&#34;number&#34;&gt;75&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;lineTo&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;,&lt;span class=&#34;number&#34;&gt;25&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;fill&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;tip&#34;&gt;所有的路径通过`stroke()`和`fill()`才能体现效果。&lt;/div&gt;

&lt;p&gt;里面包含了常见的&lt;code&gt;moveTo&lt;/code&gt;和&lt;code&gt;lineTo&lt;/code&gt;，表示移动画笔&amp;#x2F;画直线到(x,y)处。画曲线时可以选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arc(x, y, radius, startAngle, endAngle, anticlockwise)&lt;/code&gt;&lt;br&gt;画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arcTo(x1, y1, x2, y2, radius)&lt;/code&gt; 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quadraticCurveTo(cp1x, cp1y, x, y)&lt;/code&gt; 绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)&lt;/code&gt; 绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;path2D&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;new path2D()&lt;/code&gt;用path2D声明子路径，允许你保留和重用路径对象。除了CanvasRenderingContext2D对象的API外，还可以用&lt;code&gt;addPath&lt;/code&gt;新增路径到path2D对象中，它还支持通过SVG格式的字符串导入为路径。&lt;/p&gt;
&lt;h2 id=&#34;样式&#34;&gt;&lt;a href=&#34;#样式&#34; class=&#34;headerlink&#34; title=&#34;样式&#34;&gt;&lt;/a&gt;样式&lt;/h2&gt;&lt;p&gt;通过修改&lt;code&gt;fillStyle&lt;/code&gt;和&lt;code&gt;strokeStyle&lt;/code&gt;改变当前填充和描边的默认颜色。支持的颜色格式有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;颜色名&lt;/li&gt;
&lt;li&gt;hex&lt;/li&gt;
&lt;li&gt;rgb&lt;/li&gt;
&lt;li&gt;rgba&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过&lt;code&gt;globalAlpha&lt;/code&gt;修改画布里的所有图形的透明度，取值在0到1之间。&lt;/p&gt;
&lt;p&gt;线型样式选择有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lineWidth &amp;#x3D; value 设置线条宽度。&lt;/li&gt;
&lt;li&gt;lineCap &amp;#x3D; type 设置线条末端样式。默认为butt，还有round、square可选。&lt;/li&gt;
&lt;li&gt;lineJoin &amp;#x3D; type 设定线条与线条间接合处的样式。round, bevel 和 miter三种可选，miter时，miterLimit可以限制尖角的高度。&lt;/li&gt;
&lt;li&gt;miterLimit &amp;#x3D; value 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置虚线时，&lt;code&gt;setLineDash(segments)&lt;/code&gt;设置当前虚线样式。&lt;code&gt;lineDashOffset = value&lt;/code&gt;设置虚线样式的起始偏移量。&lt;code&gt;getLineDash()&lt;/code&gt;返回一个包含当前虚线样式，长度为非负偶数的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;渐变需要先指定类型和覆盖范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;createLinearGradient(x1, y1, x2, y2)&lt;/code&gt; 方法接受4个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createRadialGradient(x1, y1, r1, x2, y2, r2)&lt;/code&gt; 方法接受6个参数，前三个定义一个以 (x1,y1) 为原点，半径为r1的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为r2的圆。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建的渐变通过&lt;code&gt;addColorStop(position, color)&lt;/code&gt;添加多个color stop。position参数是一个0.0与1.0之间的数值，表示渐变中颜色所在的相对位置。&lt;strong&gt;渐变是一种样式，通过指定给fillStyle或是strokeStyle发挥作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;createPattern(image, type)&lt;/code&gt;创建pattern，Image可以是一个Image对象的引用，或者另一个canvas对象。Type描述重复的格式，是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。&lt;/p&gt;
&lt;p&gt;同样，通过指定给&lt;code&gt;fillStyle&lt;/code&gt;和&lt;code&gt;strokeStyle&lt;/code&gt;使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阴影&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shadowOffsetX &amp;#x3D; float&lt;/li&gt;
&lt;li&gt;shadowOffsetY &amp;#x3D; float&lt;br&gt;shadowOffsetX和shadowOffsetY用来设定阴影在X和Y轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为0。&lt;/li&gt;
&lt;li&gt;shadowBlur &amp;#x3D; float shadowBlur 用于设定阴影的模糊程度，默认为 0。&lt;/li&gt;
&lt;li&gt;shadowColor &amp;#x3D; color，默认为黑色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;canvas有两种填充规则&lt;a href=&#34;https://en.wikipedia.org/wiki/Nonzero-rule&#34;&gt;&lt;code&gt;non-zero&lt;/code&gt;&lt;/a&gt;和&lt;code&gt;even-odd&lt;/code&gt;，默认为前者。&lt;/p&gt;
&lt;h2 id=&#34;文字&#34;&gt;&lt;a href=&#34;#文字&#34; class=&#34;headerlink&#34; title=&#34;文字&#34;&gt;&lt;/a&gt;文字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fillText(text, x, y [, maxWidth])&lt;/code&gt; 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strokeText(text, x, y [, maxWidth])&lt;/code&gt; 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;property&#34;&gt;font&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&amp;quot;48px PingFangSC&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ctx.&lt;span class=&#34;title function_&#34;&gt;strokeText&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello world&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;除了&lt;code&gt;font&lt;/code&gt;（语法和CSS的font相同）外，还有下面的选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;textAlign &amp;#x3D; value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。&lt;/li&gt;
&lt;li&gt;textBaseline &amp;#x3D; value 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。&lt;/li&gt;
&lt;li&gt;direction &amp;#x3D; value 文本方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，可以通过&lt;code&gt;measureText()&lt;/code&gt;，得到文本绘制的宽度。&lt;/p&gt;
&lt;h2 id=&#34;使用图片&#34;&gt;&lt;a href=&#34;#使用图片&#34; class=&#34;headerlink&#34; title=&#34;使用图片&#34;&gt;&lt;/a&gt;使用图片&lt;/h2&gt;&lt;p&gt;canvas里可以引入Image对象或其他canvas元素，或者通过URL方式使用图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用相同页面内的图片，使用正常地获取元素的方式获取即可&lt;/li&gt;
&lt;li&gt;使用其它域名下的图片，在HTMLImageElement上使用&lt;code&gt;crossOrigin&lt;/code&gt;属性，可以请求加载其它域名上的图片。若服务器不允许跨域加载，则会污染canvas，即不能导出数据&lt;/li&gt;
&lt;li&gt;使用canvas，按获取元素的方式获取即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;image可以指定&lt;code&gt;src&lt;/code&gt;属性为URL或&lt;code&gt;data:url&lt;/code&gt;的形式。甚至引入&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;使用视频帧作为image。绘制图片时，使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;drawImage(image, x, y)&lt;/code&gt; 其中image是image或者canvas对象，x和y是其在目标canvas里的起始坐标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)&lt;/code&gt;是包含了缩放和切片后完整的&lt;code&gt;drawImage&lt;/code&gt;用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变形和裁剪&#34;&gt;&lt;a href=&#34;#变形和裁剪&#34; class=&#34;headerlink&#34; title=&#34;变形和裁剪&#34;&gt;&lt;/a&gt;变形和裁剪&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;save&lt;/strong&gt;和&lt;strong&gt;restore&lt;/strong&gt;用来保存和恢复canvas状态。每当&lt;code&gt;save()&lt;/code&gt;方法被调用后，当前的状态就被推送到栈中保存。状态包括所有变形、样式信息。每次&lt;code&gt;restore&lt;/code&gt;时会弹出栈顶的状态。&lt;strong&gt;建议在做变形和裁剪前保存状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;变形用到的属性和CSS很像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;translate(x,y)&lt;/code&gt;改变当前原点位置，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rotate(angle)&lt;/code&gt;以当前原点为圆心旋转画布，angle为弧度值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale(x, y)&lt;/code&gt;缩放当前canvas中的图形大小，x和y分别表示两轴上的缩放因子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transform(m11, m12, m21, m22, dx, dy)&lt;/code&gt;通过变形矩阵进行变换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTransform(m11, m12, m21, m22, dx, dy)&lt;/code&gt;先还原为单位矩阵，再按入参的矩阵变换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resetTransform&lt;/code&gt;重置变形为单位矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;globalCompositeOperation&lt;/code&gt;定义了图形相互重叠时的处理策略，类似PS中图层的混合模式，默认为&lt;code&gt;darker&lt;/code&gt;，还有很多&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation&#34;&gt;别的选项&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clip()&lt;/code&gt;即裁剪方法，和&lt;code&gt;fill&lt;/code&gt;以及&lt;code&gt;stroke&lt;/code&gt;类似，不过&lt;code&gt;clip&lt;/code&gt;将路径对应的部分裁剪出指定区域。&lt;/p&gt;
&lt;h2 id=&#34;动画&#34;&gt;&lt;a href=&#34;#动画&#34; class=&#34;headerlink&#34; title=&#34;动画&#34;&gt;&lt;/a&gt;动画&lt;/h2&gt;&lt;p&gt;canvas只是一个画布，画出的东西都会保持原样。制作动画只能采取重绘，逐帧绘制，而每一帧包括下面几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清空canvas，可以使用&lt;code&gt;clearRect&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;em&gt;可选&lt;/em&gt;，保存当前状态&lt;/li&gt;
&lt;li&gt;使用上面提过的种种方法绘制下一帧&lt;/li&gt;
&lt;li&gt;&lt;em&gt;可选&lt;/em&gt;，恢复状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绘制动画通常要结合用户交互以及&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;setInterval&lt;/code&gt;，&lt;code&gt;requestAnimationFrame&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;MDN给个一个&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations&#34;&gt;小球的组合动画&lt;/a&gt;可以参考。&lt;/p&gt;
&lt;h2 id=&#34;像素级操作&#34;&gt;&lt;a href=&#34;#像素级操作&#34; class=&#34;headerlink&#34; title=&#34;像素级操作&#34;&gt;&lt;/a&gt;像素级操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ImageData&lt;/code&gt;接口描述&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;元素的一个包含像素数据的区域。它包含&lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;单个只读属性。&lt;code&gt;ImageData&lt;/code&gt;可以通过&lt;code&gt;ctx.createImageData(width, height)&lt;/code&gt;或者从已有对象中创建，除此创建的所有像素都是透明黑。&lt;/p&gt;
&lt;p&gt;可以用&lt;code&gt;getImageData(left, top, width, height)&lt;/code&gt;方法获取指定范围的&lt;code&gt;ImageData&lt;/code&gt;信息，当&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;都为1时，取得当前像素信息。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;putImageData(imageData, dx, dy)&lt;/code&gt;可以在当前画布(dx, dy)处绘制imageData像素数据。&lt;code&gt;imageSmoothingEnabled&lt;/code&gt;默认开启，关闭后可以在图片缩放时看到清楚颗粒化的细节。&lt;/p&gt;
&lt;h2 id=&#34;导出&#34;&gt;&lt;a href=&#34;#导出&#34; class=&#34;headerlink&#34; title=&#34;导出&#34;&gt;&lt;/a&gt;导出&lt;/h2&gt;&lt;p&gt;主要有三种用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;canvas.toDataURL(&amp;#39;image/png&amp;#39;)&lt;/code&gt;，默认将canvas导出成png文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;canvas.toDataURL(&amp;#39;image/jpeg&amp;#39;, quality)&lt;/code&gt;，quality指定在0到1之间，默认为0.92。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;canvas.toBlob(callback, type, encoderOptions)&lt;/code&gt;，这个创建了一个在画布中的代表图片的Blob对像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;toDataURL&lt;/code&gt;除了上面两种导出格式还有别的选择。&lt;/p&gt;
&lt;h2 id=&#34;交互&#34;&gt;&lt;a href=&#34;#交互&#34; class=&#34;headerlink&#34; title=&#34;交互&#34;&gt;&lt;/a&gt;交互&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;标签只是一个位图，它并不提供任何已经绘制在上面的对象的信息。canvas的内容不能像语义化的HTML一样暴露给一些协助工具。一般来说，你应该避免在交互型的网站或者App上使用canvas。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addHitRegion(options)&lt;/code&gt;可以将添加一个点击区域，options可以参考&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/addHitRegion&#34;&gt;MDN文档&lt;/a&gt;，鼠标事件如果触发在点击区域中，会带上region用于定位点击区域。&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;drawFocusIfNeeded()&lt;/code&gt;和&lt;code&gt;scrollPathIntoView()&lt;/code&gt;方法还可以绘制焦点圈。&lt;/p&gt;
&lt;h2 id=&#34;性能问题&#34;&gt;&lt;a href=&#34;#性能问题&#34; class=&#34;headerlink&#34; title=&#34;性能问题&#34;&gt;&lt;/a&gt;性能问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;预渲染相似或重复对象&lt;/li&gt;
&lt;li&gt;为了避免抗锯齿带来的额外运算，减少使用浮点数&lt;/li&gt;
&lt;li&gt;在离屏canvas中缓存图片的不同尺寸，不要用&lt;code&gt;drawImage()&lt;/code&gt;去缩放它们&lt;/li&gt;
&lt;li&gt;使用多层画布去画一个复杂的场景，比如使用多层画布，描绘不同层级的内容。  &lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;div id=&lt;span class=&#34;string&#34;&gt;&amp;quot;stage&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;language-xml&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;ui-layer&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;width&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;480&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;height&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;320&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;language-xml&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;game-layer&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;width&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;480&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;height&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;320&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;language-xml&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;background-layer&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;width&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;480&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;height&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;320&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;用CSS画大的背景图&lt;/li&gt;
&lt;li&gt;用CSS transforms特性缩放画布，建议不要将小画布放大，而是去将大画布缩小&lt;/li&gt;
&lt;li&gt;尽可能避免text rendering&lt;/li&gt;
&lt;li&gt;尽可能避免 shadowBlur&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;性能优于&lt;code&gt;window.setInterval()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="canvas" />
        <category term="绘图" />
        <category term="动画" />
        <updated>2018-05-14T13:28:01.000Z</updated>
    </entry>
</feed>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"axios\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2018/04/17/some-tips/",
            "url": "http://shenlvmeng.github.com/blog/2018/04/17/some-tips/",
            "title": "工作中的遇到的一些小知识",
            "date_published": "2018-04-17T15:48:27.000Z",
            "content_html": "<p><em>持续更新…</em></p>\n<h2 id=\"免密ssh步骤\"><a href=\"#免密ssh步骤\" class=\"headerlink\" title=\"免密ssh步骤\"></a>免密ssh步骤</h2><p>一句命令代替繁琐的ssh远程登录开发机。</p>\n<h3 id=\"Step-1：免密\"><a href=\"#Step-1：免密\" class=\"headerlink\" title=\"Step 1：免密\"></a>Step 1：免密</h3><ol>\n<li>ssh-keygen生成公钥。<code>ssh-keygen</code></li>\n<li>拷贝公钥。<code>ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;your-remote-host&gt;</code></li>\n<li>免密登录。<code>ssh &lt;your-remote-host&gt;</code></li>\n</ol>\n<h3 id=\"Step-2：简化命令\"><a href=\"#Step-2：简化命令\" class=\"headerlink\" title=\"Step 2：简化命令\"></a>Step 2：简化命令</h3><p>使用<code>alias</code>，比如：<code>alias timetowork=&quot;ssh &lt;your-remote-host&gt;&quot;</code></p>\n<h3 id=\"Step-3：get-back-to-work\"><a href=\"#Step-3：get-back-to-work\" class=\"headerlink\" title=\"Step 3：get back to work\"></a>Step 3：get back to work</h3><p>输入<code>timetowork</code>。</p>\n<p>参考：</p>\n<ul>\n<li>[<a href=\"http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id]\">http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id]</a></li>\n<li>[<a href=\"http://www.linfo.org/alias.html]\">http://www.linfo.org/alias.html]</a></li>\n</ul>\n<h2 id=\"fis-receiver\"><a href=\"#fis-receiver\" class=\"headerlink\" title=\"fis-receiver\"></a>fis-receiver</h2><p>简写为<code>fisrcv</code>。使用fis进行项目构建时，若需要release到远端开发机，可以通过配置<code>fis-conf.js</code>里的<code>deploy</code>项目实现，fis会通过HTTP的方式上传压缩过的代码到远端指定位置，这需要远端有receiver接收上传的文件。</p>\n<p>fis-receiver是在远端接收上传文件的服务端脚本，node、python、PHP等都可以。<code>fisrcv</code>实际上是使用node服务在远端接收deploy文件的服务端脚本而已。</p>\n<p>参考：</p>\n<ul>\n<li>[<a href=\"https://github.com/zhoujq/fis-receiver]\">https://github.com/zhoujq/fis-receiver]</a></li>\n<li>[<a href=\"http://fis.baidu.com/fis3/docs/api/dev-plugin.html#Deploy%20%E6%8F%92%E4%BB%B6]\">http://fis.baidu.com/fis3/docs/api/dev-plugin.html#Deploy%20%E6%8F%92%E4%BB%B6]</a></li>\n</ul>\n<h2 id=\"webpack-release\"><a href=\"#webpack-release\" class=\"headerlink\" title=\"webpack-release\"></a>webpack-release</h2><p>等同于webpack版的<code>fis release</code>，不过原先写在<code>fis-conf.js</code>中的部署设置，现在写在<code>webpack.config.js</code>中。<code>receiveUrl</code>和<code>remotePath</code>即远端开发机位置。实现上也采用HTTP POST的方式。</p>\n<p>参考：</p>\n<ul>\n<li>[<a href=\"https://www.npmjs.com/package/webpack-release]\">https://www.npmjs.com/package/webpack-release]</a></li>\n<li>[<a href=\"https://github.com/markate/webpack-release/blob/master/index.js]\">https://github.com/markate/webpack-release/blob/master/index.js]</a></li>\n</ul>\n<h2 id=\"tmux\"><a href=\"#tmux\" class=\"headerlink\" title=\"tmux\"></a>tmux</h2><p>tmux是终端复用工具，允许在单个终端下相互隔离地运行多个后台程序。甚至在关闭终端时可以让程序在后台运行。使用<code>tmux attach</code>和<code>tmux detach</code>进入和离开各个session。<code>attach</code>后还可以接<code>-t</code>指定连接的session。</p>\n<p>参考：</p>\n<ul>\n<li>[<a href=\"https://github.com/tmux/tmux/wiki]\">https://github.com/tmux/tmux/wiki]</a></li>\n</ul>\n<h2 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h2><p>把html和js或css文件对应组织起来，可以指定<code>filename</code>，<code>template</code>，<code>chunks</code>等。</p>\n<p>参考：</p>\n<ul>\n<li>[<a href=\"https://github.com/jantimon/html-webpack-plugin]\">https://github.com/jantimon/html-webpack-plugin]</a></li>\n</ul>\n<h2 id=\"encodeURI和encodeURIComponent\"><a href=\"#encodeURI和encodeURIComponent\" class=\"headerlink\" title=\"encodeURI和encodeURIComponent\"></a>encodeURI和encodeURIComponent</h2><p>前者用于对整段URI转码，后者用于对URI中被分割符隔开的部分进行边编码。因此，</p>\n<ul>\n<li><code>encodeURI</code>会忽略允许出现在URI的符号，包括特殊符号。对空格、中文等进行转码</li>\n<li><code>encodeURIComponent</code>也会转码特殊符号，如&#x2F;，$，@，.等</li>\n</ul>\n<h2 id=\"origami\"><a href=\"#origami\" class=\"headerlink\" title=\"origami\"></a>origami</h2><p>origami是sublime中的一个拆分窗口的插件，用快捷键可以像在vim中一样方便地创建和转移到各个窗口编码。通过command + K开启快捷键。</p>\n<ul>\n<li>+up&#x2F;down&#x2F;left&#x2F;right 转移到其他窗口</li>\n<li>+command+up&#x2F;down&#x2F;left&#x2F;right 在该方向上打开新的工作窗口</li>\n<li>+shift+command+up&#x2F;down&#x2F;left&#x2F;right 销毁该方向上的新窗口</li>\n</ul>\n<h2 id=\"nrm与n\"><a href=\"#nrm与n\" class=\"headerlink\" title=\"nrm与n\"></a>nrm与n</h2><p>npm registry管理工具nrm，能够查看和切换当前使用的registry，在切换和查看registry时非常有用。常用命令:</p>\n<ul>\n<li><code>nrm ls</code></li>\n<li><code>nrm use</code></li>\n<li><code>nrm help</code></li>\n<li><code>nrm home</code></li>\n<li><code>nrm add/delete</code> 增加和删除registry</li>\n<li><code>nrm test</code> 测速</li>\n</ul>\n<p><a href=\"https://www.npmjs.com/package/n\">n</a>是类似nvm的node.js版本管理工具。</p>\n<h2 id=\"Promise-then的链式调用\"><a href=\"#Promise-then的链式调用\" class=\"headerlink\" title=\"Promise then的链式调用\"></a>Promise then的链式调用</h2><p><code>then()</code>方法返回一个Promise 。它最多需要有两个参数：Promise的成功和失败情况的回调函数。</p>\n<p><code>then</code>方法会返回一个Promise，它的行为与then中指定的回调函数返回值有关：</p>\n<ul>\n<li>如果then中的回调函数<strong>返回一个值</strong>，那么then返回的Promise将会成为接受状态（即使原Promise始Rejected状态），并且将返回的值作为接受状态的回调函数的参数值。</li>\n<li>如果then中的回调函数<strong>抛出一个错误</strong>，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li>\n<li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li>\n<li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li>\n<li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li>\n</ul>\n<p>下面是几个官网上的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;foo&quot;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 1. 接收 &quot;foo&quot; 并与 &quot;bar&quot; 拼接，并将其结果做为下一个resolve返回。</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        string += <span class=\"string\">&#x27;bar&#x27;</span>;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(string);</span><br><span class=\"line\">      &#125;, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 2. 接收 &quot;foobar&quot;, 放入一个异步函数中处理该字符串</span></span><br><span class=\"line\">  <span class=\"comment\">// 并将其打印到控制台中, 但是不将处理后的字符串返回到下一个。</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      string += <span class=\"string\">&#x27;baz&#x27;</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(string);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> string;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 3. 打印本节中代码将如何运行的帮助消息，</span></span><br><span class=\"line\">  <span class=\"comment\">// 字符串实际上是由上一个回调函数之前的那块异步代码处理的。</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Last Then:  oops... didn&#x27;t bother to instantiate and return &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;a promise in the prior then so the sequence may be a bit &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;surprising&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意 `string` 这时不会存在 &#x27;baz&#x27;。</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为这是发生在我们通过setTimeout模拟的异步函数中。</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(string);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>( <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使 .then() 返回一个 rejected promise</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&#x27;Oh no!&#x27;</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>( <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>( <span class=\"string\">&#x27;onRejected function called: &#x27;</span>, reason );</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>( <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&quot;I am always called even if the prior then&#x27;s promise rejects&quot;</span> );</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h2><p>程序设计领域，尤其是面向对象编程的优秀实践里，有着一些实现原则，如SOLID（单一功能、开闭原则、里氏替换、接口隔离、依赖翻转）。这些设计模式原则可以有助于编写可维护、可拓展、清晰可读的代码。</p>\n<ul>\n<li>S，Single Responsibility Principle，每个类都应有<strong>单一</strong>的功能，且被类封装起来。</li>\n<li>O，Open-Closed Principle，对象（类、接口、函数等）对于拓展是开放的，对于修改是封闭的。即易拓展、保证可靠。</li>\n<li>L，Liskov Substitution Principle，子类可以在不改变正确性的情况下替换父类</li>\n<li>I，Interface-segregation Principle，多个特定功能的接口好于单个宽泛功能的接口</li>\n<li>D，Dependency Inversion Principle，方法应该依赖于一个抽象（接口）而不是一个实例（类）</li>\n</ul>\n<h2 id=\"axios-mock-adpter\"><a href=\"#axios-mock-adpter\" class=\"headerlink\" title=\"axios-mock-adpter\"></a>axios-mock-adpter</h2><p>使用axios获取数据时，通过<code>axios-mock-adapter</code>mock数据。MockAdapter可以绑定在axios上，拦截通过绑定的axios发送的请求。使用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> axios = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;axios&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">MockAdapter</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;axios-mock-adapter&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This sets the mock adapter on the default instance</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = <span class=\"keyword\">new</span> <span class=\"title class_\">MockAdapter</span>(axios);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Mock any GET request to /users</span></span><br><span class=\"line\"><span class=\"comment\">// arguments for reply are (status, data, headers)</span></span><br><span class=\"line\">mock.<span class=\"title function_\">onGet</span>(<span class=\"string\">&#x27;/users&#x27;</span>).<span class=\"title function_\">reply</span>(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">users</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Smith&#x27;</span> &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">axios.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/users&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response.<span class=\"property\">data</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>另外，可以用<code>mock.restore()</code>撤销所有mocking行为，或通过<code>mock.reset()</code>除去所有mocking的handler。通过<code>mock.on&lt;方法名&gt;</code>还可以链式调用其他方法：</p>\n<ul>\n<li><code>onAny()</code> 绑定任何方法</li>\n<li><code>networkError()</code> 返回网络错误</li>\n<li><code>timeout()</code> 返回请求超时</li>\n<li><code>passThrough()</code> 跳过mocking直接请求</li>\n</ul>\n<p>在reply中可以使用函数进行更复杂的操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> normalAxios = axios.<span class=\"title function_\">create</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> mockAxios = axios.<span class=\"title function_\">create</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = <span class=\"title class_\">MockAdapter</span>(mockAxios);</span><br><span class=\"line\"></span><br><span class=\"line\">mock</span><br><span class=\"line\">  .<span class=\"title function_\">onGet</span>(<span class=\"string\">&#x27;/orders&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">reply</span>(<span class=\"function\">() =&gt;</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">      normalAxios</span><br><span class=\"line\">        .<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/api/v1/orders&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">resp</span> =&gt;</span> resp.<span class=\"property\">data</span>),</span><br><span class=\"line\">      normalAxios</span><br><span class=\"line\">        .<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/api/v2/orders&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">resp</span> =&gt;</span> resp.<span class=\"property\">data</span>),</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"string\">&#x27;-1&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;extra row 1&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"string\">&#x27;-2&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;extra row 2&#x27;</span> &#125;</span><br><span class=\"line\">    ]).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">      <span class=\"function\"><span class=\"params\">sources</span> =&gt;</span> [<span class=\"number\">200</span>, sources.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">agg, source</span>) =&gt;</span> agg.<span class=\"title function_\">concat</span>(source))]</span><br><span class=\"line\">    )</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"移动端Charles调试经验\"><a href=\"#移动端Charles调试经验\" class=\"headerlink\" title=\"移动端Charles调试经验\"></a>移动端Charles调试经验</h2><ol>\n<li>设置http代理为8888端口</li>\n<li>设置SSL代理，填写对应的域名，设置端口为443，安装根证书</li>\n<li>手机打开无线设置，设置代理IP和端口8888</li>\n<li>打开<a href=\"http://chls.pro/ssl\">chls.pro&#x2F;ssl</a>，安装根证书并信任</li>\n<li>使用Map remote访问开发机位置</li>\n<li>使用Map local可以劫持WebView中请求的JS等资源到本地，通过alert的方式打印调试信息，进行临时的线上Webview环境debug</li>\n</ol>\n",
            "tags": [
                "mock",
                "ssh",
                "fis-receiver",
                "tmux",
                "origami",
                "promise",
                "encodeURI",
                "encodeURIComponent",
                "axios",
                "charles"
            ]
        }
    ]
}
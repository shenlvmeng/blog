{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"闭包\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "url": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "title": "函数式编程扫盲",
            "date_published": "2017-06-20T11:45:44.000Z",
            "content_html": "<p>名谓扫盲，实则是为自己扫盲。前些日子通过Elm的学习接触到了函数式编程的概念，发现语言风格和以C为代表的命令式编程大不相同，接触不同的编程思维还是很有助于自我提升的。在回顾的同时，这里走马观花地带过一些函数式编程的“热门词汇”。</p>\n<h2 id=\"历史故事\"><a href=\"#历史故事\" class=\"headerlink\" title=\"历史故事\"></a><a href=\"http://www.defmacro.org/ramblings/fp.html\">历史故事</a></h2><p>什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？这得从20世纪30年代开始讲起：</p>\n<blockquote>\n<p>新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫<a href=\"http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87\">阿隆佐·邱奇</a>(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有<a href=\"https://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5\">艾伦·图灵</a>、<a href=\"http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC\">约翰·冯·诺伊曼</a>、<a href=\"https://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94\">库尔特·哥德尔</a>。</p>\n</blockquote>\n<p>在与这些人的合作下，阿隆佐设计了一个名为<a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">lambda演算</a>的形式系统。在这种语言里面，函数的参数是函数，返回值也是函数。篇幅和本人能力限制，不对lambda演算做更多讲解。</p>\n<p>除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。</p>\n<p>到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！而后的诸多函数式编程语言（如Haskell，ML等）也多少收到Lisp的影响。</p>\n<h2 id=\"法则\"><a href=\"#法则\" class=\"headerlink\" title=\"法则\"></a><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">法则</a></h2><p>函数式编程的思想来源Lambda演算在最初设计时就是用来解决计算相关问题，它是一种相对于“命令式编程”完全不同的编程范式，后者告诉计算机怎么做，前者着眼在从数学角度描述问题。它的特点也很明显：</p>\n<ul>\n<li><strong>变量不可变</strong>，即默认带上<code>const</code>或是<code>final</code>（当然函数式编程里压根没有<code>const</code>和<code>final</code>的概念）。这么来看，叫它为“符号”似乎更合适</li>\n<li><strong>惰性求值</strong>，变量直到使用时才会真正计算它的值，因为这个特点，Haskell甚至允许无限列表的出现。同时，这也意味着语句的出现顺序和执行顺序并不相关。</li>\n<li><strong>高阶函数</strong>，函数可以作为入参或是返回值，这个也被很多不那么OOP的语言借鉴去了</li>\n<li><strong>无副作用</strong>，<strong>函数只负责映射数据</strong>，更像是个管道，绝不改变外部状态，同样的输入在任何时候会得到同样的输出（测试人员笑开了花）。这一点使得函数式编程语言天生支持并发执行。</li>\n<li><strong>一切皆函数</strong>，函数是第一公民</li>\n</ul>\n<p>λ演算用来描述一种形式系统，它的语法只有三条：</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>术语</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a</td>\n<td>变量</td>\n<td>一个代表参数或数字&#x2F;逻辑值的符号或字符串</td>\n</tr>\n<tr>\n<td>(λx.M)</td>\n<td>定义</td>\n<td>函数定义，<code>.</code>前面的标识符<code>x</code>为入参，M为表达式</td>\n</tr>\n<tr>\n<td>(M N)</td>\n<td>调用</td>\n<td>应用函数到一个入参</td>\n</tr>\n</tbody></table>\n<p>例如：<code>((λ x y. x + y) 1 2)</code>表示1和2相加。</p>\n<p>λ演算公理只有两个：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(λx.M[x]) → (λy.M[y])</td>\n<td>α变换</td>\n<td>改变入参名不影响结果</td>\n</tr>\n<tr>\n<td>((λx.M) E) → (M[x:&#x3D;E])</td>\n<td>β规约</td>\n<td>将入参传入λ意味着对它做演算</td>\n</tr>\n</tbody></table>\n<p>还以上面的相加为例，α变换就是<code>λ x y. x + y → λ a b. a + b</code>；β规约就是<code>(λ x y. x + y) a b → a + b</code>。是不是很好理解。</p>\n<p>通过这两个基本的公理，结合基本变量类型可以构造各种函数。如not函数，and函数，or函数，甚至if函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> and =</span><br><span class=\"line\"><span class=\"title\">true</span> value  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">false</span> value -&gt;  false</span><br><span class=\"line\"><span class=\"title\">value</span> true  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">value</span> false -&gt;  false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">let</span> <span class=\"keyword\">if</span> =</span><br><span class=\"line\">λ cond tvalue fvalue. (cond and tvalue) or (not cond  and fvalue)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数意味着，我们可以把函数直接作为入参传入，或作为返回值返回。这早已不是函数式编程语言的专利，Python，JavaScript等也吸收了这个设计理念。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\">函数柯里化</a>即部分求值，就利用了高阶函数的特点提出的技术，它使得函数可以一个一个接受入参，返回相同的计算结果。类似于下面的感觉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pow</span>(<span class=\"params\">i, j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i^j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funtion <span class=\"title function_\">square</span>(<span class=\"params\">j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">pow</span>(i, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>square</code>函数返回的函数需要指定<code>i</code>才可执行。柯里的名字来自于第一次提出这个技巧的逻辑学家<a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\">Haskell Curry</a>。</p>\n<p>另外，值得注意的是，在函数式编程下，高阶函数通过将函数作为参数惰性求值实现。那命令式编程下呢，答案是<a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">闭包</a>（lexical closure）。</p>\n<h2 id=\"递归？\"><a href=\"#递归？\" class=\"headerlink\" title=\"递归？\"></a>递归？</h2><p>函数式编程里没有状态变量（可以用其他方式实现），因此自然没有循环结构。实际上，函数式编程中的循环都是通过递归实现的。比如，斐波那契数列函数像下面这样：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> fact = λ n. <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"number\">1</span> (n * fact n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>这里<code>fact</code>函数引用了自身，虽然编译器可以识别这种写法，但是显然它并不符合严格的数学公理。</p>\n<p>重新审视这个变换，我们可以通过传入自身的方式来让它“数学化”。<code>let P = λ self n. if (n == 0) 1 (n * self(self n-1))</code>，然后在令<code>let fact n = P (P n)</code>。如此这般：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact 4</span><br><span class=\"line\">-&gt; P (P 4)</span><br><span class=\"line\">-&gt; if (4 == 0) (1) (4 * P(P 3))</span><br><span class=\"line\">-&gt; 4 * P(P 3)</span><br><span class=\"line\">-&gt; 4 * 3 * P(P 2)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * P(P 1)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * 1</span><br></pre></td></tr></table></figure>\n\n<p>可是，这个函数看上去并不自然，不像一个真正的递归函数，且λ演算的公理里并没有这样一条公理可以让你在定义函数的时候引用本身。还好，已经有人做了<a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">研究</a>，借助Y组合子的帮助，可以实现真正的递归函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> <span class=\"type\">Y</span> = λ <span class=\"type\">F</span>. <span class=\"type\">G</span>(<span class=\"type\">G</span>)</span><br><span class=\"line\"><span class=\"type\">G</span> = λ self. <span class=\"type\">F</span>(self(self))</span><br></pre></td></tr></table></figure>\n\n<p>这相当于我们在λ演算公理体系中添加了一条“可以在函数调用时引用自身”。这也是证明λ演算图灵等价的关键一步。这意味着它的计算能力和计算机是一致的，能通过λ演算描述的函数一定可以由计算机计算。</p>\n<h2 id=\"Haskell\"><a href=\"#Haskell\" class=\"headerlink\" title=\"Haskell\"></a>Haskell</h2><p><a href=\"https://www.zhihu.com/question/27355585\">Haskell</a>是一个纯函数式编程语言，它得名于上面提到过的Haskell Curry。Y组合子也是他发现的。</p>\n<p>Haskell中一切都是函数，甚至没有指令式编程中变量的概念，它的变量全部都是只允许一次赋值，不可改变。</p>\n<p>Haskell还没有一般意义上的控制流结构，如for循环，取而代之的是递归。同样，Haskell还有两个重要的特性，即无副作用和惰<br>性求值。偏数学的问题，用Haskell解决通常代码量都很小。下面是一个列表去重例子</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">cut</span> cond  []  = []</span><br><span class=\"line\"><span class=\"title\">cut</span> cond  (elem:rest) = <span class=\"keyword\">if</span>  cond elem <span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"title\">cut</span> cond  rest  <span class=\"keyword\">else</span>  elem:rest</span><br><span class=\"line\"><span class=\"title\">compress</span>  []  = []</span><br><span class=\"line\"><span class=\"title\">compress</span>  (elem:rest) = elem  : compress</span><br><span class=\"line\">(cut  (== elem) rest)</span><br></pre></td></tr></table></figure>\n<p>还有一个快排（不过借助了filter函数）的例子，也是短得不行</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> (elem:rest) = (qsort lesser) ++ [elem] ++ (qsort greater)</span><br><span class=\"line\">  <span class=\"keyword\">where</span></span><br><span class=\"line\">    lesser = filter (&lt; elem) rest</span><br><span class=\"line\">    greater = filter (&gt;= elem) rest</span><br></pre></td></tr></table></figure>\n<p>Haskell中还可以定义无穷列表，如[1..]表示所有正整数。这也是惰性求值特性带来的。<code>[1,3..] !! 42</code>将会返回85。</p>\n<h2 id=\"Monad\"><a href=\"#Monad\" class=\"headerlink\" title=\"Monad\"></a>Monad</h2><blockquote>\n<p>Monad其实就是自函子范畴上的一个幺半群而已</p>\n</blockquote>\n<p>这节将展示一个图文并茂的说明但并不致力于解释清楚monad到底是个什么（因为我自己也不明白）。这篇对比<a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">functor，applicatives，monad</a>的文章写得很透彻易懂，尽管这可能并不能描述一个100%的monad。要更深刻了解monad还是需要学习范畴论的内容。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">函数式编程.pdf</a><br><a href=\"http://www.defmacro.org/ramblings/fp.html\">Functional Programming For The Rest of Us</a><br><a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors, Applicatives, And Monads In Pictures</a></p>\n",
            "tags": [
                "函数式编程",
                "闭包",
                "Haskell",
                "monad"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/09/js-function/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/09/js-function/",
            "title": "JavaScript中的函数表达式与闭包",
            "date_published": "2017-03-09T12:43:41.000Z",
            "content_html": "<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数是JavaScript中最有特色同时又容易让人困扰的特性。定义函数的方式有两种：函数声明和函数表达式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span> (arg0, arg1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在非IE浏览器中，function都有非标准的name属性，属性值为function后的标识符或表达式的接收变量名。在<strong>函数声明</strong>里有一个重要特征——<strong>函数声明提升（function declaration hoisting）</strong>。这意味着函数声明可以放在调用它的语句后。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span> () &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;Hi!&quot;</span>); <span class=\"comment\">// &quot;Hi!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而函数表达式则不能这样使用，因为<strong>变量声明提升</strong>会将函数名提升，下面的代码将导致错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;Hi!&quot;</span>); <span class=\"comment\">// Error！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确理解函数声明提升将会避免很多潜在的错误，<em>或者干脆养成好习惯——定义在前，调用在后</em>。</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>递归函数是一个函数通过调用自身得到的。如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">factorial</span> (num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num * <span class=\"title function_\">factorial</span>(num-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个经典的递归阶乘函数。不过当我们不知道函数名或者函数是匿名函数时，可以通过<code>arguments.callee</code>来调用自身。<br><code>argument.callee</code>是一个指向正在执行的函数的指针。</p>\n<div class=\"tip\">在ES5的严格模式下，`arguments.callee`特性是禁止使用的。它将影响解释器的优化和运行效率。\n</div>\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p><strong>闭包</strong>几乎是前端面试必考的一个知识点。它的存在是JavaScript中作用域链带来的特性。<strong>闭包</strong>是指有权访问另一个函数<br>作用域中变量的函数。创建闭包最常用的方式就是在函数内部创建另一个函数。就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fatherFunction</span> (propertyName, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">object1, object2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = object1[propertyName],</span><br><span class=\"line\">            b = object2[propertyName];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a + b &gt; value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在返回的函数中引用了外部函数的变量<code>propertyName</code>和<code>sum</code>。即使这个函数已经返回，只要内部函数还存在，那么这两个变量就仍然可以访问。这就是闭包的直观体现。</p>\n<p>解释闭包就要先理解JS中的<em>作用域链</em>。执行环境是JS中的一个关键概念。它定义了变量或函数可以访问的数据。全局执行环境是最外层的执行环境。根据ECMAScript实现宿主的不同，全局执行环境也各不相同。某个执行环境中的代码执行完毕后，环境被销毁，包括其中的所有变量和函数定义。<strong>JS中的每个函数都有自己的执行环境</strong>。执行流进入一个函数时，函数环境就被推入到环境栈中，待执行完毕后出栈。在执行环境中的代码时，会创建变量对象的作用域链，由当前的活动对象到外部环境变量对象一直到全局执行环境中的变量对象。内部环境可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境中的变量和函数。</p>\n<p>现在回过头看闭包。在函数执行过程中，为了读取和写入变量值，需要保存整个作用域链。因此，在<code>fatherFunction</code>中创建的匿名函数的作用域链实际上包含了<code>fantherFunction()</code>的活动对象（输入参数和变量）以及全局变量对象。在<code>fatherFunction()</code>返回时，匿名函数的作用域链仍然引用着它的活动对象，使其并不会被销毁，直到匿名函数被销毁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compare = <span class=\"title function_\">fatherFunction</span>(<span class=\"string\">&quot;value&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"title function_\">compare</span>(&#123;<span class=\"attr\">value</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">value</span>: -<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 解除匿名函数的引用，释放内存</span></span><br><span class=\"line\">compare = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">由于闭包会携带包含它的函数作用域，过度使用闭包会导致内存占用过多。忘记解除匿名函数引用还会导致内存泄漏。\n</div>\n\n<h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p>闭包可以取得父级函数的变量的<em>最终值</em>，因此配合for循环这样的结构就容易发生意外，就像下面的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bindClickFunctions</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buttons = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 让我们假设length是20</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = buttons.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        buttons[i].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数会为所有的按钮绑定点击事件，不过效果却并不像预想中那样，不同的button弹出不同的值。结果是所有的button在点击后弹出的都是20。这是因为所有的匿名函数都使用着同一个外部函数的活动对象。可以通过在创建一层闭包来达到预期的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bindClickFunctions</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buttons = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = buttons.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        buttons[i].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">alert</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在每层循环中创建了一个匿名函数，匿名函数包含一个输入参数<code>i</code>，再分别保存在内部函数的作用域链中，就可以使闭包间引用的i互不干扰了。</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>JavaScript中是没有块级作用域的。不过可以利用匿名函数的作用域模拟一个块级作用域出来。在其中定义的私有变量也不必担心与其他作用域的变量名相冲突。这种用法很常用于最外层的封装，用于隐藏代码中的变量，在一定程度上保证安全。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"string\">&quot;You can see me, but you cannot touch me.&quot;</span></span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(foo);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>同样的，JavaScript中是没有私有成员的概念的。但是，利用闭包可以制造出私有变量。原理是，利用函数作用域隐藏其中的变量甚至输入参数，通过返回的闭包操作这些“私有”变量。如下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Stu</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&quot;Shenlvmeng&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">stu.<span class=\"title function_\">setName</span>(<span class=\"string\">&quot;Weii&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu.<span class=\"title function_\">getName</span>());</span><br></pre></td></tr></table></figure>\n<p>这里只是一个很简单的展示，红宝书中还介绍了模块模式和增强模块模式，利用闭包的特点实现了单例的构造和特权方法。下面对上面的<code>Stu</code>函数进行改造，可以使得所有通过<code>Stu()</code>构造的对象都有相同的公有变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&#x27;shenlvmeng&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu1.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\"><span class=\"keyword\">var</span> stu2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&#x27;weii&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu2.<span class=\"title function_\">getName</span>());\t\t<span class=\"comment\">// &quot;weii&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu1.<span class=\"title function_\">getName</span>());\t\t<span class=\"comment\">// &quot;weii&quot;</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "JavaScript",
                "闭包",
                "函数表达式"
            ]
        }
    ]
}
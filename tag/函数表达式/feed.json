{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"函数表达式\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/09/js-function/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/09/js-function/",
            "title": "JavaScript中的函数表达式与闭包",
            "date_published": "2017-03-09T12:43:41.000Z",
            "content_html": "<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数是JavaScript中最有特色同时又容易让人困扰的特性。定义函数的方式有两种：函数声明和函数表达式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span> (arg0, arg1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在非IE浏览器中，function都有非标准的name属性，属性值为function后的标识符或表达式的接收变量名。在<strong>函数声明</strong>里有一个重要特征——<strong>函数声明提升（function declaration hoisting）</strong>。这意味着函数声明可以放在调用它的语句后。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span> () &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;Hi!&quot;</span>); <span class=\"comment\">// &quot;Hi!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而函数表达式则不能这样使用，因为<strong>变量声明提升</strong>会将函数名提升，下面的代码将导致错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;Hi!&quot;</span>); <span class=\"comment\">// Error！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确理解函数声明提升将会避免很多潜在的错误，<em>或者干脆养成好习惯——定义在前，调用在后</em>。</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>递归函数是一个函数通过调用自身得到的。如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">factorial</span> (num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num * <span class=\"title function_\">factorial</span>(num-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个经典的递归阶乘函数。不过当我们不知道函数名或者函数是匿名函数时，可以通过<code>arguments.callee</code>来调用自身。<br><code>argument.callee</code>是一个指向正在执行的函数的指针。</p>\n<div class=\"tip\">在ES5的严格模式下，`arguments.callee`特性是禁止使用的。它将影响解释器的优化和运行效率。\n</div>\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p><strong>闭包</strong>几乎是前端面试必考的一个知识点。它的存在是JavaScript中作用域链带来的特性。<strong>闭包</strong>是指有权访问另一个函数<br>作用域中变量的函数。创建闭包最常用的方式就是在函数内部创建另一个函数。就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fatherFunction</span> (propertyName, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">object1, object2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = object1[propertyName],</span><br><span class=\"line\">            b = object2[propertyName];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a + b &gt; value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在返回的函数中引用了外部函数的变量<code>propertyName</code>和<code>sum</code>。即使这个函数已经返回，只要内部函数还存在，那么这两个变量就仍然可以访问。这就是闭包的直观体现。</p>\n<p>解释闭包就要先理解JS中的<em>作用域链</em>。执行环境是JS中的一个关键概念。它定义了变量或函数可以访问的数据。全局执行环境是最外层的执行环境。根据ECMAScript实现宿主的不同，全局执行环境也各不相同。某个执行环境中的代码执行完毕后，环境被销毁，包括其中的所有变量和函数定义。<strong>JS中的每个函数都有自己的执行环境</strong>。执行流进入一个函数时，函数环境就被推入到环境栈中，待执行完毕后出栈。在执行环境中的代码时，会创建变量对象的作用域链，由当前的活动对象到外部环境变量对象一直到全局执行环境中的变量对象。内部环境可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境中的变量和函数。</p>\n<p>现在回过头看闭包。在函数执行过程中，为了读取和写入变量值，需要保存整个作用域链。因此，在<code>fatherFunction</code>中创建的匿名函数的作用域链实际上包含了<code>fantherFunction()</code>的活动对象（输入参数和变量）以及全局变量对象。在<code>fatherFunction()</code>返回时，匿名函数的作用域链仍然引用着它的活动对象，使其并不会被销毁，直到匿名函数被销毁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compare = <span class=\"title function_\">fatherFunction</span>(<span class=\"string\">&quot;value&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"title function_\">compare</span>(&#123;<span class=\"attr\">value</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">value</span>: -<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 解除匿名函数的引用，释放内存</span></span><br><span class=\"line\">compare = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">由于闭包会携带包含它的函数作用域，过度使用闭包会导致内存占用过多。忘记解除匿名函数引用还会导致内存泄漏。\n</div>\n\n<h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p>闭包可以取得父级函数的变量的<em>最终值</em>，因此配合for循环这样的结构就容易发生意外，就像下面的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bindClickFunctions</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buttons = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 让我们假设length是20</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = buttons.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        buttons[i].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数会为所有的按钮绑定点击事件，不过效果却并不像预想中那样，不同的button弹出不同的值。结果是所有的button在点击后弹出的都是20。这是因为所有的匿名函数都使用着同一个外部函数的活动对象。可以通过在创建一层闭包来达到预期的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bindClickFunctions</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buttons = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = buttons.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        buttons[i].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">alert</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在每层循环中创建了一个匿名函数，匿名函数包含一个输入参数<code>i</code>，再分别保存在内部函数的作用域链中，就可以使闭包间引用的i互不干扰了。</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>JavaScript中是没有块级作用域的。不过可以利用匿名函数的作用域模拟一个块级作用域出来。在其中定义的私有变量也不必担心与其他作用域的变量名相冲突。这种用法很常用于最外层的封装，用于隐藏代码中的变量，在一定程度上保证安全。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"string\">&quot;You can see me, but you cannot touch me.&quot;</span></span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(foo);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>同样的，JavaScript中是没有私有成员的概念的。但是，利用闭包可以制造出私有变量。原理是，利用函数作用域隐藏其中的变量甚至输入参数，通过返回的闭包操作这些“私有”变量。如下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Stu</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&quot;Shenlvmeng&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">stu.<span class=\"title function_\">setName</span>(<span class=\"string\">&quot;Weii&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu.<span class=\"title function_\">getName</span>());</span><br></pre></td></tr></table></figure>\n<p>这里只是一个很简单的展示，红宝书中还介绍了模块模式和增强模块模式，利用闭包的特点实现了单例的构造和特权方法。下面对上面的<code>Stu</code>函数进行改造，可以使得所有通过<code>Stu()</code>构造的对象都有相同的公有变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Stu</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        name = value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&#x27;shenlvmeng&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu1.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\"><span class=\"keyword\">var</span> stu2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stu</span>(<span class=\"string\">&#x27;weii&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu2.<span class=\"title function_\">getName</span>());\t\t<span class=\"comment\">// &quot;weii&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(stu1.<span class=\"title function_\">getName</span>());\t\t<span class=\"comment\">// &quot;weii&quot;</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "JavaScript",
                "闭包",
                "函数表达式"
            ]
        }
    ]
}
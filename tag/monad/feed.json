{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"monad\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "url": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "title": "函数式编程扫盲",
            "date_published": "2017-06-20T11:45:44.000Z",
            "content_html": "<p>名谓扫盲，实则是为自己扫盲。前些日子通过Elm的学习接触到了函数式编程的概念，发现语言风格和以C为代表的命令式编程大不相同，接触不同的编程思维还是很有助于自我提升的。在回顾的同时，这里走马观花地带过一些函数式编程的“热门词汇”。</p>\n<h2 id=\"历史故事\"><a href=\"#历史故事\" class=\"headerlink\" title=\"历史故事\"></a><a href=\"http://www.defmacro.org/ramblings/fp.html\">历史故事</a></h2><p>什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？这得从20世纪30年代开始讲起：</p>\n<blockquote>\n<p>新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫<a href=\"http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87\">阿隆佐·邱奇</a>(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有<a href=\"https://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5\">艾伦·图灵</a>、<a href=\"http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC\">约翰·冯·诺伊曼</a>、<a href=\"https://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94\">库尔特·哥德尔</a>。</p>\n</blockquote>\n<p>在与这些人的合作下，阿隆佐设计了一个名为<a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">lambda演算</a>的形式系统。在这种语言里面，函数的参数是函数，返回值也是函数。篇幅和本人能力限制，不对lambda演算做更多讲解。</p>\n<p>除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。</p>\n<p>到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！而后的诸多函数式编程语言（如Haskell，ML等）也多少收到Lisp的影响。</p>\n<h2 id=\"法则\"><a href=\"#法则\" class=\"headerlink\" title=\"法则\"></a><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">法则</a></h2><p>函数式编程的思想来源Lambda演算在最初设计时就是用来解决计算相关问题，它是一种相对于“命令式编程”完全不同的编程范式，后者告诉计算机怎么做，前者着眼在从数学角度描述问题。它的特点也很明显：</p>\n<ul>\n<li><strong>变量不可变</strong>，即默认带上<code>const</code>或是<code>final</code>（当然函数式编程里压根没有<code>const</code>和<code>final</code>的概念）。这么来看，叫它为“符号”似乎更合适</li>\n<li><strong>惰性求值</strong>，变量直到使用时才会真正计算它的值，因为这个特点，Haskell甚至允许无限列表的出现。同时，这也意味着语句的出现顺序和执行顺序并不相关。</li>\n<li><strong>高阶函数</strong>，函数可以作为入参或是返回值，这个也被很多不那么OOP的语言借鉴去了</li>\n<li><strong>无副作用</strong>，<strong>函数只负责映射数据</strong>，更像是个管道，绝不改变外部状态，同样的输入在任何时候会得到同样的输出（测试人员笑开了花）。这一点使得函数式编程语言天生支持并发执行。</li>\n<li><strong>一切皆函数</strong>，函数是第一公民</li>\n</ul>\n<p>λ演算用来描述一种形式系统，它的语法只有三条：</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>术语</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a</td>\n<td>变量</td>\n<td>一个代表参数或数字&#x2F;逻辑值的符号或字符串</td>\n</tr>\n<tr>\n<td>(λx.M)</td>\n<td>定义</td>\n<td>函数定义，<code>.</code>前面的标识符<code>x</code>为入参，M为表达式</td>\n</tr>\n<tr>\n<td>(M N)</td>\n<td>调用</td>\n<td>应用函数到一个入参</td>\n</tr>\n</tbody></table>\n<p>例如：<code>((λ x y. x + y) 1 2)</code>表示1和2相加。</p>\n<p>λ演算公理只有两个：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(λx.M[x]) → (λy.M[y])</td>\n<td>α变换</td>\n<td>改变入参名不影响结果</td>\n</tr>\n<tr>\n<td>((λx.M) E) → (M[x:&#x3D;E])</td>\n<td>β规约</td>\n<td>将入参传入λ意味着对它做演算</td>\n</tr>\n</tbody></table>\n<p>还以上面的相加为例，α变换就是<code>λ x y. x + y → λ a b. a + b</code>；β规约就是<code>(λ x y. x + y) a b → a + b</code>。是不是很好理解。</p>\n<p>通过这两个基本的公理，结合基本变量类型可以构造各种函数。如not函数，and函数，or函数，甚至if函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> and =</span><br><span class=\"line\"><span class=\"title\">true</span> value  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">false</span> value -&gt;  false</span><br><span class=\"line\"><span class=\"title\">value</span> true  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">value</span> false -&gt;  false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">let</span> <span class=\"keyword\">if</span> =</span><br><span class=\"line\">λ cond tvalue fvalue. (cond and tvalue) or (not cond  and fvalue)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数意味着，我们可以把函数直接作为入参传入，或作为返回值返回。这早已不是函数式编程语言的专利，Python，JavaScript等也吸收了这个设计理念。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\">函数柯里化</a>即部分求值，就利用了高阶函数的特点提出的技术，它使得函数可以一个一个接受入参，返回相同的计算结果。类似于下面的感觉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pow</span>(<span class=\"params\">i, j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i^j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funtion <span class=\"title function_\">square</span>(<span class=\"params\">j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">pow</span>(i, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>square</code>函数返回的函数需要指定<code>i</code>才可执行。柯里的名字来自于第一次提出这个技巧的逻辑学家<a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\">Haskell Curry</a>。</p>\n<p>另外，值得注意的是，在函数式编程下，高阶函数通过将函数作为参数惰性求值实现。那命令式编程下呢，答案是<a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">闭包</a>（lexical closure）。</p>\n<h2 id=\"递归？\"><a href=\"#递归？\" class=\"headerlink\" title=\"递归？\"></a>递归？</h2><p>函数式编程里没有状态变量（可以用其他方式实现），因此自然没有循环结构。实际上，函数式编程中的循环都是通过递归实现的。比如，斐波那契数列函数像下面这样：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> fact = λ n. <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"number\">1</span> (n * fact n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>这里<code>fact</code>函数引用了自身，虽然编译器可以识别这种写法，但是显然它并不符合严格的数学公理。</p>\n<p>重新审视这个变换，我们可以通过传入自身的方式来让它“数学化”。<code>let P = λ self n. if (n == 0) 1 (n * self(self n-1))</code>，然后在令<code>let fact n = P (P n)</code>。如此这般：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact 4</span><br><span class=\"line\">-&gt; P (P 4)</span><br><span class=\"line\">-&gt; if (4 == 0) (1) (4 * P(P 3))</span><br><span class=\"line\">-&gt; 4 * P(P 3)</span><br><span class=\"line\">-&gt; 4 * 3 * P(P 2)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * P(P 1)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * 1</span><br></pre></td></tr></table></figure>\n\n<p>可是，这个函数看上去并不自然，不像一个真正的递归函数，且λ演算的公理里并没有这样一条公理可以让你在定义函数的时候引用本身。还好，已经有人做了<a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">研究</a>，借助Y组合子的帮助，可以实现真正的递归函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> <span class=\"type\">Y</span> = λ <span class=\"type\">F</span>. <span class=\"type\">G</span>(<span class=\"type\">G</span>)</span><br><span class=\"line\"><span class=\"type\">G</span> = λ self. <span class=\"type\">F</span>(self(self))</span><br></pre></td></tr></table></figure>\n\n<p>这相当于我们在λ演算公理体系中添加了一条“可以在函数调用时引用自身”。这也是证明λ演算图灵等价的关键一步。这意味着它的计算能力和计算机是一致的，能通过λ演算描述的函数一定可以由计算机计算。</p>\n<h2 id=\"Haskell\"><a href=\"#Haskell\" class=\"headerlink\" title=\"Haskell\"></a>Haskell</h2><p><a href=\"https://www.zhihu.com/question/27355585\">Haskell</a>是一个纯函数式编程语言，它得名于上面提到过的Haskell Curry。Y组合子也是他发现的。</p>\n<p>Haskell中一切都是函数，甚至没有指令式编程中变量的概念，它的变量全部都是只允许一次赋值，不可改变。</p>\n<p>Haskell还没有一般意义上的控制流结构，如for循环，取而代之的是递归。同样，Haskell还有两个重要的特性，即无副作用和惰<br>性求值。偏数学的问题，用Haskell解决通常代码量都很小。下面是一个列表去重例子</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">cut</span> cond  []  = []</span><br><span class=\"line\"><span class=\"title\">cut</span> cond  (elem:rest) = <span class=\"keyword\">if</span>  cond elem <span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"title\">cut</span> cond  rest  <span class=\"keyword\">else</span>  elem:rest</span><br><span class=\"line\"><span class=\"title\">compress</span>  []  = []</span><br><span class=\"line\"><span class=\"title\">compress</span>  (elem:rest) = elem  : compress</span><br><span class=\"line\">(cut  (== elem) rest)</span><br></pre></td></tr></table></figure>\n<p>还有一个快排（不过借助了filter函数）的例子，也是短得不行</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> (elem:rest) = (qsort lesser) ++ [elem] ++ (qsort greater)</span><br><span class=\"line\">  <span class=\"keyword\">where</span></span><br><span class=\"line\">    lesser = filter (&lt; elem) rest</span><br><span class=\"line\">    greater = filter (&gt;= elem) rest</span><br></pre></td></tr></table></figure>\n<p>Haskell中还可以定义无穷列表，如[1..]表示所有正整数。这也是惰性求值特性带来的。<code>[1,3..] !! 42</code>将会返回85。</p>\n<h2 id=\"Monad\"><a href=\"#Monad\" class=\"headerlink\" title=\"Monad\"></a>Monad</h2><blockquote>\n<p>Monad其实就是自函子范畴上的一个幺半群而已</p>\n</blockquote>\n<p>这节将展示一个图文并茂的说明但并不致力于解释清楚monad到底是个什么（因为我自己也不明白）。这篇对比<a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">functor，applicatives，monad</a>的文章写得很透彻易懂，尽管这可能并不能描述一个100%的monad。要更深刻了解monad还是需要学习范畴论的内容。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">函数式编程.pdf</a><br><a href=\"http://www.defmacro.org/ramblings/fp.html\">Functional Programming For The Rest of Us</a><br><a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors, Applicatives, And Monads In Pictures</a></p>\n",
            "tags": [
                "函数式编程",
                "闭包",
                "Haskell",
                "monad"
            ]
        }
    ]
}
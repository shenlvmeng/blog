<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;monad&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2017-06-20T11:45:44.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="2018" />
    <category term="2019" />
    <category term="flag" />
    <category term="2020" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="绘图" />
    <category term="动画" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="DOM" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="架构" />
    <category term="组件" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="形式系统" />
    <category term="不完全性" />
    <category term="隐喻" />
    <category term="哥德尔" />
    <category term="巴赫" />
    <category term="埃舍尔" />
    <category term="济州" />
    <category term="西归浦" />
    <category term="城山" />
    <category term="咸德" />
    <category term="人工智能" />
    <category term="心智" />
    <category term="自指" />
    <category term="图灵" />
    <category term="马列主义" />
    <category term="恩格斯" />
    <category term="家庭" />
    <category term="国家" />
    <category term="阶级" />
    <category term="氏族" />
    <category term="哲学史" />
    <category term="孔子" />
    <category term="老子" />
    <category term="儒家" />
    <category term="道家" />
    <category term="佛教" />
    <category term="禅宗" />
    <category term="理学" />
    <category term="心学" />
    <category term="计算机" />
    <category term="微机原理" />
    <category term="门" />
    <category term="操作系统" />
    <category term="数字电路" />
    <category term="2024" />
    <category term="政府" />
    <category term="经济" />
    <category term="消费" />
    <category term="土地金融" />
    <category term="饮食" />
    <category term="蛋白质" />
    <category term="碳水" />
    <category term="慢性病" />
    <category term="三高" />
    <category term="肿瘤" />
    <category term="启蒙" />
    <category term="社会主义" />
    <category term="当代史" />
    <category term="共产党" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/</id>
        <title>函数式编程扫盲</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/"/>
        <content type="html">&lt;p&gt;名谓扫盲，实则是为自己扫盲。前些日子通过Elm的学习接触到了函数式编程的概念，发现语言风格和以C为代表的命令式编程大不相同，接触不同的编程思维还是很有助于自我提升的。在回顾的同时，这里走马观花地带过一些函数式编程的“热门词汇”。&lt;/p&gt;
&lt;h2 id=&#34;历史故事&#34;&gt;&lt;a href=&#34;#历史故事&#34; class=&#34;headerlink&#34; title=&#34;历史故事&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.defmacro.org/ramblings/fp.html&#34;&gt;历史故事&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？这得从20世纪30年代开始讲起：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫&lt;a href=&#34;http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87&#34;&gt;阿隆佐·邱奇&lt;/a&gt;(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有&lt;a href=&#34;https://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5&#34;&gt;艾伦·图灵&lt;/a&gt;、&lt;a href=&#34;http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC&#34;&gt;约翰·冯·诺伊曼&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94&#34;&gt;库尔特·哥德尔&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在与这些人的合作下，阿隆佐设计了一个名为&lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus&#34;&gt;lambda演算&lt;/a&gt;的形式系统。在这种语言里面，函数的参数是函数，返回值也是函数。篇幅和本人能力限制，不对lambda演算做更多讲解。&lt;/p&gt;
&lt;p&gt;除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。&lt;/p&gt;
&lt;p&gt;到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！而后的诸多函数式编程语言（如Haskell，ML等）也多少收到Lisp的影响。&lt;/p&gt;
&lt;h2 id=&#34;法则&#34;&gt;&lt;a href=&#34;#法则&#34; class=&#34;headerlink&#34; title=&#34;法则&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.byvoid.com/upload/fl/images/FP/FP.pdf&#34;&gt;法则&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;函数式编程的思想来源Lambda演算在最初设计时就是用来解决计算相关问题，它是一种相对于“命令式编程”完全不同的编程范式，后者告诉计算机怎么做，前者着眼在从数学角度描述问题。它的特点也很明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量不可变&lt;/strong&gt;，即默认带上&lt;code&gt;const&lt;/code&gt;或是&lt;code&gt;final&lt;/code&gt;（当然函数式编程里压根没有&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;final&lt;/code&gt;的概念）。这么来看，叫它为“符号”似乎更合适&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;惰性求值&lt;/strong&gt;，变量直到使用时才会真正计算它的值，因为这个特点，Haskell甚至允许无限列表的出现。同时，这也意味着语句的出现顺序和执行顺序并不相关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;，函数可以作为入参或是返回值，这个也被很多不那么OOP的语言借鉴去了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无副作用&lt;/strong&gt;，&lt;strong&gt;函数只负责映射数据&lt;/strong&gt;，更像是个管道，绝不改变外部状态，同样的输入在任何时候会得到同样的输出（测试人员笑开了花）。这一点使得函数式编程语言天生支持并发执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一切皆函数&lt;/strong&gt;，函数是第一公民&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;λ演算用来描述一种形式系统，它的语法只有三条：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;td&gt;一个代表参数或数字&amp;#x2F;逻辑值的符号或字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(λx.M)&lt;/td&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;函数定义，&lt;code&gt;.&lt;/code&gt;前面的标识符&lt;code&gt;x&lt;/code&gt;为入参，M为表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(M N)&lt;/td&gt;
&lt;td&gt;调用&lt;/td&gt;
&lt;td&gt;应用函数到一个入参&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;例如：&lt;code&gt;((λ x y. x + y) 1 2)&lt;/code&gt;表示1和2相加。&lt;/p&gt;
&lt;p&gt;λ演算公理只有两个：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;(λx.M[x]) → (λy.M[y])&lt;/td&gt;
&lt;td&gt;α变换&lt;/td&gt;
&lt;td&gt;改变入参名不影响结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;((λx.M) E) → (M[x:&amp;#x3D;E])&lt;/td&gt;
&lt;td&gt;β规约&lt;/td&gt;
&lt;td&gt;将入参传入λ意味着对它做演算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;还以上面的相加为例，α变换就是&lt;code&gt;λ x y. x + y → λ a b. a + b&lt;/code&gt;；β规约就是&lt;code&gt;(λ x y. x + y) a b → a + b&lt;/code&gt;。是不是很好理解。&lt;/p&gt;
&lt;p&gt;通过这两个基本的公理，结合基本变量类型可以构造各种函数。如not函数，and函数，or函数，甚至if函数。&lt;/p&gt;
&lt;figure class=&#34;highlight haskell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;let&lt;/span&gt; and =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;true&lt;/span&gt; value  -&amp;gt;  value&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;false&lt;/span&gt; value -&amp;gt;  false&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;value&lt;/span&gt; true  -&amp;gt;  value&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;value&lt;/span&gt; false -&amp;gt;  false&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;λ cond tvalue fvalue. (cond and tvalue) or (not cond  and fvalue)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;高阶函数&#34;&gt;&lt;a href=&#34;#高阶函数&#34; class=&#34;headerlink&#34; title=&#34;高阶函数&#34;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;高阶函数意味着，我们可以把函数直接作为入参传入，或作为返回值返回。这早已不是函数式编程语言的专利，Python，JavaScript等也吸收了这个设计理念。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;函数柯里化&lt;/a&gt;即部分求值，就利用了高阶函数的特点提出的技术，它使得函数可以一个一个接受入参，返回相同的计算结果。类似于下面的感觉：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;pow&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;i, j&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; i^j;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;funtion &lt;span class=&#34;title function_&#34;&gt;square&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;j&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;pow&lt;/span&gt;(i, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;square&lt;/code&gt;函数返回的函数需要指定&lt;code&gt;i&lt;/code&gt;才可执行。柯里的名字来自于第一次提出这个技巧的逻辑学家&lt;a href=&#34;https://en.wikipedia.org/wiki/Haskell_Curry&#34;&gt;Haskell Curry&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，值得注意的是，在函数式编程下，高阶函数通过将函数作为参数惰性求值实现。那命令式编程下呢，答案是&lt;a href=&#34;https://en.wikipedia.org/wiki/Closure_(computer_programming)&#34;&gt;闭包&lt;/a&gt;（lexical closure）。&lt;/p&gt;
&lt;h2 id=&#34;递归？&#34;&gt;&lt;a href=&#34;#递归？&#34; class=&#34;headerlink&#34; title=&#34;递归？&#34;&gt;&lt;/a&gt;递归？&lt;/h2&gt;&lt;p&gt;函数式编程里没有状态变量（可以用其他方式实现），因此自然没有循环结构。实际上，函数式编程中的循环都是通过递归实现的。比如，斐波那契数列函数像下面这样：&lt;/p&gt;
&lt;figure class=&#34;highlight haskell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;let&lt;/span&gt; fact = λ n. &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (n == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; (n * fact n-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;fact&lt;/code&gt;函数引用了自身，虽然编译器可以识别这种写法，但是显然它并不符合严格的数学公理。&lt;/p&gt;
&lt;p&gt;重新审视这个变换，我们可以通过传入自身的方式来让它“数学化”。&lt;code&gt;let P = λ self n. if (n == 0) 1 (n * self(self n-1))&lt;/code&gt;，然后在令&lt;code&gt;let fact n = P (P n)&lt;/code&gt;。如此这般：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;fact 4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; P (P 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; if (4 == 0) (1) (4 * P(P 3))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; 4 * P(P 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; 4 * 3 * P(P 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; 4 * 3 * 2 * P(P 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&amp;gt; 4 * 3 * 2 * 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可是，这个函数看上去并不自然，不像一个真正的递归函数，且λ演算的公理里并没有这样一条公理可以让你在定义函数的时候引用本身。还好，已经有人做了&lt;a href=&#34;https://en.wikipedia.org/wiki/Fixed-point_combinator&#34;&gt;研究&lt;/a&gt;，借助Y组合子的帮助，可以实现真正的递归函数。&lt;/p&gt;
&lt;figure class=&#34;highlight haskell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;Y&lt;/span&gt; = λ &lt;span class=&#34;type&#34;&gt;F&lt;/span&gt;. &lt;span class=&#34;type&#34;&gt;G&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;G&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;G&lt;/span&gt; = λ self. &lt;span class=&#34;type&#34;&gt;F&lt;/span&gt;(self(self))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这相当于我们在λ演算公理体系中添加了一条“可以在函数调用时引用自身”。这也是证明λ演算图灵等价的关键一步。这意味着它的计算能力和计算机是一致的，能通过λ演算描述的函数一定可以由计算机计算。&lt;/p&gt;
&lt;h2 id=&#34;Haskell&#34;&gt;&lt;a href=&#34;#Haskell&#34; class=&#34;headerlink&#34; title=&#34;Haskell&#34;&gt;&lt;/a&gt;Haskell&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/27355585&#34;&gt;Haskell&lt;/a&gt;是一个纯函数式编程语言，它得名于上面提到过的Haskell Curry。Y组合子也是他发现的。&lt;/p&gt;
&lt;p&gt;Haskell中一切都是函数，甚至没有指令式编程中变量的概念，它的变量全部都是只允许一次赋值，不可改变。&lt;/p&gt;
&lt;p&gt;Haskell还没有一般意义上的控制流结构，如for循环，取而代之的是递归。同样，Haskell还有两个重要的特性，即无副作用和惰&lt;br&gt;性求值。偏数学的问题，用Haskell解决通常代码量都很小。下面是一个列表去重例子&lt;/p&gt;
&lt;figure class=&#34;highlight haskell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;cut&lt;/span&gt; cond  []  = []&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;cut&lt;/span&gt; cond  (elem:rest) = &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;  cond elem &lt;span class=&#34;keyword&#34;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;cut&lt;/span&gt; cond  rest  &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;  elem:rest&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;compress&lt;/span&gt;  []  = []&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;compress&lt;/span&gt;  (elem:rest) = elem  : compress&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(cut  (== elem) rest)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一个快排（不过借助了filter函数）的例子，也是短得不行&lt;/p&gt;
&lt;figure class=&#34;highlight haskell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title&#34;&gt;qsort&lt;/span&gt; (elem:rest) = (qsort lesser) ++ [elem] ++ (qsort greater)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    lesser = filter (&amp;lt; elem) rest&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    greater = filter (&amp;gt;= elem) rest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Haskell中还可以定义无穷列表，如[1..]表示所有正整数。这也是惰性求值特性带来的。&lt;code&gt;[1,3..] !! 42&lt;/code&gt;将会返回85。&lt;/p&gt;
&lt;h2 id=&#34;Monad&#34;&gt;&lt;a href=&#34;#Monad&#34; class=&#34;headerlink&#34; title=&#34;Monad&#34;&gt;&lt;/a&gt;Monad&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Monad其实就是自函子范畴上的一个幺半群而已&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这节将展示一个图文并茂的说明但并不致力于解释清楚monad到底是个什么（因为我自己也不明白）。这篇对比&lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;functor，applicatives，monad&lt;/a&gt;的文章写得很透彻易懂，尽管这可能并不能描述一个100%的monad。要更深刻了解monad还是需要学习范畴论的内容。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;&lt;a href=&#34;#参考&#34; class=&#34;headerlink&#34; title=&#34;参考&#34;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://www.byvoid.com/upload/fl/images/FP/FP.pdf&#34;&gt;函数式编程.pdf&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;http://www.defmacro.org/ramblings/fp.html&#34;&gt;Functional Programming For The Rest of Us&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;Functors, Applicatives, And Monads In Pictures&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="函数式编程" />
        <category term="闭包" />
        <category term="Haskell" />
        <category term="monad" />
        <updated>2017-06-20T11:45:44.000Z</updated>
    </entry>
</feed>

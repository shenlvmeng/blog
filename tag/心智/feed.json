{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"心智\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2023/09/28/g-e-b-2/",
            "url": "http://shenlvmeng.github.com/blog/2023/09/28/g-e-b-2/",
            "title": "GEB —— 集异璧之大成 下",
            "date_published": "2023-09-28T11:43:09.000Z",
            "content_html": "<p>下半部分对人工智能、计算机的探讨和前半部分有相通之处。</p>\r\n<h2 id=\"描述的层次和计算机系统\">描述的层次和计算机系统</h2>\r\n<blockquote>\r\n<p>描述、组块化、旁效现象</p>\r\n</blockquote>\r\n<p>上半部分对WJ谜题的讨论以及对哥德尔、巴赫的赏析中，就出现过不同的层次，日常中<strong>描述是有层次的</strong>。人由几十万亿个细胞组成，但日常行为却根本没法描述到每个细胞的层级。人工智能里也有和层次相关的追求，即如何构造一个系统，接收一个层次的描述，去生成另一个层级的描述。关于这方面的研究很久前就开始了，荷兰心理学家阿德里安·德·格鲁特发现大师对于棋局的感知是<strong>组块化的</strong>。他感知的是整个棋局的战略态势（很类似《程序员思维修炼》里的<a\r\nhref=\"https://shenlvmeng.github.io/blog/2020/05/31/pragmatic-thinking-and-learning/#%E6%91%98%E5%BD%95-2\">R型思维</a>）。大师在对局期间，会识别棋局的<strong>模式</strong>，对庞大可能性的树状结构做修剪。从而嗅出更大获胜可能的选择，这种直觉是涌现的。</p>\r\n<p>计算机系统其实很类似，也有层次的概念。庞大复杂的计算机系统也是基于模块化思路一层层构成的。从最底层的存储器、CPU、字，到有限的机器指令、机器语言，再到编译语言、解释语言、算法，层次一点点提高。运行着的程序也有着上面每个层面上的描述，层次越靠下，需要的描述就越多。计算机为了减少用户的负担，掩盖了绝大多数的低层的复杂度，只暴露最高的几个层次。其他系统也是如此，飞机的乘客并不需要知道当前的风速、油箱还有多少燃料。</p>\r\n<p>计算机这些年的发展里，涌现出更多的高级语言，向人工智能做着努力；不过<strong>计算机的全部潜能已经存在于它所有的机器指令集中</strong>，指令集就是它的原子能力集合。每种高层次语言都使用着“能力空间”里的不同区域，语言并没有强迫程序员编写某类特定程序，但为他做某些事提供了便利。用不同的语言编程，就像使用不同的调式编曲，每种调式都有自己的感情色彩。人工智能要求的计算机层级可能比我们想象的还多不少。</p>\r\n<p>软件和硬件也是不同层级的一种表达，就像脑细胞是硬件，想象是软件，我们无法使我们的神经元更快或者更慢些，或控制它们重连。但我们仍然可以控制自己的思维方式。软件是无法超越硬件存在的，我们自己也能意识到。本书意在两者间需要一些调和途径。</p>\r\n<p>在低层和高层间还有一些中间层次，就像空气分子和气候间还有局部风暴这种描述。我们日常感知的这样的中间层次可能也只是高层的一部分。从最底层的夸克向上，原子物理学家有原子核的图景，化学家有通过电子构成的小分子图景，分子生物学家又可以构成大分子相互作用领域，细胞生物学家基于大分子组块化说明细胞的作用方式。科学间临近的层次间可能没那么“隔离”，不过两个相距较远的层次就没有太大关系了。人们相互沟通交往，可不需要了解夸克、原子理论、化学键、蛋白质、细胞、器官生理学等知识。当然，这种组块化<strong>牺牲了确定性来获得简单性</strong>。让我们可以<strong>或然地估计</strong>他人的感觉。一般来说也够用了。这种掩盖了复杂性的高层组块化描述，让低层像是黑盒。你甚至根本不知道低层做了什么。不过还好，稳定的低层子系统可以得出“可靠地”独立于自身系统的结论。这种结论是无法用低层词汇表描述的。</p>\r\n<p>本章最后抛出来一个“旁效现象”的说法，一个高层系统从不同的角度看有很多的“旁效现象”，这些现象往往是系统内各个层次成千上万因素相互作用的结果，不可能从某个低层找到一个答案。就像一个短跑运动员100米成绩10秒5，不代表身体的某处存着这个数字；一个人上当受骗也不代表他大脑某处有个“上当中枢”。</p>\r\n<h3 id=\"蚂蚁赋格\">蚂蚁赋格</h3>\r\n<p>这篇很长的小品，借食蚁兽、螃蟹、阿基里斯围绕蚂蚁群体和个体关系的讨论，类比人的心智，借由符号、信号等概念，给读者心智模型的感性印象。在意识系统中，我们只能从符号层次感受自己，而无法在更低的层次感受到意识。要理解整个结构，就需要忽略组成结构的基本单元。</p>\r\n<h2 id=\"大脑和思维\">大脑和思维</h2>\r\n<blockquote>\r\n<p>符号、信号、过程性知识、描述性知识</p>\r\n</blockquote>\r\n<p>本章对人类大脑的思维的运行方式做了艰深难懂的探讨，首先，<strong>人的思维一定是依赖于大脑硬件中的客观存在的</strong>，而且我们也能发现特定的记忆也是和局部区域的功能相关的。然而从神经元的底层生物反应到高层思维间的领域，却没人能说得清楚。以视觉为例，视觉细胞可以分为三层：简单的、复杂的、超复杂的。我们看到祖母出现在眼前当然也不会是有一个“祖母细胞”在发挥作用。不过正如刚才所说，没有人知道复杂细胞和超复杂细胞的输出在哪里或如何转换成对祖母形状、位置、图形、面容这些有意义的识别。</p>\r\n<p>视觉的形成会有一个汇集的过程，在光线射在视网膜上时，你可以感觉到有什么东西在脑海中<strong>结晶</strong>了，这个过程是在视网膜作用的稍迟一些。为了更好描述思维过程，书里用“符号”这种抽象概念掩盖了底层神经元的作用过程。这里的<strong>符号</strong>比较像是日常生活中可以用一个词或者一个固定短语描述出来的事物。</p>\r\n<p>在人的思维里，也有<strong>类</strong>和<strong>例</strong>的区分，思维善于从已有的类中制造新的例，如听到“乒乓球运动员张三”时，脑海里会想象出运动员的形象和乒乓球的场景，这也是人类想象力的基础，让人可以创造自己的人工宇宙；另外，思维也可以将一个实例作为一个新生类的范例，在补充更多的上下文和真实世界有更多相互作用后，从这个例（孩童状态）中创造新的类（成人状态），如听到“乒乓球运动员张三”的声音，知道他的历史成绩，看了他的比赛，甚至有了他的签名。之后，“张三”脱胎成为新的类。思维中激活张三便不需要其他类的帮助。在昆虫的世界里，书中以黄蜂为例，可能只有孤立的例，而没有类存在。</p>\r\n<p>在符号的激活通讯上，符号在大脑神经元中的存储可能是重叠而并非独立的，激活通讯同时在许多神经元上发生，就像水波可以同时承载多个波源一样。符号的唤醒也是交织在一起同时又能彼此区分的。单个符号并不能被隔离出来，它的个性体现在和其他符号的彼此联系上。我们目前没法用更精确的语言去描述这种彼此联系，而这种可以基于抽象符号描述的思维方式，是思维软件性的证明，也是智能“可抽取性”的基础。因为符号本身是可以做到移植性的。</p>\r\n<p>在人工智能的研究里，有过程性知识和描述性知识两种区分，前者是显式贮存地址读取的，后者是演绎式的。举个例子，“广州市有多少人”的问题会触发你读取知识点答出；而“房间里有多少人”则会触发你一个过程化方法被调用。我们日常感知的物理学和其他学科常识通常是过程性的，而有些问题则在这两种类型之间，如“唱一首生日快乐歌”。</p>\r\n<h3 id=\"英法德中组曲\">英法德中组曲</h3>\r\n<p>小品中的诗中掺杂了很多自创字和短语，为下文介绍思维中的映射准备了例子。</p>\r\n<h2 id=\"心智和思维\">心智和思维</h2>\r\n<blockquote>\r\n<p>自想国、自我意识、子系统</p>\r\n</blockquote>\r\n<p>上一章中，对大脑和思维用符号进行了模拟化的描述。不同大脑间存在着一些重构，即对于可选符号的对应和符号触发模式的对应。书中以上篇小品的翻译为例，自创字的含义会通过其偏旁去猜测其意思，在英法德的翻译中也有类似的猜测。而这种猜测也意味着不同国家的读者在读这篇小品的过程中，大脑里也有粗略的同构。</p>\r\n<p>在之后，作者又用自想国为例，描述了一个事实——你所想象出的地图轮廓或多或少来自真实世界的地图（这里暗示人无法想象出没有经历过的东西）。以自想国作比喻，作者用意有双关。除了上面提到的引申之外，也借由自想国中的都市、城镇和公路类比思维中的符号和触发通路。人在自想国中旅游也是因为，当外界环境类似时，类似的触发通路也会触发同样的符号。当然，不同的人身上也会存在细微的差别。</p>\r\n<p>之后，书中话锋一转，开始讨论语言文化对母语者思维的影响。之后聊到在翻译外文作品的时候，保留文字原意意味着不完全忠于原文的本土化改造。就像本书尤其这几节所做的一样。作者借由威佛尔对翻译的理解，认为翻译应该像是解码文字中描述的客观意义，而不只是做字面的转译。在程序语言领域，不同语言写成的程序，可以在高层次上抽象出“概念骨架”。那么大脑可以这么做么？</p>\r\n<p>作者认为可以，因为我们可以用组块化去描述我们的意识活动，即虽然对于一个给定的符号，可能存在不止一条合理的触发通道，但在特定环境下，只会选择其中一条。人类往往是矛盾的混合体，在统一起来后，在某个特定时刻只表现出其中一个方面。</p>\r\n<p>上面的讨论和上一章可以说别无二致，但聊到<strong>自我意识</strong>后，问题复杂了起来。人们是如何觉察到符号的触发过程，即自我意识呢？这是个自指的过程。作者认为意识是系统的一种性质，每当系统有触发模式的符号时，这种性质就会出现。这个描述很显然过于简单。之后文中提出<strong>子系统</strong>的概念试图解释，子系统是过度生长的符号，可以翻译一种思维模式，从而可以自己产生符号。子系统不仅可以体现自我意识，和可以借助自己的符号去<strong>尽量模拟</strong>他人的意识，有点像换位思考。这样的子系统一旦触发，几乎是自主的，就像有灵魂一样。不过我认为这段描述仍不够，解释不了这样的子系统是如何自生产符号的，以及它无限递归地意识到它自己存在时，符号和触发链路是如何工作的。</p>\r\n<p>本章最后用稍显明晰的卢卡斯文章材料收尾，文章里也提到，意识物可以无限递归地认识到它认识到什么事物，更关键的是，在思想无限进行下去的同时它还能自我运作起来。这意味着它能处理哥德尔式的自指问题，而机器却不行。也许机器的复杂度存在<strong>临界点</strong>，就像核裂变一样。超出这个临界点，机器就可以形成心智，而我们无法预测它将如何运转。对于这种可以回答哥德尔式问题的东西，我们也许已不能用机器去叫它们。</p>\r\n<h3 id=\"咏叹调及其种种变奏\">咏叹调及其种种变奏</h3>\r\n<p>这篇小品从巴赫创作哥德堡变奏曲的年份1742年引入了哥德巴赫猜想和乌龟猜想，讨论了命题证明中判定的有限和无限两种情况。Cantor在小品前后的前后呼应，以及金币被偷的前后呼应也很有趣。其中Cantor作为数学家名字出现在皮包上多个数学家名字的对角线里也是很绝。</p>\r\n<h2 id=\"bloop和floop和gloop\">BlooP和FlooP和GlooP</h2>\r\n<blockquote>\r\n<p>算法、对角线法、停机问题、丘奇-图灵论题</p>\r\n</blockquote>\r\n<p>在两章对于人类意识的讨论后，又回到对于递归可验证和计算机算法的探讨。从TNT中我们可以发现，一个<strong>充分复杂到可以反映自身的有序系统是不可能有序的</strong>。换句话说，一个足够强力到可以验证“全部原始递归真理”的系统总会遇到一个它无法验证的命题。</p>\r\n<p>接着，书里带着探索事件背后规律的想法继续展开。为了讨论自然数，接着把<strong>数论和计算机算法关联起来</strong>，首先BlooP（Bounded\r\nloop）语言被发明出来，它的控制结构包含分支、<strong>有界</strong>循环（for\r\nloop），以及退出循环的QUIT、退出过程的ABORT。这样写出的BlooP过程（procedure）即BlooP函数，另外我们约定接受一个唯一的参数N且输出YES或NO的BlooP函数被称为<strong>测试</strong>，它可以用来验证一些命题。像计算机编程里一样，之前定义过的每个BlooP过程都可以直接被拿来当做一个组块（模块化）。</p>\r\n<p>在这样的BlooP语言里，我们可以写一个定义质数的BlooP测试PRIME?，伪代码像下面这样</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE PROCEDURE</span><br><span class=\"line\">&quot;PRIME?&quot;[N]:</span><br><span class=\"line\">BLOCK 0:BEGIN</span><br><span class=\"line\">  IF N=0,THEN:</span><br><span class=\"line\">  QUIT BLOCK 0;</span><br><span class=\"line\">  CELL(0)&lt;-2 # 把CELL(0)置为2</span><br><span class=\"line\">  LOOP AT MOST MINUS[N,2] TIMES:</span><br><span class=\"line\">  BLOCK 1:BEGIN</span><br><span class=\"line\">    IF REMAINDER[N, CELL(0)]=0,</span><br><span class=\"line\">    THEN:</span><br><span class=\"line\">    QUIT BLOCK 0;</span><br><span class=\"line\">    CELL(0)&lt;-CELL(0)+1</span><br><span class=\"line\">  BLOCK 1:END;</span><br><span class=\"line\">  OUTPUT&lt;-YES;</span><br><span class=\"line\">BLOCK 0:END.</span><br></pre></td></tr></table></figure>\r\n<p>可以用BlooP定义出来的过程都可以预知终止结果，这样的函数叫做<strong>原始递归函数</strong>，而可以这么验证的性质被称为<strong>原始递归谓词</strong>。哥德巴赫猜想也可以很轻松写出一个BlooP测试，另一方面，也可以用BlooP函数写一些计算自然数的功能，如阶乘、求余数、斐波那契数列，甚至是用哥德尔配数法表示的定理。</p>\r\n<p>在讨论FlooP之前，有必要再次赘述下<strong>可表示性</strong>和<strong>可表现性</strong>，前者是指能否将一个自然语言的性质形式化表述出来，比如可以轻易用TNT串表示出，一个数b具有“乌龟性质”（作者在上节小品里提的哥德巴赫猜想的2-1=1版本）。但是可表现性意味着，该谓词的全部为真的实例皆为定理，全部为假的实例均为非定理。这也是TNT作为一个公理系统到底有多强力的体现。虽然这种完全性在后面将被发现不存在，但TNT对于<strong>原始递归谓词</strong>来说还是完全的，即如果数论中某个陈述的真假可以在可预知时间段内判定，那在TNT中一定也是可判定的。</p>\r\n<p>那么存在非原始递归么？我们可以设想一个存放所有BlooP程序的库，<strong>B库</strong>。它必然是无穷大的。之后，我们在库里筛选出满足下面条件的过程：</p>\r\n<ul>\r\n<li>只接受1个参数</li>\r\n<li>返回数字</li>\r\n</ul>\r\n<p>之后将筛选过后的特殊程序称作蓝程序（Bloo发音近似blue，P指代Program），由于蓝程序由有限的字符集组成，我们可以按照程序代码在ASCII码中的字典序来排列，这样每一个蓝程序都可以有一个唯一的索引编号。从而用<code>蓝程序&#123;k&#125;[N]</code>来表示第k个蓝程序。</p>\r\n<p>之后用康托尔使用的<strong>对角线法</strong>，可以制造一些不能在BlooP中编程的函数。我们不妨称之为蓝对角，定义如下：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">蓝对角[N] = 1 + 蓝程序&#123;#N&#125;[N]</span><br></pre></td></tr></table></figure>\r\n<p>这样的蓝对角不能存在于蓝程序中，因为假如存在，它一定有一个编号，假设为X。那么根据蓝程序的定义<code>蓝对角[N] = 蓝程序&#123;X&#125;[N]</code>，代入X可以得到<code>蓝对角[X] = 蓝程序&#123;X&#125;[X]</code>；同时根据蓝对角的定义，代入X可以得到<code>蓝对角[X] = 1 + 蓝程序&#123;X&#125;[X]</code>，两者相互矛盾。从而意味着一定存在<strong>非原始递归函数</strong>，映射到数论中，一定存在某个数论中的函数没法在可预测的步数内被算出来。实际上，对于每个给定的N，蓝对角可以转化到蓝程序从而步数可预测，但每个N的步数预测不能结合成一个朴实的方法去预测<code>蓝对角[N]</code>的计算步数。</p>\r\n<p>对角线论证源于康托尔论证如果建立一个实数登记表，那么会不可避免的排除一些实数。论证过程上，构造了一个这样的表然后按<strong>对角线的形式</strong>取第n行第n列，之后将每个数都减1，这样得到的数总有一位和每一行都不一样，从而排除于表之外。这个证明过程实质上用了<strong>两种方式使用了同一个整数</strong>（横向和纵向索引），在蓝对角里也是如此（程序索引序号和输入参数）。</p>\r\n<p>看到了BlooP的局限性，我们可以发明一个FlooP（Free\r\nLoop）语言。它的μ算子可以包括一个无穷的循环。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MU-LOOP</span><br><span class=\"line\">BLOCK n:BEGIN</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">BLOCK n:END</span><br></pre></td></tr></table></figure>\r\n<p>假设用它来验证妙极性（角谷猜想最后的1-4-2-1-4-2循环），那么，如果输入的N是妙极的，那么程序会返回YES，如果是非妙极的，那么要么程序返回非1-4-2的循环，要么干脆没有返回永不停歇。后面这种情况就是个<strong>无终止过程</strong>。对于FlooP多出来的无终止过程，可以和有终止过程分成两类。那么对于每个FlooP程序，我们是否可以通过一个复杂的<strong>有终止过程</strong>的检测可以得到它是否无终止过程呢？如果存在这种检测，我们就可以通过它的返回验证妙极性和乌龟猜想了。</p>\r\n<p>首先我们需要改造BlooP，让它可以接受程序而非数字。哥德尔配数可以帮我们完成。将程序的字符映射成数字即可。阿兰·图灵使用对角线法类似的思路（往这种终止检验程序中输入它自己的哥德尔数）证明不存在这样的BlooP函数。书中用另外的方法做了证明。</p>\r\n<p>类似蓝对角，我们构造同样的<strong>绿对角</strong>（绿灯和free对应）：<code>绿对角[N]=1+绿程序&#123;N&#125;[N]</code>。现在问题来了，由于F库中还存在无终止过程，我们需要把它们剔除。刚才提到的“终止检测器”可以帮我们实现，经过它的过滤得到的绿程序我们可以叫做红程序（总会遇到红灯停下）。之后红对角会面临和蓝对角一样的困境。</p>\r\n<p>要么我们用GlooP表示一个比FlooP更强大的存在，要么接受不存在这样的终止检测器。但实际上，我们现在的计算机语言只能做到FlooP的地步。阿兰·图灵和阿朗佐·丘奇定理独立论证了不存在这样的GlooP：</p>\r\n<ul>\r\n<li>人能计算的就是机器能计算的</li>\r\n<li>机器能计算的就是FlooP能计算的</li>\r\n<li>人能计算的也就是FlooP能计算的</li>\r\n</ul>\r\n<h3 id=\"g弦上的咏叹调\">G弦上的咏叹调</h3>\r\n<p>小品里对使用-引用做了讨论，提出了自引用的说法，如“‘放在其引文形式后面得到假句子’放在其引文形式后面得到假句子”。</p>\r\n<h2\r\nid=\"论tnt及有关系统中形式不可判定的命题\">论TNT及有关系统中形式不可判定的命题</h2>\r\n<blockquote>\r\n<p>证明对、㧟摁、算术㧟摁、哥德尔第二定理、ω不完全性</p>\r\n</blockquote>\r\n<p>在上面的小品引导下，本章逐步用自引用和反例构成悖论，体现TNT的ω不完全性。首先，在前面的章节里能看到，通过<strong>哥德尔配数法</strong>，TNT有自省能力，即可以表述自身。再结合上一章中的<strong>对角线方法</strong>，两个关键概念已经集齐。</p>\r\n<p>为了制造自我指涉，首先引入<strong>证明对</strong>的概念——<strong>两个自然数（m和n）形成一个证明对，当且仅当m是TNT推导的哥德尔数，n是推导最后一行（即结论）的哥德尔数</strong>。例如：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WJ</span><br><span class=\"line\">WJJ</span><br><span class=\"line\">WJJJJ</span><br><span class=\"line\">WUJ</span><br></pre></td></tr></table></figure>\r\n<p>从而m=3131131111301和n=301时构成证明对。TNT也是一个道理。要证明一对mn是证明对是很简单的，观察m代表的推导过程有无问题，以及n是不是最后一行的结论。从而</p>\r\n<ul>\r\n<li>“是证明对”这个性质是原始递归的，即可以用一个BlooP程序测试；进一步地，<strong>可以被一个有两个自由变元的公式在TNT中体现</strong>（这一步很关键）</li>\r\n<li>要断定n是一个<strong>定理数</strong>，就是要找到一个m和n构成证明对</li>\r\n</ul>\r\n<p>上面提到的BlooP测试程序写成TNT的形式，用WJU系统可以叫做<code>WJU-PROOF-PAIR&#123;a,a'&#125;</code>，自由变元<code>a</code>和<code>a'</code>可以接受2个WJU形式系统的哥德尔数，检测它们是否构成证明对。同样的，在TNT系统里叫做<code>TNT-PROOF-PAIR&#123;a,a'&#125;</code>。假设我们要表示<code>0=0</code>是TNT定理，那么TNT公式可以写成<span\r\nclass=\"math inline\">\\(∃a:TNT-PROOF-PAIR\\{a,\r\nSSS...SSS0/a&#39;\\}\\)</span>，其中有a’的值666,111,666（<code>0=0</code>）个S。OK，目前为止，我们已经将是TNT定理数<strong>表示</strong>出来了</p>\r\n<p><span\r\nclass=\"math display\">\\[∃a:TNT-PROOF-PAIR\\{a,a&#39;\\}\\]</span></p>\r\n<p>但并未担保这个性质原始递归。之后，让我们将<strong>代入</strong>引入到哥德尔数里，代入即将所有自由变元都用数字替换。同样的，哥德尔数表示后也可以做这个替换，例如将<span\r\nclass=\"math inline\">\\(a=a\\)</span>替换为<span\r\nclass=\"math inline\">\\(SS0=SS0\\)</span>，对应的哥德尔数就从262,111,262替换为123,123,666,111,123,123,666。容易看到这个<code>哥德尔数&lt;-&gt;插入的具体数字&lt;-&gt;结果哥德尔数</code>的关系是<strong>原始递归</strong>的，即可以写一个BlooP测试，验证给的3个数字是否满足这个关系（都翻译回TNT表示，再观察即可）。从而，可以用一个有三个自由变元的TNT公式来体现。</p>\r\n<p><span class=\"math display\">\\[SUB\\{a,a&#39;,a&#39;&#39;\\}\\]</span></p>\r\n<p>将满足上面关系的3个数代入公式，就可以得到一个TNT定理。例如<span\r\nclass=\"math inline\">\\(SUB\\{SSS...SSS0/a,SS0/a&#39;,SSS...SSS0/a&#39;&#39;\\}\\)</span>，其中第一个参数有262,111,262个S，第三参数有123,123,666,111,123,123,666个S。</p>\r\n<p>接下来引入“<strong>算术㧟摁</strong>”（自引用）的概念，试图把<code>TNT-PROOF-PAIR</code>和<code>SUB</code>合成一个单一的TNT句子。我们定义将<strong>公式自身的哥德尔数代入公式</strong>称为㧟摁，得到一种谈论自身的公式的感觉。首先需要一个至少一个自由变元的公式如<span\r\nclass=\"math inline\">\\(a=S0\\)</span>，接入代入它的哥德尔数262,111,123,666得到<span\r\nclass=\"math inline\">\\(SSS...SSS(262,111,123,666个S)0=S0\\)</span>。既然是代入，<strong>算术㧟摁</strong>就可以用<span\r\nclass=\"math inline\">\\(SUB\\{a&#39;&#39;,a&#39;&#39;,a&#39;\\}\\)</span>来表示，里面前两个参数是相同的，可以观察到对角线法的影子，这里数<code>a''</code>既作为公式的哥德尔数，又作为代入的数字。为了便于使用，我们简记为</p>\r\n<p><span\r\nclass=\"math display\">\\[ARITHMOQUINE\\{a&#39;&#39;,a\\}\\]</span></p>\r\n<p>用汉语说就是，<code>a'</code>是哥德尔数为<code>a''</code>的公式做算术㧟摁（即代入<code>a''</code>）所得公式的哥德尔数，换句话说，<strong>a'是a''的算术㧟摁化</strong>。</p>\r\n<p>现在为止，两个组件都有了。现在给出那个<strong>㧟摁一个提及㧟摁的句子</strong>。</p>\r\n<p><span\r\nclass=\"math display\">\\[~∃a:∃a&#39;:&lt;TNT-PROOF-PAIR\\{a,a&#39;\\}&gt;∧ARITHMOQUINE&lt;a&#39;&#39;,a&#39;&gt;\\]</span></p>\r\n<p>这个符号串当然有一个哥德尔数，叫它<code>u</code>吧。我们现在要㧟摁这个符号串，即把唯一的自由变元<code>a''</code>替换成u。得到<span\r\nclass=\"math inline\">\\(~∃a:∃a&#39;:&lt;TNT-PROOF-PAIR\\{a,a&#39;\\}&gt;∧ARITHMOQUINE&lt;SSS...SSS(u个S)/a&#39;&#39;,a&#39;&gt;\\)</span>。考虑到它和哥德尔的用法接近，我们叫它<code>G</code>。好的，现在问题来了</p>\r\n<ol type=\"1\">\r\n<li>G的哥德尔数是什么？</li>\r\n<li>G怎么解释？</li>\r\n</ol>\r\n<p>首先，既然G是对原符号串的㧟摁化，那么<strong>G的哥德尔数自然是u的算术㧟摁化</strong>。好，看第二个问题，从字面意义翻译可以得到“不存在数a和a’使得（1）它们形成TNT证明对，同时（2）a'是u的算术㧟摁化”。根据刚才的加粗，G的哥德尔数就是u的算术㧟摁化。那么肯定是a出了问题。现在可以简化翻译成“没有一个数a能与u的算术㧟摁化形成TNT证明对”，换句话说，“以u的算术㧟摁化为哥德尔数的<strong>公式G不是TNT定理</strong>”。那么这句话本身是谁呢？就是<code>G</code>。因此，我们可以得到最终翻译：</p>\r\n<p>“G不是TNT定理”（G是这句话本身）</p>\r\n<p>我们构造出了一个TNT元语言句子。这句看着就有悖论意味的话可以很容易找到矛盾。如果G这句话是定理，那么G就是TNT中的真理，这和G在说的矛盾。如果G不是定理，那么就存在一个不是TNT定理的真理，也有矛盾。这个定理在TNT系统中<strong>无法判断真假</strong>。上面这段过程用TNT和数论的语言结合自引用的思路构造出了悖论。</p>\r\n<p>哥德尔在论文中，对于在可以“自我反映的元数学”中证明TNT的一致性做了探讨。但最终通过类似上面的构造证明只要TNT一致——用TNT符号写出的一致性语句不是个TNT定理。可见纵然TNT在<strong>表示</strong>事物时，反省能力很强，但要<strong>证明</strong>这些事物，反省能力就比较差了。</p>\r\n<p>本书在第8章第一次介绍印符数论的的时候提到过ω不完全性，即无法从特例到规律。上面找到的G就是一个例子。将里面a''替换成每个具体的数，都可以验证为真，但对G就无法判断。可以用第8章的方法，人为定义G的真假，来朝非欧几何一样的方向发展，但无论怎么加都会和我们对自然数的认识抵触。书里发明了超自然数和广义自然数的概念来解释，它们和自然数的性质没什么区别，但可以兼容<span\r\nclass=\"math inline\">\\(G\\)</span>或者<span\r\nclass=\"math inline\">\\(~G\\)</span>。G和~G的证明需要无穷步，因此不会干扰正常的自然数性质，对正常生活没有影响，但对元数学家有很重要。在本章最后，作者又将丢番图方程是否有整数解和数论中的G关联了起来。</p>\r\n<h3 id=\"生日大合唱哇哇哇呜啊呜啊呜啊\">生日大合唱哇哇哇呜啊呜啊呜啊</h3>\r\n<p>小品里乌龟用近乎无理取闹的方式给了ω答案模式和之后的各种迭代，只为证明阿基里斯生日的事实，同时为下章试图跳出系统的构造方法设好铺垫。</p>\r\n<h2 id=\"跳出系统\">跳出系统</h2>\r\n<blockquote>\r\n<p>多重分叉，本质不完全性</p>\r\n</blockquote>\r\n<p>在上一章里，我们发现在TNT里存在一个“漏洞”——存在一个不可判定的句子G。那如果把这个漏洞补上呢，构造一个TNT+G的形式系统。对于TNT+G也可以同样<span\r\nclass=\"math inline\">\\((TNT+G)-PROOF_PAIR{a,a&#39;}\\)</span>的思路构造一个G'（用TNT+G的字符串表示我在形式系统TNT+G中不可证）来制造矛盾。这种不断给漏洞打正反命题的方式（G，~G）在TNT下形成了多重分叉的树。</p>\r\n<p>然而，加入补丁后的形式系统仍可以找到“我在形式系统X中不可证”的字符串。所有这些“漏洞”构造方式相似，似乎可以找到一条公理模式<span\r\nclass=\"math inline\">\\(G_{ω}\\)</span>来表示所有这些G、G'、G''。那么我们把<span\r\nclass=\"math inline\">\\(G_{ω}\\)</span>加入到TNT中呢，能否补全这个漏洞。但既然有一个模子<span\r\nclass=\"math inline\">\\(G_{ω}\\)</span>来刻画G，也会有一种方法用算术模子来描述其对应的哥德尔数。用公式<span\r\nclass=\"math inline\">\\(OMEGA-AXIOM{a}\\)</span>描述，它的解释是<strong>a是出自<span\r\nclass=\"math inline\">\\(G_{ω}\\)</span>一条公理的哥德尔数</strong>。借助这个公式，就可以在<span\r\nclass=\"math inline\">\\(TNT+G_{ω}\\)</span>内部体现<strong>T<span\r\nclass=\"math inline\">\\(TNT+G_{ω}\\)</span>证明对</strong>的更复杂的概念。从而可以用一模一样的套路构造一个用来算术㧟摁的字符串，之后继续不可判定。我们叫它<span\r\nclass=\"math inline\">\\(TNT+G_{ω+1}\\)</span>。为什么<span\r\nclass=\"math inline\">\\(G_{ω}\\)</span>没法生成出<span\r\nclass=\"math inline\">\\(G_{ω+1}\\)</span>呢？答案是它自身还没有“聪明”到意识这一点。就像乌龟制造“不能播放的唱片”一样。</p>\r\n<p>依照哥德尔的手段，一个系统本身的性质在证明对概念之内得到反映，然后再针对它使用这些性质，就可以“以子之矛，攻子之盾”。一个系统不论多复杂，都能进行哥德尔配数，因而就能定义证明对。这其实和康托尔的对角线法类似——<strong>明确地排列</strong>一组实体。在康托尔的办法里，实数们的“详细梳理完毕”导致了无法自圆其说。在构造出不在列表里的数L后，把它添加进去试图弥补漏洞，只会得到一个新的漏洞L'。一旦<strong>确定了唱机的“体系结构”</strong>，唱机就必然会被找到弱点。因此TNT患上的是<strong>本质不完全性</strong>——这种不完全性就是TNT的基础组成部分。事实上，在一个系统里，能否利用哥德尔的自指办法构造不可判定的字符串，只依赖下面三个条件：</p>\r\n<ol type=\"1\">\r\n<li>系统要做足够丰富，以便容纳所有关于数的描述，不管是真是假（能构造命题）</li>\r\n<li>所有一般递归关系都可以用系统公式体现（能进行推导）</li>\r\n<li>公理和根据系统规则得到的印符模式，都能通过<strong>有限过程</strong>来辨识（能形式化证明）</li>\r\n</ol>\r\n<p>任何这样的系统在内部存在“黑洞”，这种系统强得能有自指句子，也因此自我崩塌。</p>\r\n<p>书中后面引用了卢卡斯的观点——由于哥德尔式论证的存在，人类思想具有某种难以捉摸、不可名状的特点，这使得“机械自动机”——计算机无法达到人工智能的高度。看起来很显而易见，毕竟人们总能跳出系统，在机器身上实施哥德尔手段（思路类似于计算机依赖刻板的内部编码-&gt;同构于形式系统-&gt;可以完成原始递归算术-&gt;上了哥德尔的“圈套”），所以我们总是知道的更多。作者并不赞同这种观点，本质在于我们总是<strong>处于系统之外</strong>，但机器不是，就像二维生物无法想象三维生物的细节一样。看起来我们在写出哥德尔方法的公式，但我们写出哥德尔方法的过程也是机械式的从ω到ω+1，再到<span\r\nclass=\"math inline\">\\(ω_{ω}\\)</span>，<span\r\nclass=\"math inline\">\\(ω_{ω+1}\\)</span>，而无法跳出系统之外。</p>\r\n<p>更直观一点，人本身也无法很好处理哥德尔手段的文字圈套，即<strong>悖论</strong>，如“我这句话是假话”、“只给不给自己理发的人理发的理发师”。人的大脑也没法做到前后一致的理解。人类无法超越自身就像计算机无法跳出自身一样。TNT可以讨论自身，却不能跳出自身——一个计算机程序可以修改自己，但不能违背自己的指令。</p>\r\n<p><strong>跳出自身，化身观察者</strong>成为了后面的论题。书里从文学作品说到禅宗。禅宗顿悟的过程也是这样的过程——<strong>逐步加深一个人的自我意识，逐步扩展“系统”的范围，最终感到和整个宇宙一致，突破自己达成顿悟</strong>。</p>\r\n<h3 id=\"一个烟民富于启发性的思想\">一个烟民富于启发性的思想</h3>\r\n<p>小品里讨论了自我复制的病毒、尝试拍摄自身的摄影机和显示器、自我指代的马格利特的画作。</p>\r\n<h2 id=\"自指和自复制\">自指和自复制</h2>\r\n<blockquote>\r\n<p>自复制、副本、印符遗传学、串、基、酶、氨基酸、核糖体、翻译、转录、DNA、mRNA、tRNA、蛋白质、中心法则、反馈、分化</p>\r\n</blockquote>\r\n<p>在上章借助自指构造矛盾后，这一章开头给出了很多自指或者自复制的例子，包括但不限于：</p>\r\n<ul>\r\n<li>本句子有七个字这种自我描述的句子</li>\r\n<li>可以打印自身函数体的程序</li>\r\n<li>打印自身哥德尔数的程序</li>\r\n<li>凯姆式自复制（输入一条会导致打印自身的错误信息）</li>\r\n</ul>\r\n<p>在对原件和复件做了不同层级的探讨后，引入了本章的主要内容：作者发明的印符遗传学，和遗传学相似但又有些改造的模型，在分子生物学之上、遗传学之下。印符遗传学有着和遗传学一样的<strong>基</strong>：</p>\r\n<ul>\r\n<li>A（腺嘌呤）</li>\r\n<li>C（胞嘧啶）</li>\r\n<li>G（鸟嘌呤）</li>\r\n<li>T（胸腺嘧啶）</li>\r\n</ul>\r\n<p>在前面的章节我们已经发现了这四个字母碰巧也可以代表A（阿基里斯，Achilles），C（螃蟹，Crab），G（基因，Gene），T（乌龟，Tortoise）把这些符号连一起可以构成<strong>串</strong>，串可以被印符酶（简称为<strong>酶</strong>）操作，移动、插入、删除等等。另外，嘌呤（A、G）和嘧啶（C、T）可以相互配对，其中A和T、C和G。酶可以使用的指令有15种，它们都有一个3个字母的代号，就像机器语言里一样，如cut、mov、rpy等，这样一个指令称为<strong>氨基酸</strong>，酶正是由氨基酸构成的。因此，一个串会按照氨基酸的指令逐步被处理，最终得到新串。</p>\r\n<p>那么串和酶还有什么关系呢？刚刚得到的新串，可以按照一个新的规则（书中叫做印符遗传密码）在核糖体里“翻译”成一个个氨基酸，并最终构成酶。例如，AC可以翻译为cut。具体可以参见下面的表格。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th></th>\r\n<th>A</th>\r\n<th>C</th>\r\n<th>G</th>\r\n<th>T</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>A</td>\r\n<td></td>\r\n<td>cut(s)</td>\r\n<td>del(s)</td>\r\n<td>swi(r)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>C</td>\r\n<td>mvr(s)</td>\r\n<td>mvl(s)</td>\r\n<td>cop(r)</td>\r\n<td>off(l)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>G</td>\r\n<td>ina(s)</td>\r\n<td>inc(r)</td>\r\n<td>ing(r)</td>\r\n<td>int(l)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>T</td>\r\n<td>rpy(r)</td>\r\n<td>rpu(l)</td>\r\n<td>lpy(l)</td>\r\n<td>lpu(u)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>注意到表格单元格的最后，括号里的符号表示了氨基酸的前进方向，这也形成了酶的三级结构，s代表straight，l代表left、r代表right。之后我们把第一段氨基酸调整到指向右边，那么根据最后一段的指向，分别代表酶初始化挂载的基是A还是C、G、T。可以发现，在确定酶的三级结构上，所有氨基酸都发挥了作用。另外，AA代表标点符号，标识一段串的结尾。</p>\r\n<p>读串并生成新的酶的过程，实际上由核糖体完成。至此，我们就可以从最初的串生成新的酶，新的酶又可以继续作用在串上形成新的酶，如此不断往复。在印符遗传学里，中心法则就是<strong>酶-印符操作-&gt;串-核糖体翻译-&gt;酶</strong>。在这个循环里，串既充当了程序的作用，又充当了数据的作用。到这里，又和TNT有点像了。</p>\r\n<p>生物学里的情况和这里很像。DNA就是“串”，蛋白质就是“酶”。DNA由核苷酸长链组成，核苷酸上的基标识了不同的核苷酸，正是A、C、G、T。核苷酸间通过共价键紧密连接，DNA双链间互补的核苷酸通过弱得多的氢键相连。在细胞核内部，DNA的一条链通过RNA聚合酶<strong>转录</strong>得到信使RNA（mRNA）。RNA和DNA的不同在于U（尿嘧啶）取代了T和A配对。核糖体其实不止制造酶，而是所有蛋白质。同时氨基酸共有20多种。mRNA在核糖体上的<strong>翻译</strong>过程和印符遗传密码类似，不过是以三个基为单位，如CAU产生组氨酸（his）。氨基酸间通过更强的共价键（肽键）组成蛋白质，蛋白质的三级结构比印符遗传学复杂得多，最终的结构和每个酶的关系目前也没有结论。在翻译过程中，需要的氨基酸，由对应的转运RNA（tRNA）运送过来。最后，UAA、UAG、UGA发挥着印符遗传学里AA的标点作用，表示一段翻译的结束。从DNA到蛋白质的过程便是如此。蛋白质和音乐有着一些相似，氨基酸就像印符，其连接起来组成的二级和三级结构就像旋律、乐章给人的乐曲感。并行工作的RNA聚合酶和核糖体产出多个蛋白质就像卡农的多个声部一样。</p>\r\n<p><strong>RNA聚合酶和核糖体（由蛋白质和rRNA组成）外加DNA就组成了一个自复制的最小支撑系统</strong>，DNA在其中既作为待复制的“数据”，又作为需要执行什么操作的“指令”。从DNA到蛋白质的过程称为<strong>基因表达</strong>。蛋白质再往上若干个我们无法把握的层次从遗传型跃升到表现型，从而决定人的精神、心智、物理表现。遗传学的中心法则和TNT的中心法则一一映射，其中DNA即TNT串，mRNA即数论描述，蛋白质即元TNT的陈述，遗传密码即哥德尔编码。有意思的是，数理逻辑在嘌呤一方（算术化（Arithemetization）、哥德尔（Godel）），分子生物学在嘧啶一方（翻译（Translation），克里克（Crick）），同时A和T构成基对，C和G构成基对。</p>\r\n<p>那么问题来了？按这个映射，哥德尔不完全定理对应什么？借《对位藏头诗》小品里的唱机和唱片，得到这样的描述</p>\r\n<p><em>总可以设计一个DNA串，如果把它注入到细胞中，在被转录时它将促使一些将会毁掉这个细胞的蛋白质或DNA生成出来</em></p>\r\n<p>当然这在分子生物学家那里看来有些诡异。不过和噬菌体摧毁大肠杆菌有点像。噬菌体的DNA通过伪装绕过了大肠杆菌细胞内的酶的检查，使之可以被核糖体翻译出来。有趣的是噬菌体（T方）和细胞（Cell）的TC之争就像乌龟（Tortoise）和螃蟹（Crab）之争。<strong>对于能否在特定的细胞内形成的“噬菌体句子”，在数理逻辑里有对应的描述——汉肯句子</strong>。隐式汉肯句子在说“存在某个符号串序列是我的推导”，显示汉肯句子是说“这里描述的符号串序列...就是我的推导”。前者就像只给DNA病毒组成编码的自组装病毒，可以自行利用化学亲和力链接，后者还加上了组装需要的酶。</p>\r\n<p>细胞分化形成不同功能的细胞，最终形成不同形态。这个过程是通过阻遏让基因不被表达实现的，诱导物又可以和阻遏蛋白结合，阻止阻遏的发生。整体来看，细胞里发生的这一切的机制比人为设计出来的形式系统都要深奥的多。在这各种过程里，DNA、蛋白质、核糖体、tRNA分子它们即可以作为“数据”、也可以作为“程序”、也可以作为“解释程序”或者“处理机”。巧合的是，人工智能研究里也有着把看上去不同的所有方面混为一谈的趋势。</p>\r\n<h3 id=\"的确该赞美螃蟹\">的确该赞美螃蟹</h3>\r\n<p>小品里把TNT命题类比乐曲，命题的真假类比乐曲是否悦耳。</p>\r\n<h2 id=\"丘奇图灵塔斯基和别的人\">丘奇、图灵、塔斯基和别的人</h2>\r\n<blockquote>\r\n<p>丘奇定理、塔斯基-丘奇-图灵定理、拉马努金、真理</p>\r\n</blockquote>\r\n<p>在上一章把话题引向生物学后，这一章又回到对于思维的讨论。书中在“大脑与思维”一章里实际上已经做了很多探讨，思维有无数层面，它还有一个形式化的硬件层级（可以叫它基底）。在从下到上的不断“组块化”下，每一步都会损失严格性，直到顶层复杂到我们找不到词汇去思考规律。</p>\r\n<p>在小品里螃蟹似乎有一种<strong>直觉</strong>可以区分出音乐是不是优美。然而这违背了丘奇定理：<strong>没有切实可靠的方法来区分TNT的定理和非定理</strong>。类似地还有塔斯基-丘奇-图灵的描述：没有切实可靠的方法来区分真的数论语句和假的数论语句。它还有许多表述形式：</p>\r\n<ul>\r\n<li>标准形式：把数分成两类的任何一个心智过程都可以用FlooP程序来描述</li>\r\n<li>大众过程形式：把数分成两类的任何一个可以用语言完美传达的心智过程都可以用FlooP程序来描述</li>\r\n<li>同构形式：把数分成两类的任何一个可以用语言完美传达的心智过程都可以用FlooP程序来描述，且<strong>心智过程和FlooP在下面意义上同构：某个层次上，计算机和大脑执行的步骤间存在对应</strong></li>\r\n</ul>\r\n<p>拉马努金和一些神童似乎有神谕一般突破这种限制的能力，似乎能绕过数学、分析的方法解决问题，不过这只是因为这些人的中间步骤完成的十分迅速而已，他们也不是通过某种顿悟式的闪念来得到答案。有一个简单的证据是，当数字变大时，答案出来的就慢了。</p>\r\n<p>大脑的神经元活动作为基质，本身并没有意义，它之上各种符号的意义是在进化环境中作为后效出现的。因此计算机在模拟神经元网络时，原则上可以用可执行的计算来描述。可以因此给出丘奇-图灵命题的另外2种形式:</p>\r\n<ul>\r\n<li>微观形式：生物体各组成部分的行为可以用计算机来模拟，也就是说，任何元素的行为都可以用一个FlooP程序来计算到任意精确的程度</li>\r\n<li>简化论形式：<strong>全部的大脑过程可以用一个可计算的基质导出</strong>，这也是人工智能可行性的理论基础；人工智能的一个意义在于可能会有一些意义重大的智能特征是漂浮在这种生物大脑基质以外的基质之上的。</li>\r\n</ul>\r\n<p>当然，人工智能绝不只是简单的大脑模拟。</p>\r\n<p>回到螃蟹的问题，美感是不是大脑过程；对此，作者认为大脑能做的某些事情都可以用计算机来模拟，但计算机不能代替灵魂。尽管美感是个非理性过程，但不代表它和计算机就不相容。因为，<strong>低层次的理性不妨碍高层次的非理性</strong>。大脑都是由简单的神经元组成，但也会想出悖论，换句话说，<strong>大脑是理性的，但心智不是</strong>。书里用类似的说法，驳斥了卢卡斯机器不如心智的观点，然后给出了丘奇-图灵论题的最后一种形式。</p>\r\n<ul>\r\n<li>人工智能形式：任何种类的四年制过程都可以用计算机程序模拟，而程序语言和FlooP一样强，也可以说递归函数都可以用这种语言程序化。</li>\r\n</ul>\r\n<p>美来源于形式，形式通过共鸣来传达，无法语言传递。字面意义的“句法性质”很好表述，但是形式的<strong>语义</strong>方面则需要无尽头的检验，它是经验编码的，和无数客体存在联系，且在不同人心里都可能引起不同解释器的反应。</p>\r\n<h3 id=\"施德鲁人设计的玩具\">施德鲁，人设计的玩具</h3>\r\n<p>小品展示了“施德鲁”这个新的AI模型对语言的理解。</p>\r\n<h2 id=\"人工智能回顾\">人工智能：回顾</h2>\r\n<blockquote>\r\n<p>图灵测试、人工智能、知识表示</p>\r\n</blockquote>\r\n<p>图灵在自己对计算机和智能的研究中，提出过图灵测验的过程，即机器能否在交谈中向人隐藏自己是机器的能力，图灵对于机器是否能有思维的讨论在那个年代遇到了许多反对意见。在作者的年代，人工智能很显然进步了许多，后面的篇幅对于人工智能的发展现状做了简单的综述式的介绍。</p>\r\n<p>人工智能的起步很早，在19世纪，布尔和德·摩根就提出了“思维定律”——本质上是命题演算——因此迈出人工智能软件的第一步。随着时代的服战，越来越多“智能”的成果涌现出来。似乎<strong>某个心智功能被程序化之后，人们一旦习惯这种存在便不再把它当做“真正的思维”本质成分</strong>。换句话说，目前为止，<strong>人工智能是尚未做到的部分</strong>。书里列出了人工智能的下面一些领域：</p>\r\n<ul>\r\n<li>机器翻译</li>\r\n<li>博弈\r\n<ul>\r\n<li>象棋</li>\r\n<li>跳棋</li>\r\n<li>围棋</li>\r\n<li>五子棋</li>\r\n<li>扑克</li>\r\n<li>桥牌</li>\r\n</ul></li>\r\n<li>数学定理证明</li>\r\n<li>数学符号处理\r\n<ul>\r\n<li>积分</li>\r\n<li>化简</li>\r\n<li>级数求和</li>\r\n</ul></li>\r\n<li>视觉\r\n<ul>\r\n<li>文本识别</li>\r\n<li>图像识别</li>\r\n</ul></li>\r\n<li>听觉\r\n<ul>\r\n<li>词汇识别</li>\r\n<li>语句时别</li>\r\n</ul></li>\r\n<li>自然语言理解\r\n<ul>\r\n<li>特定领域回答问题</li>\r\n<li>复杂句的语法分析</li>\r\n<li>基于现实世界理解一段话</li>\r\n<li>解决有歧义的指代关系</li>\r\n</ul></li>\r\n<li>自然语言生成\r\n<ul>\r\n<li>抽象的诗</li>\r\n<li>随机的语段</li>\r\n<li>输出内部知识表示</li>\r\n</ul></li>\r\n<li>创造艺术\r\n<ul>\r\n<li>写诗</li>\r\n<li>写小说</li>\r\n<li>计算机绘画（AIGC）</li>\r\n<li>音乐创作</li>\r\n</ul></li>\r\n<li>类比思维\r\n<ul>\r\n<li>启发式数学证明</li>\r\n</ul></li>\r\n<li>学习\r\n<ul>\r\n<li>形成概念</li>\r\n<li>参数调整</li>\r\n</ul></li>\r\n</ul>\r\n<p>后面的章节里，对各领域做了简单的介绍，在机器翻译、棋类策略、数学证明、音乐创作里都能看到，机器似乎只是把编程者的思维具体展现了出来，它本身还是做的机械式的事情。在定理证明里，人工智能使用了问题分解的手段，把一个总目标分解成要推导的局部目标，然后在不断递归，最终到可以明确看到路径的地步。不过问题分解的路径也是有讲究的，有些看似“绕远路”的路径实际上在全局上确实更近的解法。而发现这一点需要一些<strong>直觉</strong>，也许这种直觉就是智能的灵光一闪。这也像在之前讨论过的W方式和J方式，需要W方式跳出系统观察才能发现捷径。</p>\r\n<p><strong>知识表示</strong>在人工智能李也是重要的命题，它可以以描述性（死记硬背）的也可以是过程性（需要推导）的，前者像是DNA，存储体积更小，像是“<strong>数据</strong>”一样；后者像是蛋白质，体积更大但有可操作性，就像“<strong>程序</strong>”一样。组块化的知识之间也可能存在着相互联系。知识的表示和加工有<strong>演绎式</strong>和<strong>类比式</strong>。前者更像数理逻辑里的推导过程，后者则通过同构的思路唤起知识。当一个人在遗忘的时候，往往是指<strong>失去了通往相关信息的通路，而不是物理上删除或损坏了</strong>。</p>\r\n<p>在本章的后半段，书中对自然语言和音乐的语法做了探讨。最后对“施德鲁”里使用的高级Planner语言做了介绍，自然语言里<strong>句法</strong>和<strong>语义</strong>的混杂让语句的理解变得困难，一个解决办法就是通过设计Planner这样的高级语言去提供更靠近自然语言的可能性。</p>\r\n<h3 id=\"对实\">对实</h3>\r\n<p>小品里，借由阿基里斯和螃蟹邀请乌龟和树懒来家里做客看橄榄球赛，展示了一个可以展现不同假设反应到实际的电视机，小品和电视机里都出现了矛盾的画面，比如两只左手。</p>\r\n<h2 id=\"人工智能展望\">人工智能：展望</h2>\r\n<blockquote>\r\n<p>框架、邦加德问题、模板、同一性检测器、概念网络、元描述、酶、裂变、聚变、受迫匹配</p>\r\n</blockquote>\r\n<p>在小品里，能看到一些偏离现实的虚拟场景，就像是“差一点儿”或者“万一……，那么”的这种想象。人类似乎很容易很容易在固定一些不变的场景下，想象可变部分变化后的样子。这也许这是创造力和洞察力来源的根本。同时，人们很容易区分出三种符号：</p>\r\n<ul>\r\n<li>有的符号是常量，我们默认它们不变，作为大背景出现，例如三维的世界，或者是看足球赛时候的规则</li>\r\n<li>有的符号是参量，在需要的时候变化，作为动态背景出现，例如天气、球赛的场地</li>\r\n<li>有的符号是变量，就是在心智里面最容易“滑来滑去”的部分</li>\r\n</ul>\r\n<p>在人工智能研究中，存在<strong>框架</strong>的概念，框架可以理解成一套上下文，在不提供更多信息时它带有默认值，如夜晚的框架就会有一个月亮，框架之间也可以相互插入。后面作者用邦加德问题来谈论了模式识别里的一些方法论，并类比人类从基因里集成的难以捉摸的性质。如</p>\r\n<ul>\r\n<li>预处理成原子微词汇表，如三角形，原型</li>\r\n<li>更高层一点的描述，如上、下、大、小、平行、靠近</li>\r\n<li>使用<strong>模板</strong>试图构造描述，利用<strong>同一性检测器</strong>概括模式规律。其中模板通过微词汇关联得到的<strong>概念网络</strong>来启发式生成，而同一性检测器则去检查模板的正确性</li>\r\n<li>有的模式可能需要在更高层总结，这时需要用<strong>滑动</strong>来尝试，从而“发明”一些概念</li>\r\n<li>更进一步的，可以在得到的模板里发现共性，从而得到<strong>元描述</strong>，譬如，某个模板里的槽都会被填入“三次”</li>\r\n<li>有时还需要用集聚和过滤的办法来忽略一些细节抑或关注一些系列</li>\r\n</ul>\r\n<p>之后，书里将邦加德问题里的思路联系到科学研究和人类思维中，甚至是和酶做了类比，进入提出符号聚变和裂变的概念。这段意在将好几个不同领域的概念放到一起找相同点，但写得有点神神叨叨了。之后对于概念骨架（比喻对象间的共同点）和多重表示（一个概念的多种理解来跟比喻对象匹配上）的介绍也是有点陶醉在自己的世界里。</p>\r\n<p>在之后，书里提出了“出入口”的概念，即脑海里的意象——事件、对象、思想——都有一个“把柄”，譬如收音机的把柄可以是“音乐产生器”或者“烦恼解除器”，在这些把柄间存在精神隔板，避免人在自由联想时过于自由。但这种隔板也不百分百牢靠，就像懂得多种语言的翻译在翻译某个词的时候，就可能想到另外一种语言上的答案。</p>\r\n<p>在艺术作品里，<strong>受迫匹配</strong>经常出现。即强行寻找意象和本质的深刻同构，事物的各种细节是如此之多，以至于这种同构基本都能成功。譬如在政治漫画里画了一个政治家和一头大象，观者总有办法将他们关联起来。当然受迫匹配也有优劣之分，要不能太浅显也不能太牵强才是最妙的。就像和弦一样，离得太近太远都不好听，得是恰好的距离。</p>\r\n<p>本章最后，作者用设问的方式抛出了10个和人工智能未来有关的问题，里面比较有意思的观点有：</p>\r\n<ul>\r\n<li>程序在有人类一样复杂的情感前，只能谱写机械式的乐曲，缺失灵魂</li>\r\n<li>情感无法在机器中模拟，机器只能做到哭这件事情，但没法体会到哭代表的情绪</li>\r\n<li>人工智能的终点做加法可能比现在的机械计算机还慢</li>\r\n<li>当人工智能足够智能时，人将无法精准控制它，就像人无法精准控制另一个人一样</li>\r\n<li>终极人工智能可能和我们想象的很不同，人看待终极人工智能时也许并不能理解，就像人无法理解另一颗星球上拥有智能的外星人一样</li>\r\n</ul>\r\n<h3 id=\"树懒卡农\">树懒卡农</h3>\r\n<p>这则小品用树懒、阿基里斯、乌龟同构了巴赫的《音乐的奉献》中一首卡农，并命名树懒卡农。</p>\r\n<h2 id=\"怪圈或缠结的层次结构\">怪圈。或缠结的层次结构</h2>\r\n<blockquote>\r\n<p>缠结、怪圈、证据、心智、符号-对象、主义、无限升高的卡农</p>\r\n</blockquote>\r\n<p>本章作为全书最后一章，试图在上面所有章节谈论的事情间寻找一种共性。在开头，作者引入了塞缪尔的机器不具有创造性的观点——“机器所表现出来的‘意向’是实现已明确化的人类程序员的意向，或是依照程序员所指定的规则从这些意向中导出的子意向”，因此对意愿的任何机械化都需要一种无穷回归，因为机器在得到指令前不会做任何事。但其实像人一样，有些最底层的规则——它们不需要依赖“元规则”——是嵌入在硬件中的。就像人的动机都来自遗传的物理基质。</p>\r\n<p>在之后，梳理给出了可以自我表示的跳棋、作者三角形、艾舍尔的《画手》三个例子，它们都涉及自我指代的缠结层次，但也都有一个独立在缠结层次外的“不受影响”的观察层次，就像W方式一样。自我表示的跳棋里是不变的规则，作者三角形里是看书的读者，艾舍尔的《画手》里则是画作的欣赏者。在人类大脑心智中，缠结的符号层次下也有独立的神经元层次。</p>\r\n<p>现实生活也有能发现这种怪圈，比如政府里相互的信用背书，又或者伪科学证伪中对于证据的无穷递归证明，最终都可以通过更低层次的限制解决争议。不过要把哥德尔映射到其他学科上时，也不能迷信的<strong>逐字逐句翻译</strong>。它带来的只是启发价值，譬如</p>\r\n<ul>\r\n<li>我们人类在认识自己的心智和大脑时，是否也存在某种模糊的哥德尔式循环，限制个人认识自己心灵时所能达到的程度。</li>\r\n<li>所有元数学和计算理论中的限制性定理都说明：<strong>一旦表示自身结构的能力达到某个临界点，那就无法完整地表示自己</strong></li>\r\n<li>任何人都无法摆脱自我的神秘性，你可以幻想但没法跳出自己之外</li>\r\n<li>在科学领域经常被批评偏向主体-客体“二元论”，之前研究被观察对象很多，现在也开始更多研究观察者了，譬如量子力学里观察者相关研究和人工智能</li>\r\n<li>艺术中也有符号-对象二分法，符号即想表达的内容，对象即意象。在现代艺术中，也开始刻意混淆“使用”和“谈论”。譬如一些语义错觉画里赤裸地突出体现对象（马格利特作品里画之外的水果，烟斗）、Cage著名的《4分33秒》直接将空白作为符号。艺术作品本身的<strong>框架效应</strong>会让欣赏者试图寻找里面的意义，而艺术家本意则仅仅只是对象本身，这种禅宗式的艺术对象传达了缠结的层次结构，这也是现代艺术难懂的原因</li>\r\n</ul>\r\n<p>那么哥德尔定理会限制我们的心智吗？看起来是不会的。<strong>我们从神经元到符号中间的层次模糊和对心智的不可捉摸背后并非一定有某种哥德尔式的缠结。这可能仅仅是命运的一个偶然结果</strong>。我们大脑的进化碰巧未能强到理解它自己。但就像我们用W方式从更高角度去解释G的非定理性，也可能存在某个解释心智的高层方式，只是我们还没发现或发现不了而已。</p>\r\n<p>我们的意识和思想归根到底还是基于底层的<strong>物理因果关系</strong>，不过是不同层次的“共鸣”形成了几乎不可分析的高层符号。<strong>也只有到符号这个层次，我们才能谈论自我意志的存在</strong>，它在更下的层次只是无情的自然规律，而并非出自任何深切渴望。但这种符号并不能控制在它之下的所有内部过程，使得它的工作过程看起来是一种“直觉”，而缺乏完全的理解。</p>\r\n<p>本章的最后，又回到艾舍尔的《画廊》和巴赫《无限升高的卡农》，这两个作品里都有着自指的缠结。而在《无限升高的卡农》里，借助了<strong>谢泼德音调</strong>看起来在不断升高，但最后又回到原声调，就像本书一样，以巴赫《音乐的奉献》开始，又以它做结。</p>\r\n<h3 id=\"六部无插入赋格\">六部无插入赋格</h3>\r\n<p>最后一个小品借用阿基里斯、螃蟹、乌龟、“作者”、巴比奇、图灵6个角色，类比《六部无插入赋格》中的6个声部，最终引出本书和巴赫的《六部无插入赋格》和全书开头形成回环，实在是妙极。不仅如此，其中的内容设计也尽显精妙：</p>\r\n<ul>\r\n<li>阿基里斯开头在收音机里听到的讨论自由意志和决定论的6个学者类比小品里的6个角色</li>\r\n<li>“没有这种噪音我照样行”共出现6次，就像6个声部，最后一次是变奏的“有这种噪音我照样行”</li>\r\n<li>作者直接进入小品里作为角色出场，和书中的角色对话，打破了第四面墙，形成了神奇的缠结结构</li>\r\n<li>“无插入赋格”在小品里通过插在句子中10次出现，其中有1次3连出现和1次倒序连带正序出现</li>\r\n<li>“甭提多棒了”在小品里5次出现</li>\r\n<li>巴比奇和图灵相互编程实现对方实现了一种缠结</li>\r\n<li>“作者”和乌龟的交流介绍了本小品用人物模拟声部的思路，达成了自指</li>\r\n<li>螃蟹主题的音符是C-Eb-G-Ab-B-B-A-B，倒过来正是Babbage,C，即巴比奇</li>\r\n<li>“作者”、螃蟹、巴比奇三人用几乎一样的语段类比螃蟹主题里的波音</li>\r\n<li>乌龟、巴比奇、图灵三人用几乎一样的语段类比三和弦</li>\r\n<li>在小品后半段通过拆字的方式在语段中嵌入了“侯世达”，类比了巴赫在六部无插入赋格里的最高两个声部嵌入了自己的名字[BACH]</li>\r\n<li>小品的最后，大家在开始阅读本书之前，准备演奏《音乐的奉献》中《六部无插入赋格》，就像全书的开头一样，所以这个小品其实也是序章的引子，就像最后一句写的那样</li>\r\n</ul>\r\n<blockquote>\r\n<p>“<strong>无插入赋格</strong>”之后<strong>插入</strong>导言将<strong>赋</strong>有“无穷升高的卡农”的风<strong>格</strong></p>\r\n</blockquote>\r\n<p><em>--END--</em></p>\r\n",
            "tags": [
                "基因",
                "隐喻",
                "哥德尔",
                "巴赫",
                "埃舍尔",
                "人工智能",
                "心智",
                "自指",
                "图灵"
            ]
        }
    ]
}
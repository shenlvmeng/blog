{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"elm\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/",
            "url": "http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/",
            "title": "Elm——函数式前端框架介绍",
            "date_published": "2017-06-19T09:36:01.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Elm提出于2012年，最初出现在Evan Czaplicki的毕业论文中（掩面）。目标是提出一个面向web的函数式编程语言。它拥有诸多特性</p>\n<ul>\n<li>强类型语言</li>\n<li>一次编译，no runtime error</li>\n<li>状态不可修改</li>\n<li>函数是一级公民等</li>\n</ul>\n<p>Elm是门新语言，它是一个类似React（但绝对和它不一样）的前端框架。在Web App的设计它甚至启发了Flux设计的提出。在如今前端框架吸收函数式编程以及强类型语言优点的形势下，学习Elm可能会开启对Web前端开发的重新认识。</p>\n<p>再看完下面的介绍后，建议阅读两篇对Elm的评价，相信更有助于对这门年轻语言特点的理解：</p>\n<ul>\n<li><a href=\"https://medium.com/@ericdreichert/my-thoughts-on-elm-lang-b609d69cfa4d\">My thoughts on Elm Lang</a></li>\n<li><a href=\"https://hackernoon.com/some-thoughts-on-elm-development-39a0f8a9002a\">Some thoughts on Elm Development</a></li>\n</ul>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>Elm是通过将代码编译成JavaScript工作的。一个最简单的Elm App大概像下面这样：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Html <span class=\"keyword\">exposing</span> (<span class=\"type\">Html</span>, button, div, text)</span><br><span class=\"line\"><span class=\"keyword\">import</span> Html.Events <span class=\"keyword\">exposing</span> (onClick)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> =</span><br><span class=\"line\">  <span class=\"type\">Html</span>.beginnerProgram &#123; model = <span class=\"number\">0</span>, view = view, update = update &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Msg</span> = <span class=\"type\">Increment</span> | <span class=\"type\">Decrement</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Increment</span> -&gt;</span><br><span class=\"line\">      model + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Decrement</span> -&gt;</span><br><span class=\"line\">      model - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">view</span> model =</span><br><span class=\"line\">  div []</span><br><span class=\"line\">    [ button [ onClick <span class=\"type\">Decrement</span> ] [ text <span class=\"string\">&quot;-&quot;</span> ]</span><br><span class=\"line\">    , div [] [ text (toString model) ]</span><br><span class=\"line\">    , button [ onClick <span class=\"type\">Increment</span> ] [ text <span class=\"string\">&quot;+&quot;</span> ]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n\n<p>那么这样一个Elm文件是怎么应用在页面中呢？</p>\n<p>在<a href=\"http://elm-lang.org/\">Elm</a>安装完成后，会有4个Elm相关的包：</p>\n<ul>\n<li>elm-repl 命令行操作，在cli中感受Elm的语法特点</li>\n<li>elm-reactor 快速脚手架搭建</li>\n<li>elm-make 编译工具</li>\n<li>elm-package 包管理工具</li>\n</ul>\n<p>麻雀虽小，五脏俱全。</p>\n<h2 id=\"语法特点\"><a href=\"#语法特点\" class=\"headerlink\" title=\"语法特点\"></a>语法特点</h2><p>Elm在<a href=\"http://elm-lang.org/docs/syntax\">语法</a>上不同于C风格的所有语言，和Haskell更为靠近。</p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>用<code>--</code>开启单行注释，结合<code>&#123;&#125;</code>进行多行注释</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- a single line comment</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&#123;- a multiline comment</span></span><br><span class=\"line\"><span class=\"comment\">   <span class=\"comment\">&#123;- can be nested -&#125;</span></span></span><br><span class=\"line\"><span class=\"comment\">-&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>Elm是强类型语言，有Bool，Int，Float，Char，String 5种基本类型。有意思的是，<strong>Elm没有Null</strong>。这也是特别<a href=\"https://guide.elm-lang.org/error_handling/\">设计</a>的。</p>\n<div class=\"tip\">注意：Elm中Char类型用单引号`'`包裹，而String类型用双引号`\"`包裹。\n</div>\n\n<p>除了基本类型，Elm中还有List，Array，Tuple，Dict，Record几种泛型。其中List，Record设计类似JavaScript中的Array和Object。</p>\n<div class=\"tip\">在Elm中`Array`和`List`是两种不同的类型，前者通过链表实现，后者通过Relaxed Radix Tree实现。前者在增删节点上高效，后者在随机查询时高效。</div>\n\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">1</span> :: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">1</span> :: <span class=\"number\">2</span> :: <span class=\"number\">3</span> :: <span class=\"number\">4</span> :: []</span><br><span class=\"line\"><span class=\"title\">point</span> =                         <span class=\"comment\">-- create a record</span></span><br><span class=\"line\">  &#123; x = <span class=\"number\">3</span>, y = <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">point</span>.x                         <span class=\"comment\">-- access field</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">List</span>.map .x [point,&#123;x=<span class=\"number\">0</span>,y=<span class=\"number\">0</span>&#125;]   <span class=\"comment\">-- field access function</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; point | x = <span class=\"number\">6</span> &#125;               <span class=\"comment\">-- update a field</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; point |                       <span class=\"comment\">-- update many fields</span></span><br><span class=\"line\">    x = point.x + <span class=\"number\">1</span>,</span><br><span class=\"line\">    y = point.y + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>*(值得注意的是，上面的<code>::</code>和<code>.x</code>实际上都是函数)*。</p>\n<h4 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h4><p>类型是Elm中重要的一环，每个变量都需要有类型，编译时需要进行检查。因此显式地声明变量类型很重要。</p>\n<p>当我们需要通过基本类型构造复杂类型时，可以通过<code>type alias</code>的形式为record创建新的类型。在新类型创建的同时，会同步生成一个record构造函数。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- Before：麻烦的函数写法</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> : &#123; name : <span class=\"type\">String</span>, bio : <span class=\"type\">String</span>, pic : <span class=\"type\">String</span> &#125; -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> user =</span><br><span class=\"line\">  <span class=\"type\">String</span>.length user.bio &gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">-- After：简便的写法</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">User</span> =</span><br><span class=\"line\">  &#123; name : <span class=\"type\">String</span></span><br><span class=\"line\">  , bio : <span class=\"type\">String</span></span><br><span class=\"line\">  , pic : <span class=\"type\">String</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"title\">hasBio</span> : <span class=\"type\">User</span> -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> user =</span><br><span class=\"line\">  <span class=\"type\">String</span>.length user.bio &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Union类型\"><a href=\"#Union类型\" class=\"headerlink\" title=\"Union类型\"></a>Union类型</h4><p>之所以单独拿出来说，是因为Union Type的设计几乎是Elm的精髓。首先，它类似于枚举（enum）的概念，通过<code>type enum = A | B | C</code>的形式定义一个类型。这是简单的Union Type的使用。</p>\n<p>Union Type还有Tagged Union的用法。即下面这样。这意味着<strong>User可以是不带信息的Anonymous或带有String信息的Named</strong>。<code>Anonymous</code>和<code>Named</code>是User的两个构造函数。其中Named接受一个String类型入参构造User类型。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">User</span> = <span class=\"type\">Anonymous</span> | <span class=\"type\">Named</span> <span class=\"type\">String</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">注意：不同Union Type间的Tag构造函数不能同名，即不能出现下面的情况。同时Tag后的额外消息是泛型`a`时，需要在type名后也加上，便于type check</div>\n\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">User</span> = <span class=\"type\">Named</span> | <span class=\"type\">Named</span> <span class=\"type\">String</span> <span class=\"comment\">-- Wrong!</span></span><br></pre></td></tr></table></figure>\n\n<p>结合上面的特点，可以很容易地将相似数据结构或设计抽象为单一模板，如<a href=\"https://guide.elm-lang.org/types/union_types.html\">举例</a>中的将时间轴、日志等统一抽象为widget。思路：<strong>逐个击破，合而为一</strong></p>\n<p>由于Union Type可以递归定义，通过Union Type甚至可以构建链表和<a href=\"http://elm-lang.org/examples/binary-tree\">二叉树</a>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">List</span> a = <span class=\"type\">Empty</span> | <span class=\"type\">Node</span> a (<span class=\"type\">List</span> a)</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Tree</span> a = <span class=\"type\">Empty</span> | <span class=\"type\">Node</span> a (<span class=\"type\">Tree</span> a) (<span class=\"type\">Tree</span> a)</span><br></pre></td></tr></table></figure>\n\n<p>此外，Elm中的错误处理<a href=\"https://guide.elm-lang.org/error_handling/maybe.html\">Maybe</a>和<a href=\"https://guide.elm-lang.org/error_handling/result.html\">Result</a>也是基于Union Type实现的。</p>\n<p>因为Union Type的不同子类型可以有自己独特的构造函数，且支持解构赋值，因此非常适合用作实现状态管理的事件。Web App中的update函数接受的Html Msg类型实际上也是Union Type实现的。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>除了不能手动更改状态的变量（因此<strong>递归完全替代了循环结构</strong>），函数是Elm中最常见的存在。命令式编程中，函数用作告诉电脑该怎么做。函数式编程中，函数用作描述一种映射关系，告诉电脑要什么。Elm中函数像下面这样声明：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">square</span> n =</span><br><span class=\"line\">  n^<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">hypotenuse</span> : <span class=\"type\">Float</span> -&gt; <span class=\"type\">Float</span> -&gt; <span class=\"type\">Float</span></span><br><span class=\"line\"><span class=\"title\">hypotenuse</span> a b =</span><br><span class=\"line\">  sqrt (square a + square b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">distance</span> (a,b) (x,y) =</span><br><span class=\"line\">  hypotenuse (a-x) (b-y)</span><br></pre></td></tr></table></figure>\n\n<p>入参在上，返回值在下。入参间通过空格隔开，由于Elm支持函数柯里化，所以在函数的类型声明中，也是通过<code>-&gt;</code>隔开每个入参以及返回值的。由于函数变成了纯粹的“通道”，函数体中声明临时变量的语法通过<code>let ... in</code>的形式实现。</p>\n<p>Elm中也有匿名函数，像下面这样，由反斜线<code>\\</code>开头：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">square</span> =</span><br><span class=\"line\">  \\n -&gt; n^<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">squares</span> =</span><br><span class=\"line\">  <span class=\"type\">List</span>.map (\\n -&gt; n^<span class=\"number\">2</span>) (<span class=\"type\">List</span>.range <span class=\"number\">1</span> <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p>函数间通过<code>|&gt;</code>和<code>&lt;|</code>连接减少括号的使用。例如下面这样</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">viewNames1</span> names =</span><br><span class=\"line\">  <span class=\"type\">String</span>.join <span class=\"string\">&quot;, &quot;</span> (<span class=\"type\">List</span>.sort names)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">viewNames2</span> names =</span><br><span class=\"line\">  names</span><br><span class=\"line\">    |&gt; <span class=\"type\">List</span>.sort</span><br><span class=\"line\">    |&gt; <span class=\"type\">String</span>.join <span class=\"string\">&quot;, &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- (arg |&gt; func) is the same as (func arg)</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，可以通过<code>&gt;&gt;</code>和<code>&lt;&lt;</code>构造复合函数。<code>``</code>用来将第<code>n</code>个函数入参前置，使得居于更符合语法习惯，如<code>buyMilk `then` drinkMilk</code>中<code>buyMilk</code>参数被提前。<code>n</code>可以通过<code>infixr</code>设置。</p>\n<p>其中可能较难理解的是<strong>递归完全替代了循环结构</strong>，Elm类似其他函数式语言，没有<code>for</code>和<code>while</code>。它用描述问题的方式，通过递归解决普通的循环问题，下面举两个例子：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">reverse</span> : <span class=\"type\">List</span> a -&gt; <span class=\"type\">List</span> a</span><br><span class=\"line\"><span class=\"title\">reverse</span> list =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> list <span class=\"keyword\">of</span></span><br><span class=\"line\">    [] -&gt; []</span><br><span class=\"line\">    (x::xs) -&gt; reverse xs ++ [x]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">quicksort</span> : <span class=\"type\">List</span> comparable -&gt; <span class=\"type\">List</span> comparable</span><br><span class=\"line\"><span class=\"title\">quicksort</span> list = </span><br><span class=\"line\">  <span class=\"keyword\">case</span> list <span class=\"keyword\">of</span></span><br><span class=\"line\">    [] -&gt; []</span><br><span class=\"line\">    (x::xs) -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> </span><br><span class=\"line\">        smallerSorted = quicksort (<span class=\"type\">List</span>.filter ((&gt;) x) xs)</span><br><span class=\"line\">        biggerSorted = quicksort (<span class=\"type\">List</span>.filter ((&lt;=) x) xs)</span><br><span class=\"line\">      <span class=\"keyword\">in</span>  </span><br><span class=\"line\">        smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure>\n\n<p>可以找到规律：</p>\n<blockquote>\n<p>Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest.</p>\n</blockquote>\n<p>更具体的解释可以看参考链接3。</p>\n<h3 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h3><p>Elm中没有<code>for</code>和<code>while</code>循环（都通过递归实现了）。但是存在<code>if</code>和<code>case</code>语句。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">if</span> powerLevel &gt; <span class=\"number\">9000</span> <span class=\"keyword\">then</span> <span class=\"string\">&quot;OVER 9000!!!&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;meh&quot;</span></span><br><span class=\"line\"><span class=\"title\">case</span> maybe <span class=\"keyword\">of</span></span><br><span class=\"line\">  <span class=\"type\">Just</span> xs -&gt; xs</span><br><span class=\"line\">  <span class=\"type\">Nothing</span> -&gt; []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">case</span> xs <span class=\"keyword\">of</span></span><br><span class=\"line\">  hd::tl -&gt; <span class=\"type\">Just</span> (hd,tl)</span><br><span class=\"line\">  []     -&gt; <span class=\"type\">Nothing</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">case</span> n <span class=\"keyword\">of</span></span><br><span class=\"line\">  <span class=\"number\">0</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"number\">1</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">  _ -&gt; fib (n<span class=\"number\">-1</span>) + fib (n<span class=\"number\">-2</span>) <span class=\"comment\">-- _表示不接受入参</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><ul>\n<li><code>++</code>连接字符串，<code>+</code>表示相加</li>\n<li>Elm不会进行强制类型转换</li>\n<li>缩进会影响语句解析</li>\n<li>list中所有元素类型必须一致</li>\n<li>tuples设计类似python</li>\n<li>records类型不允许访问不存在的属性</li>\n<li><code>//</code>用来进行C风格的除法</li>\n<li>Elm中!用于连接Model和Cmd，用<code>/=</code>表示<code>!=</code>，同<code>not</code>表示<code>!</code></li>\n</ul>\n<p>Elm的语言设定大不同于C风格，所以，多写去熟悉它的语法风格吧。</p>\n<h2 id=\"Elm架构\"><a href=\"#Elm架构\" class=\"headerlink\" title=\"Elm架构\"></a>Elm架构</h2><p>Elm构建Web App的架构为MVU（不考虑Cmd和Subscription的话），这和目前大部分MVVM框架一样，致力于减少UI维护，减少不必要的状态修改来更好地定位错误。有意思的是，Elm也<a href=\"http://elm-lang.org/blog/blazing-fast-html\">采用了Virtual DOM的设计</a>。</p>\n<ul>\n<li>Model，类似Web App的state，通常为<code>records</code>类型</li>\n<li>Update，更新state的唯一方式（类似于action或commit），通常类型为<code>Msg -&gt; Model -&gt; (Model, Cmd Msg)</code></li>\n<li>View，根据state渲染HTML的方式，通常类型为<code>Model -&gt; Html Msg</code></li>\n</ul>\n<p>Update部分，通常像下面这样，接受Union Type的Msg，并通过<code>case ... of</code>接受到附在Msg上的payload。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; <span class=\"type\">Model</span></span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Change</span> newContent -&gt;</span><br><span class=\"line\">      &#123; model | content = newContent &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View部分，所有常用的标签名和属性名都被封装为函数，接受属性列表和子元素列表两个入参，像下面这样。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">view</span> : <span class=\"type\">Model</span> -&gt; <span class=\"type\">Html</span> <span class=\"type\">Msg</span></span><br><span class=\"line\"><span class=\"title\">view</span> model =</span><br><span class=\"line\">  div []</span><br><span class=\"line\">    [ input [ placeholder <span class=\"string\">&quot;Text to reverse&quot;</span>, onInput <span class=\"type\">Change</span> ] []</span><br><span class=\"line\">    , div [] [ text (<span class=\"type\">String</span>.reverse model.content) ]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n\n<p>将M、V、U三部分结合在一起就可以构造简单的web应用了。当有异步任务等复杂情况出现时，需要通过Cmd和Subscription实现。</p>\n<h3 id=\"Effects\"><a href=\"#Effects\" class=\"headerlink\" title=\"Effects\"></a>Effects</h3><p><img src=\"https://guide.elm-lang.org/architecture/effects/beginnerProgram.svg\" alt=\"Elm Architecture\"></p>\n<p>说这两位之前，我们要回顾下之前的工作流。仔细观察就能发现，我们所做的事只是描述了接受Html Msg后如何生产新的Model并根据新的Model生产新的Html Msg交给Elm Runtime，之后的脏活累活都交给Elm干了。根据Elm的描述，除了vDOM外，它还使用了下面两个手段提升效率：</p>\n<ul>\n<li><strong>Skip Work</strong>，通过<code>lazy</code>（类似React的<code>shouldComponentUpdate</code>）限制更新频率</li>\n<li><strong>Align Work</strong>，通过<code>Html.keyed</code>（类似React的<code>key</code>）减少无意义的diffing。</li>\n</ul>\n<p>回到正题，Cmd和Subscription也是对Msg所做的外层包装而已。除了能向Elm Runtime pipe Html Msg外，当然也可以发送命令或订阅事件</p>\n<p><img src=\"https://guide.elm-lang.org/architecture/effects/program.svg\"></p>\n<p>。Html, Cmd, Sub三者实际上没太大区别，都是我们将生成的数据交给Elm Runtime，剩下的做甩手掌柜。它可以帮助我们：</p>\n<ul>\n<li>更好的debug</li>\n<li>确保Elm函数的线性时不变</li>\n<li>优化HTTP连接，缓存effects</li>\n</ul>\n<p>下面是一个Sub的例子：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SUBSCRIPTIONS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">subscriptions</span> : <span class=\"type\">Model</span> -&gt; <span class=\"type\">Sub</span> <span class=\"type\">Msg</span></span><br><span class=\"line\"><span class=\"title\">subscriptions</span> model =</span><br><span class=\"line\">  <span class=\"type\">Time</span>.every second <span class=\"type\">Tick</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; (<span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span>)</span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Tick</span> newTime -&gt;</span><br><span class=\"line\">      (newTime, <span class=\"type\">Cmd</span>.none)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>之前提到过Elm致力于“编辑时无bug&#x3D;&gt;Runtime无bug”。除了强类型和无状态（实际上是Immutable的状态）外，还有Maybe和Result的辅助。</p>\n<blockquote>\n<p>Elm treats errors as data.</p>\n</blockquote>\n<p>参考<a href=\"https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/\">null的糟糕设计</a>，Elm通过</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Maybe</span> a = <span class=\"type\">Nothing</span> | <span class=\"type\">Just</span> a</span><br></pre></td></tr></table></figure>\n<p>定义了Maybe类型。结合<code>case of</code>的特殊情况处理，通过<strong>option types</strong>的方法<strong>替代Null</strong>。<a href=\"http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Maybe\">core&#x2F;Maybe</a>模块还有<code>withDefault</code>，<code>andThen</code>等其他方法。</p>\n<p>类似于Maybe，Result用Union Type的形式定义了不可靠操作的返回值。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Result</span> error value = <span class=\"type\">Err</span> error | <span class=\"type\">Ok</span> value</span><br></pre></td></tr></table></figure>\n<p>通过Err和Ok两种类型，隐含了其他语言中的<code>try catch</code>操作，<strong>避免exception</strong>的出现。Elm库函数是实现了Result类型的，如<code>Http.get</code>。Result预定义在<a href=\"http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Result\">core&#x2F;Result</a>中</p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>另外，Elm中有Task用来处理异步操作中的失败情况。类似于JS中的Promise。使用思路是先通过succeed方法和fail方法定义Task再使用。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">Task</span> err ok =</span><br><span class=\"line\">  <span class=\"type\">Task</span> err ok</span><br><span class=\"line\"><span class=\"title\">succeed</span> : a -&gt; <span class=\"type\">Task</span> x a</span><br><span class=\"line\"><span class=\"title\">fail</span> : x -&gt; <span class=\"type\">Task</span> x a</span><br></pre></td></tr></table></figure>\n\n<p>在Elm由0.17升级到0.18时，有两种方式执行一个Task。<code>Task.perform</code>和<code>Task.attempt</code>。前者针对<strong>从不返回错误</strong>的task，后者针对<strong>可能出错</strong>的task。更重要的是，在<code>Task.attempt</code>中结合了熟悉的Result模型。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">perform</span> : (a -&gt; msg) -&gt; <span class=\"type\">Task</span> <span class=\"type\">Never</span> a -&gt; <span class=\"type\">Cmd</span> msg</span><br><span class=\"line\"><span class=\"title\">attempt</span> : (<span class=\"type\">Result</span> x a -&gt; msg) -&gt; <span class=\"type\">Task</span> x a -&gt; <span class=\"type\">Cmd</span> msg</span><br><span class=\"line\"><span class=\"comment\">-- example</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Msg</span> = <span class=\"type\">Click</span> | <span class=\"type\">NewTime</span> <span class=\"type\">Time</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; ( <span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span> )</span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Click</span> -&gt;</span><br><span class=\"line\">      ( model, <span class=\"type\">Task</span>.perform <span class=\"type\">NewTime</span> <span class=\"type\">Time</span>.now )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NewTime</span> time -&gt;</span><br><span class=\"line\">      ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"互操作性\"><a href=\"#互操作性\" class=\"headerlink\" title=\"互操作性\"></a>互操作性</h2><p>Elm的互操作性体现在和JSON以及JavaScript上。</p>\n<h3 id=\"与JSON\"><a href=\"#与JSON\" class=\"headerlink\" title=\"与JSON\"></a>与JSON</h3><p>通过Json.Decode和Json.Encode完成相关工作。解析部分由<code>decodeString</code>完成。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">decodeString</span> : <span class=\"type\">Decoder</span> a -&gt; <span class=\"type\">String</span> -&gt; <span class=\"type\">Result</span> <span class=\"type\">String</span> a</span><br></pre></td></tr></table></figure>\n<p>由第一个参数指定decoder类型，如 <code>decodeString int &quot;42&quot;</code>就指定了一个整数的解析器。在多数情况下，JSON字符串并没这么简单。这时，需要先利用基本的int、string、list、dict解析器结合map2、map3等构造相应的Decoder，再交给decodeString处理。<strong>函数返回<code>Result</code>类型</strong>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Json.Decode <span class=\"keyword\">exposing</span> (..)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">Point</span> = &#123; x : <span class=\"type\">Int</span>, y : <span class=\"type\">Int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> = map2 <span class=\"type\">Point</span> (field <span class=\"string\">&quot;x&quot;</span> int) (field <span class=\"string\">&quot;y&quot;</span> int)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">decodeString</span> pointDecoder <span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;&#123; &quot;</span>x<span class=\"string\">&quot;: 3, &quot;</span>y<span class=\"string\">&quot;: 4 &#125;&quot;</span><span class=\"string\">&quot;&quot;</span> <span class=\"comment\">-- Ok &#123; x = 3, y = 4 &#125; : Result String Point</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很麻烦。不像JavaScript里一个<code>JSON.parse()</code>完事，确实Elm解析JSON的笨拙为人诟病，官方的<a href=\"http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest\">pipeline</a>包通过<code>|&gt;</code>组合Decoder，让语法稍微好了一点。最新的0.18版本下有<a href=\"http://package.elm-lang.org/packages/elm-community/json-extra/2.6.0/Json-Decode-Extra\">json-extra</a>提供更方便的decoder选择。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Json.Decode.Pipeline <span class=\"keyword\">exposing</span> (decode, required)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> : <span class=\"type\">Decoder</span> <span class=\"type\">Point</span></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> =</span><br><span class=\"line\">  decode <span class=\"type\">Point</span></span><br><span class=\"line\">    |&gt; required <span class=\"string\">&quot;x&quot;</span> int</span><br><span class=\"line\">    |&gt; required <span class=\"string\">&quot;y&quot;</span> int</span><br></pre></td></tr></table></figure>\n\n<p>可这距离<code>JSON.parse</code>还是不够啊。于是有人写了个根据Records类型<a href=\"https://github.com/eeue56/json-to-elm\">生成decoder的工具</a>，或者<a href=\"http://noredink.github.io/json-to-elm/\">在线生成</a>。</p>\n<p>相比之下，<a href=\"http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode\">encode</a>过程就简单多了。</p>\n<h3 id=\"与JavaScript\"><a href=\"#与JavaScript\" class=\"headerlink\" title=\"与JavaScript\"></a>与JavaScript</h3><p>有两种方式，port或flag。</p>\n<p>前者类似于在Elm应用上凿洞，用类似订阅发布的模式工作。需要在文件开头的module声明前，额外加上<code>port</code>关键词，同时需要暴露的接口前也需要<code>port</code>关键词。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">port</span> <span class=\"keyword\">module</span> Spelling <span class=\"keyword\">exposing</span> (..)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- port for sending strings out to JavaScript</span></span><br><span class=\"line\"><span class=\"keyword\">port</span> check : String -&gt; Cmd msg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- port for listening for suggestions from JavaScript</span></span><br><span class=\"line\"><span class=\"keyword\">port</span> suggestions : (<span class=\"type\">List</span> <span class=\"type\">String</span> -&gt; msg) -&gt; Sub msg</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title class_\">Elm</span>.<span class=\"property\">Spelling</span>.<span class=\"title function_\">fullscreen</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"property\">ports</span>.<span class=\"property\">check</span>.<span class=\"title function_\">subscribe</span>(<span class=\"keyword\">function</span>(<span class=\"params\">word</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> suggestions = <span class=\"title function_\">spellCheck</span>(word);</span><br><span class=\"line\">  app.<span class=\"property\">ports</span>.<span class=\"property\">suggestions</span>.<span class=\"title function_\">send</span>(suggestions);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spellCheck</span>(<span class=\"params\">word</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// have a real implementation!</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后者暴露program的init给外部JavaScript。在声明Elm program时，使用<code>programWithFlags</code>而非<code>program</code>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">init</span> : <span class=\"type\">Flags</span> -&gt; ( <span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span> )</span><br><span class=\"line\"><span class=\"title\">init</span> flags =</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> =</span><br><span class=\"line\">  programWithFlags &#123; init = init, ... &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title class_\">Elm</span>.<span class=\"property\">MyApp</span>.<span class=\"title function_\">fullscreen</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&#x27;Tom&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">token</span>: <span class=\"string\">&#x27;12345&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Elm的思路是不向后兼容，避免过去问题的引入。只通过port和flags的方式，借由Elm runtime和外部JS沟通，避免自身的runtime exception，把问题只留在JavaScript部分。</p>\n<h2 id=\"工程实践\"><a href=\"#工程实践\" class=\"headerlink\" title=\"工程实践\"></a>工程实践</h2><p>使用Elm编写简单的应用时，可能一个.elm文件完成后，就可以直接<code>elm-make index.elm --output index.js</code>就OK了。当工程较大时（目前还没怎么看到生产环境用Elm的），必然需要拆分组件。</p>\n<p>Elm在设计上，拆分的比MVVM框架更细。它拆分到了函数的级别，由于它pure function的特点，不受状态的束缚，重用函数比MVVM框架顾虑少太多了。如，重用view函数就相当于React和Vue中的函数式组件。重用update函数，可以实现MVVM中“组件A改变组件B，组件B改变组件C，组件C改变组件A”的史诗级难题。</p>\n<p>封装和应用是通过<code>module ... exposing ...</code>和<code>import ... exposing ...</code>的语法完成的。Elm会去elm-package.json中的<code>source-directories</code>以及<code>dependencies</code>中声明的路径和包下寻找<code>import</code>对应的东西。剩下的，只要控制好复用程度，在习惯Elm语法后，就可以轻松且高逼格地编写Web应用了。</p>\n<p>Elm编写好，且通过<code>elm-make</code>成功编译后，会得到一个<code>.js</code>文件，在需要的HTML文件中引入，会得到一个<code>Elm</code>全局对象，存储了所有的program。<strong>每个program都有<code>embed</code>方法和<code>fullscreen</code>方法绑定在HTML文件中</strong>。之后，大功告成！</p>\n<p>参考作者所写的<a href=\"https://github.com/evancz/elm-todomvc\">TODOMVC</a>是个不错的开始。</p>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p><strong>Q：Where are my components? And how do they communicate?</strong><br>A：参见<a href=\"https://guide.elm-lang.org/reuse/\">Scaling The Elm Architecture</a></p>\n<p><strong>Q：What’s the “Elm style”?</strong><br>A：回头看看<a href=\"#%E5%89%8D%E8%A8%80\">前言</a>一节最后放的两个Elm开发感受，Elm中，View和Updates两部分均可以拆解成多个&#x2F;组helper functions。最后在一个门面文件中汇总。Elm将state、updates、view放在一个文件，对开发更友好。Elm的优势在于函数式编程特点的帮助（无副作用&#x2F;纯函数&#x2F;强类型&#x2F;出色的错误处理机制）和对人机交互模式的优异抽象。它的问题在</p>\n<ul>\n<li>不完善的文档</li>\n<li>蹩脚的互操作（interop）设计（port和flag）</li>\n<li>学习曲线陡峭</li>\n<li>缺乏成熟的成套解决方案</li>\n<li>坑爹的JSON支持</li>\n</ul>\n<p><strong>Q：Who will save my front-end routing?</strong><br>A：有的，借助<a href=\"https://github.com/elm-lang/navigation\">Elm Navigation package</a>就可以做到，具体如何和状态变化绑定起来参见<a href=\"https://www.elm-tutorial.org/en/07-routing/01-intro.html\">tutorial的routing部分</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://guide.elm-lang.org/\">An Introduction to Elm</a></li>\n<li><a href=\"http://elm-lang.org/docs/syntax\">syntax</a></li>\n<li><a href=\"https://learnyouanelm.github.io/pages/05-recursion.html\">Recursion | Elm</a></li>\n<li><a href=\"https://infi.nl/nieuws/why-i-became-an-elm-evangelist/\">Why I became an Elm evangelist</a></li>\n<li><a href=\"https://github.com/isRuslan/awesome-elm\">awesome-elm</a></li>\n</ul>\n",
            "tags": [
                "Elm",
                "框架",
                "函数式编程"
            ]
        }
    ]
}
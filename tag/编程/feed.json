{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"编程\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2022/08/25/all-about-code-2/",
            "url": "http://shenlvmeng.github.com/blog/2022/08/25/all-about-code-2/",
            "title": "关于编码的一切 ——《代码大全》 下",
            "date_published": "2022-08-25T14:37:19.000Z",
            "content_html": "<blockquote>\n<p>文接<a href=\"https://shenlvmeng.github.io/blog/2022/03/03/all-about-code/\">关于编码的一切 ——《代码大全》 下</a></p>\n</blockquote>\n<h2 id=\"软件质量\"><a href=\"#软件质量\" class=\"headerlink\" title=\"软件质量\"></a>软件质量</h2><p>在了解最基本的变量和语句组织后，这一部分围绕提高软件质量展开。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>软件的外在质量特性体现在：</p>\n<ul>\n<li>正确性</li>\n<li>可用性</li>\n<li>效率</li>\n<li>可靠性</li>\n<li>健壮性</li>\n<li>适应性</li>\n<li>完整性</li>\n<li>精确性</li>\n</ul>\n<p>内在质量特性体现在：</p>\n<ul>\n<li>可维护性</li>\n<li>可扩展性</li>\n<li>可移植性</li>\n<li>可读性</li>\n<li>可测试性</li>\n<li>可理解性</li>\n</ul>\n<p>而改善软件质量可以有很多技术：</p>\n<ul>\n<li>确定目标</li>\n<li>测试策略</li>\n<li>非正式走查</li>\n<li>正式技术复查</li>\n<li>外部审查</li>\n</ul>\n<p>开发过程中可以通过量化结果、制作原型、控制变更等手段提升质量。</p>\n<ul>\n<li>不同的质量保障手段效率各不相同，多种缺陷检测办法结合、人工和计算机检测结合，效果会比单打独斗要好；然而没有任何一种错误检测办法可以解决全部问题</li>\n<li>越早引入软件的问题，修正代价越大，尽早开始代码质量保障工作</li>\n<li>需求或架构上的错误相比编码阶段会带来更广泛的影响</li>\n<li>改善质量可以降低开发成本</li>\n</ul>\n<h3 id=\"协同构建\"><a href=\"#协同构建\" class=\"headerlink\" title=\"协同构建\"></a>协同构建</h3><p>协同构建即在同行的帮助下完成代码构建。方式包括但不限于结对编程、正式检查、非正式技术复查、文档阅读等等。<strong>结对编程</strong>和<strong>技术性复查</strong>可以缩短开发周期，排查出更多错误，减少代码的维护时间。同时，同行间的协同构建也有助于快速提升公司开发者的开发水平。</p>\n<ul>\n<li>结对编程<ul>\n<li>结对编程中，一名程序员敲代码，另外一名注意有没有出现错误，以及考虑策略性问题</li>\n<li>成功秘诀<ul>\n<li>事先确定编程规范，避免琐碎争吵</li>\n<li>不编程的成员不能变成旁观者</li>\n<li>不需要在简单问题上使用结对编程</li>\n<li>灵活对结对成员轮换，让大家熟悉不同系统</li>\n<li>避免新手组队</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>正式检查<ul>\n<li>一种特殊的复查，与会主持人负责组织事宜，按计划、概述、准备、与会人（非作者）阐述代码、详查报告、跟进等步骤推进</li>\n<li>针对代码而非作者</li>\n<li>最终由作者负责如何处理缺陷</li>\n</ul>\n</li>\n<li>走查<ul>\n<li>走查是形式和流程都比较宽松的代码复查方式，时间较短，重点也在检查错误而非修正它们</li>\n</ul>\n</li>\n<li>代码阅读<ul>\n<li>类似Code Review，关注点主要在代码本身，而非会议</li>\n</ul>\n</li>\n<li>公开演示：类似showcase</li>\n</ul>\n<h3 id=\"开发者测试\"><a href=\"#开发者测试\" class=\"headerlink\" title=\"开发者测试\"></a>开发者测试</h3><p>测试分单元测试、组件测试、集成测试、回归测试、系统测试，前两部分通常由开发者进行，后三部分由专门的测试人员进行。测试按是否了解测试对象内部工作原理也可以分为黑盒测试和白盒测试。最后要注意，<strong>测试 ≠ 调试</strong>。</p>\n<p>对于开发者而言，测试天生有些特别：</p>\n<ul>\n<li>测试的目标是找出错误而非实现功能</li>\n<li>测试绝不可能彻底证明程序里没有错误</li>\n<li>测试无法改善软件质量，它本身只是一个指示器</li>\n</ul>\n<p>开发者测试在整个项目时间中大概占8% - 25%，在测试时有一些tips：</p>\n<ul>\n<li>写代码前先写测试用例，不会比后写多花功夫</li>\n<li>不止进行“干净测试”，也要考虑“肮脏测试”</li>\n<li>很容易对测试覆盖率过度乐观</li>\n</ul>\n<p>在现实世界中，要穷尽所有可能的输入是不可能的，<strong>测试不可能完全</strong>，有些方法会起到作用：</p>\n<ul>\n<li>使用<strong>路径数</strong>计算计算用例的<strong>最少</strong>数目，它可以保证所有代码的执行<ul>\n<li>通过子程序时，开始记1</li>\n<li>遇到<code>if</code>、<code>while</code>、<code>repeat</code>、<code>for</code>、<code>and</code>、<code>or</code>或等价物时，+1</li>\n<li>遇到每一个<code>case</code>语句，+1；没有缺省分支时，再+1</li>\n</ul>\n</li>\n<li><strong>数据流测试</strong>可以覆盖到数据的变化情况<ul>\n<li>数据有<strong>已定义</strong>、<strong>已使用</strong>、<strong>已销毁</strong>状态</li>\n<li>子程序控制流有<strong>已进入</strong>、<strong>已退出</strong>状态</li>\n<li>测试所有的<strong>已定义</strong>、<strong>已定义-已使用</strong>组合，注意其他的组合顺序</li>\n</ul>\n</li>\n<li>一个好的测试用例可以覆盖可数据数据的一大部分</li>\n<li>用启发式方法去<strong>猜测错误</strong></li>\n<li>留意<strong>边界值</strong>，如数组边界的off-by-one错误</li>\n<li>考察<strong>好数据</strong>和<strong>坏数据</strong><ul>\n<li>好数据：期望输入、最小正常值、最大正常值、旧数据兼容性</li>\n<li>坏数据：没有数据、过多数据、无效数据、长度错误、未初始化</li>\n</ul>\n</li>\n<li>使用容易验证结果的测试数据</li>\n</ul>\n<p>关于错误，也有一些先验的规律：</p>\n<ul>\n<li>符合八二法则、<strong>绝大多数错误通常和几个具有严重缺陷的子程序有关</strong></li>\n<li>大多数错误影响范围有限</li>\n<li>大多数构建错误来自编程人员的错误，多从自身想问题</li>\n<li>笔误是一个常见的问题根源</li>\n<li>错误理解需求也是常见原因</li>\n<li>大多数的错误都较易修正</li>\n<li>业界经验是，平均1000行代码发现1-25个错误，发布产品大概是1000行代码0.5个，</li>\n<li>同样留意，测试用例本身是否有误</li>\n</ul>\n<p>在当前的编程环境和工作条件下，容易找到很多测试框架，它们会包含脚手架、diff工具、测试数据生成器、覆盖率监测、日志记录、系统干扰器等。另外，自动化测试、测试问题复盘等对测试质量也有提升帮助。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>调试（debug）是寻找错误根本原因和纠正错误的过程。它和测试一样，本身不是提升代码质量的方法，而是诊断代码缺陷的手段。</p>\n<ul>\n<li>调试の误区<ul>\n<li>纯靠猜测找到问题所在</li>\n<li>不去花时间理解程序和问题</li>\n<li>暂时性的掩盖问题</li>\n<li>把问题推给硬件，而不思考是不是出在自己身上</li>\n</ul>\n</li>\n<li>寻找缺陷的步骤<ul>\n<li>让错误状态稳定下来 &#x3D;&gt; 稳定复现</li>\n<li>收集相关数据，构造错误原因假说</li>\n<li>通过测试或检查代码证实或证伪假说</li>\n</ul>\n</li>\n<li>一个无法稳定重现的问题，可能和初始化或和时间有关系</li>\n<li>寻找缺陷的tips<ul>\n<li>构建缺陷假说时，要能合理解释所有测试用例</li>\n<li>定位缺陷困难时，及时补充更多的测试用例复现问题，用<strong>多视图</strong>的方式盲人摸象定位缺陷</li>\n<li>测试用例过于发散时，及时用用例否定一些假说</li>\n<li><strong>二分法</strong>缩小嫌疑范围</li>\n<li>检查<strong>最近修改</strong>或<strong>最近出过错</strong>的代码</li>\n<li>小黄鸭调试法</li>\n<li>暂时休息一下</li>\n<li>蛮力调试<ul>\n<li>抛弃有问题的代码，从头设计和编码</li>\n<li>抛弃整个程序，从头开始设计和编码</li>\n<li>不放过任何一个编译器错误</li>\n<li>手动遍历所有的循环</li>\n<li>更换编译环境或比那一起</li>\n<li>持续自动化测试</li>\n<li>显示代码中所有的打印日志信息</li>\n</ul>\n</li>\n<li>给启发式调试法一个deadline</li>\n<li>调试中避免心理惯性：人们总期望一个新现象类似他们见过的某种现象</li>\n</ul>\n</li>\n<li>修正缺陷<ul>\n<li>修正问题前确保已经很好地理解了</li>\n<li>理解程序而不仅是问题</li>\n<li>验证对错误的分析或理解</li>\n<li>保留最初的源代码</li>\n<li>治本，而不要治标</li>\n<li>一次只改一个地方</li>\n<li>搜寻代码中还有没有类似的缺陷</li>\n</ul>\n</li>\n<li>调试工具<ul>\n<li>源代码diff</li>\n<li>编译警告信息</li>\n<li>lint和代码自动修正</li>\n<li>性能剖测（profile）</li>\n<li>测试脚手架</li>\n<li>调试器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h3><blockquote>\n<p>更多重构介绍可以参考这篇blog<a href=\"https://shenlvmeng.github.io/blog/2020/08/17/refactoring-design-improvement/\">重构 —— 代码的实用性与艺术性</a></p>\n</blockquote>\n<p>重构即在<strong>不改变软件外部行为的基础上，改变其内部结构</strong>。即便是管理完善的项目，每个月都会发生需求变化，稳定不变的需求是个童话。</p>\n<p>代码出现以下“坏味道”（smell）时，代表需要重构了。</p>\n<ul>\n<li>代码重复</li>\n<li>子程序冗长</li>\n<li>嵌套过深</li>\n<li>内聚性差</li>\n<li>参数列表过长</li>\n<li>类和继承关系不合理</li>\n<li>基本数据类型过多</li>\n<li>“流浪数据”传递</li>\n<li>无所事事的类</li>\n<li>命名不当</li>\n<li>难理解的注释</li>\n<li>全局变量</li>\n<li>子程序需要前置或后置处理</li>\n<li>过早设计或过度设计</li>\n<li>…</li>\n</ul>\n<p>重构分级别有下面一些手段</p>\n<ul>\n<li>数据级<ul>\n<li>具名常量</li>\n<li>更可读的变量</li>\n<li>函数替代表达式</li>\n<li>中间变量</li>\n<li>减少重复使用变量</li>\n<li>类型码转成类或枚举类型</li>\n<li>类封装</li>\n</ul>\n</li>\n<li>语句级<ul>\n<li>分解布尔表达式</li>\n<li>用可读名字的布尔函数替代布尔表达式</li>\n<li>合并条件语句中的重复代码片段</li>\n<li><code>break</code>或<code>return</code>替代循环控制变量</li>\n<li>多态替换条件语句</li>\n<li>null对象替代空值检测</li>\n</ul>\n</li>\n<li>子程序<ul>\n<li>内莲花</li>\n<li>提炼子程序</li>\n<li>转化为类</li>\n<li>增&#x2F;删参数</li>\n<li>合并&#x2F;拆分子程序</li>\n<li>读写操作分离</li>\n<li>传递成员&#x2F;类</li>\n</ul>\n</li>\n<li>类实现<ul>\n<li>值&#x2F;引用对象转化</li>\n<li>成员函数&#x2F;成员数据位置移动</li>\n<li>相似代码提炼到基类</li>\n<li>差异代码拆分到派生类</li>\n</ul>\n</li>\n<li>类接口<ul>\n<li>类拆分&#x2F;合并</li>\n<li>删除类</li>\n<li>去掉中间人</li>\n<li>继承替代委托</li>\n<li>委托替代继承</li>\n<li>引入外部成员函数</li>\n<li>引入扩展类</li>\n<li>封装不使用的成员函数</li>\n</ul>\n</li>\n<li>系统级<ul>\n<li>为无法控制的数据创建索引源</li>\n<li>工厂模式</li>\n<li>异常&#x2F;错误处理代码选型</li>\n</ul>\n</li>\n</ul>\n<p>要想让重构不影响日常功能开发，需要考虑</p>\n<ul>\n<li>有一个代码版本管理工具</li>\n<li>重构步伐小一点</li>\n<li>同一时间只做一个重构</li>\n<li><strong>重新测试</strong></li>\n<li>增加测试用例</li>\n<li>检查代码更改</li>\n<li>根据重构风险选择重构方法</li>\n<li>不要把重构当成糟糕设计的挡箭牌</li>\n<li>避免用重构代替重写</li>\n</ul>\n<p>重构可以在修改代码的时候进行，不论是增加修改子程序还是类，或者是修复缺陷。对于从未重构的糟糕代码，可以用一部分混乱的代码隔离复杂度，把理想规整的代码和混乱不堪的真实世界隔离开。</p>\n<h3 id=\"代码调整策略\"><a href=\"#代码调整策略\" class=\"headerlink\" title=\"代码调整策略\"></a>代码调整策略</h3><p>代码调整指出于<strong>性能</strong>考虑，对代码进行实现上的调整。本章主要讨论策略。</p>\n<ul>\n<li>动手前的考虑<ul>\n<li><strong>性能≠代码速度</strong></li>\n<li>想清楚你确实在解决一个需要解决的问题</li>\n</ul>\n</li>\n<li>调整考量<ul>\n<li>程序设计：设计架构时考虑整体性能，再为每个子系统、类设计要达到的资源占用目标</li>\n<li>和操作系统的交互</li>\n<li>代码编译</li>\n<li>硬件</li>\n<li>类和子程序设计</li>\n<li>代码调整</li>\n</ul>\n</li>\n<li>帕累托法则，又称八二法则，程序中20%的子程序耗费了80%的执行时间</li>\n<li>一些<strong>错误认知</strong><ul>\n<li>减少代码行数就可以减少资源占用</li>\n<li>特定的写法会比其他的更快，代码也会更小（<em>要看编译环境</em>）</li>\n<li>应当随时随地优化（<em>不成熟的优化不如不优化</em>）</li>\n<li>运行速度和正确性同样重要</li>\n</ul>\n</li>\n<li>先提升代码可维护性，在程序完成且表现正确后，再去提升系统性能</li>\n<li>常见的低效率来源<ul>\n<li>IO操作</li>\n<li>内存分页</li>\n<li>系统API调用</li>\n<li>脚本语言</li>\n</ul>\n</li>\n<li>性能测量：没有准确的性能测量就不要去做优化</li>\n<li>代码调整需要反复尝试，才能达到理想的性能提高</li>\n</ul>\n<h3 id=\"代码调整技术\"><a href=\"#代码调整技术\" class=\"headerlink\" title=\"代码调整技术\"></a>代码调整技术</h3><p>文接上章，本章讨论具体调整手段。</p>\n<ul>\n<li>代码调整和重构相反，大多数情况下是以牺牲程序可读性为代价换取更高的性能</li>\n<li>调整手段<ul>\n<li>逻辑<ul>\n<li>知道答案后停止判断</li>\n<li>按照出现频率调整判断顺序，把容易为真的判断放在最前面</li>\n<li>表驱动法代替复杂表达式</li>\n<li>惰性求值</li>\n</ul>\n</li>\n<li>循环<ul>\n<li>把判断提出循环体</li>\n<li>展开小循环</li>\n<li>合并循环</li>\n<li>减少循环体内的操作</li>\n<li>用哨兵值提前结束循环</li>\n<li>把最忙的循环放在最内侧</li>\n<li>用低强度的计算代替高强度计算，如加法替代乘法，乘法代替幂运算</li>\n</ul>\n</li>\n<li>数据<ul>\n<li>使用整型而非浮点数</li>\n<li>减少数组维度</li>\n<li>使用辅助索引</li>\n<li>使用缓存</li>\n</ul>\n</li>\n<li>表达式<ul>\n<li>利用恒等式简化代码复杂度</li>\n<li>削弱计算强度</li>\n<li>编译期初始化</li>\n<li>小心系统函数，为了兼容最糟情况，系统函数会比较复杂</li>\n<li>事先算出结果</li>\n<li>删除公共表达式</li>\n</ul>\n</li>\n<li>子程序<ul>\n<li>子程序改为内联</li>\n</ul>\n</li>\n<li>用低级语言重写</li>\n</ul>\n</li>\n<li>再次强调，<strong>没有性能优化测量就没有代码调整</strong></li>\n</ul>\n<h2 id=\"系统考虑\"><a href=\"#系统考虑\" class=\"headerlink\" title=\"系统考虑\"></a>系统考虑</h2><p>这一部分站在系统的角度考虑构建过程中的程序规模、集成、工具等问题。</p>\n<h3 id=\"程序规模带来的影响\"><a href=\"#程序规模带来的影响\" class=\"headerlink\" title=\"程序规模带来的影响\"></a>程序规模带来的影响</h3><p>软件规模的扩大可能会为你带来意料之外的大量问题。</p>\n<ul>\n<li>如果你习惯于开发小项目，那么你的第一个大型项目很可能会严重失控</li>\n<li><strong>沟通交流</strong>：项目成员的扩大带来的交流路径不是加性的，是<strong>乘性</strong>的</li>\n<li><strong>错误</strong>：项目规模的扩大也会带来更高的缺陷密度</li>\n<li><strong>生产率</strong>：大项目会带来更低的生产率</li>\n<li><strong>工作量</strong>：软件构建的工作量和项目大小是线性关系，而其他活动的工作量则是非线性增加</li>\n<li>不同规模的代码从小到大可以称作程序、产品、系统、系统产品，没能意识到它们间的不同也是估算偏差的出现来源</li>\n<li>项目越正规，就越重视<strong>方法论</strong>，不得不写的文档也会更多，撰写的文档也会更正规</li>\n</ul>\n<h3 id=\"构建管理\"><a href=\"#构建管理\" class=\"headerlink\" title=\"构建管理\"></a>构建管理</h3><p>构建管理是软件管理中的一部分。</p>\n<ul>\n<li>鼓励良好的编程实践<ul>\n<li>逐行复查</li>\n<li>代码签名</li>\n<li>鼓励最佳实践</li>\n</ul>\n</li>\n<li>配置管理：系统化定义项目工件和处理流程<ul>\n<li>需求和设计变更<ul>\n<li>遵循系统化的变更手续</li>\n<li>成组变更</li>\n<li>评估变更成本</li>\n<li>坏味道：频繁大量变更</li>\n</ul>\n</li>\n<li>软件变更：版本控制软件</li>\n<li>机器配置变更：机器镜像</li>\n</ul>\n</li>\n<li>评估构建进度表<ul>\n<li>评估项目规模和工作量是软件项目管理中最具挑战性的部分，平均水平的大型软件都要超时1年，超预算100%才能完成</li>\n<li>清楚说明软件需求</li>\n<li>使用不同方法评估再对比</li>\n<li>定期更新评估</li>\n<li>以下因素会影响软件开发进度，但不易被量化<ul>\n<li>开发者的经验和能力</li>\n<li>团队的动力</li>\n<li>管理质量</li>\n<li>可重用的代码数目</li>\n<li>人员流动性</li>\n<li>需求变更</li>\n<li>文档量</li>\n<li>分级安全环境</li>\n</ul>\n</li>\n<li>如果进度落后了要怎么办<ul>\n<li>扩充团队在<strong>项目任务不能分割并一一击破</strong>时，只会增加项目交流复杂度，并加速项目延期</li>\n<li>缩减项目范围，有限保证核心功能</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>度量：对项目特征进行度量可以评估项目进度和风险，当然保证ddl比收集度量数据更重要</li>\n<li>把程序员当人看<ul>\n<li>程序员1天大概有30%时间花费在“对项目没有直接好处”的非技术活动中</li>\n<li><strong>不同程序员间的努力和能力差异很大</strong>，不同团队在软件质量和生产率的差异上也很大，好的和坏的程序员都倾向于聚集在一起</li>\n<li>在代码风格的信仰问题上，使用“建议”或大多数人达成统一的指导规范</li>\n<li>优良的物理工作环境有助于提升程序员的生产率和生产质量</li>\n</ul>\n</li>\n<li>管理你的管理者：向上管理</li>\n</ul>\n<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><p>集成方式也会影响到集成的质量。从频率上分，有<strong>阶段式集成</strong>和<strong>增量集成</strong>，在阶段式集成中，分为单元开发和系统集成两个阶段。增量集成中，程序是一点一点写出来并一点点拼接起来的。对比阶段式集成，增量集成有下面一些好处：</p>\n<ul>\n<li>易于定位错误</li>\n<li>更早在项目中取得系统级结果</li>\n<li>对项目结果更好的监控</li>\n<li>能在更短的开发计划中建造出整个系统</li>\n</ul>\n<p>而增量集成有下面一些常见策略：</p>\n<ul>\n<li><strong>自顶向下集成</strong>：先集成系统设计，再集成具体实现；优点是能更早有整个系统的大局观，缺点是在前期会加入很多底层的mock代码，且将调试过程推迟到项目后期</li>\n<li><strong>自底向上集成</strong>：和自顶向下相反，优点是很容易定位错误，缺点是丧失全局的认识，系统设计的问题在后期修改成本较高</li>\n<li><strong>三明治集成</strong>：先集成顶部的高层业务对象和底部的基础工具类，再集成中间层代码，整合了自顶向下和自底向上</li>\n<li><strong>风险导向的集成</strong>：鉴别不同类的风险级别，先集成风险高的</li>\n<li><strong>功能导向的集成</strong>：一次集成一组功能，它基本上不需要脚手架，且每次集成都能增强系统的功能性，且和面向对象设计比较好协同工作</li>\n<li><strong>T型集成</strong>：在集成高层对象后，先选中某个特定功能块，完成一次所有类的集成，这样可以作为MVP演练整个系统</li>\n</ul>\n<p>结合<strong>冒烟测试</strong>的“<strong>每日构建</strong>”（daily build）是软件集成的一种最佳实践。它能让产品每天都有进步，且让项目保持一个固定的脉搏。做好daily build，有下面一些建议</p>\n<ul>\n<li>不放过失败的build，保证每次build都能通过冒烟测试</li>\n<li>每天进行冒烟测试</li>\n<li>冒烟测试需要和代码一样“与时俱进”</li>\n<li>让daily build和冒烟测试<strong>自动化</strong></li>\n<li>要求开发人员构建前进行冒烟测试</li>\n<li>将修订保持合适的合并节奏，不要太密，也不要太疏</li>\n<li>在早上发布build，给潜在问题留下修复时间</li>\n<li>顶住需求压力，保证daily build和冒烟测试</li>\n</ul>\n<p>在daily build的基础上，可以很轻易地做到1日多次的<strong>持续集成</strong>。</p>\n<h3 id=\"编程工具\"><a href=\"#编程工具\" class=\"headerlink\" title=\"编程工具\"></a>编程工具</h3><blockquote>\n<p>工欲善其事，必先利其器</p>\n</blockquote>\n<p>现代化的编程环境下，有很多可以采用的编程工具：</p>\n<ul>\n<li>设计工具</li>\n<li>源代码工具<ul>\n<li>IDE</li>\n<li>文本替换工具</li>\n<li>diff工具</li>\n<li>merge工具</li>\n<li>源代码美化器</li>\n<li>接口文档生成</li>\n<li>代码模板&#x2F;代码生成</li>\n<li>命令行</li>\n<li>代码质量分析<ul>\n<li>linter</li>\n<li>metrics报告</li>\n</ul>\n</li>\n<li>重构代码<ul>\n<li>重构器</li>\n<li>代码翻译器</li>\n</ul>\n</li>\n<li>版本控制工具</li>\n<li>数据字典</li>\n</ul>\n</li>\n<li>可执行码工具<ul>\n<li>目标码生成<ul>\n<li>编译器、链接器</li>\n<li>build工具，如make、ant</li>\n</ul>\n</li>\n<li>程序库&#x2F;第三方库</li>\n<li>代码生成向导</li>\n<li>安装指引</li>\n</ul>\n</li>\n<li>调试</li>\n<li>测试</li>\n<li>代码调整<ul>\n<li>性能剖测</li>\n<li>汇编和反汇编</li>\n</ul>\n</li>\n</ul>\n<p>在Unix这样的工具导向环境下就更容易孕育编程工具，如grep、diff、sort、make、tar、line、sed、awk、vi等。几乎所有的大型组织都有自己的内部工具和支持团队，不少比市面上的还要优秀。针对特定项目，有时候也会开发特定的项目工具，如航天、保险、医疗等。对于个人开发，也可以使用脚本这种自动执行重复性杂务的工具。</p>\n<p>最后要澄清一个事实，<strong>编程工具并不能消灭人在编程里的核心地位</strong>，只是不断<strong>重塑</strong>（reshape）编程的含义。连接到其他软硬件的复杂接口，规章制度、业务规则这些计算机编程之外的复杂之源还是要人来应对。而被用来填补真实世界和解决问题的计算机之间鸿沟的人，被称作程序员。</p>\n<h2 id=\"软件工艺\"><a href=\"#软件工艺\" class=\"headerlink\" title=\"软件工艺\"></a>软件工艺</h2><p>编程是硬件与艺术的融合体，软件工艺是编程美学的一种体现。</p>\n<h3 id=\"布局与风格\"><a href=\"#布局与风格\" class=\"headerlink\" title=\"布局与风格\"></a>布局与风格</h3><p>编排出色的代码会带来<strong>视觉</strong>上和<strong>思维</strong>上的愉悦。</p>\n<ul>\n<li>基本原则<ul>\n<li>好的布局可以凸显程序的逻辑结构，也更符合人类直觉</li>\n<li><strong>傻子都会写计算机理解的代码，而优秀程序员写的是人能看懂的代码</strong></li>\n<li>高手的机型并非天生优于新手，而是高手具备某种知识结构，这种结构有助于高手记住特定类型的信息；因此当信息符合这些结构时，就可以被轻易的理解</li>\n<li>布局非信仰，要保持头脑开放，接受已被证实更好的方法</li>\n</ul>\n</li>\n<li>布局技术<ul>\n<li><strong>空白</strong><ul>\n<li>分组</li>\n<li>空行</li>\n<li>缩进</li>\n</ul>\n</li>\n<li>括号</li>\n</ul>\n</li>\n<li>布局风格：同一层级的语句缩进相同<ul>\n<li>纯块结构</li>\n<li>模仿块结构</li>\n<li>花括号指定边界</li>\n<li>行尾布局（不推荐）</li>\n</ul>\n</li>\n<li>控制结构布局<ul>\n<li>段落间的空行</li>\n<li>复杂的表达式拆分条件到多行</li>\n<li>不用<code>goto</code></li>\n</ul>\n</li>\n<li>单行语句布局<ul>\n<li>控制长度</li>\n<li>使用空格</li>\n<li>后续行缩进统一</li>\n<li>后续行结尾统一</li>\n<li><strong>一行一条语句</strong><ul>\n<li>减少复杂度</li>\n<li>读代码仅需自上而下</li>\n<li>不要在单行中多个操作</li>\n</ul>\n</li>\n<li>一行一个声明</li>\n</ul>\n</li>\n<li>注释风格<ul>\n<li>缩进和代码一致</li>\n<li>用空行和代码隔开</li>\n</ul>\n</li>\n<li>子程序布局<ul>\n<li>空行分段</li>\n<li>参数按标准缩进</li>\n</ul>\n</li>\n<li>类布局<ul>\n<li>头部注释 -&gt; 构造函数&#x2F;析构函数 -&gt; public子程序 -&gt; protected子程序 -&gt; private子程序和成员</li>\n<li>文件布局<ul>\n<li>一个文件一个类</li>\n<li>文件命名和类有关</li>\n<li>在文件中清晰分隔各子程序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自说明代码\"><a href=\"#自说明代码\" class=\"headerlink\" title=\"自说明代码\"></a>自说明代码</h3><p>本节专注于文档的特殊补充形式，即“注释”。</p>\n<ul>\n<li>在代码中起主要作用的并非注释，而是<strong>好的编程风格</strong></li>\n<li>注释的哲学<ul>\n<li>注释能提供更高层级的抽象</li>\n<li>重复注释根本没用</li>\n<li>注释写的不合适只会起反作用</li>\n</ul>\n</li>\n<li>注释类别：在代码完工后，只允许出现后三种<ul>\n<li>重复代码（Bad case）</li>\n<li>解释代码：当代码过于复杂到需要解释时，最好是改进代码，而不是添加注释</li>\n<li>代码标记，如<code>TODO</code>，<code>FIXME</code></li>\n<li>概述代码</li>\n<li>意图说明</li>\n<li>传达代码以外的信息，如版权声明、保密要求</li>\n</ul>\n</li>\n<li>高效注释<ul>\n<li>用伪代码法减少注释时间</li>\n<li>将注释如何到开发风格中</li>\n</ul>\n</li>\n<li>注释技术<ul>\n<li>注释单行<ul>\n<li>去掉无关注是</li>\n<li>减少行尾注释</li>\n<li>行尾注释只用于数据声明、维护标记、标记行尾等场景</li>\n</ul>\n</li>\n<li>注释代码段<ul>\n<li>应表达<strong>why</strong>而非<strong>how</strong></li>\n<li>代码本身应尽力组做好说明</li>\n<li>注明非常规用法</li>\n<li>错误或语言环境独特点要加注释</li>\n</ul>\n</li>\n<li>注释数据声明<ul>\n<li>数值单位</li>\n<li>允许范围</li>\n<li>输入限制</li>\n<li>全局数据</li>\n</ul>\n</li>\n<li>注释控制结构<ul>\n<li>循环结束的行尾注释是代码太复杂的征兆</li>\n</ul>\n</li>\n<li>注释子程序<ul>\n<li>注释要靠近说明的代码</li>\n<li>用简短的话进行说明</li>\n<li>注释声明参数</li>\n<li>可以使用Javadoc这种工具</li>\n<li>说明子程序的全局作用</li>\n</ul>\n</li>\n<li>注释类、文件、程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"个人性格\"><a href=\"#个人性格\" class=\"headerlink\" title=\"个人性格\"></a>个人性格</h3><p>软件工程是纯粹的脑力劳动。软件工程师研究工具和原材料的本质时，实际上是在研究人的智力、性格这种无形的东西。</p>\n<ul>\n<li>编程工作本质上是项难以监督的工作，你也需要对自己负责</li>\n<li>聪明和谦虚</li>\n<li>求知欲<ul>\n<li>形成自我意识</li>\n<li>实验</li>\n<li>学习成功项目</li>\n<li>阅读文档</li>\n<li>和同行交流</li>\n</ul>\n</li>\n<li>不屈不挠的诚实感</li>\n<li>交流和合作：<strong>编程首先是与人交流，然后才是和计算机交流</strong></li>\n<li>创造力和纪律</li>\n<li>懒惰：避免“实在懒”，追求“开明懒”和“一劳永逸的懒”</li>\n<li>可能不那么明显的性格<ul>\n<li>坚持：要时不时抬头开清方向</li>\n<li>经验：不同于其他行业，<strong>软件开发行业的经验比书本知识价值要小，基础知识变化很快</strong>，不存在越老越吃香的情况。不持续学习跟上潮流，仅靠经验吃饭，会被逐渐淘汰。</li>\n</ul>\n</li>\n<li>习惯<ul>\n<li>好习惯很重要</li>\n<li>不要用“没有习惯”替代“坏习惯”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"软件工艺探讨的话题\"><a href=\"#软件工艺探讨的话题\" class=\"headerlink\" title=\"软件工艺探讨的话题\"></a>软件工艺探讨的话题</h3><p>《代码大全》全书都着重于软件构建的细节，本章从抽象的关注点出发，看看哪些方面会影响软件的工艺。</p>\n<ul>\n<li>软件开发的核心是致力于<strong>降低复杂度</strong>，管理复杂度是软件的核心使命，之前各章节提过了很多具体办法。各种形式的抽象都是管理复杂度的强大工具。<ul>\n<li>划分子系统</li>\n<li>仔细定义类接口</li>\n<li>保持接口抽象性</li>\n<li>避免全局变量</li>\n<li>避免深层次继承</li>\n<li>避免深度嵌套和循环</li>\n<li>不用<code>goto</code></li>\n<li>子程序短小精悍</li>\n<li>使用清晰明了的变量名</li>\n<li>使用规范和约定减少理解负担</li>\n</ul>\n</li>\n<li>软件开发和其<strong>过程</strong>密不可分，在多程序员参与的项目里，组织性的重要性超过了个人技能<ul>\n<li>坏的过程只会损耗脑力，好的过程则可以开发脑力到极限</li>\n</ul>\n</li>\n<li>首先为人写程序，然后才是机器，强调代码可读性，便于与同行沟通</li>\n<li>深入一门语言去编程，不浮于表面<ul>\n<li>杰出的程序员会考虑他们要干什么，然后才是怎么用手头的工具实现目标</li>\n</ul>\n</li>\n<li>借助<strong>规范</strong>集中注意力</li>\n<li>基于问题域编程<ul>\n<li>将程序划分为不同层级的抽象<ul>\n<li>第0层：操作系统的操作和机器指令</li>\n<li>第1层：编程语言结构和工具</li>\n<li>第2层：底层实现结构，如算法和数据结构</li>\n<li>第3层：低层问题域，这一层已经有问题域相关的操作原语可以使用</li>\n<li>第4层：高层问题域，你的非技术用户某种程度也应该可以看懂你的代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编程是科学和艺术融合的一门工程学科</li>\n<li><strong>迭代</strong>在软件开发中是很正常的现象。软件设计是一个逐步精化的过程。</li>\n<li>将软件和信仰分离开<ul>\n<li>不要盲目跟风</li>\n<li>保持折中态度</li>\n<li>权衡各种技术，再做决定</li>\n<li>基于实验，保持开放心态</li>\n</ul>\n</li>\n</ul>\n<p>–END–</p>\n",
            "tags": [
                "编程",
                "范式",
                "设计",
                "艺术",
                "质量"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2022/03/03/all-about-code/",
            "url": "http://shenlvmeng.github.com/blog/2022/03/03/all-about-code/",
            "title": "关于编码的一切 ——《代码大全》 上",
            "date_published": "2022-03-03T15:09:50.000Z",
            "content_html": "<blockquote>\n<p>拿到它的时候，它已印刷了13年之久；能在京东上找到，也是极大的幸运。</p>\n</blockquote>\n<p>《代码大全》是一部又大又全的工具书，它涵盖了关于编程各个环节的充分经验，可以作为日程编程工作的指导。将其他教我如何编程的书中的内容做了一个打包。数月研读下来，难免有所遗忘。这里将其中的精华尽量记录下来，也作为对全书内容的一个回顾。</p>\n<h2 id=\"打好基础\"><a href=\"#打好基础\" class=\"headerlink\" title=\"打好基础\"></a>打好基础</h2><p>第1部分主要围绕构建为读者讲解什么是构建，和关于构建我们需要了解和准备的。也为后面展开具体编程细节和设计艺术打基础。</p>\n<h3 id=\"走进软件构建\"><a href=\"#走进软件构建\" class=\"headerlink\" title=\"走进软件构建\"></a>走进软件构建</h3><p>构建是软件开发的核心，构建的质量对软件质量有实质影响。</p>\n<h3 id=\"隐喻理解软件开发\"><a href=\"#隐喻理解软件开发\" class=\"headerlink\" title=\"隐喻理解软件开发\"></a>隐喻理解软件开发</h3><p>用隐喻可以帮助理解软件开发的过程。</p>\n<ul>\n<li>一个好的隐喻应该是简单的，忽略了不必要的细节，对概念进行内化和抽象，让人从更高层面思考问题，从而避免低层次错误</li>\n<li>隐喻更像<strong>启示</strong>，而非<em>算法</em></li>\n<li>对于编程来说，还是将问题概念化</li>\n<li>有一些常见的软件隐喻<ul>\n<li>写作&#x2F;耕作：这些隐喻不太合适</li>\n<li>养殖：增量、迭代、自适应、演进的成长概念</li>\n<li>建造：规划设计文档，使用现成组件</li>\n</ul>\n</li>\n<li>组合各种隐喻，不要过度引申隐喻，带来误导</li>\n</ul>\n<h3 id=\"提前准备\"><a href=\"#提前准备\" class=\"headerlink\" title=\"提前准备\"></a>提前准备</h3><p>提前准备，降低风险。</p>\n<ul>\n<li>前期准备的必要性<ul>\n<li>降低风险</li>\n<li>通过逻辑、类比、数据说服项目经理<ul>\n<li>开始大项目前需要制定计划</li>\n<li>程序员是食物链的最后一环，架构师吃掉需求，设计师吃掉架构，程序员消化设计</li>\n<li>发现错误的时间要尽可能接近引入错误的时间，可以尽量降低修复时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判别你所在的软件领域<ul>\n<li>在软件开发中，适用迭代式开发法比适用序列式开发法的情况多得多</li>\n</ul>\n</li>\n<li>先清楚定义问题</li>\n<li>再正确认清需求<ul>\n<li>正式详尽地描述需求，是项目成功的关键<ul>\n<li>面向目标、契约式编程</li>\n</ul>\n</li>\n<li>稳定需求是可望而不可即的<ul>\n<li><strong>开发过程会帮助客户更好地理解自己的需求，这也是需求变更的主要来源</strong></li>\n</ul>\n</li>\n<li>应对需求变更<ul>\n<li>核对当前需求的质量（<em>需要有一个需求质量的核对表</em>），及时回退到需求设计环节</li>\n<li>确保每个人都知道变更的代价</li>\n<li>建立变更的控制流程</li>\n<li>要放弃么？</li>\n<li>考虑项目的商业价值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>考虑架构设计<ul>\n<li>架构指整个系统的设计约束，不会细节到子系统或类的设计约束</li>\n<li>架构的组成部分<ul>\n<li>程序组织</li>\n<li>主要的类和类的继承体系</li>\n<li>数据结构设计</li>\n<li>业务规则描述</li>\n<li>UI设计</li>\n<li>资源管理：数据库连接、线程、句柄</li>\n<li>安全</li>\n<li>性能</li>\n<li>可扩展性</li>\n<li>国际化</li>\n<li>错误处理：纠正还是检测、主动还是被动</li>\n<li>输入输出</li>\n<li>容错性</li>\n<li>过度工程：明确设立期望目标</li>\n<li>“买”还是“造”：如果架构选择自己做，那么一定要证明自己定制的组件在某方面胜过现有的</li>\n<li>变更策略：如何应对变更</li>\n</ul>\n</li>\n<li>架构的总体质量<ul>\n<li>和嗦、所解决的问题和谐一致，看起来自然</li>\n<li>描述所有主要的决策动机</li>\n<li>优秀的架构很大程度和机器与编程语言无关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>投入的时间一般在20%-30%</li>\n</ul>\n<h3 id=\"关键的构建决策\"><a href=\"#关键的构建决策\" class=\"headerlink\" title=\"关键的构建决策\"></a>关键的构建决策</h3><p>选择语言、技术、构建实践。</p>\n<ul>\n<li>高级语言表达力更强<ul>\n<li><strong>你思考的能力取决于你是否知道可以表达该思想的词汇</strong></li>\n</ul>\n</li>\n<li>提前讲好使用的<strong>编程约定</strong>，去统一编程语言的细节</li>\n<li>找准在技术浪潮中的位置<ul>\n<li>如果在浪潮后期，就可以持续使用稳定的功能；在浪潮前期，则需要花时间找到文档中没有说明的编程语言特性</li>\n<li>“深入一种语言去编程”，<strong>程序员现决定想表达的思想是什么，再决定如何使用特定语言的工具去表达这些思想</strong></li>\n</ul>\n</li>\n<li>选择构建实践</li>\n</ul>\n<h2 id=\"创建高质量代码\"><a href=\"#创建高质量代码\" class=\"headerlink\" title=\"创建高质量代码\"></a>创建高质量代码</h2><p>这一部分主要讲解类和子程序的设计和编码。</p>\n<h3 id=\"如何做设计\"><a href=\"#如何做设计\" class=\"headerlink\" title=\"如何做设计\"></a>如何做设计</h3><p>一些启发式准则和idea</p>\n<ul>\n<li>设计的挑战<ul>\n<li>有的问题需要“解决”一边，才能明确定义它，然后再次解决</li>\n<li>设计成功应该是组织良好且清爽的，不过设计过程却并非如此</li>\n<li>设计需要取舍，受到限制</li>\n<li>设计需要启发式思维，但也是不断评估、讨论、调试实验中诞生的</li>\n</ul>\n</li>\n<li>设计的关键概念<ul>\n<li>管理复杂度<ul>\n<li>软件开发的本质复杂性来自复杂无序的现实世界，精确完整地识别依赖关系和意外情况，设计完全正确而不是部分正确的方案</li>\n<li>软件需要管理复杂度，在组织程序的时候便于在一个时刻专注于一个特定的部分，另外不遗漏暂时忽视的部分</li>\n<li>应对复杂度：减少本质复杂度到最小、避免偶然复杂度的无谓增长</li>\n</ul>\n</li>\n<li>理想的设计特征<ul>\n<li>最小复杂度</li>\n<li>易于维护</li>\n<li>松耦合</li>\n<li>可扩展、可重用</li>\n<li>高扇入（类被其他类大量使用）、低扇出（类少量使用其他类）</li>\n<li>可移植性</li>\n<li>精简性</li>\n<li>标准化</li>\n</ul>\n</li>\n<li>设计的层次<ul>\n<li>软件系统 &gt; 子系统或包 &gt; 类 &gt; 子程序 &gt; 子程序内</li>\n<li>常用子系统：业务规则、用户界面、数据库访问、OS抽象层</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计构造块：启发式方法<ul>\n<li>寻找现实对象：想想系统要模仿什么<ul>\n<li>辨识对象和其属性</li>\n<li>确定可以对对象做的操作</li>\n<li>确定对象能对其他对象进行的操作</li>\n<li>确定对象的可见范围</li>\n<li>定义对象接口</li>\n</ul>\n</li>\n<li>形成一致的<strong>抽象</strong>：让你关注某概念的时候忽略不必要的细节</li>\n<li><strong>封装</strong>实现细节：封装帮你掩盖不需要你看到的复杂度</li>\n<li><strong>继承</strong>能简化设计就继承</li>\n<li>隐藏秘密信息<ul>\n<li>保证接口最小且完备</li>\n<li>隐藏复杂度和变化源</li>\n</ul>\n</li>\n<li>找出容易改变的区域<ul>\n<li>业务规则、硬件依赖、输入输出、非标准的预演特性、状态变量、糟糕或复杂的设计</li>\n<li>将容易变化的部分隔离开，让变化的影响范围和变化的可能性成反比</li>\n</ul>\n</li>\n<li>保持松散耦合<ul>\n<li>耦合种类：简单数据参数、简单对象、对象参数、语义耦合（过多假设）</li>\n</ul>\n</li>\n<li>了解常用的设计模式<ul>\n<li>设计模式提供了现成的抽象来减少复杂度</li>\n<li>设计模式将抽象SOP化</li>\n<li>设计模式可以起到启发性作用</li>\n<li>设计模式将设计对话提高到更高层次来简化交流</li>\n</ul>\n</li>\n<li>其他启发式方法<ul>\n<li>高内聚</li>\n<li>契约式设计</li>\n<li>TDD</li>\n<li><strong>创建中央控制点，集中管控</strong></li>\n<li>拿不准时，使用蛮力突破</li>\n<li>画一个图</li>\n<li>设计模块化</li>\n</ul>\n</li>\n<li>使用启发式方法的原则<ul>\n<li>先理解问题</li>\n<li>找出现有数据和未知量之间的联系</li>\n<li>寻找之前的类似问题，或者解决一些相关问题</li>\n<li>执行计划</li>\n<li>回顾解</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计实践<ul>\n<li>迭代：第二个尝试往往会好于第一个</li>\n<li>分而治之，增量式改进</li>\n<li>自上而下设计和自下而上设计</li>\n<li>建立试验性原型：原型要足够简单可抛弃，又足以验证效果</li>\n<li>记录你的设计成果：wiki、邮件、UML图</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设计类\"><a href=\"#设计类\" class=\"headerlink\" title=\"设计类\"></a>设计类</h3><ul>\n<li><strong>类是一组数据和子程序的聚合，有内聚的明确定义的职责</strong></li>\n<li>抽象数据类型（ADT）<ul>\n<li>ADT可以让你像现实世界一样操作实体，而不必在底层实现上摆弄实体</li>\n<li>ADT的好处<ul>\n<li>隐藏实现细节</li>\n<li>改动不需要影响整个程序</li>\n<li>接口语义更强</li>\n<li>更容易提高性能</li>\n</ul>\n</li>\n<li>在非面向对象环境，也可以使用ADT</li>\n</ul>\n</li>\n<li>良好的类接口<ul>\n<li>好的抽象<ul>\n<li>类接口应该有一致的抽象层次</li>\n<li>要理解类的抽象是什么</li>\n<li>考虑提供成对的服务，如打开&#x2F;关闭、添加&#x2F;删除</li>\n<li>尽可能让接口可编程，而不仅是表达语义</li>\n<li>谨防在修改时破坏接口抽象</li>\n<li>同时考虑抽象性和内聚性</li>\n</ul>\n</li>\n<li>好的封装<ul>\n<li>封装比抽象更强，它直接阻止你看到细节</li>\n<li>尽可能限制类和成员的可访问性</li>\n<li>不要公开暴露成员数据</li>\n<li>不要将实现细节暴露在接口上</li>\n<li>不要对类的使用者做任何假设</li>\n<li>让阅读代码比编写更方便，代码的阅读次数比编写多得多</li>\n<li>不要<strong>透过</strong>接口来编程，仅仅看类的接口文档无法得知如何使用一个类的话，正确的做法不是拉出类的源代码，查看内部实现，而是联系类作者。对于类作者来讲，正确的做法不是面对面告诉答案，而是去修改类的接口文档</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计和实现<ul>\n<li>通过<strong>包含</strong>来实现“有一个”的关系<ul>\n<li>警惕超过<strong>7</strong>个成员的类</li>\n</ul>\n</li>\n<li>通过<strong>继承</strong>实现“是一个”的关系<ul>\n<li>用public继承</li>\n<li>要么使用继承并详细说明，要么就不要使用它</li>\n<li>遵循Liskov替换原则，即对基类的子程序，在它的所有派生类上含义都应该是相同的，在调用时只用看基类无需考虑是哪一个派生类</li>\n<li>只继承需要继承的部分</li>\n<li>只有一个实例的类值得怀疑</li>\n<li>只有一个派生类的类也值得怀疑</li>\n<li>派生中覆盖了某个子程序，但是其中没做任何操作，也值得怀疑<ul>\n<li>很可能修改了基类接口的语义，慢慢地从基类接口很难理解派生类上的行为</li>\n</ul>\n</li>\n<li>避免过深地继承：降低复杂度</li>\n<li>尽量使用<strong>多态</strong>，避免类型检查</li>\n<li>适度使用继承<ul>\n<li>多个类共享数据而非行为 &#x3D;&gt; 创建类包含的公用对象</li>\n<li>多个类共享行为而非数据 &#x3D;&gt; 都从基类派生，在基类中定义公用的子程序</li>\n<li>多个类既公用数据也公用行为 &#x3D;&gt; 都从基类派生，在基类中定义公用的子程序和数据</li>\n<li>通过基类控制接口 &#x3D;&gt; 继承</li>\n<li>自己控制接口 &#x3D;&gt; 包含</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>成员函数和数据成员<ul>\n<li>减少子程序</li>\n<li>进制不必要的成员和运算符</li>\n<li>减少对其他类子程序的间接调用</li>\n</ul>\n</li>\n<li>构造函数<ul>\n<li>尽可能早构造函数中初始化所有数据成员</li>\n<li><strong>用私有构造函数来实现单例数据</strong></li>\n<li>优先使用深拷贝，除非需要，才使用浅拷贝</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>创建类的原因<ul>\n<li>为现实&#x2F;抽象世界的对象建模</li>\n<li>降低&#x2F;隔离复杂度</li>\n<li>隐藏实现细节</li>\n<li>限制变动的影响范围</li>\n<li>建立中心控制点</li>\n<li>将相关操作包装在一起</li>\n<li>避免的类：万能类、无关紧要类、动词命名类</li>\n</ul>\n</li>\n<li>超越类：包</li>\n</ul>\n<h3 id=\"设计子程序\"><a href=\"#设计子程序\" class=\"headerlink\" title=\"设计子程序\"></a>设计子程序</h3><ul>\n<li>子程序是为了实现特定目的编写的方法或过程</li>\n<li>编写子程序的正当理由<ul>\n<li>降低复杂度</li>\n<li>引入中间、易懂的抽象</li>\n<li>避免代码重复</li>\n<li>支持派生类覆盖</li>\n<li>隐藏指针操作</li>\n<li>改善性能</li>\n<li>增加可读性</li>\n</ul>\n</li>\n<li>子程序上的设计<ul>\n<li><strong>一个子程序只做一件事</strong></li>\n<li><strong>考虑靠近纯函数或纯副作用函数</strong></li>\n<li>内聚性<ul>\n<li>功能上的、顺序上的、通信上的</li>\n<li>避免临时的内聚性（只是需要同时执行才放在一起操作的子程序），如贫血的<code>startup()</code>方法</li>\n<li>避免逻辑上的、巧合的内聚性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>起个好名字<ul>\n<li>描述所做的事情，而非做事情的过程</li>\n<li>避免使用模糊的动词</li>\n<li>不要仅用数字区分子程序名</li>\n<li>函数名不要过长</li>\n<li>考虑描述返回值</li>\n<li>使用预期强烈的动词 + 宾语</li>\n<li>使用对仗词，如add&#x2F;remove</li>\n<li><strong>为常用操作统一命名</strong></li>\n</ul>\n</li>\n<li>子程序长度：最好少于100行，可以接受100 - 200行</li>\n<li>子程序入参<ul>\n<li>按输入、修改、输出顺序排列参数</li>\n<li>如果子程序使用了相似的参数，考虑让他们的排列顺序一致</li>\n<li>删掉没有使用到的参数</li>\n<li>不要给入参重新赋值</li>\n<li>限制入参数（有的说3个，有的说7个）</li>\n<li>考虑给参数名增加前缀、后缀</li>\n<li><strong>入参和子程序需要在一个抽象层级下</strong></li>\n<li>使用具名参数</li>\n</ul>\n</li>\n<li>宏子程序和内联子程序<ul>\n<li>将宏表达式整个包含在括号内</li>\n<li>一般来讲，是不会用宏代替子程序的</li>\n<li>节制使用inline子程序，在确认有性能改进后再使用inline子程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"防御式编程\"><a href=\"#防御式编程\" class=\"headerlink\" title=\"防御式编程\"></a>防御式编程</h3><p>防御式编程让错误更容易发现和修改，并减小破坏。</p>\n<ul>\n<li>断言<ul>\n<li>主要用于开发和维护的阶段</li>\n<li>用错误处理代码处理预期中的状况，用断言处理绝不该出现的状况</li>\n<li>避免把需要执行的代码放在断言中</li>\n<li>对于高健壮性代码，应该先断言再处理错误</li>\n</ul>\n</li>\n<li>错误处理技术<ul>\n<li>返回中立值，如空串、0</li>\n<li>换用下一个正确数据，如获取温度</li>\n<li>返回上一个正确数据，如屏幕重绘</li>\n<li>使用最接近的合法值</li>\n<li>打印警告信息到日志文件中</li>\n<li>返回错误码</li>\n<li>显示出错信息</li>\n<li>关闭程序</li>\n<li>平衡正确性和健壮性</li>\n</ul>\n</li>\n<li>异常<ul>\n<li>通知程序其他部分，发生了不可忽略的错误</li>\n<li>只在真正例外的情况下才抛出异常</li>\n<li>避免再构造函数或析构函数中抛出异常</li>\n<li>在恰当抽象层次抛出异常</li>\n<li>在异常信息中加上导致异常的所有信息</li>\n<li>避免空的<code>catch</code>语句</li>\n<li>异常标准化 &amp; 异常报告机制</li>\n</ul>\n</li>\n<li>辅助调试的代码<ul>\n<li>进攻式编程：让问题更早暴露</li>\n<li>方便地移除调试代码</li>\n</ul>\n</li>\n<li>保留防御式代码的程度<ul>\n<li>保留检查重要错误的代码</li>\n<li>去掉检查细微错误的代码</li>\n<li>保留让程序稳妥崩溃的代码</li>\n<li>记录错误信息</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"伪代码编写\"><a href=\"#伪代码编写\" class=\"headerlink\" title=\"伪代码编写\"></a>伪代码编写</h3><ul>\n<li>创建一个类<ul>\n<li>创建类的总体设计</li>\n<li>创建类中的子程序</li>\n<li>复审并测试</li>\n</ul>\n</li>\n<li>伪代码<ul>\n<li>使用类似英语的用法描述准确操作</li>\n<li>避免使用特定编程语言的语法元素，防止陷入到代码本身的层级上设计</li>\n<li>在略高于代码的层次上进行设计</li>\n</ul>\n</li>\n<li>通过伪代码创建子程序<ul>\n<li>检查先决条件</li>\n<li>定义子程序要解决的问题</li>\n<li>决定如何测试</li>\n<li>在第三方库中搜寻可用功能</li>\n<li>考虑错误处理</li>\n<li>编写伪代码</li>\n<li>将伪代码转为高层次的注释</li>\n<li>在注释下填充代码</li>\n<li>检查代码是否需要进一步分解</li>\n<li>使用lint或编译器检查错误</li>\n<li>去掉冗余注释</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>这一部分深入到代码细节，围绕如何正确使用变量展开。</p>\n<h3 id=\"一般事项\"><a href=\"#一般事项\" class=\"headerlink\" title=\"一般事项\"></a>一般事项</h3><ul>\n<li>初始化的一些建议<ul>\n<li>声明的时候初始化</li>\n<li>靠近变量使用的时候初始化</li>\n<li>考虑对常量使用<code>final</code>或<code>const</code></li>\n<li>注意累加器和计数器的重置</li>\n<li>用可执行代码初始化</li>\n<li>检查合法性</li>\n</ul>\n</li>\n<li>作用域<ul>\n<li>将变量引用点集中起来可以提高可读性，这样可以减少大脑缓存</li>\n<li>减少变量的“存活时间”（从第一条引用语句到最后一条）</li>\n<li>减少作用域的一些原则<ul>\n<li>循环开始时初始化循环变量</li>\n<li>变量使用前再赋值</li>\n<li>对于变量先采用最严格的可见性，再逐渐放宽</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>持续性<ul>\n<li>子程序内&#x2F;手动回收前&#x2F;程序运行时&#x2F;持久存储</li>\n<li>为变量选择合适的持续性</li>\n</ul>\n</li>\n<li>绑定时间<ul>\n<li>编码时&#x2F;编译时&#x2F;加载时&#x2F;实例化时&#x2F;运行时</li>\n<li><strong>越晚绑定越有灵活</strong></li>\n<li>选择合适的灵活度</li>\n</ul>\n</li>\n<li>和控制结构匹配的数据结构<ul>\n<li>序列型数据 -&gt; 顺序语句</li>\n<li>选择型数据 -&gt; <code>if case</code>语句</li>\n<li>迭代型数据 -&gt; 循环语句</li>\n</ul>\n</li>\n<li>变量单一用途<ul>\n<li>只用作一件事</li>\n<li>使用所有已声明变量</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"取名\"><a href=\"#取名\" class=\"headerlink\" title=\"取名\"></a>取名</h3><p>取名是个学问。</p>\n<ul>\n<li>几个原则<ul>\n<li><strong>信达雅</strong></li>\n<li><strong>以问题为导向</strong>，面向目的而不是手段</li>\n<li>适当的长度，小于20个字符，大于8个字符</li>\n<li>作用域越小，变量名越短；使用较少的变量或全局变量适用较长的名字</li>\n<li>使用限定词（如min、avg、max）和对仗词</li>\n</ul>\n</li>\n<li>特定类型的变量名<ul>\n<li>循环下标：<code>i</code>,<code>j</code>,<code>k</code>，在嵌套循环时建议使用表意的变量名</li>\n<li>状态变量：取个比<code>xxxflag</code>更好的名字</li>\n<li>临时变量：避免用临时名字</li>\n<li>布尔变量：名字要蕴含真假的意义<ul>\n<li><code>done</code>&#x2F;<code>error</code>&#x2F;<code>found</code>&#x2F;<code>success</code></li>\n<li><strong>不建议使用<code>is</code>前缀</strong></li>\n<li>使用表示<strong>肯定</strong>的名字，理解成本低</li>\n</ul>\n</li>\n<li>枚举变量：缺少组前缀的需要加上前缀</li>\n<li>常量：不使用magic number或magic string</li>\n</ul>\n</li>\n<li>组内需要确定一个命名规范</li>\n<li>标准前缀<ul>\n<li>用户自定义类型缩写，UDT缩写</li>\n<li>正交化、便于检索</li>\n</ul>\n</li>\n<li>如何缩写<ul>\n<li>使用标准缩写</li>\n<li>去掉非前置元音</li>\n<li>去掉虚词，<code>and</code>等</li>\n<li>去掉无用后缀</li>\n<li>使用每个单词的第一或前几个字母</li>\n<li>不提倡语音缩写</li>\n<li>缩写要能读出来</li>\n<li>避免容易看错或读错的字符组合</li>\n</ul>\n</li>\n<li>应该避免的名字<ul>\n<li>令人误解</li>\n<li>具有不同含义但有相似名字</li>\n<li>发音相近</li>\n<li>出现数字，这是不好的征兆</li>\n<li>拼写错误</li>\n<li>仅靠大小写区分</li>\n<li>使用易混淆的字符，如<code>0</code>和<code>o</code>，<code>1</code>和<code>l</code></li>\n</ul>\n</li>\n<li>代码阅读次数要远远多于编写次数</li>\n</ul>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><ul>\n<li>数值<ul>\n<li>避免magic number</li>\n<li>避免除0</li>\n<li>避免混合类型比较哦</li>\n</ul>\n</li>\n<li>整数<ul>\n<li>检查整数除法</li>\n<li>检查整数溢出</li>\n</ul>\n</li>\n<li>浮点数<ul>\n<li>避免数据级相差巨大的数之间的加减</li>\n<li>避免相等比较</li>\n<li>避免舍入误差</li>\n</ul>\n</li>\n<li>字符串<ul>\n<li>避免magic string</li>\n<li>考虑国际化</li>\n<li>unicode支持</li>\n<li>C语言的字符串<ul>\n<li>注意字符串指针和字符数组的差异</li>\n<li>注意字符串长度声明为CONSTANT + 1</li>\n<li>用<code>null</code>初始化避免无结束符</li>\n<li>建议使用字符数组</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>布尔变量<ul>\n<li>使用布尔中间变量简化复杂判断</li>\n</ul>\n</li>\n<li>枚举类型<ul>\n<li>带来类型提示和提升可读性</li>\n<li>简化修改</li>\n<li>作为布尔变量的可扩展性方案</li>\n<li>枚举类型的第一个元素留作非法制</li>\n</ul>\n</li>\n<li>具名常量：“参数化”程序<ul>\n<li>统一使用</li>\n</ul>\n</li>\n<li>数组<ul>\n<li>确认数组下标</li>\n<li>顺序访问元素，不建议随机访问</li>\n<li>数组边界点</li>\n</ul>\n</li>\n<li>自定义类型：<code>typedef</code>作为类的轻量级方案</li>\n</ul>\n<h3 id=\"不常见的数据类型\"><a href=\"#不常见的数据类型\" class=\"headerlink\" title=\"不常见的数据类型\"></a>不常见的数据类型</h3><ul>\n<li>结构体：数据组合，没有行为的类<ul>\n<li><strong>用前一问：可以用类么</strong></li>\n<li>简化数据块操作</li>\n<li>简化参数列表</li>\n</ul>\n</li>\n<li>指针：灵活但容易出错<ul>\n<li><strong>用前一问：有访问器子程序或防御式编程么</strong></li>\n<li>标识内存中<strong>某个位置</strong>有<strong>某种内容</strong></li>\n<li>一般技巧<ul>\n<li>同时声明和定义</li>\n<li>使用前检查</li>\n<li>使用前判断内存是否损毁</li>\n<li>在提高代码清晰度上，不要节约使用指针</li>\n<li>简化指针表达式</li>\n<li>正确删除链表中的指针</li>\n<li>删除或释放前设为空值</li>\n<li>删除前检查是否非法</li>\n<li>统一跟踪分配情况</li>\n<li>统一在子程序里，集中实现上述策略</li>\n</ul>\n</li>\n<li>C++指针<ul>\n<li>理解指针和引用</li>\n<li><strong>指针用于“按引用传递”，const引用用于“按值传递”</strong></li>\n<li>使用<code>shared_ptr</code></li>\n</ul>\n</li>\n<li>C指针<ul>\n<li>使用显式类型</li>\n<li>避免强制类型转换</li>\n<li>遵循参数传递的<code>*</code>规则</li>\n<li>内存分配时使用<code>sizeof()</code>确定变量大小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>全局数据：风险较大<ul>\n<li><strong>用前一问：有更好的方法么</strong></li>\n<li>常见问题<ul>\n<li>多线程重入问题</li>\n<li>阻碍代码重用</li>\n<li>破坏模块化和智力上的可管理性</li>\n</ul>\n</li>\n<li>使用理由<ul>\n<li>简化极常用的数据使用</li>\n<li>消除流浪数据（调用链中间的子程序不使用数据）</li>\n</ul>\n</li>\n<li>用访问器子程序取代全局数据<ul>\n<li>在访问前锁定控制</li>\n<li>在访问器子程序里构建一个抽象层</li>\n<li>对数据的所有访问限制在一个抽象层</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><p>在了解了数据视角的变量元素后，这一部分围绕语句组织展开。</p>\n<h3 id=\"直线型代码\"><a href=\"#直线型代码\" class=\"headerlink\" title=\"直线型代码\"></a>直线型代码</h3><ul>\n<li>直线型代码即按先后顺序放置语句和语句块</li>\n<li>必须明确先后顺序的语句<ul>\n<li><strong>想办法明确展示语句的依赖关系</strong><ul>\n<li>组织代码</li>\n<li>使用子程序名&#x2F;子程序参数凸显依赖</li>\n<li>使用注释</li>\n<li>通过断言或错误处理来检查</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>顺序无关的语句<ul>\n<li>使代码易于从上向下阅读，避免跳来跳去</li>\n<li>将相关语句组织在一起</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><ul>\n<li><code>if</code>语句<ul>\n<li><code>if-then</code>语句<ul>\n<li>先写正常代码，再写不常见情况</li>\n<li>不要在<code>if</code>后跟随空子句</li>\n<li>看看是不是不需要<code>else</code>子句</li>\n</ul>\n</li>\n<li><code>if-then-else</code>语句<ul>\n<li>利用布尔函数简化复杂的检测</li>\n<li>把常见情况放在最前面</li>\n<li>检查是否考虑了所有情况</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>case</code>语句<ul>\n<li>选择最有效的排列顺序，如执行频率</li>\n<li>简化每种case下的操作</li>\n<li><strong>最好能搭配枚举类型一起使用</strong></li>\n<li>使用<code>default</code>子句检查默认情况或错误</li>\n<li>注意有些语言的<code>case</code>会有fallthrough，需要加<code>break</code></li>\n</ul>\n</li>\n<li>循环语句<ul>\n<li>分为计数循环、连续求值循环、无限循环、迭代器循环。分别适用<code>for</code>、<code>while</code>、<code>foreach</code>语句</li>\n<li>循环控制<ul>\n<li>应该把循环体看作黑盒子，外围程序只知道它的控制条件</li>\n<li>合理判断使用<code>for</code>和<code>while</code>的地方</li>\n<li>尽量避免空循环</li>\n<li>循环内务（包括索引增加）要么放在循环开始，要么放在循环最后</li>\n<li>让循环终止条件看起来明显</li>\n<li>不要为了终止循环改动<code>for</code>循环的下标</li>\n<li>小心散布了很多<code>break</code>的循环，小心谨慎使用<code>break</code>和<code>continue</code></li>\n<li>检查循环端点是否会有off-by-one的问题</li>\n<li>在嵌套循环中使用有意义的变量名增强可读性</li>\n<li>循环要尽可能短，便于一目了然</li>\n<li>把嵌套限制在3层以内</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"不常见的控制结构\"><a href=\"#不常见的控制结构\" class=\"headerlink\" title=\"不常见的控制结构\"></a>不常见的控制结构</h3><ul>\n<li>多处返回：指程序中途的return或exit<ul>\n<li>只在能增强可读性时，使用中途的<code>return</code></li>\n<li>用防卫子句提前退出，简化复杂的错误处理</li>\n<li>减少程序中的<code>return</code>数目</li>\n</ul>\n</li>\n<li>递归：将复杂问题分而治之<ul>\n<li>确认终止条件</li>\n<li>使用安全计数器防止出现无穷递归</li>\n<li>把递归限制在一个子程序里，避免循环调用</li>\n<li>留意栈空间</li>\n<li>可以用循环结构等价式的先考虑循环结构，如阶乘和斐波那契数列</li>\n</ul>\n</li>\n<li><code>goto</code><ul>\n<li>反对随意使用<code>goto</code></li>\n<li><code>goto</code>灵活度太高，不容易用好，在可以使用其他控制结构时，不使用<code>goto</code></li>\n<li>在错误处理中，可以用状态变量、<code>try finally</code>语句实现跳出正常流</li>\n<li>如果在那1%的情况下需要使用<code>goto</code>，注意以下几点<ul>\n<li>尽量一个子程序只使用一个<code>goto</code></li>\n<li>尽量向前跳转而非向后</li>\n<li>确保所有的goto标号都被执行到</li>\n<li><strong>确认<code>goto</code>不会产生执行不到的代码</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"表驱动法\"><a href=\"#表驱动法\" class=\"headerlink\" title=\"表驱动法\"></a>表驱动法</h3><p>表驱动法是<strong>空间换时间</strong>的一种编程模式，使用数据结构模拟逻辑结构，将大部分复杂度放到容易被理解的数据结构中，从而提升代码可读性。下面是一个代码范例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (((<span class=\"string\">&#x27;a&#x27;</span> &lt;= inputChar) &amp;&amp; (inputChar &lt;= <span class=\"string\">&#x27;z&#x27;</span>)) ||</span><br><span class=\"line\">  ((<span class=\"string\">&#x27;A&#x27;</span> &lt;= inputChar) &amp;&amp; (inputChar &lt;= <span class=\"string\">&#x27;Z&#x27;</span>)))  &#123;</span><br><span class=\"line\">  charType = CharacterType.Letter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((inputChar == <span class=\"string\">&#x27; &#x27;</span>) || (inputChar == <span class=\"string\">&#x27;,&#x27;</span>) ||</span><br><span class=\"line\">  (inputChar = <span class=\"string\">&#x27;.&#x27;</span>) || (inputChar == <span class=\"string\">&#x27;!&#x27;</span>) || (inputChar == <span class=\"string\">&#x27;(&#x27;</span>) ||</span><br><span class=\"line\">  (inputChar = <span class=\"string\">&#x27;)&#x27;</span>) || (inputChar == <span class=\"string\">&#x27;:&#x27;</span>) || (inputChar == <span class=\"string\">&#x27;;&#x27;</span>) ||</span><br><span class=\"line\">  (inputChar = <span class=\"string\">&#x27;?&#x27;</span>) || (inputChar == <span class=\"string\">&#x27;-&#x27;</span>)) &#123;</span><br><span class=\"line\">  charType = CharacterType.Punctuation;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((<span class=\"string\">&#x27;0&#x27;</span> &lt;= inputChar) &amp;&amp; (inputChar &lt;= <span class=\"string\">&#x27;9&#x27;</span>)) &#123;</span><br><span class=\"line\">  charType = CharacterType.Digit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用一个查询表建立每个字符和它的字符类型的关联后，代码可以简化为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">charType = charTypeTable[inputChar];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查表方法<ul>\n<li>直接访问：如查询每月天数，或不同年龄对应的保险费率<ul>\n<li>有的时候键值要预先处理后才能直接使用，如可能很多年龄对应相似的费率，这时最好先将年龄<strong>换算</strong>到一个更好的key上</li>\n<li>进一步，我们可以把键值转换提取为独立的子程序</li>\n</ul>\n</li>\n<li>索引访问表：和直接访问的区别在于，对于不易<strong>换算</strong>到键值的情况，提供一个额外的索引表，先<strong>映射</strong>到索引表再查到数据</li>\n<li>阶梯访问表：主要针对表中的记录是对<strong>数据范围</strong>而非<strong>数据点</strong>生效的情况，使用端点作为key<ul>\n<li>留心端点带来的off-by-one情况</li>\n<li>可以使用二分查找代替顺序查找</li>\n<li>也可以使用索引访问技术</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一般性问题\"><a href=\"#一般性问题\" class=\"headerlink\" title=\"一般性问题\"></a>一般性问题</h3><h4 id=\"布尔表达式\"><a href=\"#布尔表达式\" class=\"headerlink\" title=\"布尔表达式\"></a>布尔表达式</h4><ul>\n<li>使用<code>true</code>或<code>false</code>作判断</li>\n<li>简化复杂的表达式<ul>\n<li>使用中间变量或布尔函数</li>\n<li>使用决策表替代复杂的判断逻辑</li>\n</ul>\n</li>\n<li>编写<strong>肯定</strong>的布尔表达式，会让布尔表达式更易理解</li>\n<li>用括号分割较长的布尔表达式</li>\n<li>注意短路求值或惰性求值的情况</li>\n<li><strong>按照数轴的顺序编写数值表达式</strong>，类似<code>MIN_VALUE &lt;= i and i &lt;= MAX_VALUE</code>，可读性好很多</li>\n<li>在C语言中最好把常量放在左边</li>\n<li>注意区分Java中<code>a==b</code>和<code>a.equals(b)</code></li>\n</ul>\n<h4 id=\"空语句\"><a href=\"#空语句\" class=\"headerlink\" title=\"空语句\"></a>空语句</h4><ul>\n<li>小心使用</li>\n<li>使用<code>doNothing()</code>函数或<code>noop()</code>函数</li>\n<li>考虑能否换用非空的循环体</li>\n</ul>\n<h4 id=\"优化深层嵌套\"><a href=\"#优化深层嵌套\" class=\"headerlink\" title=\"优化深层嵌套\"></a>优化深层嵌套</h4><ul>\n<li>优化重复的<code>if</code>检查</li>\n<li>使用<code>break</code>简化嵌套<code>if</code>，如防卫子句</li>\n<li>转换成一组<code>if-then-else</code>结构</li>\n<li>转换成<code>case</code>语句</li>\n<li>将深度嵌套的语句抽离成子程序</li>\n<li>借助多态</li>\n<li>借助异常来跳出正常流</li>\n</ul>\n<h4 id=\"结构化编程\"><a href=\"#结构化编程\" class=\"headerlink\" title=\"结构化编程\"></a>结构化编程</h4><p>结构化编程的思路是仅使用<strong>顺序</strong>、<strong>选择</strong>、<strong>迭代</strong>的思路描述程序流，避免使用<code>break</code>，<code>continue</code>，<code>return</code>，<code>try-catch</code>来打断。</p>\n<h4 id=\"降低复杂度\"><a href=\"#降低复杂度\" class=\"headerlink\" title=\"降低复杂度\"></a>降低复杂度</h4><ul>\n<li><strong>程序复杂度的一个衡量标准是，为了理解程序，必须在同一时间记忆的智力实体数目</strong>，即理解程序花费的精力</li>\n<li>控制流的复杂度和不可靠的代码以及频繁出现的错误息息相关</li>\n<li>可以通过计算子程序的“决策点”粗估子程序的复杂度<ul>\n<li>从1开始，遇到<code>if</code>，<code>while</code>，<code>repeat</code>，<code>for</code>，<code>and</code>，<code>or</code>加一，为每一种<code>case</code>加一</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "编程",
                "范式",
                "设计"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/12/02/clean-code/",
            "url": "http://shenlvmeng.github.com/blog/2019/12/02/clean-code/",
            "title": "《代码整洁之道》——有一个好的代码品味",
            "date_published": "2019-12-02T15:08:32.000Z",
            "content_html": "<blockquote>\n<p>The only valid measurement of code quality: WTFs&#x2F;minute</p>\n</blockquote>\n<p>在成为一个程序员的初期，实现功能还需磕磕绊绊的阶段，我们大抵没有精力操心代码风格的问题；而在能够搞定环境和API使用的时间段，大部分人又会沉湎于使用一门语言让想象实现的成就感，而没有发现暗藏在迭代后的危机。往往迭代了一段时间后，才发现之前埋下的巨坑已经让自己无从下手。这时一部分人醒悟过来，意识到一个优良的代码风格对于项目推进的长远意义。这也是《Clean Code》这本书的宗旨。它较之《程序员修炼之道》更为具体，较之《重构》更为宏观。对于工作一段时间后的程序员来说，是一个很好的提醒和反思归纳的建议。让代码work的方式是千万种，而让代码可持续，可扩展，长久work的方式也许需要前辈指引些方法。</p>\n<h2 id=\"观念\"><a href=\"#观念\" class=\"headerlink\" title=\"观念\"></a>观念</h2><blockquote>\n<p>Later equals never —— Leblanc Law</p>\n</blockquote>\n<p>糟糕的代码会让人难以下手，拖慢进度，若无人着手改善，混乱会持续增加，进而降低团队生产力，降低人效，然后搞砸整个项目。为什么不一开始就打好基础，写出整洁代码呢？</p>\n<p>下面是一些大师对“整洁代码”的界定</p>\n<ul>\n<li>“代码逻辑直截了当，缺陷难以隐藏；减少依赖关系，从而便于维护；性能调优，省得引人做出没规矩的优化，干出蠢事；整洁的代码只干一件事” —— Bjarne Stroustrup</li>\n<li>“代码简单直接，如同优美的散文；从不隐藏设计者的意图，充满干净利落的抽象和直截了当的控制语句” —— Grady Booch</li>\n<li>“可由作者外的人阅读和扩展，应该有单元测试和验收测试；只使用有意义的命名；提供尽量正交的使用方法（一种而非多种做一件事的方法）；尽量少的API；尽量少的依赖关系，且要明确定义和清晰提供；代码应从字面意义上表达其含义” —— Dave Thomas</li>\n<li>“整洁的代码总是看起来像某位特别在意的人写的，几乎没有改进的余地，所有的改进都会回到原点” —— Michael Feather</li>\n<li>“能通过所有测试；没有重复代码，表达力强大；体现系统中的全部设计理念；包括尽量少的实体，如类、方法、函数。” —— Ron Jeffries</li>\n<li>“整洁代码让每个例程都深合己意；漂亮代码让语言看起来像是专门为解决那个问题而存在” —— Ward Cunningham</li>\n</ul>\n<p>编写代码的难度，取决于读周边代码的难度，要想干得快，就先让代码易读。</p>\n<blockquote>\n<p>让营地比你来时更干净 —— 童子军军规</p>\n</blockquote>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>好的命名，可以让人一眼就明白代码的逻辑。看下面两段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"type\">int</span>[]&gt; getThem() &#123;</span><br><span class=\"line\">  List&lt;<span class=\"type\">int</span>[]&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] x : theList)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x[<span class=\"number\">0</span>] == <span class=\"number\">4</span>)</span><br><span class=\"line\">      list1.add(x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Cell&gt; <span class=\"title function_\">getFlaggedCells</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  List&lt;Cell&gt; flaggedCells = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Cell&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Cell cell : gameBoard)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cell.isFlagged)</span><br><span class=\"line\">      flaggedCells.add(cell);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些准则：</p>\n<ul>\n<li>名副其实，一旦发现更好的，就替换掉旧的。<strong>如果名称还需要注释补充，那就不算名副其实</strong></li>\n<li>避免误导，提防使用不同之处较小的名称，比如<code>UsernameListEmptyFilter</code>和<code>UsernameListNullFilter</code>，不要混用1和l，以及0和O</li>\n<li>做有意义的区分，少废话，反例是<code>a1</code>和<code>a2</code>，<code>nameString</code>和<code>name</code></li>\n<li>使用<strong>能读出来</strong>的名称，方便程序员的沟通</li>\n<li>使用<strong>可搜索</strong>的名称，仅在块作用域或短函数内使用单字母名称</li>\n<li>不把类型信息放在名称中</li>\n<li>减少不必要的前缀和后缀</li>\n<li>类名应该是名词，方法名应该是动词或动词短语</li>\n<li>别玩梗</li>\n<li>标准化语素，为每一个抽象概念选择一个统一的词</li>\n<li>别用有多重含义的词汇，这会增加使用者顾虑和理解成本</li>\n<li>只在没有明确定义的场景下使用语境（类，前缀……）</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>下面是一些准则：</p>\n<ul>\n<li><strong>短小，更短小</strong></li>\n<li><strong>只做一件事，只做一件事，只做一件事</strong>，重要的事情说三遍<ul>\n<li>还有一种方式可以帮助判断函数是不是只做了一件事：<strong>函数语句是否在一个抽象层级上</strong></li>\n<li>只做一件事的函数无法被继续合理拆分成多段</li>\n</ul>\n</li>\n<li>让代码拥有从上到下的自然的阅读顺序，尽量避免跳来跳去的阅读顺序</li>\n<li>为函数使用<strong>描述性</strong>的名称</li>\n<li>函数<strong>最多3个入参</strong>，最理想是没有参数，其次是1个，再其次是2个，要避免3个参数<ul>\n<li><strong>布尔类型的参数会让你的函数难以理解</strong></li>\n<li>使用二元参数时，最好保证前后顺序不敏感</li>\n<li>对于复杂的入参，可以用对象封装起来</li>\n</ul>\n</li>\n<li>函数要么只做副作用（<em>做什么事</em>），要么没有副作用（<em>回答什么事</em>），而且能从名称中一目了然地看到</li>\n<li>用异常代替错误码，错误处理也是一件事</li>\n<li><strong>别重复自己（Don’t repeat yourself, DRY）</strong>。重复是软件中一切邪恶的根源，软件开发领域的所有创新都在不断尝试从源代码中消灭重复</li>\n</ul>\n<p>函数是语言的动词，类是名词。大师级的程序员把系统当做故事来讲，而不是程序来写。他们使用特定编程语言提供的工具构建一种<strong>更丰富和更具表达力的语言</strong>。好的函数必须干净利落的组合在一起，形成清晰明确的语言，帮你<strong>讲好故事</strong>。这个过程不是一蹴而就的，你可以现象什么就写什么，然后一点点打磨它。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><blockquote>\n<p>使用注释 &#x3D; 承认自己无法用代码表达清楚意图</p>\n</blockquote>\n<p>列举注释的准则前，必须摆正观念。<strong>注释是一种必须的恶，如果编程语言足够有表达力，或你长于用语言表达自己的意图，那么就不需要注释。注释的恰当用法是弥补我们用代码表达意图时遭遇的失败。</strong>注释存在的时间越久，具体所描述的事实就越远。原因很简单，程序员不可能坚持维护注释。</p>\n<p>的确，程序员应该让注释保持可维护而精准，但最好能直接写清楚代码，保证无须编写注释。<strong>真实只在一处：代码</strong>，只有代码能忠实告诉你它做的事。</p>\n<ul>\n<li><strong>注释无法挽救糟糕的代码</strong>，与其为糟糕代码补充大量注释，不如花时间写出整洁有表达力的代码</li>\n<li><strong>用代码代替注释</strong></li>\n<li>有些无法避免且合理存在的注释<ul>\n<li>法律信息</li>\n<li>对函数名的补充</li>\n<li>对稍微反常规意图的解释，避免误解</li>\n<li>糟糕的代码来自外部库或外部API</li>\n<li>敏感代码的警告</li>\n<li>TODO、FIXME</li>\n<li>Javadoc</li>\n</ul>\n</li>\n<li>下面则是一些很常见的糟糕注释，它们只是糟糕代码的借口<ul>\n<li>只有自己看得懂的注释</li>\n<li>对函数名的复述</li>\n<li>误导性注释</li>\n<li>日志型注释，如Milestone记录</li>\n<li>废话</li>\n<li>位置标记，如<code>====================</code></li>\n<li>代码署名</li>\n<li><em>大多数</em>注释掉的代码</li>\n<li>百科式的介绍</li>\n<li>私有代码的Javadoc</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>格式即代码风格，可以利用lint这样的自动化工具完成，需要在团队内保持一致。</p>\n<h3 id=\"垂直格式\"><a href=\"#垂直格式\" class=\"headerlink\" title=\"垂直格式\"></a>垂直格式</h3><p>在从上到下的组织上，</p>\n<ul>\n<li>可以向报纸一样，先大纲，再粗线条概述，再给出细节，越往下细节越多</li>\n<li>用<strong>空行</strong>分隔概念</li>\n<li>靠近的代码行暗示了代码间的紧密关系</li>\n<li>应避免迫使读者在源文件和类之间跳来跳去<ul>\n<li>变量声明应尽量靠近使用位置</li>\n<li>循环中的控制变量总在循环语句中声明</li>\n<li>类成员在类顶部声明</li>\n<li>如果某个函数调用了另一个，就应该把它们放一起</li>\n<li>概念相关的代码应该放在一起，如<code>getHour</code>和<code>getMinute</code></li>\n<li>如果可以，最好把被调用的函数放在执行调用的函数下面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"横向格式\"><a href=\"#横向格式\" class=\"headerlink\" title=\"横向格式\"></a>横向格式</h3><ul>\n<li>水平字符的上限，100或120</li>\n<li>使用<strong>空格</strong>分隔概念</li>\n<li><strong>不需要水平对齐</strong>，以为从左到右的阅读顺序优先于从上到下</li>\n<li>学会用<strong>缩进</strong>表现层级</li>\n</ul>\n<h2 id=\"对象和数据结构\"><a href=\"#对象和数据结构\" class=\"headerlink\" title=\"对象和数据结构\"></a>对象和数据结构</h2><ul>\n<li><strong>对象</strong>把数据隐藏于抽象的后面，暴露操作数据的函数，<strong>数据结构</strong>暴露数据，不提供有意义的函数。</li>\n<li>过程式代码难以添加新的数据结构，因为必须修改所有函数；面向对象代码难以添加新函数，因为必须修改所有类</li>\n<li>得墨忒尔律：类C的方法f只应该调用以下对象的方法：<strong>C、f创建的对象、作为参数传给f的对象、C的成员所持有的对象</strong></li>\n<li><strong>数据结构</strong>只简单地拥有公有变量，没有函数；而<strong>对象</strong>则只拥有私有变量和函数。一半是对象一半是数据结构的混淆会增加添加新函数和数据结构的难度</li>\n<li>DTO（Data Transfer Objects，数据传输对象）就是只有公有变量，没有函数的类，Active Record就是DTO的一种</li>\n</ul>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>错误处理很重要，但要是它搞乱了代码逻辑，那就是错误的用法。</p>\n<ul>\n<li>返回异常而不是错误码</li>\n<li>try-catch-finally语句块就像事务，可以帮你定义用户应该期待些什么</li>\n<li>在Java中，可控异常违反开闭原则带来的成本要高于收益</li>\n<li>打包第三方API，一方面降低了依赖的覆盖面，另一方面也有助于模拟第三方调用</li>\n<li>可以把抛出错误封装成特定的函数</li>\n<li>别返回和传递null值</li>\n</ul>\n<h2 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h2><p>边界即我们代码和第三方代码的连接处。</p>\n<ul>\n<li>通过编写测试来概览和理解第三方代码的形式叫做<strong>学习性测试（learning tests）</strong>。它可以帮助我们快速试错和反馈，从而对第三方API快速上手。</li>\n<li>在第三方代码尚未就绪时，<strong>编写我们想要的接口</strong>，可以使我们能保持代码在自己控制中，并在未来通过编写adapter的形式无痛迁移</li>\n<li>应尽量避免过多依赖第三方的特定信息，更多依靠你能控制的东西，好过依靠你控制不了的东西，免得日后受其控制</li>\n</ul>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><ul>\n<li>TDD（Test-Driven Development）三定律<ul>\n<li>在编写不能通过的单元测试前，不编写生产代码</li>\n<li>只编写刚好无法通过的单元测试，不能编译也算</li>\n<li>只编写刚好足已通过失败测试的生产代码</li>\n</ul>\n</li>\n<li><strong>测试代码和生产代码一样重要</strong>。正是单元测试让你的代码可扩展、可维护、可复用</li>\n<li>整洁的测试代码一样要求<strong>可读性</strong>。大多数测试代码可以总结为构造-操作-检验（Build-Operate-Check）模式。第一个环节构造测试数据，第二个环节操作数据，第三个环节验证是否得到期望的结果</li>\n<li>每个测试中的断言数量应该尽量少，且只测试一个概念</li>\n<li>FIRST原则<ul>\n<li>Fast，测试应该能够快速运行</li>\n<li>Independent，测试间应该相互独立</li>\n<li>Repeatable，测试应该在任何环境下可重复通过</li>\n<li>Self-Validating，测试应该有布尔值输出</li>\n<li>Timely，测试应及时编写</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><ul>\n<li>类应该由一组成员开始，从静态到普通，从共有到私有。且很少会有公有成员。</li>\n<li>类应该短小，<strong>类的名称应该能描述其权责</strong>。类名无法精确明明时，类大概就太长了。类名越含糊，类越有可能拥有过多权责。类名应该控制在25个字母内，且不应该包含连词。</li>\n<li>单一权责原则（Single Responsibility Principle，SRP）认为，类和模块应有且仅有<strong>一条加以修改的原因</strong>。这个原则可以帮助创造更好的抽象。它也是OO设计中最重要的概念之一。</li>\n<li>内聚：类应该只有少量实体变量，且所有方法都应该操作其中一些。当类的每个变量都被每个方法使用时，我们认为该类具有最大的内聚性。当发现类逐渐丧失内聚性时，尽早拆分它！让它变成多个短小的类。这个拆分的过程也是权责的拆分过程。</li>\n<li>通过基类和子类，可以在不修改类的同时，保持类对新功能的开放。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。可以通过抽象类和接口隔离细节修改带来的影响。</li>\n<li>降低类之间的连接耦合，可以采用依赖倒置原则（Dependency Inversion Principle，DIP），让类依赖于抽象（接口）而不是具体细节（自行构造类）</li>\n</ul>\n<h2 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h2><p><em>这一章的Java概念较多</em></p>\n<ul>\n<li>分开系统的构造和使用</li>\n<li><strong>依赖注入</strong>是控制反转的一种思路，它将第二权责从对象中拿出来，转移到专门的对象中去，从而遵循<strong>单一权责原则</strong></li>\n<li>我们应该专注于今天的用户故事，并且<strong>持续适当切分</strong>我们的关注面。书中举了Java AOP、AspectJ框架的例子</li>\n<li>实现时，使用<em>大致可工作的最简单方案</em>。只要软件构架有效切分了关注面，就比较好做根本性改动</li>\n</ul>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>Kent Beck关于测试的4个原则：</p>\n<ul>\n<li>运行所有测试，全面测试并持续通过所有测试的系统，就是可测试的系统。测试也能减少重构时可能破坏代码的顾虑。</li>\n<li>不可重复，使用模板生成或继承等高级概念</li>\n<li>表达程序员的意图。代码应当清晰表达作者的意图。使用好名称、保持类和函数的短小，以及之前章节提到的各种方法</li>\n<li>尽可能减少类和方法的数目，避免前两条规范的矫枉过正</li>\n</ul>\n<h2 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h2><p>并发是一种解耦策略，帮助我们分解开<strong>做什么（目的）</strong>和<strong>何时（时机）</strong>。</p>\n<ul>\n<li>并发<strong>有时</strong>能改善性能，会在编写额外代码上带来额外开销</li>\n<li>正确的并发是复杂的</li>\n<li>并发会带来系统结构的变化</li>\n</ul>\n<p>有些防御并发代码问题的原则：</p>\n<ul>\n<li>单一权责：分离并发代码和其他代码</li>\n<li>限制对可能共享的数据的访问</li>\n<li>线程应尽可能独立</li>\n</ul>\n<p>并发执行模式：</p>\n<ul>\n<li>生产者-消费者模式：数据通过队列传递，队列本身是一种限定资源</li>\n<li>读者-作者模式</li>\n<li>宴席哲学家问题</li>\n</ul>\n<p>还有一些需要注意的事情：</p>\n<ul>\n<li>警惕同步方法间的依赖</li>\n<li>尽可能减小sychronized区域</li>\n<li>尽早考虑程序关闭问题</li>\n<li>测试线程代码</li>\n</ul>\n<h2 id=\"3个实例\"><a href=\"#3个实例\" class=\"headerlink\" title=\"3个实例\"></a>3个实例</h2><p>书中以三个实例的重构过程向我们表现了一些将之前思路应用于优化代码的方式。</p>\n<h3 id=\"命令行参数解析：args\"><a href=\"#命令行参数解析：args\" class=\"headerlink\" title=\"命令行参数解析：args\"></a>命令行参数解析：args</h3><blockquote>\n<p>编程是一种技术甚于科学的东西，要编写整洁代码，必须先写肮脏代码，然后再<strong>清理它</strong></p>\n</blockquote>\n<p>在你的初稿，当代码糟糕透顶时甚至是前几稿中，很可能还是会存在烂摊子：成员多得吓人，奇怪命名的魔法字符串，一大堆的try-catch-finally代码。程序员们不都是蠢人，这堆糟糕透顶的代码其实是从最初看起来很合理但是<strong>扩展性差</strong>的代码一步步演化来的。</p>\n<p>需要使用一些总结和抽象，来简明地表达你的目的。另外，在重构前，“我”（其实是作者）要不厌其烦地强调TDD的必要性，它能保证你重构的每一步，系统都可以工作。在重构过程中，放进拿出是常见的事，小步幅、保持测试通过，你可能会不断移动各种东西。</p>\n<p>优秀的代码设计，大都关乎<strong>分隔</strong>——创建合适的空间防止不同种类的代码。对关注面的分隔让代码更易于理解和维护（减少理解所需要的大脑缓存）</p>\n<h3 id=\"JUnit\"><a href=\"#JUnit\" class=\"headerlink\" title=\"JUnit\"></a>JUnit</h3><ul>\n<li>不必要的编码前缀（<code>f_</code>）</li>\n<li>未封装的条件判断</li>\n<li>建议使用肯定式代替否定式判断</li>\n<li>奇怪的不直观的函数名</li>\n<li>易造成理解困难的变量名</li>\n<li>拆分违反SRP原则的函数</li>\n<li>避免隐式时序耦合的函数，用hardcode的形式显示表现时序耦合</li>\n</ul>\n<h3 id=\"SerialDate重构\"><a href=\"#SerialDate重构\" class=\"headerlink\" title=\"SerialDate重构\"></a>SerialDate重构</h3><p>再强调一遍，<strong>重构前要有一个完整的验证可行性的测试</strong>。然后开始重构：</p>\n<ul>\n<li>没有描述力的类名和术语名</li>\n<li>使用枚举代替常量类</li>\n<li>抽象类中不应知道实现细节</li>\n<li>基类不宜知道子类的情况</li>\n<li>多余的注释</li>\n<li>变量声明应该放在尽量靠近使用的地方</li>\n<li>如果有专业术语，就不要自己命名了</li>\n<li>不要写无用的模板代码</li>\n<li>如果函数对成员进行操作，它就不应该是静态的</li>\n<li>用<strong>解释临时变量</strong>的方式，让大段的代码更为简化和有表达力</li>\n<li>消除魔术数</li>\n</ul>\n<h2 id=\"味道和启发\"><a href=\"#味道和启发\" class=\"headerlink\" title=\"味道和启发\"></a>味道和启发</h2><p>作者在这里对《重构：既有代码设计的改善》里提到的味道做了自己的一些扩充，也可以作为对上面章节的回顾。</p>\n<p><em>“味道”，即那些看起来不大对劲的代码</em></p>\n<h3 id=\"注释-1\"><a href=\"#注释-1\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li>不恰当的信息，如修改记录</li>\n<li>过时的注释</li>\n<li>多余的废话</li>\n<li>错误的有误导性的注释</li>\n<li>注释掉的代码</li>\n</ul>\n<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>多步才能完成的构建</li>\n<li>多步才能完成的测试</li>\n</ul>\n<h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li>过多的入参</li>\n<li>布尔类型参数</li>\n<li>从未被调用的函数</li>\n<li>用于返回的参数</li>\n</ul>\n<h3 id=\"一般性问题\"><a href=\"#一般性问题\" class=\"headerlink\" title=\"一般性问题\"></a>一般性问题</h3><ul>\n<li>源文件中有多种语言</li>\n<li>明显违背字面意义的直觉</li>\n<li>不考虑边界情况</li>\n<li>忽视安全问题</li>\n<li><strong>重复</strong>，这也是最常见的问题。每次看到重复代码都代表遗漏了抽象。有一些常见的设计模式可以帮助你。</li>\n<li>代码的抽象层级有问题，或混杂。抽象类用来容纳高层级概念，子类用来容纳低层级概念。不同层级概念放在不同容器中。</li>\n<li>基类依赖于子类。通常来说，基类对子类应该一无所知</li>\n<li>信息过多，违背SRP</li>\n<li>从未使用的代码</li>\n<li>不恰当的垂直分隔</li>\n<li>语素前后不一致</li>\n<li>基于巧合、预设假设的耦合。异或是两个没有直接目的之间的模块的耦合。</li>\n<li><strong>特性依恋</strong>，类的方法只应对自身的成员和方法感兴趣，不应关注其他类的成员和方法</li>\n<li>使用boolean或枚举参数让一个函数表现多态。使用多个函数通常由于向单个函数传递代码来选择函数行为</li>\n<li>晦涩的意图，如魔术数、魔术字符串、过度简写的表达式</li>\n<li>位置错误的权责</li>\n<li>不恰当的静态方法，如完全不需要多态的函数</li>\n<li>使用自解释的变量名</li>\n<li>使用自解释的函数名</li>\n<li>理解算法</li>\n<li>把逻辑依赖（脑海中的限制&#x2F;已知条件）改为物理依赖</li>\n<li>使用if&#x2F;else、switch前想想有没有多态的实现方法</li>\n<li>遵循团队lint规则</li>\n<li>足够准确</li>\n<li>未封装的条件判断</li>\n<li>未封装的边界条件检测</li>\n<li>避免否定性条件</li>\n<li><strong>函数应该只做一件事</strong></li>\n<li><strong>函数应该只在一个抽象层级上</strong></li>\n<li>隐蔽的时序性耦合</li>\n<li>别随意，先好好思考再下手</li>\n<li>应该在较高层级放置可配置数据</li>\n<li>避免传递浏览，即遵守德墨忒尔律</li>\n</ul>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><ul>\n<li>使用通配符避免过长的导入清单</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">package</span>.*</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不要继承<em>常量</em>，使用静态导入</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> EmployeeConstants.*</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在可以的情况下，用枚举代替常量</li>\n</ul>\n<h3 id=\"名称\"><a href=\"#名称\" class=\"headerlink\" title=\"名称\"></a>名称</h3><ul>\n<li>使用描述性名称</li>\n<li>名称应该与抽象层级相符</li>\n<li>使用标准化语素</li>\n<li>使用无歧义的名称</li>\n<li>在较大作用范围使用较长名称，较小作用范围<em>可以</em>使用较短名称</li>\n<li>名称应该明确说明有副作用存在</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>要有足够的测试</li>\n<li>使用覆盖率工具</li>\n<li>别放过小测试</li>\n<li>被忽略的测试是对不确定事物的疑问</li>\n<li>测试边界条件</li>\n<li>测试失败的模式（pattern）会有启发性</li>\n<li>测试覆盖率的模式会有启发性</li>\n<li>测试应该快速</li>\n</ul>\n<h2 id=\"并发编程示例\"><a href=\"#并发编程示例\" class=\"headerlink\" title=\"并发编程示例\"></a>并发编程示例</h2><h3 id=\"客户端-x2F-服务端\"><a href=\"#客户端-x2F-服务端\" class=\"headerlink\" title=\"客户端&#x2F;服务端\"></a>客户端&#x2F;服务端</h3><ul>\n<li>如果吞吐量与I&#x2F;O有关，则并发编程可以提升运行效率</li>\n<li>保持并发系统整洁，把线程管理隔离到一个位置</li>\n</ul>\n<h3 id=\"可能的执行路径\"><a href=\"#可能的执行路径\" class=\"headerlink\" title=\"可能的执行路径\"></a>可能的执行路径</h3><p>深入到字节码和汇编语句的执行上，有些并非线程安全的操作中，不同的执行路径会带来不同结果。</p>\n<h3 id=\"了解类库\"><a href=\"#了解类库\" class=\"headerlink\" title=\"了解类库\"></a>了解类库</h3><ul>\n<li>Executor框架</li>\n<li>非锁定方案：AtomicBoolean，AtomicInteger和AtomicReference</li>\n<li>数据库连接、java.util中的容器、Servlet天生不是线程安全的</li>\n</ul>\n<h3 id=\"提升吞吐量\"><a href=\"#提升吞吐量\" class=\"headerlink\" title=\"提升吞吐量\"></a>提升吞吐量</h3><ul>\n<li>synchronized代码块最好能限制在小范围内</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁需要满足4个条件：</p>\n<ul>\n<li><strong>互斥</strong>，即资源数量有限，或无法在同一时间为多个线程公用</li>\n<li><strong>上锁及等待</strong>，从线程获取资源到完成工作前，不会释放这个资源</li>\n<li><strong>无抢先机制</strong>，线程无法从其他线程处夺取资源</li>\n<li><strong>循环等待</strong></li>\n</ul>\n<p>相反地，有4种避免死锁的方式：</p>\n<ul>\n<li><strong>不互斥</strong>，使用允许同时使用的资源，或增加资源数目</li>\n<li><strong>不上锁及等待</strong>，如果有等待情况就释放所有资源从新来过</li>\n<li><strong>满足抢先机制</strong></li>\n<li><strong>不做循环等待</strong></li>\n</ul>\n<h3 id=\"测试多线程代码\"><a href=\"#测试多线程代码\" class=\"headerlink\" title=\"测试多线程代码\"></a>测试多线程代码</h3><ul>\n<li>复现问题可能很难，可以借助工具（如ConTest）帮助</li>\n</ul>\n<p><em>–END–</em></p>\n",
            "tags": [
                "编程",
                "重构",
                "代码",
                "代码风格"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2018/05/01/sicp-note/",
            "url": "http://shenlvmeng.github.com/blog/2018/05/01/sicp-note/",
            "title": "SICP大纲",
            "date_published": "2018-05-01T09:18:04.000Z",
            "content_html": "<blockquote>\n<p>本文是《计算机程序的构造和解释》的笔记</p>\n</blockquote>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>序中其实也包含了很多睿智的观点，值得细细体会。</p>\n<ul>\n<li>“每一个计算机程序都是现实中的或者精神中的某个过程的一个模型”</li>\n<li>“我们很少能通过自己的程序将这种过程模拟到永远令人满意的程度”</li>\n<li>“不幸的是，随着程序变得更大更复杂（实际上它们几乎总是如此），这种描述本身的适宜性，一致性和正确性也都变得非常值得怀疑了”</li>\n<li>“如何利用一些已经证明和有价值的组织技术，将这些结构组合成更大的结构，这些都是至关重要的”</li>\n<li>“将我们的Lisp程序变换到‘机器’程序的过程本身也是抽象模型，是通过程序设计做出来的。研究和构造它们，能使人更加深刻地理解与任何模型的程序设计有关的程序组织问题”</li>\n<li>“计算机永远都不够大也不够快。硬件技术的每一次突破都带来了更大规模的程序设计事业，新的组织原理，以及更加丰富的抽象模型。每个读者都应该反复问自己‘到哪里才是头儿，到哪里才是头儿’——但是不要问的过于频繁，以免忽略了程序设计的乐趣，使自己陷入一种喜忧参半的呆滞状态中”</li>\n<li>“Pascal是为了建造金字塔——壮丽辉煌，令人震撼，是由各就其位的沉重巨石筑起的静态结构，而Lisp则是为了构造有机体——同样壮丽辉煌并令人震撼，由各就其位但却永不静止的无数简单的有机体片段构成的动态结构”</li>\n<li>“Lisp程序大大抬高了函数库的地位，使其可用性超越了催生它们的那些具体应用”</li>\n<li>“采用100个函数在一种数据结构上操作，远远优于用10个函数在10个数据结构上操作。作为这些情况的必然后果，金字塔矗立在那里千年不变，而有机体则必须演化，否则会死亡”</li>\n<li>“在任何非常大的程序设计工作中，一条有用的组织原则就是通过发明新语言，去控制和隔离作业模块之间的信息流动”</li>\n</ul>\n<h2 id=\"过程抽象\"><a href=\"#过程抽象\" class=\"headerlink\" title=\"过程抽象\"></a>过程抽象</h2><ul>\n<li>应用序和正则序</li>\n<li>递归和迭代在展开式上的区分，以及尾递归</li>\n<li>过程（函数）作为入参、返回值</li>\n<li>匿名函数和高阶函数</li>\n</ul>\n<h2 id=\"数据抽象\"><a href=\"#数据抽象\" class=\"headerlink\" title=\"数据抽象\"></a>数据抽象</h2><ul>\n<li>构造函数和方法函数</li>\n<li><code>cons</code>和<code>car</code>、<code>cdr</code></li>\n<li>序对和list（层次化数据）</li>\n<li>表操作和表映射</li>\n<li>序列化操作</li>\n<li>符号数据（类似字符串）</li>\n<li>数据的多种表示（类型）与通用操作</li>\n</ul>\n<h2 id=\"模块化、对象和状态\"><a href=\"#模块化、对象和状态\" class=\"headerlink\" title=\"模块化、对象和状态\"></a>模块化、对象和状态</h2><ul>\n<li>面向对象和面向流</li>\n<li>从时间角度理解赋值和局部状态</li>\n<li>赋值的利与弊</li>\n<li>赋值带来的环境模型解释（作用域、作用域链）<ul>\n<li>局部状态</li>\n<li>作用域模型的解释</li>\n</ul>\n</li>\n<li>变动的表<ul>\n<li>区分共享和相等（相同的指针、相同的值）</li>\n<li>队列与键值对</li>\n</ul>\n</li>\n<li>描述约束系统</li>\n<li>并发（交错进行的读写操作）<ul>\n<li>串行化和串行化组</li>\n<li>mutex(mutual exclusion)和实现</li>\n<li>死锁（多共享资源）<ul>\n<li>按顺序获取资源列表</li>\n<li>死锁恢复</li>\n<li>屏障同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流<ul>\n<li>延时求值的表序列</li>\n<li>延时求值的原理</li>\n<li>无穷流的构造</li>\n<li>流操作和组合</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"元语言设计\"><a href=\"#元语言设计\" class=\"headerlink\" title=\"元语言设计\"></a>元语言设计</h2><ul>\n<li>求值器（解释器）的工作与意义<ul>\n<li>在基本过程上提供组合与抽象构建一个语言<ul>\n<li>表达式的嵌套</li>\n<li>变量维护</li>\n<li>过程复合</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>求值器内核<ul>\n<li>eval 过程体解释</li>\n<li>apply 过程求值解释</li>\n<li>表达式规范化和实现 &#x2F; 派生表达式</li>\n<li>环境模型的数据结构</li>\n<li>求值器程序初始化</li>\n</ul>\n</li>\n<li>数据即程序<ul>\n<li>图灵机和停机问题</li>\n</ul>\n</li>\n<li>内部定义<ul>\n<li>内部定义是否应该具有时序</li>\n<li>Y结合子与lambda演算</li>\n</ul>\n</li>\n<li>语法分析与执行分离</li>\n<li>惰性求值<ul>\n<li>thunk化，关联表达式和环境</li>\n<li>惰性的表</li>\n</ul>\n</li>\n<li>非确定性求值（满足约束的所有可行解）<ul>\n<li>amb和自动回溯</li>\n<li>amb实现，成功与失败继续过程</li>\n</ul>\n</li>\n<li>逻辑语言设计<ul>\n<li>类SQL语言基于amb的实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"解释与编译\"><a href=\"#解释与编译\" class=\"headerlink\" title=\"解释与编译\"></a>解释与编译</h2><ul>\n<li>机器描述<ul>\n<li>基本指令与子程序（label）</li>\n<li>堆栈实现递归</li>\n</ul>\n</li>\n<li>基本指令的实现<ul>\n<li>类汇编语言</li>\n</ul>\n</li>\n<li>内存管理<ul>\n<li>表与堆栈的实现</li>\n<li>garbage collection机制</li>\n</ul>\n</li>\n<li>解释<ul>\n<li>基础操作实现</li>\n<li>尾递归优化解释</li>\n</ul>\n</li>\n<li>编译<ul>\n<li>与解释有何区别，各自优势</li>\n<li>env&#x2F;argl&#x2F;proc&#x2F;val&#x2F;continue寄存器</li>\n<li>编译器结构<ul>\n<li>语法分派</li>\n<li>入参：target（存储表达式值的寄存器）与linkage（continue寄存器）</li>\n<li>指令序列的结构与构造，分析指令序列，<code>preserving</code>机制避免无谓的堆栈操作</li>\n</ul>\n</li>\n<li>表达式的编译<ul>\n<li>linkage的编译，检查<code>next</code>或<code>return</code>的情况</li>\n<li>简单、条件表达式、表达式序列的编译</li>\n<li>lambda表达式的编译</li>\n</ul>\n</li>\n<li>过程的编译<ul>\n<li>入参的处理</li>\n<li>尾递归</li>\n</ul>\n</li>\n<li>指令序列的组合</li>\n<li>代码编译的实例</li>\n<li>优化变量查找<ul>\n<li>词法地址</li>\n</ul>\n</li>\n<li>解释与编译<ul>\n<li>解释：机器语言 -&gt; 用户程序</li>\n<li>编译：用户程序 -&gt; 机器语言</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>最后吐槽下，书是本好书，就是翻译的不太给力，在有些地方强行提高了理解难度。</p>\n",
            "tags": [
                "编程",
                "思想",
                "程序设计"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/07/10/hacker-and-artist/",
            "url": "http://shenlvmeng.github.com/blog/2017/07/10/hacker-and-artist/",
            "title": "黑客与画家 —— 关于编程和创业",
            "date_published": "2017-07-10T13:21:02.000Z",
            "content_html": "<p>《黑客与画家》是Paul Graham的博文集。出版于2006年。它从一个“黑客”的角度阐述了编程，互联网程序等时兴的概念。深刻新鲜而发人深省。其对工作、语言的认识别具特色，而在学校教育和贫富分化等方面的认识却略显偏颇。</p>\n<p>全书大致分为3部分</p>\n<ul>\n<li>1-4章解释黑客如何成长以及如何看待世界</li>\n<li>5-9章介绍创业、工作的方法论</li>\n<li>10-15章讨论编程语言的特点和使用方法</li>\n</ul>\n<p>下面仅摘出些句子。个人评注已加粗。</p>\n<h2 id=\"为什么书呆子不受欢迎\"><a href=\"#为什么书呆子不受欢迎\" class=\"headerlink\" title=\"为什么书呆子不受欢迎\"></a>为什么书呆子不受欢迎</h2><ul>\n<li>在人产生良知前，折磨是种娱乐。</li>\n<li>学校的真正目的是把儿童都关在一个地方，以便大人们白天可以腾出手来把事情做完（<strong>哈哈哈</strong>）</li>\n</ul>\n<h2 id=\"黑客与画家\"><a href=\"#黑客与画家\" class=\"headerlink\" title=\"黑客与画家\"></a>黑客与画家</h2><ul>\n<li>编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序</li>\n<li>大多数黑客不是通过大学课程学会编程的，他们从实践中学习，13岁时就已经自己动手写程序了。</li>\n<li>debug对我来说属于轻松的工作</li>\n<li>软件的部分功能就是解释自身，软件的使用方式最好能符合用户的直觉，源代码应该可以自己解释自己</li>\n<li>程序是写出来给人看的，附带能在机器上运行</li>\n</ul>\n<h2 id=\"不能说的话\"><a href=\"#不能说的话\" class=\"headerlink\" title=\"不能说的话\"></a>不能说的话</h2><ul>\n<li>（流行）第一批的接收者总是带有很强的抱负心，他们有自觉的精英意识，想把自己与普通人区分开来</li>\n<li>流行趋势确立以后，第二接收者就加入进来了，他们接受流行，不是因为想要与众不同，而是害怕与众不同</li>\n<li>与笨蛋辩论，你也会变成笨蛋</li>\n</ul>\n<h2 id=\"良好的坏习惯\"><a href=\"#良好的坏习惯\" class=\"headerlink\" title=\"良好的坏习惯\"></a>良好的坏习惯</h2><ul>\n<li>在我看来，一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案（<strong>真的么？</strong>）</li>\n</ul>\n<h2 id=\"另一条路\"><a href=\"#另一条路\" class=\"headerlink\" title=\"另一条路\"></a>另一条路</h2><ul>\n<li>（互联网程序）不需要为新版本付出额外的费用，或者做额外的准备，甚至可能你都不知道软件已经升级了</li>\n<li>互联网软件则完全不同，修改起来很方便。软件的发布过程可以分解成一系列的渐进式修改（<strong>快步小跑</strong>）</li>\n<li>软件应该做到用户认为它可以做到的事情。但是，你不知道用户到底怎么想</li>\n<li>没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司时有好处的。因为不管你的软件定价多少，有些用户永远不会购买</li>\n<li>要求用户做得越多，你担的风险就越大</li>\n<li>管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入</li>\n<li>从制造简洁的产品开始着手，首先要保证你自己愿意使用。然后，迅速作出1.0版，并不断加以改进</li>\n<li><strong>无论如何，你都要使用自己的软件</strong></li>\n</ul>\n<h2 id=\"如何创造财富\"><a href=\"#如何创造财富\" class=\"headerlink\" title=\"如何创造财富\"></a>如何创造财富</h2><div class=\"tip\">注意：标题不等于“如何致富”</div>\n\n<ul>\n<li>从经济学观点看，你可以把创业想象成一个压缩过程</li>\n<li>如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦。创业公司将你所有的压力压缩到三四年</li>\n<li>通过创造有价值的东西而致富，优势不仅在于它合法，还在于它更简单，因为你只需要做出别人需要的东西就可以了</li>\n<li>金钱不是财富，而只是我们用来转移财富所有权的东西</li>\n<li>公司就是许多人聚在一起创造财富的地方，能够制造更多人们需要的东西</li>\n<li>人们需要的东西就是财富</li>\n<li>上班的日子不如上学的日子有趣，但是有人付钱给你，而不是你付钱给学校</li>\n<li>创造财富是大多数公司盈利的手段</li>\n<li>上班的日子为什么会差别这么大？不要搞糊涂了，你现在已经从顾客变成了仆人</li>\n<li>收入和风险是对称的，所以如果有巨大的获利可能，就必然存在巨大的失败可能。如果你有一个令你感到安全的工作，你是不会致富的</li>\n<li>创业的付出和回报虽然总体上是成比例的，但是在个体上是不成比例的</li>\n<li>只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们</li>\n</ul>\n<h2 id=\"关注贫富分化\"><a href=\"#关注贫富分化\" class=\"headerlink\" title=\"关注贫富分化\"></a>关注贫富分化</h2><ul>\n<li>进入社会以后，你不能总是靠父母养活，如果你需要什么东西，要么你自己做出来，要么做其他东西与需要的人交换金钱，再用金钱去买你想要的东西</li>\n<li>技术肯定加剧了有技术者与无技术者之间的生产效率差异</li>\n<li>技术在加大收入差距的同时，缩小了大部分的其他差距</li>\n</ul>\n<h2 id=\"防止垃圾邮件的一种方法\"><a href=\"#防止垃圾邮件的一种方法\" class=\"headerlink\" title=\"防止垃圾邮件的一种方法\"></a>防止垃圾邮件的一种方法</h2><ul>\n<li>我对贝叶斯方法寄予厚望，因为它的过滤能力可以随着垃圾邮件一起进化</li>\n</ul>\n<h2 id=\"设计者的品味\"><a href=\"#设计者的品味\" class=\"headerlink\" title=\"设计者的品味\"></a>设计者的品味</h2><ul>\n<li>他想要的学生不仅应该技术过硬，还应当能够使用技术做出优美的产品</li>\n<li>你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了</li>\n<li>在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果</li>\n</ul>\n<h2 id=\"编程语言解析\"><a href=\"#编程语言解析\" class=\"headerlink\" title=\"编程语言解析\"></a>编程语言解析</h2><ul>\n<li>程序员的时间要比计算机的时间昂贵得多</li>\n<li>长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考</li>\n<li>有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事（<strong>即静态类型语言和动态类型语言</strong>）</li>\n<li>事实上，有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程</li>\n</ul>\n<h2 id=\"一百年后的编程语言\"><a href=\"#一百年后的编程语言\" class=\"headerlink\" title=\"一百年后的编程语言\"></a>一百年后的编程语言</h2><ul>\n<li>当我说Java不会成功时，我的意思是它和Cobol一样，进化之路已经走到了尽头（<strong>哦？</strong>）</li>\n<li>一种语言的内核设计越小、越干净，它的生命力就越顽强</li>\n<li>（<strong>用足够灵活的语言，聪明的程序员能写多好，笨的程序员就能写多烂</strong>）</li>\n<li>一百年后的程序员最需要的编程语言就是可以让你毫不费力写出程序第一版的编程语言</li>\n</ul>\n<h2 id=\"拒绝平庸\"><a href=\"#拒绝平庸\" class=\"headerlink\" title=\"拒绝平庸\"></a>拒绝平庸</h2><ul>\n<li>Lisp很值得学习。你掌握它之后，会感动它给你带来的极大启发</li>\n<li>大概在1960年，Lisp语言引入了垃圾回收机制。……闭包是20世纪60年代Lisp语言引入的功能……宏也是60年代中期Lisp语言引入的，现在还是一片处女地（这里的“宏”为Lisp中的<code>defmacro</code>）</li>\n<li>这里有一个评估竞争对手的妙招——关注他们的招聘职位</li>\n</ul>\n<h2 id=\"书呆子的复仇\"><a href=\"#书呆子的复仇\" class=\"headerlink\" title=\"书呆子的复仇\"></a>书呆子的复仇</h2><ul>\n<li>符号（Symbol）实际上是一种指针，指向存储在散列表中的字符串</li>\n<li>列表是Lisp的基本数据结构</li>\n<li>让客户感到满意才是你的设计方向。只要赢得用户，其他的事情就会接踵而至</li>\n<li>JavaScript的写法比Lisp和Ruby稍微长一点，因为JavaScript依然区分语句和表达式</li>\n<li>所有这些语言都是图灵等价的</li>\n<li>“任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是bug的、运行速度很慢的Common Lisp实现。”</li>\n<li>想解决一个困难的问题，有三条路：1）使用一种强大的语言，2）为这个难题写一个事实上的解释器，3）你自己变成这个难题的人肉编译器（<strong>翻译过来就是语言本身&#x2F;设计模式&#x2F;问题抽象</strong>）</li>\n</ul>\n<h2 id=\"梦寐以求的编程语言\"><a href=\"#梦寐以求的编程语言\" class=\"headerlink\" title=\"梦寐以求的编程语言\"></a>梦寐以求的编程语言</h2><ul>\n<li>优秀的函数库的重要性将超过语言本身</li>\n<li>就算委员会只有两个人，还是会妨碍“再设计”，典型例子就是软件内部的各个接口有不同的人负责。这时除非两个人都同意改变接口，否则接口就无法改变</li>\n</ul>\n<h2 id=\"设计与研究\"><a href=\"#设计与研究\" class=\"headerlink\" title=\"设计与研究\"></a>设计与研究</h2><ul>\n<li>“用户需要的设计”≠“用户要求的设计”</li>\n<li>设计必须以人为本</li>\n<li>在软件领域，贴近用户的设计思想被归纳为“弱即是强”模式。</li>\n<li>一种功能有限但易于使用的软件可能对用户有更大吸引力</li>\n<li>先做出原型，在逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效</li>\n</ul>\n",
            "tags": [
                "编程",
                "黑客与画家",
                "创业"
            ]
        }
    ]
}
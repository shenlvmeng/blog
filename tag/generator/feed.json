{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"generator\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-2/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-2/",
            "title": "JavaScript中的异步编程 下",
            "date_published": "2017-03-29T06:28:06.000Z",
            "content_html": "<blockquote>\n<p>本文启发于阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2015/04/generator.html\">深入掌握 ECMAScript 6 异步编程</a></p>\n</blockquote>\n<p><span></span></p>\n<blockquote>\n<p>上篇传送门<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-1/\">JavaScript中的异步编程 上</a></p>\n</blockquote>\n<p>上篇说到了使用回调的思路解决JavaScript中异步编程的难题。可不论是显式的指定回调函数，通过事件绑定响应还是通过事件订阅、promise.then，都和逃不出回调的思路。写起来仍不够自然，且在批次回调任务时难以解决。</p>\n<p>有没有办法能使我们像平时写同步代码那样，来书写异步代码呢？ES6出现后，Generator对象给了我们这个机会。</p>\n<h3 id=\"生成器函数\"><a href=\"#生成器函数\" class=\"headerlink\" title=\"生成器函数\"></a>生成器函数</h3><p>提到生成器函数前，需要提到<a href=\"https://en.wikipedia.org/wiki/Coroutine\">协程</a>(coroutine)这个概念。协程是轻量级用户态的线程。用户可以手动控制协程的暂停和继续，配合线程实现异步任务。协程间通过<code>yield</code>方式切换执行权，并交换信息。就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">asyncFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行someFunc后交出执行权</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"keyword\">yield</span> <span class=\"title function_\">someFunc</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>协程在遇到<code>yield</code>关键字时交出自己的执行权，直到执行权返回。这里<code>someFunc</code>方法可以是一个异步操作。</p>\n<p>ES6中协程体现在Generator函数中。函数在<code>function</code>关键字后添加星号<code>*</code>以示和普通函数的区分。Generator函数是可以通过<code>yield</code>暂停执行的。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* gen () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>(); </span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>Generator函数的调用通过<code>next</code>方法完成。每次调用后会将函数流程移动到下一个yield语句处。yield的返回包含两个属性<code>value</code>和<code>done</code>。前者代表yield的返回值，后者代表生成器函数是否已经执行完毕。</p>\n<p>同时，每次调用<code>next</code>方法时，可以输入参数作为上个异步任务的返回值。调用<code>throw</code>方法可以向生成器函数内抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* gen () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>(); </span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\">g.<span class=\"keyword\">throw</span>(<span class=\"string\">&#x27;some error&#x27;</span>) <span class=\"comment\">// &#x27;some error&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用Generator函数封装一个异步操作，再通过执行器管理函数内部的异步流程。通过这种方式，在Generator函数中可以很方便地书写异步操作。例如，利用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch API</a>发起一次跨域请求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;http://www.example.org/data.json&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>fetch API返回一个promise对象，通过为之指定<code>then</code>，处理fetch成功后的返回值。</p>\n<h3 id=\"co和koa\"><a href=\"#co和koa\" class=\"headerlink\" title=\"co和koa\"></a>co和koa</h3><p>我们上面提到了使用Generator还缺少的一样东西——执行器。使用Generator函数在其中通过yield返回Promise，但是外层还是需要在promise的then方法中书写<code>g.next(data)</code>来通知协程继续操作。<a href=\"https://github.com/tj/co\">co</a>函数库帮助我们<strong>完成了执行器的工作</strong>。</p>\n<p>以回调函数中完成读文件操作为例（注意：其中的readFile先被改写成返回thunk函数的格式，即只接收callback作为唯一的输入参数）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;co&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readFile</span>(<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">readFile</span>(path, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf-8&#x27;</span>&#125;, cb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">co</span>(gen);</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，为<code>co</code>函数传入Generator函数，就会自动依次执行其中的异步任务，并在返回一个Promise对象。因此，可以给<code>co</code>函数通过<code>then</code>的方式添加回调函数。</p>\n<h4 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h4><p>co的代码并不复杂，核心代码只有数十行。摘录如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">co</span>(<span class=\"params\">gen</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = slice.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> gen === <span class=\"string\">&#x27;function&#x27;</span>) gen = gen.<span class=\"title function_\">apply</span>(ctx, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gen || <span class=\"keyword\">typeof</span> gen.<span class=\"property\">next</span> !== <span class=\"string\">&#x27;function&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(gen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">onFulfilled</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">onFulfilled</span>(<span class=\"params\">res</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = gen.<span class=\"title function_\">next</span>(res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">next</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">onRejected</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = gen.<span class=\"keyword\">throw</span>(err);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">next</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">ret</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret.<span class=\"property\">done</span>) <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(ret.<span class=\"property\">value</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = toPromise.<span class=\"title function_\">call</span>(ctx, ret.<span class=\"property\">value</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value &amp;&amp; <span class=\"title function_\">isPromise</span>(value)) <span class=\"keyword\">return</span> value.<span class=\"title function_\">then</span>(onFulfilled, onRejected);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">onRejected</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class=\"line\">        + <span class=\"string\">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class=\"title class_\">String</span>(ret.<span class=\"property\">value</span>) + <span class=\"string\">&#x27;&quot;&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在看co的代码前，我们不妨先想一下它的原理。Generator 函数只是一个异步操作的容器，它的流程和控制是由外部机制完成的。而<strong>thunk函数（这个在下面介绍）和Promise对象恰恰可以方便得在回调函数和then方法中交还执行权给Generator函数</strong>。</p>\n<p>这么来看就简单了，<strong>co函数库针对thunk函数和Promise对象封装了执行器</strong>。以比较好理解的Promise对象为例（co在内部也会将thunk函数转为Promise对象）。</p>\n<p>首先将readFile的thunk函数转为Promise对象。其中ctx绑定到co函数体内。（co函数库的thunkToPromise函数）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"keyword\">function</span> (<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span> (<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)&#123;</span><br><span class=\"line\">        readFile.<span class=\"title function_\">call</span>(ctx, <span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (err) <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">            <span class=\"title function_\">resolve</span>(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后同样使用上节中的生成器函数<code>gen()</code>，并手动执行下一步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    g.<span class=\"title function_\">next</span>(data).<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">        g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>发现规律了么？<strong>自动执行器实际上就是在<code>g.done == false</code>时，不断地在then方法中嵌套添加回调函数</strong>。结果呼之欲出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行器</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">run</span> (gen) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> g = gen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.<span class=\"property\">done</span>) <span class=\"keyword\">return</span> res.<span class=\"property\">value</span>;</span><br><span class=\"line\">        res.<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">run</span>(gen);</span><br></pre></td></tr></table></figure>\n\n<p>每执行一次next，检查<code>done</code>的状态，若未结束则在then方法继续指定next方法，等待下一次返回结果。这也是co函数库的基本原理。</p>\n<h5 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h5><p>理解了原理后，回头看co的源码，就比较好理解了。前6行对传入的<code>gen</code>检测是否为Generator类型。<code>onFulfilled</code>函数和<code>onRejected</code>函数对Generator函数原有的<code>next</code>和<code>throw</code>函数进行了封装，便于错误捕获和处理。</p>\n<p>在<code>next</code>方法中，主要做了下面的4步微小的工作：</p>\n<ol>\n<li>查是否已经到Generator函数的最后一步，如果是则返回</li>\n<li>确保每次<code>yield</code>返回值都是Promise对象</li>\n<li>通过<code>then</code>方法，为返回值添加回调函数，并在回调中再次调用自身</li>\n<li>对于类型不合适的<code>gen</code>，将状态修改为<code>rejected</code></li>\n</ol>\n<p>co能接收的yield返回值类型是有限的（尽管Generator函数中的yield后不限制返回值类型），有thunk函数，array，object，Promise对象。其中array和object使co可以胜任并发的操作，即可以在yield中返回多个异步操作任务。</p>\n<h4 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h4><p>koa是建立在generator和co之上的中间件框架，由Express开发人员打造。它通过组合不同的生成器函数，避免了繁杂易出错的回调函数嵌套。koa中没有绑定任何中间件，仅仅提供了一个轻量级函数库。</p>\n<blockquote>\n<p>Koa 中间件以一种更加传统的方式级联起来, 跟你在其他系统或工具中碰到的方式非常相似。 然而在以往的 Node 开发中, 级联是通过回调实现的, 想要开发用户友好的代码是非常困难的, Koa 借助 generators 实现了真正的中间件架构, 与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的方法直到某个结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 yield next 关键字时，会被传递到下游中间件（downstream），在 yield next 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>\n</blockquote>\n<h3 id=\"thunk\"><a href=\"#thunk\" class=\"headerlink\" title=\"thunk\"></a>thunk</h3><p>上文中提到的thunk函数实际上由来已久，它是函数传名调用的一种实现方式，不同于函数的传值调用。就像下面的例子一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行器</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>(x * <span class=\"number\">3</span> + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以写成下面这样</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">thunk</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">3</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">thunk, <span class=\"number\">1</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">thunk</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript中的thunk函数有着另外的意思，它替换的不是一个输入参数，而是<strong>将多参数的函数替换成单参数的版本，且只接受回调函数作为输入参数</strong>，正如之前写到的例子一样。</p>\n<p>一个简单的thunk函数转换器写起来并不复杂，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> thunk = <span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">done</span>) &#123;</span><br><span class=\"line\">            args.<span class=\"title function_\">push</span>(done);</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/tj/node-thunkify\">node-thunkify</a>模块对此又多了一些监测，如在最内层的function添加called变量确保回调函数只执行一次。Thunkify的源码相比co就更短了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">thunkify</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">assert</span>(<span class=\"string\">&#x27;function&#x27;</span> == <span class=\"keyword\">typeof</span> fn, <span class=\"string\">&#x27;function required&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个包含thunk函数的函数，返回的thunk函数用于执行yield，而外围这个函数用于给thunk函数传递参数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存当前上下文环境，给fn提供执行环境</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 将参数类数组转化为数组（实现方式略显臃肿，可直接用Array.prototype.slice.call(arguments)实现）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; args.<span class=\"property\">length</span>; ++i) &#123;</span><br><span class=\"line\">            args[i] = <span class=\"variable language_\">arguments</span>[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 真正的thunk函数（有且只有一个参数是callback的函数，且callback的第一个参数为error）</span></span><br><span class=\"line\">        <span class=\"comment\">// 类似于：</span></span><br><span class=\"line\">        <span class=\"comment\">// function(cb) &#123;fs.readFile(path, &#123;encoding: &#x27;utf8&#125;, cb)&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">done</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> called;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 将回调函数再包裹一层，避免重复调用；同时，将包裹了的真正的回调函数push进参数数组</span></span><br><span class=\"line\">            args.<span class=\"title function_\">push</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                done.<span class=\"title function_\">apply</span>(<span class=\"literal\">null</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在ctx上下文执行fn（一般是异步函数，如：fs.readFile）</span></span><br><span class=\"line\">                <span class=\"comment\">// 并将执行thunkify之后返回的函数的参数（含done回调）传入，类似于执行：</span></span><br><span class=\"line\">                <span class=\"comment\">// fs.readFile(path, &#123;encoding: &#x27;utf8&#125;, done)</span></span><br><span class=\"line\">                <span class=\"comment\">// 关于done是做什么用，则是在co库内</span></span><br><span class=\"line\">                fn.<span class=\"title function_\">apply</span>(ctx, args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">done</span>(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>thunk函数的特点和Promise对象类似，就是将回调函数的绑定单独抽离出来，thunk函数结合Generator函数实现自动流程管理方法和Promise一样。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>从Promise对象到Generator函数，JavaScript中的异步编程越来越简单，但是还是有戴着镣铐跳舞的感觉，async函数的提出即将把这个镣铐摘掉。</p>\n<p>async函数的使用和Generator函数很像，我们改写之前的那个读取文件函数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">readFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">await</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">await</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然和Generator函数很像，但是它有着更清晰易懂的语法，更广的适用性（<code>await</code>后可以跟任何类型，在原始类型时等同于同步操作）。最关键的是，<strong>async函数自带执行器！！！</strong></p>\n<p>在实现上，async函数和Generator函数是一样的，不过是将执行器放在自身内部而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">args</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">spawn</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spawn</span> (genF, self) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> gen = genF.<span class=\"title function_\">call</span>(self);</span><br><span class=\"line\">    <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"title function_\">next</span>(<span class=\"literal\">undefined</span>));</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">step</span> (nextF) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> next;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        next = <span class=\"title function_\">nextF</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// finished with failure, reject the promise</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (next.<span class=\"property\">done</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// finished with success, resolve the promise</span></span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(next.<span class=\"property\">value</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// not finished, chain off the yielded promise and `step` again</span></span><br><span class=\"line\">      <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(next.<span class=\"property\">value</span>).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"title function_\">next</span>(v)),</span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"keyword\">throw</span>(e))</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用上，async函数返回一个Promise对象。可以使用then方法添加回调函数。当遇到<code>await</code>时先返回，等待异步操作完成后再执行函数体后的语句。<code>await</code>只能用在async函数中，在普通函数中使用会报错。同时，async函数目前是ES7的标准，需要通过Babel转码使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\">This API is so Fetching!</a><br><a href=\"https://github.com/tj/co\">co</a><br><a href=\"https://nswbmw.github.io/N-club/1/1.3.html\">co和koa</a><br><a href=\"https://ponyfoo.com/articles/understanding-javascript-async-await\">Understanding JavaScript’s async await</a></p>\n",
            "tags": [
                "JavaScript",
                "异步",
                "Generator",
                "thunk",
                "async"
            ]
        }
    ]
}
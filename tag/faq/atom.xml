<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;faq&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2017-05-19T09:07:56.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="2018" />
    <category term="2019" />
    <category term="flag" />
    <category term="2020" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="绘图" />
    <category term="动画" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="DOM" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="架构" />
    <category term="组件" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="形式系统" />
    <category term="不完全性" />
    <category term="隐喻" />
    <category term="哥德尔" />
    <category term="巴赫" />
    <category term="埃舍尔" />
    <category term="济州" />
    <category term="西归浦" />
    <category term="城山" />
    <category term="咸德" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2017/05/19/Frontend-FAQ-part3/</id>
        <title>前端常见面试问题 part 3</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2017/05/19/Frontend-FAQ-part3/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;下面的大部分问题来自Github的这个&lt;a href=&#34;https://github.com/h5bp/Front-end-Developer-Interview-Questions&#34;&gt;仓库&lt;/a&gt;，排名不分先后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;46-html5中元素的data-属性&#34;&gt;&lt;a href=&#34;#46-html5中元素的data-属性&#34; class=&#34;headerlink&#34; title=&#34;46. html5中元素的data-*属性&#34;&gt;&lt;/a&gt;46. html5中元素的&lt;code&gt;data-*&lt;/code&gt;属性&lt;/h3&gt;&lt;p&gt;用来存储用户自定义数据，可以通过Element.dataset.foo的形式读取。&lt;/p&gt;
&lt;h3 id=&#34;47-CSS在前JS在后是一定的么&#34;&gt;&lt;a href=&#34;#47-CSS在前JS在后是一定的么&#34; class=&#34;headerlink&#34; title=&#34;47. CSS在前JS在后是一定的么&#34;&gt;&lt;/a&gt;47. CSS在前JS在后是一定的么&lt;/h3&gt;&lt;p&gt;不。调试js，日志脚本，shim或polyfill以及动态修改整个页面style的JS代码需要放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&#34;48-progressive-rendering&#34;&gt;&lt;a href=&#34;#48-progressive-rendering&#34; class=&#34;headerlink&#34; title=&#34;48. progressive rendering&#34;&gt;&lt;/a&gt;48. progressive rendering&lt;/h3&gt;&lt;p&gt;渐进式渲染技术是一种尽量快地将渲染结果展现给用户的技术。比如懒加载，优先渲染高优先级元素等手段。目标是将用户关心的内容优先展示出来，将页面信息一点点释放给用户。&lt;/p&gt;
&lt;h3 id=&#34;49-normalize-x2F-reset-CSS&#34;&gt;&lt;a href=&#34;#49-normalize-x2F-reset-CSS&#34; class=&#34;headerlink&#34; title=&#34;49. normalize&amp;#x2F;reset CSS&#34;&gt;&lt;/a&gt;49. normalize&amp;#x2F;reset CSS&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20094066&#34;&gt;知乎&lt;/a&gt;中一段说明写得太好，这里摘录下来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧。&lt;/p&gt;
&lt;p&gt;Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Normalize.css是一种CSS reset的替代方案。Reset清除了所有浏览器默认样式，强调不同浏览器间的一致性。但是在我们需要浏览器默认样式时，就需要自己重头再来。Normalize是两位设计者研究不同浏览器默认样式差异后，设计的弥补浏览器bug保证一致性的CSS。现在大多数的网站已经抛弃了Reset.css而选择Normalize.css。&lt;/p&gt;
&lt;h3 id=&#34;50-BFC是什么&#34;&gt;&lt;a href=&#34;#50-BFC是什么&#34; class=&#34;headerlink&#34; title=&#34;50. BFC是什么&#34;&gt;&lt;/a&gt;50. BFC是什么&lt;/h3&gt;&lt;p&gt;BFC意为块格式化上下文（block formatting context），BFC表示一个区域，在区域内的所有子元素共同构成一个块级上下文。有4中手段可以触发BFC：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;position: 不为static和relative&lt;/li&gt;
&lt;li&gt;display: table-cell，table-caption，inline-block，flex，inline-flex&lt;/li&gt;
&lt;li&gt;float: 不为none&lt;/li&gt;
&lt;li&gt;overflow: 不为visible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相对来说通过&lt;code&gt;overflow&lt;/code&gt;属性触发BFC对已有内容影响最小。利用BFC可以实现很多特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除box间margin的collapse现象&lt;/li&gt;
&lt;li&gt;包裹浮动元素，防止高度collapse&lt;/li&gt;
&lt;li&gt;BFC不与其他元素相交叉，避免文字围绕图片，实现多栏布局&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;51-清除浮动的一些手段&#34;&gt;&lt;a href=&#34;#51-清除浮动的一些手段&#34; class=&#34;headerlink&#34; title=&#34;51. 清除浮动的一些手段&#34;&gt;&lt;/a&gt;51. 清除浮动的一些手段&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在浮动元素后创建一个空的&lt;code&gt;div&lt;/code&gt;标签，为之设置&lt;code&gt;clear: both&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发BFC，一般通过&lt;code&gt;overflow&lt;/code&gt;属性触发&lt;/li&gt;
&lt;li&gt;使用伪类&lt;code&gt;:after&lt;/code&gt;，设置&lt;code&gt;clear: both&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52-CSS-sprites怎么实现和优缺点&#34;&gt;&lt;a href=&#34;#52-CSS-sprites怎么实现和优缺点&#34; class=&#34;headerlink&#34; title=&#34;52. CSS sprites怎么实现和优缺点&#34;&gt;&lt;/a&gt;52. CSS sprites怎么实现和优缺点&lt;/h3&gt;&lt;p&gt;将多张小图拼成大图后，通过&lt;code&gt;background-image&lt;/code&gt;和&lt;code&gt;background-position&lt;/code&gt;更改背景。优点是省流量，更换图标整体风格快；缺点是添加新图片麻烦。&lt;/p&gt;
&lt;h3 id=&#34;53-图片替代方案&#34;&gt;&lt;a href=&#34;#53-图片替代方案&#34; class=&#34;headerlink&#34; title=&#34;53. 图片替代方案&#34;&gt;&lt;/a&gt;53. 图片替代方案&lt;/h3&gt;&lt;p&gt;图片替代指使用图片替代文字，同时保证图片可读，通常用于Logo。有下面几种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;display: none + background-image&lt;/li&gt;
&lt;li&gt;text-ident: 9999px + background-image&lt;/li&gt;
&lt;li&gt;margin-left: -9999px + background-image (盒模型很大，低效)&lt;/li&gt;
&lt;li&gt;img alt属性&lt;/li&gt;
&lt;li&gt;font-size或color: #fff&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;54-解决browser-specific问题&#34;&gt;&lt;a href=&#34;#54-解决browser-specific问题&#34; class=&#34;headerlink&#34; title=&#34;54. 解决browser-specific问题&#34;&gt;&lt;/a&gt;54. 解决browser-specific问题&lt;/h3&gt;&lt;p&gt;写patches（独立的CSS文件）处理&lt;/p&gt;
&lt;h3 id=&#34;55-如何面对低等级浏览器&#34;&gt;&lt;a href=&#34;#55-如何面对低等级浏览器&#34; class=&#34;headerlink&#34; title=&#34;55. 如何面对低等级浏览器&#34;&gt;&lt;/a&gt;55. 如何面对低等级浏览器&lt;/h3&gt;&lt;p&gt;polyfill，graceful degration&lt;/p&gt;
&lt;h3 id=&#34;56-预处理语言的优缺点&#34;&gt;&lt;a href=&#34;#56-预处理语言的优缺点&#34; class=&#34;headerlink&#34; title=&#34;56. 预处理语言的优缺点&#34;&gt;&lt;/a&gt;56. 预处理语言的优缺点&lt;/h3&gt;&lt;p&gt;优点：更加友善，更好的特性，语法糖&lt;br&gt;缺点：需要编译，应用场景局限&lt;/p&gt;
&lt;h3 id=&#34;57-display有哪些可选值&#34;&gt;&lt;a href=&#34;#57-display有哪些可选值&#34; class=&#34;headerlink&#34; title=&#34;57. display有哪些可选值&#34;&gt;&lt;/a&gt;57. display有哪些可选值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;none&lt;/li&gt;
&lt;li&gt;inherit&lt;/li&gt;
&lt;li&gt;initial&lt;/li&gt;
&lt;li&gt;unset&lt;/li&gt;
&lt;li&gt;block&lt;/li&gt;
&lt;li&gt;inline&lt;/li&gt;
&lt;li&gt;inline-block&lt;/li&gt;
&lt;li&gt;flow&lt;/li&gt;
&lt;li&gt;table&lt;/li&gt;
&lt;li&gt;flex&lt;/li&gt;
&lt;li&gt;grid&lt;/li&gt;
&lt;li&gt;list-item&lt;/li&gt;
&lt;li&gt;table-row-group&lt;/li&gt;
&lt;li&gt;table-row&lt;/li&gt;
&lt;li&gt;table-header-group&lt;/li&gt;
&lt;li&gt;table-footer-group&lt;/li&gt;
&lt;li&gt;table-cell&lt;/li&gt;
&lt;li&gt;table-column-group&lt;/li&gt;
&lt;li&gt;table-column&lt;/li&gt;
&lt;li&gt;table-caption&lt;/li&gt;
&lt;li&gt;inline-flex&lt;/li&gt;
&lt;li&gt;inline-grid&lt;/li&gt;
&lt;li&gt;inline-table&lt;/li&gt;
&lt;li&gt;inline-list-item&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;58-translate和absolute的选择&#34;&gt;&lt;a href=&#34;#58-translate和absolute的选择&#34; class=&#34;headerlink&#34; title=&#34;58. translate和absolute的选择&#34;&gt;&lt;/a&gt;58. translate和absolute的选择&lt;/h3&gt;&lt;p&gt;两者并无优劣之分。只有应用场景的不同。translate可以实现复杂的位移和变形，absolute用在固定的定位时更方便&lt;/p&gt;
&lt;h3 id=&#34;59-视觉上隐藏一个元素&#34;&gt;&lt;a href=&#34;#59-视觉上隐藏一个元素&#34; class=&#34;headerlink&#34; title=&#34;59. 视觉上隐藏一个元素&#34;&gt;&lt;/a&gt;59. 视觉上隐藏一个元素&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;position: fix + left: -9999px&lt;/li&gt;
&lt;li&gt;clip + width&amp;#x2F;height + overflow&lt;/li&gt;
&lt;li&gt;visibility: hidden&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;60-grid-system&#34;&gt;&lt;a href=&#34;#60-grid-system&#34; class=&#34;headerlink&#34; title=&#34;60. grid system&#34;&gt;&lt;/a&gt;60. grid system&lt;/h3&gt;&lt;p&gt;除开最新的Grid布局。可以通过&lt;code&gt;inline-block + margin&lt;/code&gt;实现。grid布局目前支持还较差。&lt;a href=&#34;https://css-tricks.com/snippets/css/complete-guide-grid/&#34;&gt;这里&lt;/a&gt;是一篇很不错的介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/grid-support.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-高效的CSS写法&#34;&gt;&lt;a href=&#34;#61-高效的CSS写法&#34; class=&#34;headerlink&#34; title=&#34;61. 高效的CSS写法&#34;&gt;&lt;/a&gt;61. 高效的CSS写法&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://css-tricks.com/css-style-guides/&#34;&gt;这里&lt;/a&gt;有一堆CSS编码风格。总体来说，要注意&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免全局选择&lt;/li&gt;
&lt;li&gt;让选择器更加具体化&lt;/li&gt;
&lt;li&gt;减少不必要的选择器&lt;/li&gt;
&lt;li&gt;减少选择器的过深嵌套&lt;/li&gt;
&lt;li&gt;尽可能少使用表达式（即calc, rgba这些）&lt;/li&gt;
&lt;li&gt;CSS放在头部&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-CSS匹配顺序&#34;&gt;&lt;a href=&#34;#62-CSS匹配顺序&#34; class=&#34;headerlink&#34; title=&#34;62. CSS匹配顺序&#34;&gt;&lt;/a&gt;62. CSS匹配顺序&lt;/h3&gt;&lt;p&gt;先构建DOM树，再从右至左地匹配CSS选择器&lt;/p&gt;
&lt;h3 id=&#34;63-盒模型&#34;&gt;&lt;a href=&#34;#63-盒模型&#34; class=&#34;headerlink&#34; title=&#34;63. 盒模型&#34;&gt;&lt;/a&gt;63. 盒模型&lt;/h3&gt;&lt;p&gt;DOM元素以盒的形式呈现，包裹住真正的内容，有margin&amp;#x2F;border&amp;#x2F;padding&amp;#x2F;content四部分，width在默认情况下仅指content部分的宽度，height同理。若想改变盒模型，可以设置&lt;code&gt;box-sizing&lt;/code&gt;属性&lt;/p&gt;
&lt;h3 id=&#34;64-flex&#34;&gt;&lt;a href=&#34;#64-flex&#34; class=&#34;headerlink&#34; title=&#34;64. flex&#34;&gt;&lt;/a&gt;64. flex&lt;/h3&gt;&lt;p&gt;flex是弹性布局。借助flex布局，可以很轻松地实现居中置右等使用默认方法难以实现的效果。flex布局有两个轴：主轴和交叉轴。元素在主轴方向上排布，在位置不够时，会沿交叉轴推挤到下一行或下一列。flex相关的CSS属性同时针对容器和项目。（下方加粗为默认值）&lt;/p&gt;
&lt;p&gt;针对容器的属性有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flex-direction&lt;/code&gt; 主轴方向。可选&lt;strong&gt;row&lt;/strong&gt;&amp;#x2F;column&amp;#x2F;reverse&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-wrap&lt;/code&gt; 换行选项。可选&lt;strong&gt;nowrap&lt;/strong&gt;&amp;#x2F;wrap&amp;#x2F;wrap-reverse&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-flow&lt;/code&gt; 综合上面两个选项，如row wrap&lt;/li&gt;
&lt;li&gt;&lt;code&gt;justify-content&lt;/code&gt; 主轴上对齐方式。可选&lt;strong&gt;flex-start&lt;/strong&gt;&amp;#x2F;flex-end&amp;#x2F;center&amp;#x2F;space-between&amp;#x2F;space-around&lt;/li&gt;
&lt;li&gt;&lt;code&gt;align-items&lt;/code&gt;交叉轴对齐方式。可选flex-start&amp;#x2F;flex-end&amp;#x2F;center&amp;#x2F;&lt;strong&gt;stretch&lt;/strong&gt;&amp;#x2F;baseline&lt;/li&gt;
&lt;li&gt;&lt;code&gt;align-contents&lt;/code&gt;主轴间对齐方式。可选&lt;strong&gt;flex-start&lt;/strong&gt;&amp;#x2F;end&amp;#x2F;center&amp;#x2F;space-between&amp;#x2F;space-around&amp;#x2F;stretch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对项目的属性有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;order&lt;/code&gt; 项目顺序，默认按照书写顺序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-grow&lt;/code&gt; 当容器主轴上长度足够时，该项目在主轴方向上的长度，默认为1，项目间按照该值比例分配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-shrink&lt;/code&gt; 当容器主轴上长度不够时，类似&lt;code&gt;flex-grow&lt;/code&gt;处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-basis&lt;/code&gt; 容器默认的主轴方向长度，也按比例分配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;align-self&lt;/code&gt; 该项目的对齐方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;65-适应式-x2F-响应式布局&#34;&gt;&lt;a href=&#34;#65-适应式-x2F-响应式布局&#34; class=&#34;headerlink&#34; title=&#34;65. 适应式&amp;#x2F;响应式布局&#34;&gt;&lt;/a&gt;65. 适应式&amp;#x2F;响应式布局&lt;/h3&gt;&lt;p&gt;responsive：响应式布局，使用同一种布局响应浏览器窗口的连续变化&lt;br&gt;adaptive：适应式布局，在视口特定大小时改变外观或样式，是离散的&lt;/p&gt;
&lt;h3 id=&#34;66-DOM事件代理，冒泡和捕获两阶段&#34;&gt;&lt;a href=&#34;#66-DOM事件代理，冒泡和捕获两阶段&#34; class=&#34;headerlink&#34; title=&#34;66. DOM事件代理，冒泡和捕获两阶段&#34;&gt;&lt;/a&gt;66. DOM事件代理，冒泡和捕获两阶段&lt;/h3&gt;&lt;p&gt;DOM事件代理是指，在DOM2级标准中，事件触发有捕获和冒泡两阶段，所以可以将事件监听器绑定在父节点上，减少EventListener的数目。细节可以参见之前做过的一则&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/03/20/domevent-elementsize-mediatag/&#34;&gt;笔记&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;67-null-nudefined-undeclared三者的区别&#34;&gt;&lt;a href=&#34;#67-null-nudefined-undeclared三者的区别&#34; class=&#34;headerlink&#34; title=&#34;67. null, nudefined, undeclared三者的区别&#34;&gt;&lt;/a&gt;67. null, nudefined, undeclared三者的区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt;: 是Object类型，表示空对象，多用来表示还未赋值的对象&lt;br&gt;&lt;strong&gt;undefined&lt;/strong&gt;: 是基础类型，表示没有定义的变量或属性&lt;br&gt;&lt;strong&gt;undecided&lt;/strong&gt;: 只是一种称呼，表示没有用&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;或&lt;code&gt;let&lt;/code&gt;声明的变量，默认为全局变量，应该避免出现这种情况&lt;/p&gt;
&lt;h3 id=&#34;68-匿名函数的应用场景&#34;&gt;&lt;a href=&#34;#68-匿名函数的应用场景&#34; class=&#34;headerlink&#34; title=&#34;68. 匿名函数的应用场景&#34;&gt;&lt;/a&gt;68. 匿名函数的应用场景&lt;/h3&gt;&lt;p&gt;主要用作返回值或输入参数。&lt;/p&gt;
&lt;h3 id=&#34;69-host-object和native-object的区别&#34;&gt;&lt;a href=&#34;#69-host-object和native-object的区别&#34; class=&#34;headerlink&#34; title=&#34;69. host object和native object的区别&#34;&gt;&lt;/a&gt;69. host object和native object的区别&lt;/h3&gt;&lt;p&gt;前者是用户定义的对象类型，后者是环境自带的原生对象。尽量避免修改native object（包括增删改）。&lt;/p&gt;
&lt;h3 id=&#34;70-Function-prototype-bind的使用场景&#34;&gt;&lt;a href=&#34;#70-Function-prototype-bind的使用场景&#34; class=&#34;headerlink&#34; title=&#34;70. Function.prototype.bind的使用场景&#34;&gt;&lt;/a&gt;70. &lt;code&gt;Function.prototype.bind&lt;/code&gt;的使用场景&lt;/h3&gt;&lt;p&gt;在setTimeout和listener handler中最常用到&lt;/p&gt;
&lt;h3 id=&#34;71-feature-detection-x2F-feature-inference-x2F-UA&#34;&gt;&lt;a href=&#34;#71-feature-detection-x2F-feature-inference-x2F-UA&#34; class=&#34;headerlink&#34; title=&#34;71. feature detection&amp;#x2F;feature inference&amp;#x2F;UA&#34;&gt;&lt;/a&gt;71. feature detection&amp;#x2F;feature inference&amp;#x2F;UA&lt;/h3&gt;&lt;p&gt;由于浏览器之间有各自的特性差异，这三种手段用于保证代码在浏览器间的兼容性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;feature detection 检测特性是否存在再使用，比较保险科学&lt;/li&gt;
&lt;li&gt;feature inference 通过某特性是否存在推断另一特性是否存在，有风险，避免使用&lt;/li&gt;
&lt;li&gt;UA 直接通过header中的User Agent来得到浏览器信息，建议迫不得已不使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;72-AJAX技术的优劣&#34;&gt;&lt;a href=&#34;#72-AJAX技术的优劣&#34; class=&#34;headerlink&#34; title=&#34;72. AJAX技术的优劣&#34;&gt;&lt;/a&gt;72. AJAX技术的优劣&lt;/h3&gt;&lt;p&gt;优：用户体验好，局部刷新速度快，可以用于实现界面和数据分离&lt;br&gt;劣：相对来说较难调试，需要解决跨域问题，搜索引擎支持即SEO弱，会遇到移动端支持问题&lt;/p&gt;
&lt;h3 id=&#34;73-JS-templating&#34;&gt;&lt;a href=&#34;#73-JS-templating&#34; class=&#34;headerlink&#34; title=&#34;73. JS templating&#34;&gt;&lt;/a&gt;73. JS templating&lt;/h3&gt;&lt;p&gt;JS中的模板技术，如在backbone中使用的underscore的_.template方法。在&lt;a href=&#34;https://github.com/xtemplate/xtemplate&#34;&gt;xtemplate&lt;/a&gt;支持下，也可以在页面中指定&lt;code&gt;&amp;lt;script type=&amp;quot;x-template&amp;quot;&amp;gt;&lt;/code&gt;的形式声明，&lt;/p&gt;
&lt;h3 id=&#34;74-如何理解不要改动built-in特性&#34;&gt;&lt;a href=&#34;#74-如何理解不要改动built-in特性&#34; class=&#34;headerlink&#34; title=&#34;74. 如何理解不要改动built-in特性&#34;&gt;&lt;/a&gt;74. 如何理解不要改动built-in特性&lt;/h3&gt;&lt;p&gt;浏览器和标准都是在不断变化的，此刻对built-in特性做的修改在之后浏览器或标注的呢更新后可能会埋下很深的坑。&lt;/p&gt;
&lt;h3 id=&#34;75-如何区分-和&#34;&gt;&lt;a href=&#34;#75-如何区分-和&#34; class=&#34;headerlink&#34; title=&#34;75. 如何区分[]和{}&#34;&gt;&lt;/a&gt;75. 如何区分[]和{}&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Object.Prototype.toString.call()&lt;/li&gt;
&lt;li&gt;[].concat&lt;/li&gt;
&lt;li&gt;instanceof&lt;/li&gt;
&lt;li&gt;ES6中新增的方法Array.isArray&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;76-tenary-operator&#34;&gt;&lt;a href=&#34;#76-tenary-operator&#34; class=&#34;headerlink&#34; title=&#34;76. tenary operator&#34;&gt;&lt;/a&gt;76. tenary operator&lt;/h3&gt;&lt;p&gt;JS中唯一的三元操作符&lt;/p&gt;
&lt;h3 id=&#34;77-DOM中attributes和properties的区别&#34;&gt;&lt;a href=&#34;#77-DOM中attributes和properties的区别&#34; class=&#34;headerlink&#34; title=&#34;77. DOM中attributes和properties的区别&#34;&gt;&lt;/a&gt;77. DOM中attributes和properties的区别&lt;/h3&gt;&lt;p&gt;节点的特性（attributes）用&lt;code&gt;Attr&lt;/code&gt;类型表示。直观上讲，特性就是元素attributes属性中的节点，即在tag中声明的各特性名，以下面的标签为例：&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;text&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;John&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该DOM节点有两个特性：&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;。&lt;code&gt;Attr&lt;/code&gt;也是&lt;code&gt;Node&lt;/code&gt;的一种，&lt;code&gt;nodeType&lt;/code&gt;为2，&lt;code&gt;Attr&lt;/code&gt;对象有三个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 特性名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; 特性的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;specified&lt;/code&gt; 特性是否指定在代码中，抑或是默认的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点的属性（properties）则指对应的DOM对象的属性，不论是继承自&lt;code&gt;Node&lt;/code&gt;或是&lt;code&gt;Element&lt;/code&gt;类型的，还是自身类型自带的。比如上面同样的例子，该DOM节点具有&lt;code&gt;children&lt;/code&gt;, &lt;code&gt;childNodes&lt;/code&gt;, &lt;code&gt;className&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;节点的属性和特性会有重合的部分，如&lt;code&gt;id&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;等，因DOM节点而异。上面的例子里，attribute中的&lt;code&gt;value&lt;/code&gt;指声明在标签上的value默认值，而properties中的&lt;code&gt;value&lt;/code&gt;则指该input标签当前的内容。&lt;/p&gt;
&lt;h3 id=&#34;78-quot-use-strict-quot&#34;&gt;&lt;a href=&#34;#78-quot-use-strict-quot&#34; class=&#34;headerlink&#34; title=&#34;78. &amp;quot;use strict&amp;quot;;&#34;&gt;&lt;/a&gt;78. &lt;code&gt;&amp;quot;use strict&amp;quot;;&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;严格模式在ES5中引入，通过直接定义一个不赋给任何变量的上述字符串进入。可以选择在全局或是函数作用域内开启。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;严格模式下对默认模式下会静默出错的代码显式报错&lt;/li&gt;
&lt;li&gt;严格模式下禁止不合理的行为，如声明了两个一样的属性名&lt;/li&gt;
&lt;li&gt;严格模式还淘汰了一些属性，如&lt;code&gt;arguments.callee&lt;/code&gt;和&lt;code&gt;arguments.caller&lt;/code&gt;; 同时，限制一些不安全的使用，如&lt;code&gt;with&lt;/code&gt;和&lt;code&gt;eval&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;严格模式抑制了&lt;code&gt;this&lt;/code&gt;的值&lt;/li&gt;
&lt;li&gt;严格模式下，对未来版本可能用到的保留字禁止用户访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过，由于严格模式下代码的解析规则会不大一样，建议只在需要测试的特定函数内开启严格模式，&lt;/p&gt;
&lt;h3 id=&#34;79-ready和load-event的区别&#34;&gt;&lt;a href=&#34;#79-ready和load-event的区别&#34; class=&#34;headerlink&#34; title=&#34;79. ready和load event的区别&#34;&gt;&lt;/a&gt;79. ready和load event的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ready在DOM元素加载完成后触发&lt;/li&gt;
&lt;li&gt;load在页面所有资源请求完成后触发（包括图片、视频、音频等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;80-SPA的SEO优化&#34;&gt;&lt;a href=&#34;#80-SPA的SEO优化&#34; class=&#34;headerlink&#34; title=&#34;80. SPA的SEO优化&#34;&gt;&lt;/a&gt;80. SPA的SEO优化&lt;/h3&gt;&lt;p&gt;采用预渲染技术，或为爬虫专门准备静态页面&lt;/p&gt;
&lt;h3 id=&#34;81-event-loop，call-stack和task-queue&#34;&gt;&lt;a href=&#34;#81-event-loop，call-stack和task-queue&#34; class=&#34;headerlink&#34; title=&#34;81. event loop，call stack和task queue&#34;&gt;&lt;/a&gt;81. event loop，call stack和task queue&lt;/h3&gt;&lt;p&gt;见这篇&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/02/27/event-loop/&#34;&gt;笔记&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;82-JavaScript中的对象和继承&#34;&gt;&lt;a href=&#34;#82-JavaScript中的对象和继承&#34; class=&#34;headerlink&#34; title=&#34;82. JavaScript中的对象和继承&#34;&gt;&lt;/a&gt;82. JavaScript中的对象和继承&lt;/h3&gt;&lt;p&gt;见这篇&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/03/13/js-object/&#34;&gt;笔记&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不过，在ES6中引入了强类型OOP语言中传统的对象和继承语法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;class&lt;/code&gt;关键字定义类，类中用&lt;code&gt;constructor&lt;/code&gt;定义构造函数，使用&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;修饰成员级别&lt;/li&gt;
&lt;li&gt;可以在成员前指定&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;为成员指定setter和getter函数&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;extends&lt;/code&gt;实现继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;83-promise&#34;&gt;&lt;a href=&#34;#83-promise&#34; class=&#34;headerlink&#34; title=&#34;83. promise&#34;&gt;&lt;/a&gt;83. promise&lt;/h3&gt;&lt;p&gt;见之前做过的一篇&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-1/&#34;&gt;笔记&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;84-提升有滚动条时的动画渲染性能&#34;&gt;&lt;a href=&#34;#84-提升有滚动条时的动画渲染性能&#34; class=&#34;headerlink&#34; title=&#34;84. 提升有滚动条时的动画渲染性能&#34;&gt;&lt;/a&gt;84. 提升有滚动条时的动画渲染性能&lt;/h3&gt;&lt;p&gt;在CSS中为&lt;code&gt;will-change&lt;/code&gt;属性指定动画要改变的CSS属性，参见&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change&#34;&gt;MDN上的介绍&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;85-layout-painting-composition&#34;&gt;&lt;a href=&#34;#85-layout-painting-composition&#34; class=&#34;headerlink&#34; title=&#34;85. layout, painting, composition&#34;&gt;&lt;/a&gt;85. layout, painting, composition&lt;/h3&gt;&lt;p&gt;浏览器解析，绘制，组合网页的过程。DOM操作可能会触发回流（reflow）或重绘（repainting），后者代价更小，建议减少频繁的DOM操作&lt;/p&gt;
&lt;h3 id=&#34;86-一些HTTP-1-1的header&#34;&gt;&lt;a href=&#34;#86-一些HTTP-1-1的header&#34; class=&#34;headerlink&#34; title=&#34;86. 一些HTTP 1.1的header&#34;&gt;&lt;/a&gt;86. 一些HTTP 1.1的header&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt; 接受文件的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&amp;#x2F;&lt;code&gt;Accept-Encoding&lt;/code&gt; 可以接受的文件字符集和编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Age&lt;/code&gt; 从缓存实体产生到现在经历的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Allow&lt;/code&gt; 允许使用的HTTP方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cache-control&lt;/code&gt; 使用的缓存策略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Encoding&lt;/code&gt; 响应体使用编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Lenght&lt;/code&gt; 响应体长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Range&lt;/code&gt; 响应体范围，用于部分下载（服务端的返回）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt; 响应的媒体类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date&lt;/code&gt; 消息的发送时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Etag&lt;/code&gt; html实体的唯一标识，用于缓存对比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt; 缓存实体过期时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Host&lt;/code&gt; 服务器的主机名，通常是请求资源的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Location&lt;/code&gt; 重定向的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pragma&lt;/code&gt; 用于向后兼容还没有&lt;code&gt;Cache-Control&lt;/code&gt;的HTTP1.0版本，通常只用作&lt;code&gt;Pragma: no-cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Range&lt;/code&gt; 请求资源的部分内容，一般用在多线程下载（客户端发起）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Referer&lt;/code&gt; 当前请求从哪个地址发起&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Server&lt;/code&gt; 服务器端使用的软件信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt; 传输内容所用的协议类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Upgrade&lt;/code&gt; 切换到额外的通信协议，服务端需要返回101状态码，并指定升级的协议名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User-Agent&lt;/code&gt; 请求发起自什么终端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vary&lt;/code&gt; 列出一个相应字段列表，告知服务器当URL对应不同版本资源时，如何选择合适版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Via&lt;/code&gt; 用在proxies中，表示使用的协议，版本以及起始端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多header参考&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&#34;&gt;W3C文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;87-HTTP-actions&#34;&gt;&lt;a href=&#34;#87-HTTP-actions&#34; class=&#34;headerlink&#34; title=&#34;87. HTTP actions&#34;&gt;&lt;/a&gt;87. HTTP actions&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt; 描述目标资源的通信选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; 获取数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt; 类似GET，但是没有响应体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 将实体提交给服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; 用请求payload替换目标资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; 对资源部分修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; 删除指定资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TRACE&lt;/code&gt; 沿着到目标资源的路径执行一个消息环回测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONNECT&lt;/code&gt; 建立一个到由目标资源标识的服务器的隧道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;88-JS内存泄漏&#34;&gt;&lt;a href=&#34;#88-JS内存泄漏&#34; class=&#34;headerlink&#34; title=&#34;88. JS内存泄漏&#34;&gt;&lt;/a&gt;88. JS内存泄漏&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;意外的全局变量&lt;/li&gt;
&lt;li&gt;被遗忘的&lt;code&gt;setInterval&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;脱离文档的DOM引用&lt;/li&gt;
&lt;li&gt;不合理的闭包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chrome下可以通过Timeline&amp;#x2F;Profile选项卡查看内存使用情况，避免上述情况出现。&lt;/p&gt;
&lt;h3 id=&#34;89-rem，em，px&#34;&gt;&lt;a href=&#34;#89-rem，em，px&#34; class=&#34;headerlink&#34; title=&#34;89. rem，em，px&#34;&gt;&lt;/a&gt;89. rem，em，px&lt;/h3&gt;&lt;p&gt;见&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/05/17/Frontend-FAQ-part2/index.html#question24&#34;&gt;Question 24&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;90-JS数据类型&#34;&gt;&lt;a href=&#34;#90-JS数据类型&#34; class=&#34;headerlink&#34; title=&#34;90. JS数据类型&#34;&gt;&lt;/a&gt;90. JS数据类型&lt;/h3&gt;&lt;p&gt;基础类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Undefined&lt;/li&gt;
&lt;li&gt;Null&lt;/li&gt;
&lt;li&gt;Number（包括NaN Infinity）&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其余都是引用类型。更多参加&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/03/01/js-type-and-equal-judgement/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;91-Object-assign和Object-create&#34;&gt;&lt;a href=&#34;#91-Object-assign和Object-create&#34; class=&#34;headerlink&#34; title=&#34;91. Object.assign和Object.create&#34;&gt;&lt;/a&gt;91. &lt;code&gt;Object.assign&lt;/code&gt;和&lt;code&gt;Object.create&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assign&lt;/code&gt; 将传入变量的&lt;strong&gt;可枚举属性&lt;/strong&gt;和已有属性合并&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.create&lt;/code&gt; 创建一个以传入对象为&lt;code&gt;__proto__&lt;/code&gt;的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;92-回流和重绘&#34;&gt;&lt;a href=&#34;#92-回流和重绘&#34; class=&#34;headerlink&#34; title=&#34;92. 回流和重绘&#34;&gt;&lt;/a&gt;92. 回流和重绘&lt;/h3&gt;&lt;p&gt;还是参见&lt;a href=&#34;http://taligarsiel.com/Projects/howbrowserswork1.htm&#34;&gt;how browsers work&lt;/a&gt;。为了减少回流，有下面一些推荐实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性改变样式，如用&lt;code&gt;class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;推迟回流&lt;/li&gt;
&lt;li&gt;虚拟DOM&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;documentFragment&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;93-排序算法&#34;&gt;&lt;a href=&#34;#93-排序算法&#34; class=&#34;headerlink&#34; title=&#34;93. 排序算法&#34;&gt;&lt;/a&gt;93. 排序算法&lt;/h3&gt;&lt;p&gt;稳定：插冒归基；不稳定：快选堆希。实现略。&lt;/p&gt;
&lt;h3 id=&#34;94-CSS-x2F-JS跨浏览器兼容问题&#34;&gt;&lt;a href=&#34;#94-CSS-x2F-JS跨浏览器兼容问题&#34; class=&#34;headerlink&#34; title=&#34;94. CSS&amp;#x2F;JS跨浏览器兼容问题&#34;&gt;&lt;/a&gt;94. CSS&amp;#x2F;JS跨浏览器兼容问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;明确产品的兼容版本方案，选择合适的技术栈&lt;/li&gt;
&lt;li&gt;normalize.css polyfill&amp;#x2F;shim保证兼容&lt;/li&gt;
&lt;li&gt;在符合W3C标准浏览器下表现良好，旧浏览器下保证可用性，提示升级即可&lt;/li&gt;
&lt;li&gt;CSS hack（特殊的选择器，条件样式表）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;95-xss和csrf的防御&#34;&gt;&lt;a href=&#34;#95-xss和csrf的防御&#34; class=&#34;headerlink&#34; title=&#34;95. xss和csrf的防御&#34;&gt;&lt;/a&gt;95. xss和csrf的防御&lt;/h3&gt;&lt;p&gt;XSS（Cross Site Script，跨站脚本攻击），分为反射式，存储式，前者只对特定用户生效，如存储在个人资料中的脚本，后者对访问网站的所有用户生效，如攻击站点本身代码。防御转义时，不仅要监测&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，对可以书写JavaScript的&lt;code&gt;href&lt;/code&gt;属性，&lt;code&gt;src&lt;/code&gt;属性，甚至&lt;code&gt;img&lt;/code&gt;的&lt;code&gt;onerror&lt;/code&gt;等事件也要做防御。&lt;/p&gt;
&lt;p&gt;CSRF（Cross-site Request Forgery，跨站请求伪造），意为恶意网站通过用户存储的cookie，模拟向其他网站发起“合法”请求。需要注意下面两点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不使用GET方法更新数据&lt;/li&gt;
&lt;li&gt;对于POST方法，通过后台生成随机的csrf_token注入到&lt;code&gt;form&lt;/code&gt;的&lt;code&gt;&amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt;&lt;/code&gt;标签中预防&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，&lt;strong&gt;不信任用户的所有输入&lt;/strong&gt;，对输入做处理，避免SQL注入和XSS攻击。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;96-CSS属性继承&#34;&gt;&lt;a href=&#34;#96-CSS属性继承&#34; class=&#34;headerlink&#34; title=&#34;96. CSS属性继承&#34;&gt;&lt;/a&gt;96. CSS属性继承&lt;/h3&gt;&lt;p&gt;无继承性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;display&lt;/li&gt;
&lt;li&gt;文本属性：vertical-align&amp;#x2F;text-shadow&amp;#x2F;text-decoration&lt;/li&gt;
&lt;li&gt;盒模型属性&lt;/li&gt;
&lt;li&gt;背景相关属性&lt;/li&gt;
&lt;li&gt;定位属性：float clear top&amp;#x2F;left&amp;#x2F;right&amp;#x2F;bottom z-index&lt;/li&gt;
&lt;li&gt;轮廓内容：content outline&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有继承性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字体属性&lt;/li&gt;
&lt;li&gt;文本属性：text-align&amp;#x2F;line-height&amp;#x2F;word-spacing&amp;#x2F;letter-spacing&amp;#x2F;color&lt;/li&gt;
&lt;li&gt;可见性：visibility&lt;/li&gt;
&lt;li&gt;表格列表：list-style&lt;/li&gt;
&lt;li&gt;光标：cursor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行内元素可继承：字体属性，除了text-indent&amp;#x2F;text-align&lt;br&gt;块元素可继承：text-align&amp;#x2F;text-ident&lt;/p&gt;
&lt;h3 id=&#34;97-移动端实现0-5px的border&#34;&gt;&lt;a href=&#34;#97-移动端实现0-5px的border&#34; class=&#34;headerlink&#34; title=&#34;97. 移动端实现0.5px的border&#34;&gt;&lt;/a&gt;97. 移动端实现0.5px的&lt;code&gt;border&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;结合&lt;code&gt;:before&lt;/code&gt;或&lt;code&gt;:after&lt;/code&gt;通过&lt;code&gt;transform-origin&lt;/code&gt;和&lt;code&gt;scale&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;利用渐变&lt;code&gt;background-image: linear-gradient&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接使用backgroun-image&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;98-随机打乱一个数组&#34;&gt;&lt;a href=&#34;#98-随机打乱一个数组&#34; class=&#34;headerlink&#34; title=&#34;98. 随机打乱一个数组&#34;&gt;&lt;/a&gt;98. 随机打乱一个数组&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&#34;&gt;Fisher-Yates shuffle&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;shuffle&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; counter = array.&lt;span class=&#34;property&#34;&gt;length&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// While there are elements in the array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (counter &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// Pick a random index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; index = &lt;span class=&#34;title class_&#34;&gt;Math&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;floor&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Math&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;random&lt;/span&gt;() * counter);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// Decrease counter by 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        counter--;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// And swap the last element with it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; temp = array[counter];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        array[counter] = array[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        array[index] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;99-移动端fixed定位bug&#34;&gt;&lt;a href=&#34;#99-移动端fixed定位bug&#34; class=&#34;headerlink&#34; title=&#34;99. 移动端fixed定位bug&#34;&gt;&lt;/a&gt;99. 移动端fixed定位bug&lt;/h3&gt;&lt;p&gt;iOS中，在软键盘唤起后，fixed定位元素会失效，变为absolute定位。解决方案：主体部分设为&lt;code&gt;height: 100%; overflow-y: scroll&lt;/code&gt;，通过absolute定位实现。&lt;/p&gt;
&lt;h3 id=&#34;100-JS如何获知当前页面是否来自缓存&#34;&gt;&lt;a href=&#34;#100-JS如何获知当前页面是否来自缓存&#34; class=&#34;headerlink&#34; title=&#34;100. JS如何获知当前页面是否来自缓存&#34;&gt;&lt;/a&gt;100. JS如何获知当前页面是否来自缓存&lt;/h3&gt;&lt;p&gt;配合后台：后台传递时间戳到当前页面或cookie&lt;br&gt;无后台：通过xhr放送&lt;code&gt;HEAD&lt;/code&gt;请求，得到返回的status code&lt;/p&gt;
&lt;h3 id=&#34;101-重复打印字符串&#34;&gt;&lt;a href=&#34;#101-重复打印字符串&#34; class=&#34;headerlink&#34; title=&#34;101. 重复打印字符串&#34;&gt;&lt;/a&gt;101. 重复打印字符串&lt;/h3&gt;&lt;p&gt;幂次叠加，&lt;code&gt;substr&lt;/code&gt;切割字符串。&lt;/p&gt;
&lt;h3 id=&#34;102-正则匹配中-和-的意思&#34;&gt;&lt;a href=&#34;#102-正则匹配中-和-的意思&#34; class=&#34;headerlink&#34; title=&#34;102. 正则匹配中?:和?=的意思&#34;&gt;&lt;/a&gt;102. 正则匹配中&lt;code&gt;?:&lt;/code&gt;和&lt;code&gt;?=&lt;/code&gt;的意思&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?:&lt;/code&gt; 非捕获匹配分组，匹配并出现在匹配结果中，但不作为子匹配返回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?=&lt;/code&gt; 前瞻匹配，不出现在匹配结果中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多参见&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/05/12/Frontend-FAQ-part1/index.html#regexp&#34;&gt;问题16&lt;/a&gt;。&lt;/p&gt;
</content>
        <category term="面试" />
        <category term="前端" />
        <category term="FAQ" />
        <updated>2017-05-19T09:07:56.000Z</updated>
    </entry>
    <entry>
        <id>http://shenlvmeng.github.com/blog/2017/05/17/Frontend-FAQ-part2/</id>
        <title>前端常见面试问题 part 2</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2017/05/17/Frontend-FAQ-part2/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;下面的大部分问题来自Github的这个&lt;a href=&#34;https://github.com/h5bp/Front-end-Developer-Interview-Questions&#34;&gt;仓库&lt;/a&gt;，排名不分先后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;18-Vue和React框架的对比&#34;&gt;&lt;a href=&#34;#18-Vue和React框架的对比&#34; class=&#34;headerlink&#34; title=&#34;18. Vue和React框架的对比&#34;&gt;&lt;/a&gt;18. Vue和React框架的对比&lt;/h3&gt;&lt;p&gt;先说相同之处，Vue和React都是优秀的MVVM框架。具有&lt;strong&gt;响应式设计&lt;/strong&gt;的种种特点，因此&lt;strong&gt;数据驱动&lt;/strong&gt;是使用这两种框架不能忘的出发点。正如上一个问题提到的那样，开发者只需处理好数据，让框架去处理易错的UI。同时，&lt;strong&gt;组件化&lt;/strong&gt;前端开发流程也是它们强调的一点，用组件化之名行代码重用之实，通过组件积木去构建整个页面。最后，它们不约而同地使用&lt;strong&gt;虚拟DOM树&lt;/strong&gt;（vDOM）（Vue是在2.0引入的）抽象页面的节点，通过优化的diff算法减少频繁的DOM操作，减少交互的响应时间。另外，在最新的版本中，Vue和React的源码分别通过&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;和&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;加入类型约束，增强可读性和健壮性。&lt;/p&gt;
&lt;p&gt;两者同时也有MVVM框架共同的短板，把过多的渲染放在客户端，在页面元素复杂时，会加大交互的延迟。同时会影响首屏时间。&lt;/p&gt;
&lt;p&gt;再说它们的不同之处，不同之处基本都在使用细节上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue通常把网页模板写在&lt;code&gt;template&lt;/code&gt;属性中，默认不支持JSX语法（可以通过插件支持）。React中则是写在render里&lt;/li&gt;
&lt;li&gt;Vue糅合了Angular 1.x的特点，通过一些内置的自定义标签属性减少开发者的代码量。React则更加纯粹，少了这些预设的框架&lt;/li&gt;
&lt;li&gt;Vue使用&lt;code&gt;Object.defineProperty&lt;/code&gt;实现数据绑定，React通过&lt;code&gt;setState&lt;/code&gt;显式更新依赖。前者更加酷和自然，但是在编程风格不好时，容易出现难以debug的错误。React推荐immutable Object，每次更新时使用新对象更新自身&lt;code&gt;state&lt;/code&gt;，出错的概率更低。&lt;/li&gt;
&lt;li&gt;Vue和React在组件生命周期上有些细微的差别。Vue的生命周期更加简明，在create，mount，update，destroy前后设置钩子函数，React在state改变前后也会有钩子函数&lt;/li&gt;
&lt;li&gt;Vue的脚手架使用起来较React更加顺手（个人感觉），单文件.vue的组织方式，内部支持模板语言jade、ejs，预处理语言coffeescript，sass等。React的构建方式则更加自由。&lt;/li&gt;
&lt;li&gt;React的社区较之Vue更为活跃些，流行的库要更多，脚手架中的库更多是爱好者自己开发的。Vue和React生态圈中都有路由和状态管理器的工具，其中Vue的都是官方开发的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;19-TCP三次握手，四次挥手过程&#34;&gt;&lt;a href=&#34;#19-TCP三次握手，四次挥手过程&#34; class=&#34;headerlink&#34; title=&#34;19. TCP三次握手，四次挥手过程&#34;&gt;&lt;/a&gt;19. TCP三次握手，四次挥手过程&lt;/h3&gt;&lt;p&gt;过程参考下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/tcp.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/tcp2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为断开连接时数据可能并未传输完成，所以挥手时要多一步。&lt;/p&gt;
&lt;h3 id=&#34;20-CSS预处理语言&#34;&gt;&lt;a href=&#34;#20-CSS预处理语言&#34; class=&#34;headerlink&#34; title=&#34;20. CSS预处理语言&#34;&gt;&lt;/a&gt;20. CSS预处理语言&lt;/h3&gt;&lt;p&gt;Sass和Less。Sass支持变量的定义和使用，有语法控制结构，同时支持&lt;code&gt;@mixin&lt;/code&gt;定义mixin和&lt;code&gt;@function&lt;/code&gt;定义函数。更多介绍可以看我之前的&lt;a href=&#34;http://shenlvmeng.github.io/book.html#sass&#34;&gt;一段笔记&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;less语法使用上和Sass相近，采用JavaScript实现。支持本地和在线解析。本人没有用过，更多特性参考&lt;a href=&#34;http://lesscss.org/features/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;21-JS里的错误和异常处理&#34;&gt;&lt;a href=&#34;#21-JS里的错误和异常处理&#34; class=&#34;headerlink&#34; title=&#34;21. JS里的错误和异常处理&#34;&gt;&lt;/a&gt;21. JS里的错误和异常处理&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch&#34;&gt;try catch&lt;/a&gt;语句块捕获错误，catch块接受一个参数作为错误对象。对象的message属性会给出错误的详细信息。catch后还可以接上&lt;code&gt;finally&lt;/code&gt;关键字，finally语句块在错误处理后必定执行。throw语句可以抛出错误。&lt;/p&gt;
&lt;h3 id=&#34;22-闭包&#34;&gt;&lt;a href=&#34;#22-闭包&#34; class=&#34;headerlink&#34; title=&#34;22. 闭包&#34;&gt;&lt;/a&gt;22. 闭包&lt;/h3&gt;&lt;p&gt;闭包是JavaScript中比较有特色的概念。它和JS中的作用域链（见问题4）概念密切相关。闭包发生在函数中定义的函数，在外层函数退出后，其作用域环境通过作用域链仍然保存在存活的内部环境中。利用这种特点，可以实现诸如状态保存，封装等特殊性质。&lt;/p&gt;
&lt;p&gt;值得注意的是，内层函数的不合理操作会导致内存泄漏。且大量使用闭包会导致性能问题。不要过度依赖闭包。&lt;/p&gt;
&lt;h3 id=&#34;23-列举一些RESTful操作名&#34;&gt;&lt;a href=&#34;#23-列举一些RESTful操作名&#34; class=&#34;headerlink&#34; title=&#34;23. 列举一些RESTful操作名&#34;&gt;&lt;/a&gt;23. 列举一些RESTful操作名&lt;/h3&gt;&lt;p&gt;GET&amp;#x2F;POST&amp;#x2F;DELETE&amp;#x2F;UPDATE&amp;#x2F;PUT等&lt;/p&gt;
&lt;h3 id=&#34;24-列举一些CSS中的长度单位&#34;&gt;&lt;a href=&#34;#24-列举一些CSS中的长度单位&#34; class=&#34;headerlink&#34; title=&#34;24. 列举一些CSS中的长度单位&#34;&gt;&lt;/a&gt;24. 列举一些CSS中的长度单位&lt;/h3&gt;&lt;p&gt;&lt;span id=&#34;question24&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;固定长度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;px 像素点&lt;/li&gt;
&lt;li&gt;mm 毫米&lt;/li&gt;
&lt;li&gt;cm 厘米&lt;/li&gt;
&lt;li&gt;in 英寸&lt;/li&gt;
&lt;li&gt;pt 磅（1&amp;#x2F;72英寸）&lt;/li&gt;
&lt;li&gt;pc 活字（1&amp;#x2F;6英寸）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相对长度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;em 以字体大小(&lt;code&gt;font-size&lt;/code&gt;)为单位&lt;/li&gt;
&lt;li&gt;ex 以小写字母大小为单位&lt;/li&gt;
&lt;li&gt;rem 以根元素（默认为&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;）的字体大小为单位，用于自适应布局&lt;/li&gt;
&lt;li&gt;vh 视口高度的1&amp;#x2F;100&lt;/li&gt;
&lt;li&gt;vw 视口宽度的1&amp;#x2F;100&lt;/li&gt;
&lt;li&gt;vmin 视口宽高较小值的1&amp;#x2F;100&lt;/li&gt;
&lt;li&gt;vmax 视口宽高较大值的1&amp;#x2F;100&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-前端职责&#34;&gt;&lt;a href=&#34;#25-前端职责&#34; class=&#34;headerlink&#34; title=&#34;25. 前端职责&#34;&gt;&lt;/a&gt;25. 前端职责&lt;/h3&gt;&lt;p&gt;狭义地来说是实现UI设计师的设计稿和UE、UX的交互细节。宏观来说，是借助浏览器在技术上处理和用户交互的所有环节。近些年来，借助native的帮助，前端还可以实现后台的业务部分。&lt;/p&gt;
&lt;h3 id=&#34;26-职业规划&#34;&gt;&lt;a href=&#34;#26-职业规划&#34; class=&#34;headerlink&#34; title=&#34;26. 职业规划&#34;&gt;&lt;/a&gt;26. 职业规划&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;27-获取新鲜资讯的方式&#34;&gt;&lt;a href=&#34;#27-获取新鲜资讯的方式&#34; class=&#34;headerlink&#34; title=&#34;27. 获取新鲜资讯的方式&#34;&gt;&lt;/a&gt;27. 获取新鲜资讯的方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://uptodate.frontendrescue.org/zh/&#34;&gt;这个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.echojs.com/&#34;&gt;Echo JS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/welcome/frontend&#34;&gt;掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一些awesome的集锦，诸如&lt;a href=&#34;https://github.com/syaning/awesome-frontend&#34;&gt;这个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎，github等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;28-前端模块化&#34;&gt;&lt;a href=&#34;#28-前端模块化&#34; class=&#34;headerlink&#34; title=&#34;28. 前端模块化&#34;&gt;&lt;/a&gt;28. 前端模块化&lt;/h3&gt;&lt;p&gt;模块化规范包括CommonJS，CMD（SeaJS），AMD（RequireJS）等。我此前做过一个小型的&lt;a href=&#34;http://shenlvmeng.github.io/book.html#commonjs&#34;&gt;笔记&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;29-position类型&#34;&gt;&lt;a href=&#34;#29-position类型&#34; class=&#34;headerlink&#34; title=&#34;29. position类型&#34;&gt;&lt;/a&gt;29. position类型&lt;/h3&gt;&lt;p&gt;static, relative, absolute, fix四种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static 正常文档流&lt;/li&gt;
&lt;li&gt;relative 正常文档流，指定&lt;code&gt;top&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;等CSS属性相对原位置移动&lt;/li&gt;
&lt;li&gt;absolute 脱离文档流，相对上一个非static元素定位&lt;/li&gt;
&lt;li&gt;fix 脱离文档流，相对html定位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常建议使用正常文档流减少潜在bug。绘制复杂动画时，建议使用脱离文档流的布局。&lt;/p&gt;
&lt;h3 id=&#34;30-盒模型&#34;&gt;&lt;a href=&#34;#30-盒模型&#34; class=&#34;headerlink&#34; title=&#34;30. 盒模型&#34;&gt;&lt;/a&gt;30. 盒模型&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model&#34;&gt;盒模型&lt;/a&gt;意为所有渲染的元素都是一个个的矩形。矩形区域内包含&lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;border&lt;/code&gt;, &lt;code&gt;padding&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;4层。CSS属性中只有&lt;strong&gt;两种&lt;/strong&gt;盒模型：&lt;code&gt;border-box&lt;/code&gt;和&lt;code&gt;content-box&lt;/code&gt;。后者是默认值。可以通过&lt;code&gt;box-sizing&lt;/code&gt;属性设置。&lt;/p&gt;
&lt;h3 id=&#34;31-使用原生JS发送AJAX&#34;&gt;&lt;a href=&#34;#31-使用原生JS发送AJAX&#34; class=&#34;headerlink&#34; title=&#34;31. 使用原生JS发送AJAX&#34;&gt;&lt;/a&gt;31. 使用原生JS发送AJAX&lt;/h3&gt;&lt;p&gt;现代浏览器中都通过XMLHttpRquest对象实现Ajax请求。古老的IE浏览器会有不同的实现方法（目前已经很少见了），如：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ActiveXObject&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Microsoft.XMLHTTP&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ActiveXObject&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Msxml2.XMLHTTP.6.0&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通常使用XMLHttpRequest发送GET的方法如下：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; xhr = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;XMLHttpRequest&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;xhr.&lt;span class=&#34;title function_&#34;&gt;open&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;demo.php?id=1&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;xhr.&lt;span class=&#34;title function_&#34;&gt;send&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;发送POST和其他复杂请求时，需要设置request header，在需要接受AJAX返回时，还可以监听readyState的change事件&lt;br&gt;，大致像下面这样：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; xhr = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;XMLHttpRequest&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;xhr.&lt;span class=&#34;title function_&#34;&gt;open&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;POST&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;ajax_post.php&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;xhr.&lt;span class=&#34;title function_&#34;&gt;setRequestHeader&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Content-type&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;application/x-www-form-urlencoded&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;xhr.&lt;span class=&#34;property&#34;&gt;onreadystatechange&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (xhr.&lt;span class=&#34;property&#34;&gt;readyState&lt;/span&gt; === &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt; &amp;amp;&amp;amp; xhr.&lt;span class=&#34;property&#34;&gt;status&lt;/span&gt; === &lt;span class=&#34;number&#34;&gt;200&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; + xhr.&lt;span class=&#34;property&#34;&gt;responseText&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;XMLHttpRequest2中又引入了进度，跨域，中止等新特性。&lt;/p&gt;
&lt;p&gt;另外，使用新的&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch&#34;&gt;Fetch API&lt;/a&gt;也可以完成Ajax请求。Fetch提出的目标是提供访问和操纵HTTP的接口，异步的获取网络资源。它和XMLHttpRequst的区别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即使响应是404或500，返回的Promise也会正常解决&lt;/li&gt;
&lt;li&gt;默认情况下，fetch在服务端不会发送或接受任何cookies&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Ajax需要跨域时，最常用的方法是使用jsonp的形式实现。不过目前通过XMLHttpRequest2或fetch也都能完成跨域请求。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;jsonp&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, success&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; ud = &lt;span class=&#34;string&#34;&gt;&amp;#x27;_&amp;#x27;&lt;/span&gt; + +&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Date&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      script = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;createElement&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;script&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      head = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;head&amp;#x27;&lt;/span&gt;)[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          || &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;documentElement&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;window&lt;/span&gt;[ud] = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;data&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    head.&lt;span class=&#34;title function_&#34;&gt;removeChild&lt;/span&gt;(script);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    success &amp;amp;&amp;amp; &lt;span class=&#34;title function_&#34;&gt;success&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  script.&lt;span class=&#34;property&#34;&gt;src&lt;/span&gt; = url.&lt;span class=&#34;title function_&#34;&gt;replace&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;callback=?&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;callback=&amp;#x27;&lt;/span&gt; + ud);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  head.&lt;span class=&#34;title function_&#34;&gt;appendChild&lt;/span&gt;(script);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;jsonp&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;http://soundcloud.com/oembed?url=http%3A//soundcloud.com/forss/flickermood&amp;amp;format=js&amp;amp;callback=?&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;data&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;31-如何加快访问速度&#34;&gt;&lt;a href=&#34;#31-如何加快访问速度&#34; class=&#34;headerlink&#34; title=&#34;31. 如何加快访问速度&#34;&gt;&lt;/a&gt;31. 如何加快访问速度&lt;/h3&gt;&lt;p&gt;这个问题实际上很大，可以从各个方面去优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩并打包资源文件&lt;/li&gt;
&lt;li&gt;使用CDN存储资源文件&lt;/li&gt;
&lt;li&gt;设置缓存&lt;/li&gt;
&lt;li&gt;CSS sprites&lt;/li&gt;
&lt;li&gt;图片压缩&lt;/li&gt;
&lt;li&gt;图片懒加载&lt;/li&gt;
&lt;li&gt;合理的DOM层级设置&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签设置&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;或动态异步加载&lt;/li&gt;
&lt;li&gt;一般情况下，CSS在前，JS在后&lt;/li&gt;
&lt;li&gt;使用MVVM框架时，使用服务端渲染或预渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-前端的未来发展&#34;&gt;&lt;a href=&#34;#32-前端的未来发展&#34; class=&#34;headerlink&#34; title=&#34;32. 前端的未来发展&#34;&gt;&lt;/a&gt;32. 前端的未来发展&lt;/h3&gt;&lt;p&gt;随着大前端的风吹来，前端工作在横向和纵向都获得了更多的机会。横向上，由PC端到移动端甚至有界面展示的智能终端。不过后两者需要记住native库的帮助。纵向上，在NodeJS的帮助下，后台的部分业务功能抽离出来交由前端完成，前端对界面有完整的控制，数据通过接口的形式向后台索取。现在看来，身为一个前端工程师，不仅要对HTML，CSS，JavaScript老三样了如指掌，对Android或iOS也渐渐有了些要求。&lt;/p&gt;
&lt;h3 id=&#34;33-CSS-selector的优先级顺序&#34;&gt;&lt;a href=&#34;#33-CSS-selector的优先级顺序&#34; class=&#34;headerlink&#34; title=&#34;33. CSS selector的优先级顺序&#34;&gt;&lt;/a&gt;33. CSS selector的优先级顺序&lt;/h3&gt;&lt;p&gt;在&lt;a href=&#34;http://taligarsiel.com/Projects/howbrowserswork1.htm#Style_sheets&#34;&gt;how browsers work&lt;/a&gt;中有介绍。根据&lt;a href=&#34;https://www.w3.org/TR/selectors/#specificity&#34;&gt;CSS3 selectors specificity&lt;/a&gt;中的定义，一个选择器的优先级计算如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果声明来自于style属性，而不是带有选择器的规则，则记为1，否则记为0 (&amp;#x3D; a)&lt;/li&gt;
&lt;li&gt;记为选择器中ID属性的个数 (&amp;#x3D; b)&lt;br&gt;3.记为选择器中其他属性和伪类的个数 (&amp;#x3D; c)&lt;/li&gt;
&lt;li&gt;记为选择器中元素名称和伪元素的个数 (&amp;#x3D; d)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将四个数字按a-b-c-d这样连接起来（位于大数进制的数字系统中），构成特异性。所使用的进制取决于上述类别中的最高计数。最终决定优先级顺序。简而言之就是，style &amp;gt; id &amp;gt; class &amp;gt; tag &amp;gt; pseudo class，统计情况下看个数，有&lt;code&gt;!important&lt;/code&gt;时，以&lt;code&gt;!important&lt;/code&gt;为准。&lt;/p&gt;
&lt;h3 id=&#34;34-连等的赋值顺序&#34;&gt;&lt;a href=&#34;#34-连等的赋值顺序&#34; class=&#34;headerlink&#34; title=&#34;34. 连等的赋值顺序&#34;&gt;&lt;/a&gt;34. 连等的赋值顺序&lt;/h3&gt;&lt;p&gt;问题是，有这样一段代码，问原理是什么：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; foo = &amp;#123; &lt;span class=&#34;attr&#34;&gt;n&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; bar = foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;foo.&lt;span class=&#34;property&#34;&gt;x&lt;/span&gt; = foo = &amp;#123; &lt;span class=&#34;attr&#34;&gt;n&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(foo.&lt;span class=&#34;property&#34;&gt;x&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们来细化一下过程，首先我们要明确JavaScript中对象是引用类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一句里，首先创建了一个字面量对象，并将foo指向之&lt;/li&gt;
&lt;li&gt;第二句里，将foo赋值给bar，即bar也指向&lt;code&gt;&amp;#123; n: 1 &amp;#125;&lt;/code&gt;这个对象&lt;/li&gt;
&lt;li&gt;第三句里，又创建了一个&lt;code&gt;&amp;#123; n: 2 &amp;#125;&lt;/code&gt;的对象，首先寻找foo指向对象中是否有x属性，没有时则新建一个x属性指向这个字面量对象，接着改变foo存储的地址，指向这个新的对象。&lt;/li&gt;
&lt;li&gt;第四句里，由于新的对象没有x属性，&lt;code&gt;foo.x&lt;/code&gt;将返回&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时，如果我们&lt;code&gt;console.log(bar)&lt;/code&gt;结果将是{x: {n: 2}, n: 1}&amp;#96;。&lt;/p&gt;
&lt;h3 id=&#34;35-JavaScript的hoist行为&#34;&gt;&lt;a href=&#34;#35-JavaScript的hoist行为&#34; class=&#34;headerlink&#34; title=&#34;35. JavaScript的hoist行为&#34;&gt;&lt;/a&gt;35. JavaScript的hoist行为&lt;/h3&gt;&lt;p&gt;&lt;code&gt;hoist&lt;/code&gt;特性又叫&lt;strong&gt;变量声明提升&lt;/strong&gt;。是JavaScript中比较有特点的特性。意为将作用域中所有变量（包括函数）声明提升到语句的开头。如下面的语句&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;a = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; a = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; num + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; num + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是当通过函数表达式声明函数时，会提示&lt;code&gt;fun&lt;/code&gt;未定义。因为，此时的语句等同于&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; fun;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;fun = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; num + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，最佳的风格是所有的变量先声明再使用。这也是JSLint和JSHint等linter工具推荐的。&lt;/p&gt;
&lt;h3 id=&#34;36-优雅降级和渐进增强&#34;&gt;&lt;a href=&#34;#36-优雅降级和渐进增强&#34; class=&#34;headerlink&#34; title=&#34;36. 优雅降级和渐进增强&#34;&gt;&lt;/a&gt;36. 优雅降级和渐进增强&lt;/h3&gt;&lt;p&gt;又名graceful degration和progressive enhancement。是两种开发的思路。前者意为针对最高级的浏览器设计开发，再保证向下兼容；后者意为针对低版本浏览器设计，保证基础性能，再追对现代浏览器追加效果，提高用户体验。&lt;/p&gt;
&lt;h3 id=&#34;37-优化网页资源&#34;&gt;&lt;a href=&#34;#37-优化网页资源&#34; class=&#34;headerlink&#34; title=&#34;37. 优化网页资源&#34;&gt;&lt;/a&gt;37. 优化网页资源&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用CDN&lt;/li&gt;
&lt;li&gt;分布存放&lt;/li&gt;
&lt;li&gt;CSS sprites&lt;/li&gt;
&lt;li&gt;disable etag&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;38-浏览器一次可以从同一domain加载多少资源&#34;&gt;&lt;a href=&#34;#38-浏览器一次可以从同一domain加载多少资源&#34; class=&#34;headerlink&#34; title=&#34;38. 浏览器一次可以从同一domain加载多少资源&#34;&gt;&lt;/a&gt;38. 浏览器一次可以从同一domain加载多少资源&lt;/h3&gt;&lt;p&gt;2~8，因浏览器而异。&lt;a href=&#34;http://stackoverflow.com/questions/985431/max-parallel-http-connections-in-a-browser/14768266#14768266&#34;&gt;这里&lt;/a&gt;有个非常全的表。&lt;/p&gt;
&lt;h3 id=&#34;39-轮播图设计思路&#34;&gt;&lt;a href=&#34;#39-轮播图设计思路&#34; class=&#34;headerlink&#34; title=&#34;39. 轮播图设计思路&#34;&gt;&lt;/a&gt;39. 轮播图设计思路&lt;/h3&gt;&lt;p&gt;可以用display实现，配合渐变效果。需要看到幻灯片移动时，可以结合transform和scale实现，配合&lt;code&gt;overflow: hidden&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;40-CSS3的部分新特性&#34;&gt;&lt;a href=&#34;#40-CSS3的部分新特性&#34; class=&#34;headerlink&#34; title=&#34;40. CSS3的部分新特性&#34;&gt;&lt;/a&gt;40. CSS3的部分新特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;border: &lt;code&gt;border-radius&lt;/code&gt;，&lt;code&gt;border-image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;background: &lt;code&gt;background-size&lt;/code&gt;，&lt;code&gt;background-origin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;text: &lt;code&gt;font-face&lt;/code&gt;，&lt;code&gt;text-overflow&lt;/code&gt;，&lt;code&gt;text-shadow&lt;/code&gt;，&lt;code&gt;word-break&lt;/code&gt;，&lt;code&gt;word-wrap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;transform: &lt;code&gt;translate&lt;/code&gt;，&lt;code&gt;rotate&lt;/code&gt;，&lt;code&gt;skew&lt;/code&gt;，&lt;code&gt;scale&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;transition: &lt;code&gt;transition&lt;/code&gt;，&lt;code&gt;animation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;other: &lt;code&gt;box-shadow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41-ARIA&#34;&gt;&lt;a href=&#34;#41-ARIA&#34; class=&#34;headerlink&#34; title=&#34;41. ARIA&#34;&gt;&lt;/a&gt;41. ARIA&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA&#34;&gt;ARIA&lt;/a&gt;全称Accessible Rich Internet Application。主旨是提升网页易用性，方便有阅读障碍的人使用。比较常用的属性有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;role&lt;/code&gt; 当前元素的作用，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;, &lt;code&gt;aria-label&lt;/code&gt; 元素名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aria-hidden&lt;/code&gt; 是否隐藏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-CSS-animation和JavaScript-animation&#34;&gt;&lt;a href=&#34;#42-CSS-animation和JavaScript-animation&#34; class=&#34;headerlink&#34; title=&#34;42. CSS animation和JavaScript animation&#34;&gt;&lt;/a&gt;42. CSS animation和JavaScript animation&lt;/h3&gt;&lt;p&gt;前者方便简单，通过keyframe就可以画出动画，且浏览器会做一些优化，因此性能也比较好。后者更加灵活，可以暂停和反转，且支持交互性。更详细的分析参考&lt;a href=&#34;https://developers.google.com/web/fundamentals/design-and-ui/animations/css-vs-javascript?hl=zh-cn&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;43-doctype是什么&#34;&gt;&lt;a href=&#34;#43-doctype是什么&#34; class=&#34;headerlink&#34; title=&#34;43. doctype是什么&#34;&gt;&lt;/a&gt;43. doctype是什么&lt;/h3&gt;&lt;p&gt;doctype出现在HTML4.1。用于规范HTML和XML文档格式，在推出时，HTML有3种标准可以选择：strict, transitional, frameset。&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;&amp;lt;!DOCTYPE &lt;span class=&#34;keyword&#34;&gt;HTML&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PUBLIC&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;-//W3C//DTD HTML 4.01//EN&amp;quot;&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;http://www.w3.org/TR/html4/strict.dtd&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;&amp;lt;!DOCTYPE &lt;span class=&#34;keyword&#34;&gt;HTML&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PUBLIC&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;&amp;lt;!DOCTYPE &lt;span class=&#34;keyword&#34;&gt;HTML&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PUBLIC&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;-//W3C//DTD HTML 4.01 Frameset//EN&amp;quot;&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;http://www.w3.org/TR/html4/frameset.dtd&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在HTML5中，只有一种doctype可以选择，那就是html：&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;&amp;lt;!DOCTYPE &lt;span class=&#34;keyword&#34;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;44-standard-mode和quirks-mode&#34;&gt;&lt;a href=&#34;#44-standard-mode和quirks-mode&#34; class=&#34;headerlink&#34; title=&#34;44. standard mode和quirks mode&#34;&gt;&lt;/a&gt;44. standard mode和quirks mode&lt;/h3&gt;&lt;p&gt;分别是标准模式和怪异模式。由于历史原因，为了兼容标准建立前就已存在的古老网站，浏览器存在着两种解析网页的模式。在怪异模式下，排版会模拟Navigator 4与Internet Explorer 5的非标准行为。为了支持在网络标准被广泛采用前，就已经建好的网站，这么做是必要的。在标准模式下，行为即（但愿如此）由HTML与CSS的规范描述的行为。在&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/code&gt;中指定&lt;code&gt;html&lt;/code&gt;将自动启用标准模式。&lt;a href=&#34;https://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/&#34;&gt;这里&lt;/a&gt;有更多介绍。&lt;/p&gt;
&lt;h3 id=&#34;45-XHTML和HTML&#34;&gt;&lt;a href=&#34;#45-XHTML和HTML&#34; class=&#34;headerlink&#34; title=&#34;45. XHTML和HTML&#34;&gt;&lt;/a&gt;45. XHTML和HTML&lt;/h3&gt;&lt;p&gt;XHTML伴随HTML4.01一同提出，使用更加严谨的语法。MIMEtype为&lt;code&gt;application/xhtml+xml&lt;/code&gt;，比如：html元素需要有xml相关属性，元素名必须是小写字母，元素属性用&lt;code&gt;&amp;quot;&lt;/code&gt;包围不能为空值，在内容里不能有&lt;code&gt;&amp;amp;&lt;/code&gt;, 需要转义，包括其他特殊字符&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，空元素以&lt;code&gt;/&amp;gt;&lt;/code&gt;结尾。由于语法过于严苛，使用的人不多。未推出的XHTML1.1便被html5取代。&lt;/p&gt;
</content>
        <category term="面试" />
        <category term="前端" />
        <category term="FAQ" />
        <updated>2017-05-17T07:16:27.000Z</updated>
    </entry>
    <entry>
        <id>http://shenlvmeng.github.com/blog/2017/05/12/Frontend-FAQ-part1/</id>
        <title>前端常见面试问题 part 1</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2017/05/12/Frontend-FAQ-part1/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;下面的大部分问题来自Github的这个&lt;a href=&#34;https://github.com/h5bp/Front-end-Developer-Interview-Questions&#34;&gt;仓库&lt;/a&gt;，排名不分先后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-JS中如何定义自定义事件，实现订阅-x2F-发布模式&#34;&gt;&lt;a href=&#34;#1-JS中如何定义自定义事件，实现订阅-x2F-发布模式&#34; class=&#34;headerlink&#34; title=&#34;1. JS中如何定义自定义事件，实现订阅&amp;#x2F;发布模式&#34;&gt;&lt;/a&gt;1. JS中如何定义自定义事件，实现订阅&amp;#x2F;发布模式&lt;/h3&gt;&lt;p&gt;明确需求：可以通过&lt;code&gt;on&lt;/code&gt;和&lt;code&gt;emit&lt;/code&gt;绑定和触发事件。&lt;/p&gt;
&lt;p&gt;方案：创建全局事件管理器&lt;code&gt;events&lt;/code&gt;，构建事件名和回调函数数组的键值对。&lt;code&gt;on&lt;/code&gt;和&lt;code&gt;emit&lt;/code&gt;分别写和读&lt;code&gt;events&lt;/code&gt;。大概像下面这样。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;EventUtil&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 全局事件管理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; events = &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 注册事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        on = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;type, handler&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (events[type]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                events[type].&lt;span class=&#34;title function_&#34;&gt;push&lt;/span&gt;(handler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                events[type] = [handler];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 触发事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        emit = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;type&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!events[type]) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, len = events[type].&lt;span class=&#34;property&#34;&gt;length&lt;/span&gt;; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                events[type][i];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当使用&lt;code&gt;Object.assign&lt;/code&gt;实现继承时，会出现&lt;code&gt;events&lt;/code&gt;共享的问题。可以通过在第一次调用&lt;code&gt;on&lt;/code&gt;时，通过&lt;code&gt;Object.defineProperty&lt;/code&gt;的方式创建避免共享。&lt;/p&gt;
&lt;h3 id=&#34;2-js中的this&#34;&gt;&lt;a href=&#34;#2-js中的this&#34; class=&#34;headerlink&#34; title=&#34;2. js中的this&#34;&gt;&lt;/a&gt;2. js中的&lt;code&gt;this&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;首先，&lt;code&gt;this&lt;/code&gt;永远是对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局上下文内，&lt;code&gt;this&lt;/code&gt;为&lt;strong&gt;全局对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;函数上下文内，根据调用场景分情况讨论&lt;ul&gt;
&lt;li&gt;直接调用：&lt;strong&gt;全局对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过对象的方法调用：&lt;strong&gt;调用方法的对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;构造函数中：&lt;strong&gt;即将被创建的对象&lt;/strong&gt;，有&lt;code&gt;return&lt;/code&gt;语句时，以&lt;code&gt;return&lt;/code&gt;的返回值为准&lt;/li&gt;
&lt;li&gt;call和apply：传入的第一个值&lt;/li&gt;
&lt;li&gt;bind方法：永久绑定到第一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-js跨域问题和解决方案&#34;&gt;&lt;a href=&#34;#3-js跨域问题和解决方案&#34; class=&#34;headerlink&#34; title=&#34;3. js跨域问题和解决方案&#34;&gt;&lt;/a&gt;3. js跨域问题和解决方案&lt;/h3&gt;&lt;p&gt;跨域（Cross-domain）是网景最初基于安全性考虑提出的策略。意为&lt;strong&gt;不同域名&lt;/strong&gt;或&lt;strong&gt;不同协议&lt;/strong&gt;或&lt;strong&gt;不同端口&lt;/strong&gt;间的Ajax通信是被禁止的。根据使用需求，可以分为跨站请求资源和跨页面共享资源（我自己发明的说法）&lt;/p&gt;
&lt;p&gt;跨站请求资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jsonp（json with padding）跨域，利用了&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的可跨域完成，自己写一遍就能搞懂&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getJSONP&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, success&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; ud = &lt;span class=&#34;string&#34;&gt;&amp;#x27;_&amp;#x27;&lt;/span&gt; + +&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Date&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        script = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;createElement&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;script&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        head = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;head&amp;#x27;&lt;/span&gt;)[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;               || &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;documentElement&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;window&lt;/span&gt;[ud] = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;data&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        head.&lt;span class=&#34;title function_&#34;&gt;removeChild&lt;/span&gt;(script);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        success &amp;amp;&amp;amp; &lt;span class=&#34;title function_&#34;&gt;success&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    script.&lt;span class=&#34;property&#34;&gt;src&lt;/span&gt; = url.&lt;span class=&#34;title function_&#34;&gt;replace&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;callback=?&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;callback=&amp;#x27;&lt;/span&gt; + ud);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    head.&lt;span class=&#34;title function_&#34;&gt;appendChild&lt;/span&gt;(script);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;CORS，使用CORS进行跨域请求时，在现代浏览器中已经可以像普通Ajax请求那样使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;即可，可以参考&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/04/18/cors/&#34;&gt;这个&lt;/a&gt;。需要后台服务器支持&lt;/li&gt;
&lt;li&gt;后台反向代理，需要一台中转的服务器&lt;/li&gt;
&lt;li&gt;建立websocket通信，需要后台服务器支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跨页面共享资源，结合&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;有以下几种方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改document.domain，使两个页面位于同一域名下，注意只能从精确-&amp;gt;模糊修改域名&lt;/li&gt;
&lt;li&gt;通过window.name传递消息，利用了iframe location变化后，window.name不变的特点&lt;/li&gt;
&lt;li&gt;location.hash&lt;/li&gt;
&lt;li&gt;html5中的postMessage API在不同&lt;code&gt;window&lt;/code&gt;间传递消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里附上一个&lt;a href=&#34;http://blog.csdn.net/joyhen/article/details/21631833&#34;&gt;链接&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;4-js的作用域链&#34;&gt;&lt;a href=&#34;#4-js的作用域链&#34; class=&#34;headerlink&#34; title=&#34;4. js的作用域链&#34;&gt;&lt;/a&gt;4. js的作用域链&lt;/h3&gt;&lt;p&gt;这是JavaScript最有特点同时也是最基础的内涵之一。红宝书和犀牛书都做了详尽和透彻的解释。这个问题理解了，什么是闭包就能很好地理解了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们便习得代码无法访问这个对象，但解析器在处理数据时会在后台使用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;全局执行环境是最外围的一个执行环境。…。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局环境知道应用程序退出时才会销毁）&lt;br&gt;每个函数都有自己的&lt;strong&gt;执行环境&lt;/strong&gt;。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是有这个方便的机制控制着。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，时钟都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其&lt;strong&gt;活动对象&lt;/strong&gt;做为变量对象。活动对象在最开始时只包含一个变量，即&lt;code&gt;arguments&lt;/code&gt;对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中最后一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-Function-call和Function-apply的区别&#34;&gt;&lt;a href=&#34;#5-Function-call和Function-apply的区别&#34; class=&#34;headerlink&#34; title=&#34;5. Function.call和Function.apply的区别&#34;&gt;&lt;/a&gt;5. &lt;code&gt;Function.call&lt;/code&gt;和&lt;code&gt;Function.apply&lt;/code&gt;的区别&lt;/h3&gt;&lt;p&gt;&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;同为改变&lt;code&gt;this&lt;/code&gt;的方法，前者一个一个接收输入参数，后者以数组的形式接收。&lt;/p&gt;
&lt;h3 id=&#34;6-浏览器渲染页面的原理&#34;&gt;&lt;a href=&#34;#6-浏览器渲染页面的原理&#34; class=&#34;headerlink&#34; title=&#34;6. 浏览器渲染页面的原理&#34;&gt;&lt;/a&gt;6. 浏览器渲染页面的原理&lt;/h3&gt;&lt;p&gt;可以参考经典的文章&lt;a href=&#34;http://taligarsiel.com/Projects/howbrowserswork1.htm&#34;&gt;how browsers work&lt;/a&gt;，或者&lt;a href=&#34;https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/&#34;&gt;中译版&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;7-列举一些HTML5的改进&#34;&gt;&lt;a href=&#34;#7-列举一些HTML5的改进&#34; class=&#34;headerlink&#34; title=&#34;7. 列举一些HTML5的改进&#34;&gt;&lt;/a&gt;7. 列举一些HTML5的改进&lt;/h3&gt;&lt;p&gt;可以参考MDN给出的&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5&#34;&gt;summary&lt;/a&gt;。比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义化，语义化标签&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;，语义化元素&lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;等和新的多媒体标签&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;网络通信，Websocket，WebRTC&lt;/li&gt;
&lt;li&gt;图像，Canvas和WebGL&lt;/li&gt;
&lt;li&gt;离线存储，Storage接口和IndexDB&lt;/li&gt;
&lt;li&gt;性能，Web Worker，XMLHttpRequest2（支持进度等新特性），History API，Fullscreen，PointerLock，requestAnimationFrame等&lt;/li&gt;
&lt;li&gt;CSS，CSS3的特性，有些甚至演进到了Level 4&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8-HTML5中的定位API&#34;&gt;&lt;a href=&#34;#8-HTML5中的定位API&#34; class=&#34;headerlink&#34; title=&#34;8. HTML5中的定位API&#34;&gt;&lt;/a&gt;8. HTML5中的定位API&lt;/h3&gt;&lt;p&gt;Geolocation API，新的API，红宝书中有提到。通过&lt;code&gt;navigator.geolocation&lt;/code&gt;对象实现，允许用户提供自己的所在地理位置。需要用户确认同意才可使用。最常用的方法是&lt;code&gt;getCurrentPosition()&lt;/code&gt;。这个方法接受三个参数——成功回调、可选的失败回调、可选的选项。&lt;/p&gt;
&lt;p&gt;类似的不常见的API还有&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API&#34;&gt;Battery API&lt;/a&gt;，&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/File&#34;&gt;File API&lt;/a&gt;，&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/performance&#34;&gt;performance&lt;/a&gt;等。&lt;/p&gt;
&lt;h3 id=&#34;9-一些前端框架的双向绑定原理&#34;&gt;&lt;a href=&#34;#9-一些前端框架的双向绑定原理&#34; class=&#34;headerlink&#34; title=&#34;9. 一些前端框架的双向绑定原理&#34;&gt;&lt;/a&gt;9. 一些前端框架的双向绑定原理&lt;/h3&gt;&lt;p&gt;不是所有框架都提倡双向绑定。有的框架如Angular使用数据双向绑定，适合于表单很多的站点，React和Vue这样的使用的是&lt;a href=&#34;https://www.zhihu.com/question/31585377&#34;&gt;单向绑定&lt;/a&gt;。在单向绑定背景下，可以通过&lt;code&gt;addEventListener&lt;/code&gt;实现双向绑定。&lt;/p&gt;
&lt;p&gt;实现原理上分为几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布-订阅模式，显式地绑定事件和监听函数。backbone就是这么做的，显式地通过&lt;code&gt;Model.set&lt;/code&gt;修改数据触发&lt;code&gt;change&lt;/code&gt;事件来更新视图。React也是通过&lt;code&gt;setState&lt;/code&gt;显式地触发虚拟DOM树更新和重新渲染的。&lt;/li&gt;
&lt;li&gt;脏检查（digest cycle），通过特定事件触发脏检查。脏检查即一种不关心你如何以及何时改变的数据，只关心在特定的检查阶段数据是否改变的数据监听技术。过程大致是&lt;code&gt;$update&lt;/code&gt;或其他手段触发digest阶段，遍历通过&lt;code&gt;$watch&lt;/code&gt;绑定的watcher。对比值是否改变触发更新。优点是无需知道更改数据的方式，可以统一更新view，缺点是watcher较多时会有严重的性能问题。&lt;/li&gt;
&lt;li&gt;数据劫持&lt;code&gt;Object.defineProperty&lt;/code&gt;，Vue使用这种方式实现隐式的绑定（当然在&lt;a href=&#34;https://shenlvmeng.github.io/blog/2017/04/05/vue-reactive-sourcecode/&#34;&gt;具体实现&lt;/a&gt;中复杂了许多）。这么做的问题是版本只支持到IE9+，且在数组更新时有所局限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-webpack的配置文件写法&#34;&gt;&lt;a href=&#34;#10-webpack的配置文件写法&#34; class=&#34;headerlink&#34; title=&#34;10. webpack的配置文件写法&#34;&gt;&lt;/a&gt;10. webpack的配置文件写法&lt;/h3&gt;&lt;p&gt;除了常用的&lt;code&gt;entry&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;plugins&lt;/code&gt;外，webpack的使用方法实在太多，建议去&lt;a href=&#34;https://webpack.js.org/configuration/&#34;&gt;官网&lt;/a&gt;查看完整的配置信息。&lt;/p&gt;
&lt;h3 id=&#34;11-node文件和网络API&#34;&gt;&lt;a href=&#34;#11-node文件和网络API&#34; class=&#34;headerlink&#34; title=&#34;11. node文件和网络API&#34;&gt;&lt;/a&gt;11. node文件和网络API&lt;/h3&gt;&lt;p&gt;文件操作上，常用的有&lt;code&gt;fs.readFileSync&lt;/code&gt;，&lt;code&gt;fs.writeFileSync&lt;/code&gt;，或通过流的方式使用&lt;code&gt;fs.createReadStream&lt;/code&gt;，&lt;code&gt;fs.createWriteStream&lt;/code&gt;。还有&lt;code&gt;pipe&lt;/code&gt;将流连接在一起。除此之外，&lt;code&gt;path&lt;/code&gt;，&lt;code&gt;join&lt;/code&gt;和&lt;code&gt;normalize&lt;/code&gt;常用在处理文件路径。&lt;/p&gt;
&lt;p&gt;和网络操作相关的包包括&lt;code&gt;http&lt;/code&gt;, &lt;code&gt;https&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;querystring&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt;等。其中前两个包更为常用，尤其是&lt;code&gt;http.createServer&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;另外，在进程上有&lt;code&gt;process&lt;/code&gt;, &lt;code&gt;child_process&lt;/code&gt;等包。&lt;a href=&#34;https://nqdeng.github.io/7-days-nodejs&#34;&gt;这里&lt;/a&gt; 有一篇文章做了比较详细的介绍。当然，有空最好还是去&lt;a href=&#34;https://nodejs.org/docs/latest-v5.x/api/&#34;&gt;官方文档&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;12-和-import的区别&#34;&gt;&lt;a href=&#34;#12-和-import的区别&#34; class=&#34;headerlink&#34; title=&#34;12. 和@import的区别&#34;&gt;&lt;/a&gt;12. &lt;link&gt;和@import的区别&lt;/h3&gt;&lt;p&gt;它们的最常见的使用方式都是引入CSS文件到html中。它们的区别在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;link是XHTML标签，除了加载CSS外，还可以引入RSS等其他资源；@import属于CSS范畴，只能加载CSS。&lt;/li&gt;
&lt;li&gt;link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。&lt;/li&gt;
&lt;li&gt;link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。&lt;/li&gt;
&lt;li&gt;由于link是标签，可以通过JavaScript控制来改变样式，后者不行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-cookie，localStorage和sessionStorage的区别和联系&#34;&gt;&lt;a href=&#34;#13-cookie，localStorage和sessionStorage的区别和联系&#34; class=&#34;headerlink&#34; title=&#34;13. cookie，localStorage和sessionStorage的区别和联系&#34;&gt;&lt;/a&gt;13. cookie，localStorage和sessionStorage的区别和联系&lt;/h3&gt;&lt;p&gt;cookie设计的初衷是用来为无状态的http访问添加用户状态消息的。大小4KB以下，会携带在请求头中。大多包含敏感信息，会和服务器端的session配合使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;Storage API&lt;/a&gt;是HTML5的新API。又可以细分为localStorage和sessionStorage。它们一般只存储在客户端，用来缓存用户非敏感数据，大小因浏览器而异，容量约可达到5MB。sessionStorage在浏览器关闭后清除，localStorage则在超过时限或手动clear后清除。&lt;/p&gt;
&lt;p&gt;cookie中的内容很少变化，且最好秘文储存，并通过HttpOnly添加限制（后台修改set-cookie头）。Storage则很可能会频繁读写。&lt;/p&gt;
&lt;h3 id=&#34;14-HTTP状态码&#34;&gt;&lt;a href=&#34;#14-HTTP状态码&#34; class=&#34;headerlink&#34; title=&#34;14. HTTP状态码&#34;&gt;&lt;/a&gt;14. HTTP状态码&lt;/h3&gt;&lt;p&gt;根据状态码开头的数字确定状态码类型。下面列举一些常用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1xx 信息&lt;/strong&gt;：这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100 继续：客户端应当继续发送请求。&lt;/li&gt;
&lt;li&gt;101 切换协议：将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2xx 成功&lt;/strong&gt;：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回&lt;/li&gt;
&lt;li&gt;201 已创建：请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回&lt;/li&gt;
&lt;li&gt;202 已接受：服务器已接受请求，但尚未处理&lt;/li&gt;
&lt;li&gt;204 No Content：服务器成功处理了请求，但不需要返回任何实体内容，用户浏览器应保留发送了该请求的页面&lt;/li&gt;
&lt;li&gt;205 Reset Content：和204的唯一不同是返回此状态码的响应要求请求者重置文档视图&lt;/li&gt;
&lt;li&gt;206 服务器已经成功处理了部分GET请求。该请求必须包含Range头信息来指示客户端希望得到的内容范围，多用于下载工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3xx 重定向&lt;/strong&gt;：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;300 多选择：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。&lt;/li&gt;
&lt;li&gt;301 永久移动：被请求的资源已永久移动到新位置&lt;/li&gt;
&lt;li&gt;302 临时移动：请求的资源现在临时从不同的URI响应请求&lt;/li&gt;
&lt;li&gt;303 重定向：对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源&lt;/li&gt;
&lt;li&gt;304 如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变&lt;/li&gt;
&lt;li&gt;305 使用中介：被请求的资源必须通过指定的代理才能被访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4xx 客户端错误&lt;/strong&gt;：代表了客户端看起来可能发生了错误，妨碍了服务器的处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;400 无法理解的请求：由于包含语法错误，当前请求无法被服务器理解&lt;/li&gt;
&lt;li&gt;401 需要验证：当前请求需要用户验证。响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。&lt;/li&gt;
&lt;li&gt;403 禁止访问：服务器已经理解请求，但是拒绝执行它&lt;/li&gt;
&lt;li&gt;404 未找到：请求所希望得到的资源未被在服务器上发现&lt;/li&gt;
&lt;li&gt;405 方法不允许：请求行中指定的请求方法不能被用于请求相应的资源，响应中必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表&lt;/li&gt;
&lt;li&gt;406 头部不对：请求的资源的内容特性无法满足请求头中的条件&lt;/li&gt;
&lt;li&gt;408 请求超时：客户端没有在服务器预备等待的时间内完成一个请求的发送&lt;/li&gt;
&lt;li&gt;411 需要指定长度：服务器拒绝在没有定义Content-Length头的情况下接受请求&lt;/li&gt;
&lt;li&gt;413 请求实体太长&lt;/li&gt;
&lt;li&gt;414 URI太长&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5xx 服务器错误&lt;/strong&gt;：代表了服务器在处理请求的过程中有错误或者异常状态发生&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;500 内部错误：一般来说，这个问题会在服务器的代码出错时出现&lt;/li&gt;
&lt;li&gt;501 未实现：服务器不支持当前请求所需要的某个功能&lt;/li&gt;
&lt;li&gt;502 Bad GateWay：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应&lt;/li&gt;
&lt;li&gt;503 服务不可达：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。&lt;/li&gt;
&lt;li&gt;504 网关超时：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应&lt;/li&gt;
&lt;li&gt;505 HTTP协议版本不正确&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15-URL去参数&#34;&gt;&lt;a href=&#34;#15-URL去参数&#34; class=&#34;headerlink&#34; title=&#34;15. URL去参数&#34;&gt;&lt;/a&gt;15. URL去参数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;location.search&lt;/code&gt;, &lt;code&gt;location.href&lt;/code&gt;, &lt;code&gt;location.origin&lt;/code&gt;分别代表url中的querystring，完整url和域名。再结合&lt;code&gt;location.pathname&lt;/code&gt;, &lt;code&gt;location.port&lt;/code&gt;和&lt;code&gt;location.protocol&lt;/code&gt;可以得到任意想要的URL参数。&lt;/p&gt;
&lt;p&gt;另外，新的API&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&#34;&gt;URLSearchParams&lt;/a&gt;中有些方法可以对querystring做方便的增删改查的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;append&lt;/code&gt;增加一个检索参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;删除一个检索参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt;获取检索参数的第一个值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getAll&lt;/code&gt;获取检索参数的所有值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;has&lt;/code&gt;检查是否存在某检索参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;设置一个检索参数的新值，会覆盖原值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys&lt;/code&gt;和&lt;code&gt;values&lt;/code&gt;分别返回键和值组成的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16-js中的正则匹配&#34;&gt;&lt;a href=&#34;#16-js中的正则匹配&#34; class=&#34;headerlink&#34; title=&#34;16. js中的正则匹配&#34;&gt;&lt;/a&gt;16. js中的正则匹配&lt;/h3&gt;&lt;p&gt;&lt;span id=&#34;regexp&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;js中的正则匹配和Perl的正则匹配规则基本类似。在js中，使用一个正则表达式字面量，由包含在斜杠之间的模式组成。正则表达式同时也是RegExp对象。除了简单模式外，考察对&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions&#34;&gt;正则表达式&lt;/a&gt;的熟悉在它的特殊字符使用上。&lt;/p&gt;
&lt;p&gt;一些常见的特殊字符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 用于转义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 用于匹配开始或表示一个反向字符集（如&lt;code&gt;[^xyz]&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 用于匹配结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 匹配前一个表达式0或多次 &amp;#x3D; &lt;code&gt;&amp;#123;0,&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 匹配前一个表达式1或多次 &amp;#x3D; &lt;code&gt;&amp;#123;1,&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;?&lt;/code&gt; 匹配0或1次 &amp;#x3D; &lt;code&gt;&amp;#123;0,1&amp;#125;&lt;/code&gt;；紧跟量词后使匹配非贪婪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.&lt;/code&gt; 匹配除换行符外任何单字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(x)&lt;/code&gt; 捕获匹配，会包括在最后结果中，也可以通过$1, $n来访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(?:x)&lt;/code&gt; 非捕获分组，匹配但不捕获&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;x(?=y)&lt;/code&gt; 断言匹配，捕获后跟y的x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;x|y&lt;/code&gt; 匹配x或y&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;#123;n&amp;#125;&lt;/code&gt; 量词，匹配n次，还有{n,m}和{n,}的用法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;[xyz]&lt;/code&gt; 字符集，可以使用&lt;code&gt;-&lt;/code&gt;连接，如&lt;code&gt;[x-z]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\d&lt;/code&gt; 一个数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\D&lt;/code&gt; 一个非数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\s&lt;/code&gt; 一个空白字符，包含空格，制表符，分页符，换行符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\S&lt;/code&gt; 一个非空白字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\w&lt;/code&gt; 一个单字字符，等价于&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\W&lt;/code&gt; 一个非单字字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，正则表达式还有几个可选参数辅助搜索类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;g 全局搜索&lt;/li&gt;
&lt;li&gt;i 不区分大小写&lt;/li&gt;
&lt;li&gt;m 多行搜索&lt;/li&gt;
&lt;li&gt;y 粘性搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些方法用于和正则表达式相关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt; 在字符串中执行匹配，返回匹配结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt; 测试是否能匹配RegExp，返回true或false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; 对字符串执行查找匹配的String方法，返回匹配结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search&lt;/code&gt; 在字符串中测试匹配，返回位置索引或-1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 在字符串中执行查找匹配，并使用替换字符串替换匹配的子字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;split&lt;/code&gt; 使用一个正则表达式或字符串分割一个字符串，并储存在数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的考法有，书写一个邮箱或手机号的正则表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮箱 &lt;code&gt;/^(([^&amp;lt;&amp;gt;()\[\]\\.,;:\s@&amp;quot;]+(\.[^&amp;lt;&amp;gt;()\[\]\\.,;:\s@&amp;quot;]+)*)|(&amp;quot;.+&amp;quot;))@((\[[0-9]&amp;#123;1,3&amp;#125;\.[0-9]&amp;#123;1,3&amp;#125;\.[0-9]&amp;#123;1,3&amp;#125;\.[0-9]&amp;#123;1,3&amp;#125;])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&amp;#123;2,&amp;#125;))$/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手机号 &lt;code&gt;/^0*(13|15|18|14|17)(\d&amp;#123;9&amp;#125;|\d-\d&amp;#123;3&amp;#125;-\d&amp;#123;5&amp;#125;|\d-\d&amp;#123;4&amp;#125;-\d&amp;#123;4&amp;#125;|\d&amp;#123;2&amp;#125;-\d&amp;#123;3&amp;#125;-\d&amp;#123;4&amp;#125;|\d&amp;#123;2&amp;#125;-\d&amp;#123;4&amp;#125;-\d&amp;#123;3&amp;#125;)$/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;17-MVC和MVVM框架&#34;&gt;&lt;a href=&#34;#17-MVC和MVVM框架&#34; class=&#34;headerlink&#34; title=&#34;17. MVC和MVVM框架&#34;&gt;&lt;/a&gt;17. MVC和MVVM框架&lt;/h3&gt;&lt;p&gt;框架模式不是一门写代码的学问，而是一门管理与组织代码的学问。其本质是一种软件开发的模型。与设计模式不同，设计模式是在解决某类特定问题时总结抽象出的公共方法，是&lt;strong&gt;方法论&lt;/strong&gt;的范畴，一种框架模式往往使用了多种设计模式，且和技术栈有耦合的关系。&lt;/p&gt;
&lt;p&gt;视图（View）从本质上讲是数据在图像上的一种体现和映射。用户在操作图像时可以达到操作数据的目的，在数据更改后，需要重新将数据映射到视图上。这实际上就是MVC的出发点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/mvc.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View: 放置视图相关的代码，原则上里面不应该有任何业务逻辑。&lt;/li&gt;
&lt;li&gt;Controller: 放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码(router)，但并不实现真正的功能，他只是一个桥梁。&lt;/li&gt;
&lt;li&gt;Model: 这里的model不是说实体类，它是主要实现业务逻辑的地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发流程是先创建视图组件，再将之关联到Model上，通过View修改Model中的值时，Model会触发绑定在之上的所有View的更新。Backbone是个典型的例子。这么做部分分离了视图和逻辑。但是，在情况复杂时，Model的代码量将会大大膨胀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/mvp.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;MVP因此而生，其中Presenter（分发器）代替了原来的Controller，分担了Model的部分功能。针对上面的问题，Presetner隔断了Model和View，当M改变时，会通知P去更新视图。业务逻辑和绑定逻辑从V和M中分离出来到P中。使得MVP三方分工更加鲜明。绝大多数的PHP框架都是MVP类型的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/blog/images/mvvm.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;MVVM是Model-View-ViewModel的缩写。在MVVM中，View和ViewModel是双向或单向数据绑定的关系。当ViewModel反应了Model中的数据模型，并绑定到视图属性上，反过来，视图属性变化后也会通过ViewModel影响Model。React，Vue这些流行的前端框架都是MVVM类型的。&lt;/p&gt;
&lt;p&gt;不管是MVC还是MVP或MVVM，他们都是&lt;strong&gt;数据驱动&lt;/strong&gt;的。核心上基于M推送消息，V或P来订阅这个模型。使用者需要维护的不再是UI树，而是抽象的数据。当UI的状态一旦多起来，这种框架模式的优势就很明显了。&lt;/p&gt;
</content>
        <category term="面试" />
        <category term="前端" />
        <category term="FAQ" />
        <updated>2017-05-12T09:26:22.000Z</updated>
    </entry>
</feed>

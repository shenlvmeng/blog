{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"http\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2020/06/29/http-2-for-frontend/",
            "url": "http://shenlvmeng.github.com/blog/2020/06/29/http-2-for-frontend/",
            "title": "面向前端的HTTP/2介绍",
            "date_published": "2020-06-29T14:41:51.000Z",
            "content_html": "<p>正式版HTTP&#x2F;2发布于2015年5月，距今已经快5年了，相比老一辈HTTP 1.1有了许多改进。在具体讨论这些改进前，我们先简单回顾下HTTP这一路以来的历程。</p>\n<h2 id=\"历史回顾\"><a href=\"#历史回顾\" class=\"headerlink\" title=\"历史回顾\"></a>历史回顾</h2><p>HTTP在1991年发布了最初的HTTP0.9版本，主要用于学术交流，目的也只是用来在网络之间传递HTML超文本的内容。HTTP0.9基于TCP，只有一个GET请求类型，请求和文档响应都是ASCII字符流，响应数据类型只有HTML类型，在响应结束后立即断开连接。</p>\n<p>随着互联网发展，1994年底出现了拨号上网，网景推出浏览器后，WWW已经不仅局限于学术交流，浏览器中除了承载HTML以外，还包括了JavaScript、CSS、图片、音视频等资源。HTTP1.0在这个背景下于1996年推出（RFC1945），它支持了状态码、方法、头部的概念，响应内容不局限于超文本文件，编码类型也不仅限于ASCII。但是TCP连接在响应返回后依旧会断开连接。</p>\n<p>在浏览器等技术发展，HTTP请求更多也更复杂，HTTP1.0的已有问题暴露得越来越明显。TCP频繁建立连接的时延，缓存协商机制的不完整、大文件下载的支持等问题需要解决。于是HTTP1.1在1999年推出（RFC2616），这是个很庞大的协议，全文长达176页，在后续IETF对该规范进行更新时，则被拆分成了总页数更多的六个文档（即RFC7230协议族）。HTTP1.1包含了太多细节和可选的部分，包含不常用的功能和不合适的优化，因此几乎没有任何实现包含完整的协议功能。总的来看，HTTP1.1做了一些尝试：</p>\n<ul>\n<li>TCP持久连接（keep-alive），即在一个TCP连接上发起HTTP请求</li>\n<li>支持范围请求（Accept-Ranges）</li>\n<li>更强大的缓存机制（协商缓存和强缓存，以及相关的头部）</li>\n<li>提出了HTTP pipeline，尝试改善串行HTTP请求引起的线头阻塞（Head-of-line blocking）问题</li>\n<li>更多的错误相关状态码</li>\n<li>Host头处理</li>\n</ul>\n<p>之后HTTP1.1便被一直使用至今，随着互联网页面请求资源的数量和体积增大，HTTP1.1中没能妥善解决的问题越来越明显。HTTPbis工作组在2007年夏天便着手于HTTP1.1标准的更新，并最终在2014年初形成上面提到的RFC7230系列协议族。</p>\n<p><a href=\"http://en.wikipedia.org/wiki/SPDY\">SPDY</a>（SPeeDY）是由Google牵头开发的开源协议，意图在TLS和HTTP中间插入中间层，解决HTTP协议的问题。大约在2012年提出，也被大多数主流浏览器支持。最终在2015年HTTP&#x2F;2协议发布后，逐步放弃支持。实际上HTTP&#x2F;2也是在SPDY&#x2F;3草案的基础上形成的协议初稿。</p>\n<h2 id=\"历史问题\"><a href=\"#历史问题\" class=\"headerlink\" title=\"历史问题\"></a>历史问题</h2><h3 id=\"传输资源与延迟\"><a href=\"#传输资源与延迟\" class=\"headerlink\" title=\"传输资源与延迟\"></a>传输资源与延迟</h3><p>当今的互联网环境和20世纪末那会儿已经有了很大的不同，现在的Web页面更像一个应用的概念，而非一个简单的页面（SPA）。从HTTPArchive一个页面下请求的资源数已经上百，请求的资源体积也接近2M。</p>\n<p><img src=\"https://raw.githubusercontent.com/bagder/http2-explained/master/images/transfer-size-growth.png\" alt=\"http-transfer-size\"></p>\n<p>随着这些年网络硬件条件的迅猛发展，<strong>带宽</strong>已经不再是影响人们体验的因素，而<strong>网络延迟</strong>仍然没有太好的改善。高延迟的网络上（比如移动设备），即使拥有高连接速率，也很难获得优质快速的网络体验。页面从访问到打开的近70%时间都发生在网络上。</p>\n<h3 id=\"请求-响应模型\"><a href=\"#请求-响应模型\" class=\"headerlink\" title=\"请求-响应模型\"></a>请求-响应模型</h3><p>HTTP1.1是无状态协议，需要以客户端请求开始，然后才能响应。一个TCP上同时只能有一个请求&#x2F;响应。TCP协议的能力并没有被充分利用。在HTTP1.1启用keep-alive后，TCP连接重复建立的问题被解决。但是请求还是需要排队一个一个发送，TCP的RTT（round-trip time）还是比较可观。后续的HTTP1.1提出了<strong>HTTP管线化</strong>（pipeline），即将多个HTTP请求合并成一个，一起发送，这样的确提高了服务器的资源利用率，但是也会带来线头阻塞（head-of-line blocking）问题，即一个比较耗时的请求会影响后续的所有请求。另外，它会给重试带来麻烦，需要网络中间节点的支持。所以这个特性并没有得到浏览器和服务器认可，实现也并不普及。目前大多数桌面浏览器也是默认关闭这个特性的。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png\" alt=\"http-pipeline\"></p>\n<h4 id=\"那些年，我们一起克服延迟的办法\"><a href=\"#那些年，我们一起克服延迟的办法\" class=\"headerlink\" title=\"那些年，我们一起克服延迟的办法\"></a>那些年，我们一起克服延迟的办法</h4><p>针对上面的困难，智慧的开发者们自然也是有了许多应对办法。</p>\n<p><img src=\"https://raw.githubusercontent.com/bagder/http2-explained/master/images/spriting.jpg\"></p>\n<ul>\n<li>雪碧图：将小图片整合成一张大图。</li>\n<li>内联：将高优先级资源或小资源通过script标签或style标签或dataUrl的形式直接内嵌在页面里</li>\n<li>分片（sharding）与域名散列：将图片或者其他资源分发到不同主机。最初的HTTP1.1规范（RFC2616）提到一个客户端最多只能对同一主机建立两个TCP连接。后来，两个连接的限制被取消了（RFC7230），现在的浏览器一般允许每个域名主机建立6-8个连接。根据httparchive.org的记录显示，在Top30万个URL中平均使用40个TCP连接来显示页面</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/bagder/http2-explained/master/images/expressen-sharding.jpg\" alt=\"http-sharding\"></p>\n<p>除此之外，为了减少请求数，前端会将代码合并并打包，这也是webpack这样的工具诞生的背景。</p>\n<h3 id=\"冗长的头部\"><a href=\"#冗长的头部\" class=\"headerlink\" title=\"冗长的头部\"></a>冗长的头部</h3><p>HTTP1.1中1000+字节的头部都是常见的且体积较大的，如<code>Cookie</code>。头部信息有许多多余信息。这也让许多大请求建立连接的过程变得很慢。</p>\n<p>总结来看，HTTP1.1遗留了下面几个问题：</p>\n<ul>\n<li>对TCP利用较差，同时只能有一个请求&#x2F;响应<ul>\n<li>目前应对方法：开多个TCP连接（分片），减少请求数（合并资源）；这些方法多少会遇到TCP慢启动、DNS开销等问题</li>\n</ul>\n</li>\n<li>HTTP头部没有压缩，占用较大空间<ul>\n<li>目前应对方法：减少请求数、使用cookie-less域名</li>\n</ul>\n</li>\n<li>固有的请求-响应模式，重要资源无法优先推送<ul>\n<li>目前应对方法：内联资源</li>\n</ul>\n</li>\n</ul>\n<p>HTTP&#x2F;2对于上面这些问题自然是重拳出击。</p>\n<h2 id=\"HTTP-x2F-2概述\"><a href=\"#HTTP-x2F-2概述\" class=\"headerlink\" title=\"HTTP&#x2F;2概述\"></a>HTTP&#x2F;2概述</h2><blockquote>\n<p>“HTTP&#x2F;2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients.”</p>\n</blockquote>\n<p>根据<a href=\"https://httpwg.org/specs/rfc7540.html\">RFC7540</a>的摘要，简明扼要地点出了HTTP&#x2F;2带来的几个重要特性：</p>\n<ul>\n<li>多路复用的二进制协议；一个TCP连接上不再只有1个请求&#x2F;响应，同时采用二进制而非文本传输数据</li>\n<li>头部压缩；用二进制分帧配合专门设计的头部压缩算法（HPACK）大大减少头部体积，HPACK有专门的<a href=\"https://httpwg.github.io/specs/rfc7541.html\">RFC7541</a>来规范。</li>\n<li>服务器推送；在客户端发送请求前，主动将资源推送给客户端</li>\n</ul>\n<p>整个HTTP&#x2F;2实际上还是在HTTP的框架下的，对HTTP1.1也是完全兼容的，这意味着你可以像以前一样使用HTTP的API、方法、头部、状态码这些：</p>\n<ul>\n<li>HTTP&#x2F;2必须维持HTTP的范式。它只是一个让客户端发送请求到服务器的基于TCP的协议</li>\n<li>不能改变<code>http://</code>和<code>https://</code>这样的URL，也不能对其添加新的结构。使用这类URL的网站太多了，没法指望他们全部改变。</li>\n<li>HTTP1.1的服务器和客户端依然会存在很久，所以必须提供HTTP1.1到HTTP&#x2F;2服务器的代理</li>\n<li>不再使用小版本号。服务器和客户端都必须确定自己是否完整兼容http2或者彻底不兼容</li>\n</ul>\n<h3 id=\"协商\"><a href=\"#协商\" class=\"headerlink\" title=\"协商\"></a>协商</h3><p>SPDY依赖于TLS，不过从SPDY中诞生的HTTP&#x2F;2却可以选择是否基于TLS。由此带来2种HTTP&#x2F;2协商机制。对于普通的HTTP1.1，通过给服务器发送一个带升级头部的报文。如果服务器支持HTTP&#x2F;2，它将以“101 Switching”作为回复的状态码，并从此开始在该连接上使用HTTP&#x2F;2。这种连接方式也被称为<strong>h2c</strong>（HTTP&#x2F;2 cleartext），此时HTTP&#x2F;2在TCP之上运行。出于安全性考虑。<strong>几乎所有的主流浏览器都不支持这种协商实现</strong>（curl可以支持）。</p>\n<p>对于在TLS之上的https，Next Protocol Negotiation (NPN)是一个用来在TLS服务器上协商SPDY的协议。IETF将这个非正式标准进行规范化，从而演变成了ALPN（Application Layer Protocol Negotiation）。ALPN会伴随HTTP&#x2F;2中的使用而推广，考虑到SPDY会使用NPN，而许多服务器又会同时提供SPDY以及HTTP&#x2F;2，所以在这些服务器上同时支持ALPN以及NPN显然会成为最理所当然的选择。ALPN和NPN的主要区别在于，ALPN中由服务端最终决定通信协议，NPN中由客户端最终决定。</p>\n<h2 id=\"HTTP-x2F-2特性\"><a href=\"#HTTP-x2F-2特性\" class=\"headerlink\" title=\"HTTP&#x2F;2特性\"></a>HTTP&#x2F;2特性</h2><p>在HTTP&#x2F;2的介绍中提到，协议通过定义一个优化的基础连接的HTTP语义映射来解决HTTP1.1的问题。具体地，它允许在<strong>同一连接</strong>上<strong>交错</strong>地建立请求和响应消息，并使用<strong>高效率编码</strong>的HTTP报头字段。它还允许<strong>请求的优先级</strong>，让更多的重要的请求更快速的完成，进一步提升了性能。最终协议设计为对网络更友好，因为它相对HTTP&#x2F;1.x减少了TCP连接。最后，这种封装也通过使用<strong>二进制消息帧</strong>使信息处理更具扩展性。</p>\n<p>里面加粗的部分即HTTP&#x2F;2带来的几个新特性：</p>\n<ul>\n<li>单一TCP连接</li>\n<li>二进制分帧<ul>\n<li>请求优先级</li>\n<li>服务端推送</li>\n<li>流量控制</li>\n</ul>\n</li>\n<li>多路复用</li>\n<li>头部压缩（HPACK）</li>\n</ul>\n<h3 id=\"二进制分帧“层”\"><a href=\"#二进制分帧“层”\" class=\"headerlink\" title=\"二进制分帧“层”\"></a>二进制分帧“层”</h3><p>首先，HTTP&#x2F;2是个二进制协议。它的请求和响应都是流的形式，它基本的协议单位是帧。每个帧都有不同的类型和用途。HTTP&#x2F;2所有性能增强的核心也在于这个新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg\" alt=\"http2-framing-layer\"></p>\n<p>从图中能看到，在TLS之上，HTTP&#x2F;2之下新增了一个二进制分帧层。这里所谓的“层”，指的是位于套接字接口与应用可见的高级HTTP API之间一个经过优化的新编码机制：HTTP的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的<strong>编码方式</strong>变了。不同于HTTP1.x里面用换行符作为分隔，HTTP&#x2F;2中将信息分割成帧，并进行二进制编码。整个分帧过程由客户端和服务端替我们完成。</p>\n<h3 id=\"数据流和帧\"><a href=\"#数据流和帧\" class=\"headerlink\" title=\"数据流和帧\"></a>数据流和帧</h3><p>上面这种二进制分帧机制改变了客户端与服务器之间交换数据的方式，也带来了流的概念。</p>\n<ul>\n<li>流（Stream）：一个双向字节帧流穿过HTTP&#x2F;2连接中的虚拟通道，可以承载一条或多条消息。</li>\n<li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li>\n</ul>\n<p>流的生存周期包含idle、reserved(local)、reserved(remote)、open、half closed(local)、half closed(remote)、closed多个阶段。状态间通过特定的帧类型流转。在不同状态下对应着不同的能力，对于<a href=\"https://tools.ietf.org/html/rfc7540#section-5.1\">状态规范</a>描述以外的操作请求都会给出协议错误（PROTOCOL_ERROR）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                         +--------+</span><br><span class=\"line\">                 send PP |        | recv PP</span><br><span class=\"line\">                ,--------|  idle  |--------.</span><br><span class=\"line\">               /         |        |         \\</span><br><span class=\"line\">              v          +--------+          v</span><br><span class=\"line\">       +----------+          |           +----------+</span><br><span class=\"line\">       |          |          | send H /  |          |</span><br><span class=\"line\">,------| reserved |          | recv H    | reserved |------.</span><br><span class=\"line\">|      | (local)  |          |           | (remote) |      |</span><br><span class=\"line\">|      +----------+          v           +----------+      |</span><br><span class=\"line\">|          |             +--------+             |          |</span><br><span class=\"line\">|          |     recv ES |        | send ES     |          |</span><br><span class=\"line\">|   send H |     ,-------|  open  |-------.     | recv H   |</span><br><span class=\"line\">|          |    /        |        |        \\    |          |</span><br><span class=\"line\">|          v   v         +--------+         v   v          |</span><br><span class=\"line\">|      +----------+          |           +----------+      |</span><br><span class=\"line\">|      |   half   |          |           |   half   |      |</span><br><span class=\"line\">|      |  closed  |          | send R /  |  closed  |      |</span><br><span class=\"line\">|      | (remote) |          | recv R    | (local)  |      |</span><br><span class=\"line\">|      +----------+          |           +----------+      |</span><br><span class=\"line\">|           |                |                 |           |</span><br><span class=\"line\">|           | send ES /      |       recv ES / |           |</span><br><span class=\"line\">|           | send R /       v        send R / |           |</span><br><span class=\"line\">|           | recv R     +--------+   recv R   |           |</span><br><span class=\"line\">| send R /  `-----------&gt;|        |&lt;-----------&#x27;  send R / |</span><br><span class=\"line\">| recv R                 | closed |               recv R   |</span><br><span class=\"line\">`-----------------------&gt;|        |&lt;----------------------&#x27;</span><br><span class=\"line\">                         +--------+</span><br><span class=\"line\"></span><br><span class=\"line\">   send:   endpoint sends this frame</span><br><span class=\"line\">   recv:   endpoint receives this frame</span><br><span class=\"line\"></span><br><span class=\"line\">   H:  HEADERS frame (with implied CONTINUATIONs)</span><br><span class=\"line\">   PP: PUSH_PROMISE frame (with implied CONTINUATIONs)</span><br><span class=\"line\">   ES: END_STREAM flag</span><br><span class=\"line\">   R:  RST_STREAM frame</span><br></pre></td></tr></table></figure>\n\n<p>流和帧的关系是：</p>\n<ul>\n<li>所有通信都在一个TCP连接上完成，这个连接可以承载任意数量的流</li>\n<li>每个流上面都有唯一标识符和<em>可选</em>的优先级信息，里面会承载要传递的消息</li>\n<li>每条消息都是一条逻辑HTTP信息（如请求或相应），有完整的HTTP语义，其中可能有一个或多个帧</li>\n<li>帧是最小的通信单位，承载着特定类型的数据，例如HTTP 标头、消息负载等等。帧可以<strong>交错发送</strong>，然后再根据帧头的数据流标识符进行组装</li>\n</ul>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg\" alt=\"http2-frame\"></p>\n<p>所有的帧以8字节的报头开始并且跟着0到16383字节长度的主体。帧格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0                   1                   2                   3</span><br><span class=\"line\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">| R |     Length (14)           |   Type (8)    |   Flags (8)   |</span><br><span class=\"line\">+-+-+-----------+---------------+-------------------------------+</span><br><span class=\"line\">|R|                 Stream Identifier (31)                      |</span><br><span class=\"line\">+=+=============================================================+</span><br><span class=\"line\">|                   Frame Payload (0...)                      ...</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>R：保留字段</li>\n<li>Length：14位无符号整数的帧主体长度</li>\n<li>Type：帧类型，它描述了剩余的帧报头和帧主体将如何被解释</li>\n<li>Flags：为帧类型保留的8位布尔类型字段，根据不同帧类型赋予不同语义</li>\n<li>Stream Identifier：31字节的流标识符(见StreamIdentifiers)。0是保留的，标明帧是与连接相关作为一个整体而不是一个单独的流。</li>\n</ul>\n<h3 id=\"请求与响应复用\"><a href=\"#请求与响应复用\" class=\"headerlink\" title=\"请求与响应复用\"></a>请求与响应复用</h3><p>在HTTP1.1中，客户端要想发起多个并行请求以提升性能，则必须使用多个TCP连接，这种对TCP效率低下的利用，在HTTP&#x2F;2中得到改善。二进制分帧层将HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg\" alt=\"http2-reusing\"></p>\n<p>在上图中，流1和流3交错在同一个TCP连接上并行运行。这种机制带来了下面一些具体的提升：</p>\n<ul>\n<li>请求之间交错且互不影响</li>\n<li>响应之间交错且互不影响</li>\n<li>可以使用一个连接并行发送多个请求和响应</li>\n<li>不必再为了优化HTTP1.1性能做雪碧图、分片等骚操作</li>\n<li>一定程度上解决了线头阻塞问题</li>\n</ul>\n<h3 id=\"流控制\"><a href=\"#流控制\" class=\"headerlink\" title=\"流控制\"></a>流控制</h3><p>HTTP&#x2F;2的流控制类似TCP，但是更为精细和更靠近应用层。借助HTTP&#x2F;2流控制，可以实现在用户暂停一个大型视频流后，减少或阻塞视频里带来的HTTP流量，又或者中间代理匹配上下游流量速率。HTTP&#x2F;2流控制提出了一些规则，但<strong>并没有指出特定算法</strong>，目标在于允许不需要协议改动的情况下改进流量控制算法。</p>\n<ul>\n<li>流量控制是逐跳的，而不是头尾端点的</li>\n<li>流量控制是基于窗口更新帧的。接收端广播自己准备在流及整个连接过程中接收的字节大小。这是一个信用为基础的方案。</li>\n<li>流量控制是有方向性的，由接收端全权掌握。</li>\n<li>流量控制窗口初始值是65,535字节，不过接收方可以设置一个更大的值</li>\n<li>帧类型决定了是否适用流量控制规则。目前只有DATA帧受流量控制</li>\n<li>不能被禁用</li>\n<li>通过使用<code>WINDOW_UPDATE</code>帧类型来实现</li>\n</ul>\n<h3 id=\"流优先级\"><a href=\"#流优先级\" class=\"headerlink\" title=\"流优先级\"></a>流优先级</h3><p>HTTP&#x2F;2标准允许每个数据流都有一个关联的权重和依赖关系：</p>\n<ul>\n<li>可以向每个数据流分配一个介于1至256之间的整数。</li>\n<li>每个数据流与其他数据流之间可以存在显式依赖关系。</li>\n</ul>\n<p>优先级的目的是让客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应。反过来，服务器可以使用此信息通过控制CPU、内存和其他资源的分配设定数据流处理的优先级。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/stream_prioritization01.svg\" alt=\"http2-priority\"></p>\n<p>数据流依赖关系通过将另一个数据流的唯一标识符作为父项引用进行声明；如果忽略标识符，相应数据流将依赖于“根数据流”。分配时，会尽可能先向父数据流分配资源，然后再向其依赖项分配资源。共享相同父项的数据流按其权重比例分配资源。在上图中，数据流B获得的资源是数据流A所获资源的三分之一。</p>\n<p>新建流的终端可以在报头帧中包含优先级信息来对流标记优先级。对于已存在的流，优先级帧可以用来改变流优先级。</p>\n<p>更详细规范参考<a href=\"https://tools.ietf.org/html/rfc7540#section-5.3\">RFC</a>。</p>\n<h3 id=\"帧类型\"><a href=\"#帧类型\" class=\"headerlink\" title=\"帧类型\"></a>帧类型</h3><h4 id=\"DATA\"><a href=\"#DATA\" class=\"headerlink\" title=\"DATA\"></a>DATA</h4><p>数据帧，类型0x0，传递和流关联的任意变量值长度的字节数据。例如，一个或多个数据帧被用来携带HTTP请求或者响应的载体。数据帧定义了以下标记：</p>\n<ul>\n<li>END_STREAM (0x1) ：用来表示当前帧是确定的流发送的最后一帧。设置这个标记时流进入到一种半封闭状态或者关闭状态。</li>\n<li>END_SEGMENT (0x2) ：表示是当前端的最后一帧。代理端绝对不能跨越多个端的边界来合并帧，转发帧的时候代理端必须保持片段的边界。</li>\n<li>PADDED (0x8) ： 位4用来表示Pad Length字段是可见的。</li>\n</ul>\n<p>数据帧绝对需要与流相关联，且遵从流量控制。</p>\n<h4 id=\"HEADERS\"><a href=\"#HEADERS\" class=\"headerlink\" title=\"HEADERS\"></a>HEADERS</h4><p>报头帧，类型0x1，用来打开一个流，并携带头部片段。能在流打开或者半封闭(远程)的状态下发送。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+---------------+</span><br><span class=\"line\">|Pad Length? (8)|</span><br><span class=\"line\">+-+-------------+-----------------------------------------------+</span><br><span class=\"line\">|E|                 Stream Dependency? (31)                     |</span><br><span class=\"line\">+-+-------------+-----------------------------------------------+</span><br><span class=\"line\">|  Weight? (8)  |</span><br><span class=\"line\">+-+-------------+-----------------------------------------------+</span><br><span class=\"line\">|                   Header Block Fragment (*)                 ...</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br><span class=\"line\">|                           Padding (*)                       ...</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>它有以下标记：</p>\n<ul>\n<li>END_STREAM (0x1) ：用来标识这是发送端对确定的流发送的最后报头区块。设置这个标记将使流进入一种半封闭状态。后面伴随带有END_STREAM标记的延续帧的报头帧表示流的终止。延续帧不用来终止流。</li>\n<li>END_SEGMENT (0x2) ：表示这是当前端的最后一帧。中介端绝对不能跨片段来合并帧，且在转发帧的时候必须保持片段的边界。</li>\n<li>END_HEADERS (0x4) ：表示帧包含了整个的报头块，且后面没有延续帧。不带有END_HEADERS标记的报头帧在同个流上后面必须跟着延续帧。</li>\n<li>PADDED (0x8) ：表示Pad Length字段会呈现。</li>\n<li>PRIORITY (0x8) ：设置指示专用标记(E)，流依赖及权重字段将会呈现</li>\n</ul>\n<h4 id=\"PRIORITY\"><a href=\"#PRIORITY\" class=\"headerlink\" title=\"PRIORITY\"></a>PRIORITY</h4><p>优先级帧，类型0x2。明确了发送者建议的流的优先级，它可以在任意时间的流中发送。优先级帧不包含任何标记（flag）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0                   1                   2                   3</span><br><span class=\"line\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|E|                  Stream Dependency (31)                     |</span><br><span class=\"line\">+-+-------------+-----------------------------------------------+</span><br><span class=\"line\">|   Weight (8)  |</span><br><span class=\"line\">+-+-------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RST-STREAM\"><a href=\"#RST-STREAM\" class=\"headerlink\" title=\"RST_STREAM\"></a>RST_STREAM</h4><p>类型0x3，允许流的立即终止。通常用来取消一个流，或表示有错误发生。绝不应该在idle状态下发出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                        Error Code (32)                        |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SETTINGS\"><a href=\"#SETTINGS\" class=\"headerlink\" title=\"SETTINGS\"></a>SETTINGS</h4><p>设置帧，类型0x4。包含影响如何与终端通信的设置参数，并且用来确认这些参数的接收。设置帧<em>必须</em>由两个终端在连接开始的时候发送，并且<em>可以</em>由各个终端在连接生存期的任意时间发送。</p>\n<h4 id=\"PUSH-PROMISE\"><a href=\"#PUSH-PROMISE\" class=\"headerlink\" title=\"PUSH_PROMISE\"></a>PUSH_PROMISE</h4><p>推送承诺帧，类型0x5。用来在流发送者准备发送流之前告知对等端。包含了终端准备创建的长流的31位无符号标记以及提供附加上下文的报头的集合。通常在服务器中使用。推送承诺的接收端可以选择给推送承诺的发送端返回一个与被承诺的流标识符相关的RST_STREAM标记来拒绝接收承诺流。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">| [Pad High(8)] | [Pad Low (8)] |X|  Promised Stream ID (31)  ...</span><br><span class=\"line\">+---------------+---------------+-+-----------------------------+</span><br><span class=\"line\">...    Promised Stream ID       | Header Block Fragment (*)   ...</span><br><span class=\"line\">+-------------------------------+-------------------------------+</span><br><span class=\"line\">|                   Header Block Fragment (*)                 ...</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br><span class=\"line\">|                           Padding (*)                       ...</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PING\"><a href=\"#PING\" class=\"headerlink\" title=\"PING\"></a>PING</h4><p>类型0x6。从发送端测量最小的RTT时间的机制，同样也是一种检测连接是否可用的方法。PING帧可以被任何终端发送，且必须在载体中包含一个8字节长度的任意数据。</p>\n<h4 id=\"GOAWAY\"><a href=\"#GOAWAY\" class=\"headerlink\" title=\"GOAWAY\"></a>GOAWAY</h4><p>超时帧，类型0x7。通知远端对等端不要在这个连接上建立新流。超时帧可以由客户端或者服务端发送。发送后，可以针对新的流创建一个新的连接。这个帧的目的是允许终端优雅的停止接收新的流，但仍可以继续完成之前已经建立的流的处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|X|                  Last-Stream-ID (31)                        |</span><br><span class=\"line\">+-+-------------------------------------------------------------+</span><br><span class=\"line\">|                      Error Code (32)                          |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br><span class=\"line\">|                  Additional Debug Data (*)                    |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>32位的错误码中包含了关闭连接的原因。</p>\n<h4 id=\"WINDOW-UPDATE\"><a href=\"#WINDOW-UPDATE\" class=\"headerlink\" title=\"WINDOW_UPDATE\"></a>WINDOW_UPDATE</h4><p>窗口更新帧，类型0x8。用来实现流控制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|X|              Window Size Increment (31)                     |</span><br><span class=\"line\">+-+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CONTINUATION\"><a href=\"#CONTINUATION\" class=\"headerlink\" title=\"CONTINUATION\"></a>CONTINUATION</h4><p>延续帧，类型0x9，用来延续一个报头区块。在END_HEADERS标记前，可以在HEADERS帧、PUSH_PROMISE帧以及CONTINUATION帧后接续任意数量的CONTINUATION帧。它包含一个flag：</p>\n<ul>\n<li>END_HEADERS (0x4) : 设置指示这个帧的报头区块的终止</li>\n</ul>\n<p>延续帧必须与流相关联。如果延续帧的相关流表示字段是0x0，终端必须响应一个类型为协议错误的连接错误。</p>\n<h3 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h3><p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/push01.svg\" alt=\"http2-server-push\"></p>\n<p>HTTP&#x2F;2中的服务器推送打破了原来HTTP中的请求-响应语义（对原有语义也做了<a href=\"https://tools.ietf.org/html/rfc7540#section-8.1\">改进</a>），支持服务器可以对一个客户端请求发送多个响应。在原先的HTTP1.1中我们可能会将重要资源内联到网页中，减少网络延迟，这实际上等同于HTTP&#x2F;2中的强制推送。在HTTP&#x2F;2中的服务器推送还有下面一些功能：</p>\n<ul>\n<li>推送的资源能被客户端缓存（服务器也只能推送可被缓存的资源）</li>\n<li>在不同页面之间可以重用</li>\n<li>可以由服务器设定优先级</li>\n<li>可以被客户端拒绝</li>\n</ul>\n<p>服务器推送数据流由PUSH_PROMISE帧发起，需要先于请求推送资源的响应数据传输。实现上的策略是先于父响应（即，DATA 帧）发送所有PUSH_PROMISE帧，其中包含所承诺资源的HTTP头部。客户端接收到PUSH_PROMISE帧后，它可以根据自身情况选择接受拒绝（通过RST_STREAM帧）数据流。（例如，如果资源已经位于缓存中）</p>\n<p>客户端完全掌控服务器推送的使用方式。客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。这些在HTTP&#x2F;2连接开始时通过SETTINGS帧传输，可能随时更新。</p>\n<h3 id=\"头部压缩\"><a href=\"#头部压缩\" class=\"headerlink\" title=\"头部压缩\"></a>头部压缩</h3><p>在HTTP1.1中，头部数据使用以纯文本的形式传输，所占空间较大，在使用HTTP Cookie后，更是会达到上千字节。为了减少此开销和提升性能，HTTP&#x2F;2使用专门设计的<a href=\"https://httpwg.github.io/specs/rfc7541.html\">HPACK</a>压缩格式压缩请求和响应头部，这种格式通过静态霍夫曼编码对传输的头部字段进行编码。HPACK要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表，利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的头部键值对。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/http2/images/header_compression01.svg\" alt=\"hpack\"></p>\n<p>作为一种进一步优化方式，HPACK压缩上下文包含一个<a href=\"https://httpwg.org/specs/rfc7541.html#static.table.definition\">静态表</a>和一个动态表：静态表在规范中定义，并提供了一个所有连接都可能使用的常用HTTP头部字段列表；动态表最初为空，将根据在特定连接内交换的值进行更新。</p>\n<p>早期版本的HTTP&#x2F;2和SPDY使用的<a href=\"https://tools.ietf.org/html/rfc1951\">DEFLATE</a>对头部进行压缩，但是在2012年夏天出现了<a href=\"https://en.wikipedia.org/w/index.php?title=CRIME&oldid=660948120\">CRIME</a>这种安全攻击。因此，之后HTTP&#x2F;2的头部压缩采用了专门设计的HPACK方案。在使用HPACK后，初次访问后的压缩率能达到70%~80%，甚至90%+。</p>\n<h2 id=\"支持度与调试\"><a href=\"#支持度与调试\" class=\"headerlink\" title=\"支持度与调试\"></a>支持度与调试</h2><p>支持度上，<a href=\"https://caniuse.com/#search=http%2F2\">主流浏览器</a>和<a href=\"https://github.com/http2/http2-spec/wiki/Implementations\">服务器程序</a>都已支持。你也可以访问<a href=\"https://http2.akamai.com/demo\">这个网址</a>体验HTTP&#x2F;2和HTTP1.1在load大量图片时的延迟对比。</p>\n<p>如果你想确认当前网页中的哪些请求是使用的HTTP&#x2F;2，可以在chrome devTools下的network选项卡里查看“Protocol”列（未发现此列的可以在表头右键找到并勾选显示），其中HTTP&#x2F;2将显示为h2。正如之前所说，支持HTTP&#x2F;2的浏览器会和服务器使用特定协议协商，对于不支持HTTP&#x2F;2的情况，会自动会退到HTTP1.1版本。</p>\n<p>尽管HTTP&#x2F;2使用二进制传输数据，然而浏览器为我们掩盖了实现细节。如果想要深入查看甚至是调试二进制分帧层的功能，如何去debug呢？</p>\n<ul>\n<li>Wireshark</li>\n<li>curl</li>\n<li><a href=\"https://github.com/bradfitz/http2/tree/master/h2i\">h2i</a>，不过这个好像已经不维护了</li>\n</ul>\n<h2 id=\"TLS调优\"><a href=\"#TLS调优\" class=\"headerlink\" title=\"TLS调优\"></a>TLS调优</h2><p>目前各大浏览器只在<code>https://</code>的基础上支持HTTP&#x2F;2，即在TLS层之上的HTTP&#x2F;2。多出的TLS的层也是会增加时延和成本的，具体涉及到的TLS握手、会话和加密套件协商过程还有优化空间，如减少证书层级、减少证书大小等。其余优化方向可以查看参考中一些文章介绍。</p>\n<h2 id=\"之前的优化还应该继续用么\"><a href=\"#之前的优化还应该继续用么\" class=\"headerlink\" title=\"之前的优化还应该继续用么\"></a>之前的优化还应该继续用么</h2><h3 id=\"继续保持的\"><a href=\"#继续保持的\" class=\"headerlink\" title=\"继续保持的\"></a>继续保持的</h3><ul>\n<li>减少DNS查询<ul>\n<li>减少域名</li>\n<li>启用预读：dns-prefetch</li>\n</ul>\n</li>\n<li>使用CDN</li>\n<li>避免重定向</li>\n<li>资源压缩<ul>\n<li>代码压缩（JS、HTML、CSS）</li>\n<li>资源压缩（图片、字体、音频、视频）</li>\n<li>文本压缩（Gzip）</li>\n</ul>\n</li>\n<li>使用缓存</li>\n</ul>\n<h3 id=\"不再需要的\"><a href=\"#不再需要的\" class=\"headerlink\" title=\"不再需要的\"></a>不再需要的</h3><ul>\n<li>分片与域名散列：HTTP&#x2F;2对于一个域名只使用一个TCP连接，分片反而会浪费资源，同时也会影响流控制、头部压缩的表现。</li>\n<li>资源打包合并：HTTP&#x2F;2支持多路复用，资源合并会降低缓存利用率，且会让开发流程更复杂。（<a href=\"https://github.com/pikapkg/snowpack\">snowpack</a>了解一下）</li>\n<li>资源内联：可以由服务器推送解决这类需求，资源内联一方面无法缓存，另一方面会让页面代码更大</li>\n</ul>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ul>\n<li>Q: 既然HTTP&#x2F;2是在SPDY工作基础上设计的，那HTTP&#x2F;2推出后，SPDY还使用吗</li>\n<li>A: Google公开声明了他们会在2016年移除Chrome里对SPDY和NPN的支持，并且极力推动服务器迁移至HTTP&#x2F;2。2016年2月他们<a href=\"https://blog.chromium.org/2016/02/transitioning-from-spdy-to-http2.html\">声明</a>了SPDY和NPN会在Chrome 51之后被移除。</li>\n<li>Q: 这个协议是否只对大型网站有效</li>\n<li>A: 由于缺乏内容分发网络，小网站的网络延迟往往较高，而多路复用的能力可以极大的改善在高网络延迟下的体验。</li>\n<li>Q: 基于TLS让速度变得更慢</li>\n<li>A: 正如上一节提到的，TLS的握手确实增加了额外的开销，也有越来越多的方案提出来减少TLS往返的时间。TLS同时也会更多消耗CPU等资源，更多例子可见<a href=\"https://istlsfastyet.com/\">istlsfastyet.com</a>。不过一方面HTTP&#x2F;2并不强制要求基于TLS，另一方面HTTP&#x2F;2带来的性能提升使得即使基于TLS，通常也会比HTTP1.1更快</li>\n<li>Q: 为什么不使用文本传输</li>\n<li>A: 的确，如果可以直接读出协议内容，那么调试和追踪都会变得更为简单。但是二进制带来的灵活度更高，何况浏览器会自动帮你解析。</li>\n<li>Q: 看起来，HTTP1.1中的一些短板并没有改彻底</li>\n<li>A: 实际上，设计HTTP&#x2F;2之初的目标就包括向前兼容HTTP&#x2F;1.1的范式，来保证升级协议也不用重写底层的很多东西。老的HTTP功能，如协议头、状态码、可怕的Cookie，这些都保留了。性能优化更多通过增加了一个中间分帧层解决的。</li>\n<li>Q: 目前使用的广泛程度如何</li>\n<li>A: 在2015年年底大多数浏览器就已经支持HTTP&#x2F;2，目前约96%的浏览器支持HTTP&#x2F;2，同时约46%的网站支持HTTP&#x2F;2。</li>\n</ul>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><ul>\n<li>官网在给出HTTP&#x2F;2规范时，也曾预计要10年时间和HTTP1.1并存，在这个期间，Web优化的思路也可能会有调整</li>\n<li><a href=\"https://wiki.openssl.org/index.php/TLS1.3\">TLS1.3</a>。2020年2月的<a href=\"https://tools.ietf.org/html/rfc8740\">RFC8740</a>中给出了基于TLS1.3的HTTP&#x2F;2的实现建议。</li>\n<li>既然TCP容易遇到线头阻塞问题，那么能不用使用UDP呢？Google提出的<a href=\"https://www.chromium.org/quic\">QUIC</a>（Quick UDP Internet Connection）它在很大程度上继承了SPDY的衣钵。QUIC可以理解成TCP + TLS + HTTP&#x2F;2替代实现。</li>\n<li>2018年10月，互联网工程任务组HTTP及QUIC工作小组正式将基于QUIC协议的HTTP（英语：HTTP over QUIC）重命名为<a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-http/\">HTTP&#x2F;3</a>以为确立下一代规范做准备。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://imququ.com/post/http2-new-opportunities-and-challenges.html\">HTTP&#x2F;2：新的机遇与挑战</a></li>\n<li><a href=\"https://imququ.com/post/http2-resource.html\">HTTP&#x2F;2 资料汇总</a></li>\n<li><a href=\"https://http2.github.io/\">HTTP&#x2F;2官网</a></li>\n<li><a href=\"https://httpwg.org/specs/rfc7540.html\">HTTP&#x2F;2规范</a></li>\n<li><a href=\"https://httpwg.github.io/specs/rfc7541.html\">HPACK规范</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/http2\">HTTP&#x2F;2简介</a></li>\n<li><a href=\"https://ye11ow.gitbooks.io/http2-explained/content/\">HTTP&#x2F;2讲解</a></li>\n<li><a href=\"https://imququ.com/post/header-compression-in-http2.html\">HTTP&#x2F;2 头部压缩技术介绍</a></li>\n<li><a href=\"https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88(06-29).md\">HTTP&#x2F;2草案13中英对照</a></li>\n<li><a href=\"https://www.mnot.net/talks/h2fe/#8\">HTTP&#x2F;2 for Front-End Developers</a></li>\n<li><a href=\"http://velocityconf.com/devops-web-performance-2015/public/schedule/detail/42385\">HTTP&#x2F;2 is here, let’s optimize!</a></li>\n<li><a href=\"https://caniuse.com/#search=HTTP%2F2\">HTTP&#x2F;2支持度</a></li>\n<li><a href=\"https://github.com/http2/http2-spec/wiki/Implementations\">HTTP&#x2F;2实现列表</a></li>\n<li><a href=\"https://www.chainnews.com/articles/401950499827.htm\">HTTP发展史梳理笔记</a></li>\n<li><a href=\"https://http2.akamai.com/demo\">HTTP&#x2F;2 is the future of the Web | Akamai</a></li>\n</ul>\n",
            "tags": [
                "HTTP",
                "HTTP/2",
                "SPDY",
                "QUIC"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2018/09/13/http-intro-note/",
            "url": "http://shenlvmeng.github.com/blog/2018/09/13/http-intro-note/",
            "title": "《图解HTTP》整理",
            "date_published": "2018-09-13T15:35:11.000Z",
            "content_html": "<blockquote>\n<p>读完了《图解HTTP》，就算是对计算机网络和HTTP部分内容做了个温习吧。同步做了整理，以便加强记忆和后面回顾。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>请求报文构成：</p>\n<ul>\n<li>方法</li>\n<li>URI（绝对或是相对）</li>\n<li>HTTP版本</li>\n<li>请求首部</li>\n<li>内容实体</li>\n</ul>\n<p>响应报文构成：</p>\n<ul>\n<li>HTTP版本号</li>\n<li>状态码</li>\n<li>状态码原语</li>\n<li>响应头部</li>\n<li>响应主体</li>\n</ul>\n<p>请求URI是服务器本身时，可以用<code>*</code>代替URI。</p>\n<p>可用的方法列表：</p>\n<ul>\n<li>GET 获取资源</li>\n<li>POST 传输信息</li>\n<li>PUT 传输文件，<strong>没有用户验证机制</strong>，很少用到</li>\n<li>DELETE 删除文件，同上，很少用到</li>\n<li>HEAD 获得响应头部，不返回主体</li>\n<li>OPTIONS 询问支持方法</li>\n<li>CONNECT 用来建立HTTPS连接的隧道</li>\n<li>TRACE 追踪路径上的所有服务器节点，很少用到</li>\n</ul>\n<p>其中后面三个是HTTP1.1才开始支持的。</p>\n<p><strong>持久化</strong></p>\n<p>在HTTP1.1后，HTTP建立的TCP连接默认是长连接（<code>keep-alive</code>），避免不必要的多次TCP握手和挥手。在此基础上，客户端可以同时向服务端发起多个资源请求。</p>\n<p><strong>状态化</strong></p>\n<p>HTTP本身是无状态的。通过cookie实现状态化，cookie通过服务端在响应头部的<code>set-cookie</code>字段下发，设置信息、使用范围、过期时间等内容。客户端在使用范围内的请求默认会携带上cookie信息。</p>\n<h2 id=\"HTTP报文结构\"><a href=\"#HTTP报文结构\" class=\"headerlink\" title=\"HTTP报文结构\"></a>HTTP报文结构</h2><ul>\n<li>请求首部和主体通过CR+LF分割开来</li>\n<li>报文编码<ul>\n<li>编码压缩<ul>\n<li>gzip （GNU zip）</li>\n<li>compress（UNIX compress）</li>\n<li>deflate（zlib）</li>\n<li>indentity（不压缩）</li>\n</ul>\n</li>\n<li>分块发送</li>\n<li>多部分发送（multipart）<ul>\n<li>multipart&#x2F;form-data 表单文件上传，用boundary字符<code>--</code>表示新的part的开始</li>\n<li>multipart&#x2F;byterange 配合206响应只包含了部分数据时使用</li>\n</ul>\n</li>\n<li>部分发送<ul>\n<li>Range指定字节范围</li>\n<li>206响应状态码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内容协商<ul>\n<li>双方就合适的语言、字符集、编码方式、过期时间进行协商</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><ul>\n<li>1xx 这一类型的状态码，代表请求已被接受，需要继续处理<ul>\n<li>100 Continue：客户端应当继续发送请求。</li>\n<li>101 Switching Protocals：将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。</li>\n</ul>\n</li>\n<li>2xx 成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<ul>\n<li>200 OK：请求已成功，在方法时HEAD时不返回响应主体</li>\n<li>204 No Content：服务器成功处理了请求，但不需要返回任何实体内容，<strong>用户浏览器应保留发送了该请求的页面</strong></li>\n<li>205 Reset Content：和204的唯一不同是返回此状态码的响应要求请求者重置文档视图</li>\n<li>206 Partial Content：服务器已经成功处理了部分GET请求。请求必须包含Range头信息来指示客户端希望得到的内容范围，返回使用<code>Content-Range</code>多用于下载工具</li>\n</ul>\n</li>\n<li>3xx 重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址在本次响应的Location域中指明。<ul>\n<li>300 Multiple Choices：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</li>\n<li>301 Moved Permanently：被请求的资源已永久移动到新位置，建议使用Location中的新地址</li>\n<li>302 Found：请求的资源现在临时从不同的URI响应请求</li>\n<li>303 See Other：和302的区别是，客户端<strong>应当采用GET的方式</strong>访问新的资源</li>\n<li>304 Not Modified：如果客户端发送了一个带条件（包括缓存相关的请求头部）的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变</li>\n<li>305 Use Proxy：被请求的资源必须通过指定的代理才能被访问</li>\n</ul>\n</li>\n<li>4xx 客户端错误：客户端发生了错误<ul>\n<li>400 Bad Request：由于包含语法错误，当前请求无法被服务器理解</li>\n<li>401 Unauthorized：当前请求需要用户验证，或用户未通过验证。</li>\n<li>403 Forbidden：服务器已经理解请求，但是拒绝执行它</li>\n<li>404 Not Found：资源未被在服务器上发现</li>\n<li>405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源，响应中必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表</li>\n<li>406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件</li>\n<li>413 Request Entity Too Large</li>\n<li>414 Request-URI Too Long</li>\n</ul>\n</li>\n<li>5xx 服务器错误：服务器在处理请求的过程中有错误发生<ul>\n<li>500 Internal Server Error：这个问题会在服务器的代码出错时出现</li>\n<li>501 Not Implemented：服务器不支持当前请求所需要的某个功能</li>\n<li>502 Bad GateWay：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</li>\n<li>503 Service Unavailable：临时的服务器维护或者过载。这个状况是临时的，并且将在一段时间以后恢复。</li>\n<li>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"协作机制\"><a href=\"#协作机制\" class=\"headerlink\" title=\"协作机制\"></a>协作机制</h2><ul>\n<li>代理（Proxy），单纯转发HTTP请求，会在响应头部的<code>Via</code>字段留下痕迹</li>\n<li>网关（Gateway），隔绝服务器和客户端，有安全、计费等逻辑</li>\n<li>隧道（tunnel），基于协议搭建，保证传输安全，对用户侧透明</li>\n<li>缓存（Cache），本地、服务端二级缓存，加快响应时间，有过期时间</li>\n</ul>\n<h2 id=\"报文头部\"><a href=\"#报文头部\" class=\"headerlink\" title=\"报文头部\"></a>报文头部</h2><ul>\n<li>首部用来进行连接的各种信息描述。每个首部的字段用字段名和值组成，两者用<code>:</code>隔开。</li>\n<li>首部分为端到端和逐跳两类，前者在报文转发的整个过程都保留，后者在转发后就会丢弃。典型的逐条首部有<code>Connection</code>, <code>Keep-Alive</code>, <code>Transfer-Encoding</code>, <code>Upgrade</code>等</li>\n</ul>\n<h3 id=\"通用首部\"><a href=\"#通用首部\" class=\"headerlink\" title=\"通用首部\"></a>通用首部</h3><h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>客户端和服务端协商缓存机制。配合下面一些首部字段使用：</p>\n<ul>\n<li><code>Etag</code></li>\n<li><code>Last-Modified</code></li>\n<li><code>Expires</code>（HTTP1.0）</li>\n<li><code>Pragma</code>（HTTP1.0）</li>\n<li><code>Age</code>（HTTP1.0）</li>\n<li><code>If-None-Match</code></li>\n<li><code>If-Not-Modified-Since</code></li>\n</ul>\n<p><code>Cache-Control</code>有下面一些可配置项。</p>\n<p>缓冲能力上，</p>\n<ul>\n<li>private，缓存只针对当前用户而言</li>\n<li>public，缓存对所有用户生效</li>\n<li>no-cache，始终对缓存进行过期验证</li>\n<li>no-store，不允许缓存</li>\n</ul>\n<p>过期时间上，</p>\n<ul>\n<li>min-fresh，返回指定时间范围内的非过期资源</li>\n<li>max-stale，返回指定时间范围内过期、非过期资源</li>\n<li>max-age，单位：秒，最大缓存时间</li>\n<li>s-max-age，同上，只用于CDN缓存</li>\n</ul>\n<p>二次验证上，</p>\n<ul>\n<li>only-if-cached，强制从缓存服务器中获取内容</li>\n<li>immutable，一旦缓存不可更改</li>\n<li>must-revalidate，即使本地已缓存，仍要求检查CDN缓存</li>\n<li>proxy-revalidate，缓存服务器必须检查源内容是否改变</li>\n</ul>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><p>管理连接，主要有两个用途。</p>\n<ul>\n<li>指定不希望转发给代理的字段</li>\n<li>管理持久连接。使用<code>Connection: Keep-Alive</code>建立连接（HTTP1.1默认行为），使用<code>Connection: Close</code>终止连接</li>\n</ul>\n<h4 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h4><p>报文创建时间。行如“Date: Tue, 03 Jul 2012 04:31:12 GMT”</p>\n<h4 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h4><p>历史遗留字段。<code>Pragma: no-cache</code>等同于<code>Cache-Control: no-cache</code>。</p>\n<p>除此外还有：</p>\n<ul>\n<li>Trailer，说明报文主体中记录的首部字段</li>\n<li>Transfer-Encoding，分段传输的主体编码</li>\n<li>Upgrade，切换协议，<strong>配合<code>Connection: Upgrade</code>使用</strong></li>\n<li>Via，标明沿途的整条路径</li>\n<li>Warning，缓存相关警告</li>\n</ul>\n<h3 id=\"请求首部\"><a href=\"#请求首部\" class=\"headerlink\" title=\"请求首部\"></a>请求首部</h3><ul>\n<li>Accept 接受文件的类型，类型间可以指定<code>q=x</code>表示权重值，x的取值在0到1之间。下同</li>\n<li>Accept-Charset 可以接受的文件字符集</li>\n<li>Accept-Encoding 可以接受的文件编码，有gzip，compress，deflate，indentity几种</li>\n<li>Accept-Language 可接受的语言</li>\n<li>Authorization 服务端需要的用户验证信息</li>\n<li>Age 从缓存实体产生到现在经历的时间</li>\n<li>Expect 期望的服务端返回状态码，服务端无法满足时返回417状态码，客户端等待服务端100响应时发送的请求都要带上该字段</li>\n<li>Host 服务器的主机名，通常是请求资源的URL</li>\n<li>If-Match 需要匹配的Etag，不满足时返回412，表示不满足条件</li>\n<li>If-Modified-Since 返回指定日期后的新内容，否则返回304</li>\n<li>If-Unmodified-Since 类似上</li>\n<li>If-Range 类似If-Match不过是范围匹配</li>\n<li>Max-Forwards 报文最多转发次数，通常配合TRACE方法使用</li>\n<li>Proxy-Authorization 代理服务端需要的用户验证信息</li>\n<li>Range 请求资源的部分内容，一般用在多线程下载（客户端发起）</li>\n<li>Referer 当前请求从哪个地址发起</li>\n<li>User-Agent 请求发起终端信息</li>\n</ul>\n<h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><ul>\n<li>Accept-Ranges，表示服务器是否支持Range请求，支持时值为bytes，否则是none</li>\n<li>Age，表示缓存到目前为止过了多久（HTTP1.0）</li>\n<li>Etag，资源的唯一标识，分为强Etag和弱Etag</li>\n<li>Location，用在3xx的请求中，表示客户端需要重定向到的新地址</li>\n<li>WWW-Authentication&#x2F;Proxy-Authentication，服务器、代理使用的认证类型</li>\n<li>Server，服务器信息</li>\n<li>Vary，与Vary指定首部字段同名的请求才会命中缓存</li>\n</ul>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><ul>\n<li>Allow 允许的访问方法</li>\n<li>Content-Encoding&#x2F;Content-Language&#x2F;Content-Length&#x2F; 内容的编码、语言、长度、类型</li>\n<li>Content-Location 内容的位置，通常在和访问URI时会用到</li>\n<li>Content-MD5 内容MD5编码，便于和客户端编码后进行对比，防止内容篡改</li>\n<li>Content-Range 用于部分请求</li>\n<li>Content-Type 文件类型，包括MIME type和字符集</li>\n<li>Expires&#x2F;Last-Modified 文件的过期时间和上次修改时间，用户判断缓存是否过期</li>\n</ul>\n<p>除此之外，还有和Cookie相关的两个头部，它们来自网景公司对于Cookie的设计。</p>\n<ul>\n<li>Set-Cookie，服务端下发设置Cookie信息。包含下列信息<ul>\n<li>expires，过期时间</li>\n<li>path，适用路径</li>\n<li>domain，适用域名</li>\n<li>secure，限制https才会携带Cookie</li>\n<li>HttpOnly，限制JS脚本访问Cookie</li>\n<li>下发的cookie内容</li>\n</ul>\n</li>\n<li>Cookie，客户端期望的cookie内容</li>\n</ul>\n<p>另外还有一些常用的首部字段：</p>\n<ul>\n<li>X-Frame-Options，规定页面在iframe中的呈现方式<ul>\n<li>DENY 禁止访问</li>\n<li>SAMEORIGIN 仅允许同源访问</li>\n</ul>\n</li>\n<li>X-XSS-Protection，为1时开启XSS防御</li>\n</ul>\n<p><strong>不建议使用”X-“开头的方式拓展非标准首部</strong>。 </p>\n<h2 id=\"HTTPS简介\"><a href=\"#HTTPS简介\" class=\"headerlink\" title=\"HTTPS简介\"></a>HTTPS简介</h2><p>HTTP缺点：</p>\n<ul>\n<li>使用明文 -&gt; 通信内容可以被窃听 –HTTPS–&gt; 加密通信内容</li>\n<li>不能验证身份 -&gt; DDoS攻击和伪装服务器、客户端身份 –HTTPS–&gt; 证书证明身份</li>\n<li>不能验证内容完整性 -&gt; 中间人攻击 –HTTPS–&gt; HTTPS保证完整性</li>\n</ul>\n<p>HTTPS特征：</p>\n<ul>\n<li>加密内容</li>\n<li>证书</li>\n<li>完整性保护</li>\n</ul>\n<p>HTTPS建立在SSL连接之上，SSL建立在TCP连接上。SSL使用共享秘钥和公开秘钥加密两种方式混合加密。在秘钥确保安全的情况下，使用共享秘钥对称加密，优化速度；否则使用公开秘钥确保安全性。</p>\n<ul>\n<li>共享秘钥，双方使用同一秘钥加密和解密，秘钥被监听后加密就失去了意义</li>\n<li>公开秘钥，使用公开秘钥加密，使用私有秘钥解密</li>\n</ul>\n<p>然而公开密钥本身并不能确保完整性，需要证书机构（CA）颁发证书认证，确保秘钥和端的有效以及合法性。服务端也可以使用OpenSSL为自己颁发自认证证书，但是一般会在浏览器上弹出警告。</p>\n<p>HTTPS建立连接的过程包括：</p>\n<ol>\n<li>协商决定秘钥组件</li>\n<li>服务端发送公开密钥、证书</li>\n<li>客户端检查证书合法性，以确认服务端身份，并拿到公钥</li>\n<li>客户端发送pre-master secret随机字符串</li>\n<li>服务端使用私钥加密pre-master secret hash值，返回加密的hash值（避免黑客尝试破解私钥）</li>\n<li>客户端使用公钥解密hash，对比自己之前生成的pre-master secret字符串hash，若一致，及证明服务端身份的合法性</li>\n<li>客户端生成一个对称加密算法和秘钥master-secret，使用公钥加密，发送给服务端</li>\n<li>双方使用master-secret进行通信</li>\n</ol>\n<p>通信的完整性可以通过将报文内容生成hash交由客户端验证来实现。</p>\n<p>SSL最初由网景开发，1.0和2.0版本被发现存在问题已被废弃。3.0后由IETF接手。目前可用的协议版本有SSL3.0和TLS1.0、TLS1.1、TLS1.2，其中最常用的是SSL3.0和TLS1.0。</p>\n<p><strong>证书</strong></p>\n<p>证书包含：</p>\n<ul>\n<li>发布机构（CA）</li>\n<li>有效期</li>\n<li>持有者（由CA担保证明持有者身份）</li>\n<li>公钥</li>\n<li>数字签名算法</li>\n<li>指纹算法</li>\n</ul>\n<p>为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会用自己的私钥加密后再和证书放到一起发布。使用者在打开证书时，根据加密算法，系统使用自带的公钥解密指纹和指纹算法，使用指纹算法计算证书的hash值和指纹对比，如果对的上就代表证书没问题。系统使用的公钥和证书一般由证书发布机构自己生成，内嵌在操作系统中。</p>\n<p>证书颁发机构（CA）通常会去做很多工作确保持有者的合法性，信任CA代表着信任CA颁发证书中的所有信息。所以一般系统只选择信誉较好的CA机构。公司内部使用或自生成的证书就只能被在指定范围内被信任。</p>\n<h2 id=\"身份验证\"><a href=\"#身份验证\" class=\"headerlink\" title=\"身份验证\"></a>身份验证</h2><ul>\n<li>BASIC 使用用户名密码验证，明文传输</li>\n<li>DIGEST 质询响应，防止密码被拦截，安全度和便利性都较差</li>\n<li>SSL 客户端证书 + HTTPS传输，成本高</li>\n<li>HTTP表单 + Cookie&#x2F;Session验证</li>\n</ul>\n<h2 id=\"功能追加协议\"><a href=\"#功能追加协议\" class=\"headerlink\" title=\"功能追加协议\"></a>功能追加协议</h2><p><strong>WebSocket</strong></p>\n<p>全双工，解决Ajax，长短轮询的局限。握手过程很简单：</p>\n<ul>\n<li>请求方添加<code>Upgrade</code>首部字段，声明升级到websocket。包含Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Verison等必要字段</li>\n<li>响应方回复101状态码，包含Sec-WebSocket-Accept（是根据Sec-WebSocket-Key生成的），Sec-WebSocket-Protocol</li>\n</ul>\n<p>连接建立后，双方使用WebSocket的方式进行通信</p>\n<p><strong>WebDAV</strong></p>\n<p>基于Web的文件属性管理。新增了一些方法和状态码，允许客户端远程修改服务器上的文件。</p>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><p><strong>RSS</strong></p>\n<p>RDF Site Summary，简易内容聚合。和Atom一样，使用XML的形式发布信息，通过特定的RSS阅读器阅读。</p>\n<h2 id=\"常见Web攻击方式\"><a href=\"#常见Web攻击方式\" class=\"headerlink\" title=\"常见Web攻击方式\"></a>常见Web攻击方式</h2><p>根本原因：HTTP本身没有必要的安全机制。</p>\n<h3 id=\"输出值转义相关攻击方式\"><a href=\"#输出值转义相关攻击方式\" class=\"headerlink\" title=\"输出值转义相关攻击方式\"></a>输出值转义相关攻击方式</h3><ul>\n<li>XSS，跨站脚本攻击，主要出现在<strong>动态拼接HTML</strong>的场景中，用户恶意注入的script代码段埋下陷阱，诱导用户误操作触发。盗取用户密码或Cookie信息</li>\n<li>SQL注入，通过URL注入的方式，制造恶意SQL语句，出现在<strong>动态拼接SQL语句</strong>的场景下。可以绕过认证、甚至破坏整个数据库</li>\n<li>OS命令注入，类似SQL注入，出现在<strong>动态拼接OS语句</strong>的场景下。</li>\n<li>HTTP首部攻击，出现在服务端响应头部使用了用户侧输入场景下，比如302响应中的Location头部可能存在的query部分。攻击者可以通过添加换行符，恶意添加新的首部字段，甚至篡改原有的响应主体</li>\n<li>邮箱首部注入攻击，类似HTTP首部攻击</li>\n</ul>\n<p>类似地还有目录遍历漏洞、远程文件引用漏洞。</p>\n<p>通过上面几种攻击方式，可以看到，<strong>永远不要信任用户侧输入</strong>，<strong>使用白名单机制，禁止动态拼接用户输入的语句</strong>。</p>\n<h3 id=\"设计缺陷相关攻击方式\"><a href=\"#设计缺陷相关攻击方式\" class=\"headerlink\" title=\"设计缺陷相关攻击方式\"></a>设计缺陷相关攻击方式</h3><ul>\n<li>强制浏览，在服务器公开目录下，浏览开发者本非自愿公开的文件。</li>\n<li>不正确的系统错误处理方式，数据库等内部系统抛出的错误，对用户毫无帮助，反倒能让攻击者看到服务背后的一些细节。包括，数据库错误、PHP等脚本错误、Web服务器的错误</li>\n<li>开放重定向，网站有诸如<code>?redirect=xxx</code>的path可以重定向时，一定要对redirect后的网址进行白名单控制，防止成为钓鱼攻击的跳板</li>\n</ul>\n<h3 id=\"session相关\"><a href=\"#session相关\" class=\"headerlink\" title=\"session相关\"></a>session相关</h3><ul>\n<li>XSS盗取cookie，伪装用户登录</li>\n<li>发送恶意链接，强制用户使用攻击者指定的session ID</li>\n<li>CSRF，跨站信息伪造，在带有用户信息的domain里留下恶意的网络请求，伪造用户发起请求，伪造请求可以通过<code>&lt;img src=&quot;xx&quot; /&gt;</code>, <code>&lt;video src=&quot;xxx&gt;&lt;/video&gt;</code>等多种形式</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>穷举法破解密码，暴力破解。使用图片验证码、手机验证码、机器检测等方式限制同IP的访问频率。<ul>\n<li>彩虹表。使用salt，增加破解难度</li>\n</ul>\n</li>\n<li>撞库。建议用户在不同域内使用不一样的密码</li>\n<li>点击劫持，使用透明元素覆盖在目标网页上。在18+网页中最常出现（😂）。</li>\n<li>DoS（Denial of Service）拒绝服务攻击，构造大量合法的网络请求，导致服务器超负荷。通常都是DDoS（Distributed Denial of Service）的形式。需要在IP层去过滤攻击的IP。</li>\n<li>后门程序</li>\n</ul>\n",
            "tags": [
                "笔记",
                "HTTP",
                "HTTPS",
                "状态码",
                "网络攻击",
                "介绍"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"logid\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2019/08/25/async-hooks-and-cls/",
            "url": "http://shenlvmeng.github.com/blog/2019/08/25/async-hooks-and-cls/",
            "title": "NodeJS async_hooks API与CLS（Continuation-local-storage）",
            "date_published": "2019-08-25T14:55:52.000Z",
            "content_html": "<h2 id=\"async-hooks\"><a href=\"#async-hooks\" class=\"headerlink\" title=\"async_hooks\"></a>async_hooks</h2><p><a href=\"https://nodejs.org/api/async_hooks.html#async_hooks_async_hooks\">async_hooks</a>是nodejs在8.2.1后引入的特性，目前仍然是Experimental状态。它被用来追踪NodeJS中异步资源的生命周期。</p>\n<p>在async_hooks特性加入之前，想要了解异步调用上下文或追踪异步调用逻辑是件比较困难的事情:</p>\n<ul>\n<li>最早在v0.11中有实现<a href=\"https://github.com/nodejs/node-v0.x-archive/pull/6011\">AsyncListener</a>，但在v0.12时<a href=\"https://github.com/nodejs/node-v0.x-archive/pull/8110\">被移除</a></li>\n<li>在Node6和7时，有非官方的<a href=\"http://blog.trevnorris.com/2015/02/asyncwrap-tutorial-introduction.html\">AsyncWrap</a>实现，指定回调函数监听异步资源的创建、调用前、调用后时机</li>\n</ul>\n<p>async_hooks友好地解决了异步资源创建、调用的追踪问题：</p>\n<ul>\n<li>异步资源代表一个关联了回调的对象，回调可能被调用1次或多次，比如<code>net.createServer()</code>里的<code>connect</code>事件或<code>fs.open()</code>。<code>AsyncHook</code>不区分这些场景，统一视作异步资源</li>\n<li>每一个异步上下文都有一个关联的id，即asyncId。asyncId是从1开始递增的，同一个async上下文中的id相同（在未enable async hook时，promise执行不会被分配asyncId）。<code>executionAsyncId()</code>可以获取当前异步上下文的asyncId，<code>triggerAsyncId()</code>获取触发当前异步上下文的异步上下文。借助asynId和triggerAsyncId可以追踪异步的调用关系和链路。</li>\n<li><code>async_hooks.createHook()</code>函数可以注册异步资源生命周期中init&#x2F;before&#x2F;after&#x2F;destroy&#x2F;promiseResolve事件的监听函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> async_hooks = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;async_hooks&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// ID of the current execution context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eid = async_hooks.<span class=\"title function_\">executionAsyncId</span>()</span><br><span class=\"line\"><span class=\"comment\">// ID of the handle responsible for triggering the callback of the</span></span><br><span class=\"line\"><span class=\"comment\">// current execution scope to call</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tid = async_hooks.<span class=\"title function_\">triggerAsyncId</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncHook = async_hooks.<span class=\"title function_\">createHook</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// called during object construction</span></span><br><span class=\"line\">    <span class=\"attr\">init</span>: <span class=\"keyword\">function</span> (<span class=\"params\">asyncId, type, triggerAsyncId, resource</span>) &#123; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// called just before the resource&#x27;s callback is called</span></span><br><span class=\"line\">    <span class=\"attr\">before</span>: <span class=\"keyword\">function</span> (<span class=\"params\">asyncId</span>) &#123; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// called just after the resource&#x27;s callback has finished</span></span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"keyword\">function</span> (<span class=\"params\">asyncId</span>) &#123; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// called when an AsyncWrap instance is destroyed</span></span><br><span class=\"line\">    <span class=\"attr\">destroy</span>: <span class=\"keyword\">function</span> (<span class=\"params\">asyncId</span>) &#123; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// called only for promise resources, when the `resolve`</span></span><br><span class=\"line\">    <span class=\"comment\">// function passed to the `Promise` constructor is invoked</span></span><br><span class=\"line\">    <span class=\"attr\">promiseResolve</span>: <span class=\"keyword\">function</span> (<span class=\"params\">asyncId</span>) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// starts listening for async events</span></span><br><span class=\"line\">asyncHook.<span class=\"title function_\">enable</span>()</span><br><span class=\"line\"><span class=\"comment\">// stops listening for new async events</span></span><br><span class=\"line\">asyncHook.<span class=\"title function_\">disable</span>()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"executionAsyncId和triggerAsyncId\"><a href=\"#executionAsyncId和triggerAsyncId\" class=\"headerlink\" title=\"executionAsyncId和triggerAsyncId\"></a>executionAsyncId和triggerAsyncId</h3><p>调用<code>executionAsyncId</code>和<code>triggerAsyncId</code>函数获取当前异步上下文的asyncId和triggerAsyncId。</p>\n<p><code>executionAsyncId</code>的返回值由运行时决定，<code>triggerAsyncId</code>可以返回当前上下文的触发原因上下文id。见下面的示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = net.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the ID of the server, not of the new connection, because the</span></span><br><span class=\"line\">    <span class=\"comment\">// callback runs in the execution scope of the server&#x27;s MakeCallback().</span></span><br><span class=\"line\">    async_hooks.<span class=\"title function_\">executionAsyncId</span>();</span><br><span class=\"line\">    <span class=\"comment\">// The resource that caused (or triggered) this callback to be called</span></span><br><span class=\"line\">    <span class=\"comment\">// was that of the new connection. Thus the return value of triggerAsyncId()</span></span><br><span class=\"line\">    <span class=\"comment\">// is the asyncId of &quot;conn&quot;.</span></span><br><span class=\"line\">    async_hooks.<span class=\"title function_\">triggerAsyncId</span>();</span><br><span class=\"line\">&#125;).<span class=\"title function_\">listen</span>(port, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the ID of a TickObject (i.e. process.nextTick()) because all</span></span><br><span class=\"line\">    <span class=\"comment\">// callbacks passed to .listen() are wrapped in a nextTick().</span></span><br><span class=\"line\">    async_hooks.<span class=\"title function_\">executionAsyncId</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Even though all callbacks passed to .listen() are wrapped in a nextTick()</span></span><br><span class=\"line\">    <span class=\"comment\">// the callback itself exists because the call to the server&#x27;s .listen()</span></span><br><span class=\"line\">    <span class=\"comment\">// was made. So the return value would be the ID of the server.</span></span><br><span class=\"line\">    async_hooks.<span class=\"title function_\">triggerAsyncId</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"createHook\"><a href=\"#createHook\" class=\"headerlink\" title=\"createHook\"></a><code>createHook</code></h3><p>更常用地，我们使用<code>async_hooks.createHook</code>创建异步资源的钩子，注册异步资源生命周期各阶段的回调函数，目前支持init&#x2F;before&#x2F;after&#x2F;destroy&#x2F;promiseResolve这几种。</p>\n<p><strong>注意</strong>：打印信息到控制台也是一个异步操作，<code>console.log()</code>会触发AsyncHooks的各个回调。因此AsyncHook回调内使用<code>console.log()</code>或类似异步日志打印，会造成无限递归。一种解决办法是使用<code>fs.writeFileSync</code>或<code>process._rawDebug</code>这种同步日志操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debug</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use a function like this one when debugging inside an AsyncHooks callback</span></span><br><span class=\"line\">    fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&#x27;log.out&#x27;</span>, <span class=\"string\">`<span class=\"subst\">$&#123;util.format(...args)&#125;</span>\\n`</span>, &#123; <span class=\"attr\">flag</span>: <span class=\"string\">&#x27;a&#x27;</span> &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// OR</span></span><br><span class=\"line\">    process.<span class=\"title function_\">_rawDebug</span>(<span class=\"string\">`<span class=\"subst\">$&#123;util.format(...args)&#125;</span>\\n`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"init-asyncId-type-triggerAsyncId-resource\"><a href=\"#init-asyncId-type-triggerAsyncId-resource\" class=\"headerlink\" title=\"init(asyncId, type, triggerAsyncId, resource)\"></a>init(asyncId, type, triggerAsyncId, resource)</h4><p>在<em>可能</em>会触发异步事件的资源构造时调用。这不代表后面的<code>before/after</code>事件回调会在<code>destroy</code>回调触发，只是说有这个可能。举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).<span class=\"title function_\">createServer</span>().<span class=\"title function_\">listen</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"variable language_\">this</span>.<span class=\"title function_\">close</span>(); &#125;);</span><br><span class=\"line\"><span class=\"comment\">// OR</span></span><br><span class=\"line\"><span class=\"built_in\">clearTimeout</span>(<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;, <span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<p>参数解释如下：</p>\n<ul>\n<li><code>asyncId</code> 异步资源id</li>\n<li><code>type</code> 异步资源类型，字符串枚举值，具体参见<a href=\"https://nodejs.org/api/async_hooks.html#async_hooks_type\">官方文档</a></li>\n<li><code>triggerAsyncId</code> 触发当前异步资源创建的异步上下文的asyncId</li>\n<li><code>resource</code> 被初始化的异步资源对象</li>\n</ul>\n<p><code>triggerAsyncId</code>表示的是资源创建的原因，<code>async_hooks.executionAsyncId()</code>表示的是资源创建的时机。如下面例子里体现的一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async_hooks.<span class=\"title function_\">createHook</span>(&#123;</span><br><span class=\"line\">  <span class=\"title function_\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> eid = async_hooks.<span class=\"title function_\">executionAsyncId</span>();</span><br><span class=\"line\">    fs.<span class=\"title function_\">writeSync</span>(</span><br><span class=\"line\">      <span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>): trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).<span class=\"title function_\">enable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;&#125;).<span class=\"title function_\">listen</span>(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>nc localhost 8080</code>后，打印信息如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCPSERVERWRAP(5): trigger: 1 execution: 1</span><br><span class=\"line\">TCPWRAP(7): trigger: 5 execution: 0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"before-asyncId\"><a href=\"#before-asyncId\" class=\"headerlink\" title=\"before(asyncId)\"></a>before(asyncId)</h4><p>在异步操作初始化完成（如TCP服务器接收新连接）或资源准备完成（写数据到磁盘），准备执行回调时触发。入参<code>asyncId</code>即这个异步资源的ID。<code>before</code>事件可能会触发0~N次。</p>\n<ul>\n<li>0次，异步操作被撤销</li>\n<li>&gt; 1次，持久化的异步资源，如TCP服务器</li>\n</ul>\n<h4 id=\"after-asyncId\"><a href=\"#after-asyncId\" class=\"headerlink\" title=\"after(asyncId)\"></a>after(asyncId)</h4><p>回调执行完成后立即触发。当执行回调过程中有未捕获异常，会在触发“uncaughtException”事件后触发。</p>\n<h4 id=\"destroy-asyncId\"><a href=\"#destroy-asyncId\" class=\"headerlink\" title=\"destroy(asyncId)\"></a>destroy(asyncId)</h4><p>当asyncId对应的异步资源被销毁时调用。有些异步资源的销毁要依赖垃圾回收机制，所以当引用了传递到<code>init</code>函数的resource时，destory事件可能永远不会被触发，从而造成内存泄漏。</p>\n<h4 id=\"promiseResolve-asyncId\"><a href=\"#promiseResolve-asyncId\" class=\"headerlink\" title=\"promiseResolve(asyncId)\"></a>promiseResolve(asyncId)</h4><p>当Promise构造器中的resolve函数被执行时，promiseResolve事件被触发。有些情况下，有些resolve函数是被隐式执行的，比如<code>.then</code>函数会返回一个新的Promise，这个时候也会被调用。</p>\n<p>当<code>new Promise((resolve) =&gt; resolve(true)).then((a) =&gt; &#123;&#125;);</code>语句执行时，会顺序触发下列函数：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init for PROMISE with id 5, trigger id: 1</span><br><span class=\"line\">  promise resolve 5      # corresponds to resolve(true)</span><br><span class=\"line\">init for PROMISE with id 6, trigger id: 5  # the Promise returned by then()</span><br><span class=\"line\">  before 6               # the then() callback is entered</span><br><span class=\"line\">  promise resolve 6      # the then() callback resolves the promise by returning</span><br><span class=\"line\">  after 6</span><br></pre></td></tr></table></figure>\n\n<p>AsyncHook实例定义好后，需要通过<code>enable</code>开启。可以使用<code>disable</code>关闭AsyncHook的回调执行。</p>\n<p>下面是一个AsyncHook的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indent = <span class=\"number\">0</span>;</span><br><span class=\"line\">async_hooks.<span class=\"title function_\">createHook</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> eid = async_hooks.<span class=\"title function_\">executionAsyncId</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.<span class=\"title function_\">repeat</span>(indent);</span><br><span class=\"line\">        fs.<span class=\"title function_\">writeSync</span>(</span><br><span class=\"line\">            <span class=\"number\">1</span>,</span><br><span class=\"line\">            <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span><span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>):`</span> +</span><br><span class=\"line\">            <span class=\"string\">` trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">before</span>(<span class=\"params\">asyncId</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.<span class=\"title function_\">repeat</span>(indent);</span><br><span class=\"line\">        fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&#x27;log.out&#x27;</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>before:  <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>, &#123; <span class=\"attr\">flag</span>: <span class=\"string\">&#x27;a&#x27;</span> &#125;);</span><br><span class=\"line\">        indent += <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">after</span>(<span class=\"params\">asyncId</span>) &#123;</span><br><span class=\"line\">        indent -= <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.<span class=\"title function_\">repeat</span>(indent);</span><br><span class=\"line\">        fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&#x27;log.out&#x27;</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>after:  <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>, &#123; <span class=\"attr\">flag</span>: <span class=\"string\">&#x27;a&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">destroy</span>(<span class=\"params\">asyncId</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.<span class=\"title function_\">repeat</span>(indent);</span><br><span class=\"line\">        fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&#x27;log.out&#x27;</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>destroy:  <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>, &#123; <span class=\"attr\">flag</span>: <span class=\"string\">&#x27;a&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).<span class=\"title function_\">enable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).<span class=\"title function_\">createServer</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;).<span class=\"title function_\">listen</span>(<span class=\"number\">8080</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Let&#x27;s wait 10ms before logging the server started.</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;&gt;&gt;&gt;&#x27;</span>, async_hooks.<span class=\"title function_\">executionAsyncId</span>());</span><br><span class=\"line\">    &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在启动服务器后，打印信息如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCPSERVERWRAP(5): trigger: 1 execution: 1</span><br><span class=\"line\">TickObject(6): trigger: 5 execution: 1</span><br><span class=\"line\">before:  6</span><br><span class=\"line\">  Timeout(7): trigger: 6 execution: 6</span><br><span class=\"line\">after:   6</span><br><span class=\"line\">destroy: 6</span><br><span class=\"line\">before:  7</span><br><span class=\"line\">&gt;&gt;&gt; 7</span><br><span class=\"line\">  TickObject(8): trigger: 7 execution: 7</span><br><span class=\"line\">after:   7</span><br><span class=\"line\">before:  8</span><br><span class=\"line\">after:   8</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>可以直接参考<a href=\"https://nodejs.org/api/async_hooks.html#async_hooks_error_handling\">官方文档描述</a></p>\n<h3 id=\"可以用来干嘛\"><a href=\"#可以用来干嘛\" class=\"headerlink\" title=\"可以用来干嘛\"></a>可以用来干嘛</h3><p>一个最为人知的使用场景是我们下面会提到的CLS（Continuation-local-storage）。cls-hooked库通过async_hooks建立了context对象和当前async执行上下文的关系，从而在整个执行链（execution chain）上维护一个统一的数据存储。</p>\n<p>还有一个是结合<a href=\"https://nodejs.org/api/perf_hooks.html\">Performance Timing API</a>这样的性能监测工具诊断整个异步操作流程的性能。比如<a href=\"https://clinicjs.org/blog/introducing-bubbleprof/\">这篇文章</a>所介绍的。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://nodejs.org/api/async_hooks.html\">Async Hooks | Node.js Documentation</a></li>\n<li><a href=\"https://itnext.io/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9\">A Pragmatic Overview of Async Hooks API in Node.js</a></li>\n</ul>\n<h2 id=\"CLS\"><a href=\"#CLS\" class=\"headerlink\" title=\"CLS\"></a>CLS</h2><p><a href=\"https://github.com/othiym23/node-continuation-local-storage\">Continuation-local storage(CLS)</a>类似线程编程里的线程存储，不过基于nodeJS风格的链式回调函数调用。它得名于函数式编程中的<a href=\"https://en.wikipedia.org/wiki/Continuation-passing_style\">Continuation-passing style</a>，旨在链式函数调用过程中维护一个持久的数据。</p>\n<p>在node V8之前，分别基于AsyncListener和AsyncWrap实现。在V8后，基于async_hook实现的库名为<a href=\"https://github.com/jeff-lewis/cls-hooked#readme\">cls-hooked</a>。但使用方法一致。</p>\n<p>这里借用cls README里的一个例子。假设你写了一个获取用户信息的模块，将获取到的用户信息放在session中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// setup.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createNamespace = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cls-hooked&#x27;</span>).<span class=\"property\">createNamespace</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> session = <span class=\"title function_\">createNamespace</span>(<span class=\"string\">&#x27;my session&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./lib/db.js&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\">options, next</span>) &#123;</span><br><span class=\"line\">  db.<span class=\"title function_\">fetchUserById</span>(options.<span class=\"property\">id</span>, <span class=\"keyword\">function</span> (<span class=\"params\">error, user</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> <span class=\"title function_\">next</span>(error);</span><br><span class=\"line\"></span><br><span class=\"line\">    session.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;user&#x27;</span>, user);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，需要将用户信息转化为一个HTML文档，你在另外一个文件中定义了转换函数，并从session中取出你想要的用户信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// send_response.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getNamespace = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cls-hooked&#x27;</span>).<span class=\"property\">getNamespace</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> session = <span class=\"title function_\">getNamespace</span>(<span class=\"string\">&#x27;my session&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> render = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./lib/render.js&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">finish</span>(<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> user = session.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;user&#x27;</span>);</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(&#123;<span class=\"attr\">user</span>: user&#125;).<span class=\"title function_\">pipe</span>(response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>cls的使用围绕namespace展开，你可以根据需要自由组织namespace，需要持久化的信息读写在namespace的context上进行。</p>\n<ul>\n<li><code>cls.createNamespace</code>、<code>cls.getNamespace</code> 创建和获取一个namespace</li>\n<li><code>cls.destroyNamespace</code>、<code>cls.reset</code> 删除一个namespace和重置所有namespace</li>\n<li><code>ns.get</code>、<code>ns.set</code> 在namespace的context上读取和设置持久化数据</li>\n<li><code>ns.run</code>、<code>ns.runAndReturn</code>、<code>ns.runPromise</code> 在给定context下执行函数</li>\n<li><code>ns.bind</code>、<code>ns.bindEmitter</code> 绑定context到给定函数或eventEmitter</li>\n<li><code>context</code> 维护持久化数据的plain object</li>\n</ul>\n<p>更多API参考<a href=\"https://github.com/jeff-lewis/cls-hooked#clscreatenamespacename\">文档</a>。</p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>正如上面所说，“cls-hooked库通过async_hooks建立了context对象和当前async执行上下文的关系”。下面有张图通过例子描述了cls的工作过程：</p>\n<p><img src=\"https://miro.medium.com/max/924/1*PPk_uEmQFVKO16byHpwnXA.jpeg\" alt=\"CLS workflow\"></p>\n<p>简单拆解一下：</p>\n<ul>\n<li>首先，我们有一个典型的web server和应用上的中间件，我们在整个应用的生命周期里创建一个cls的namespace。</li>\n<li>新请求到达中间件时，cls通过<code>ns.run</code>（别的方式也行）创建一个空的cls context，并入栈该context，设置为active context。</li>\n<li>由于cls内部注册了AsyncHook，在<code>init</code>阶段，在Map中关联对应active context到当前asyncId。从而有异步操作（如查数据库）时，此前入栈的context就和操作的asyncId对应上。此后get<br>、set操作都会针对同一active context进行。</li>\n<li>异步操作完成后，<code>after</code>回调触发，active context变成undefined，同时出栈当前context。当<code>destroy</code>回调触发时，会将关联到asyncId的context从Map中移除。</li>\n</ul>\n<p>在cls-hooked实现中，</p>\n<ul>\n<li><code>ns.get</code>和<code>ns.set</code>和<code>ns.active</code>相关联</li>\n<li><code>ns.active</code>通过<code>ns.enter</code>、<code>ns.exit</code>变更或者在<code>init</code>回调中从contextMap中改变。</li>\n<li><code>ns.enter</code>、<code>ns.exit</code>、<code>init</code>回调最终都经由<code>ns.runxxx</code>或<code>ns.bindxxx</code>得到初始的context</li>\n<li>cls-hooked借助async_hook和<code>ns.enter</code>、<code>ns.exit</code>保证异步流程中context和异步上下文的正确对应关系</li>\n</ul>\n<p>考虑到cls-hooked的js代码可读性，可维护性和工程角度上还有改善空间，基于上面的原理，做了ts的重构，源码见这里(待补充)，供大家参考和学习cls-hooked。</p>\n<h3 id=\"追踪logId\"><a href=\"#追踪logId\" class=\"headerlink\" title=\"追踪logId\"></a>追踪logId</h3><blockquote>\n<p>醉翁之意不在酒</p>\n</blockquote>\n<p>有了cls的帮助，我们就可以利用它帮我们持久化logId，避免“continuation-passing-context”。可以写一个中间件，为req、res包装context，同时为每次请求持久化logId。在后面的controller、services这些位置就可以拿到之前持久化的logId。</p>\n<p>一个express风格的中间件类似下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cls = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cls-hooked&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> uuidv4 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;uuid/v4&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> clsNamespace = cls.<span class=\"title function_\">createNamespace</span>(<span class=\"string\">&#x27;app&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">clsMiddleware</span> = (<span class=\"params\">req, res, next</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// req and res are event emitters. We want to access CLS context inside of their event callbacks</span></span><br><span class=\"line\">  clsNamespace.<span class=\"title function_\">bind</span>(req);</span><br><span class=\"line\">  clsNamespace.<span class=\"title function_\">bind</span>(res);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> logId = <span class=\"title function_\">uuidv4</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  clsNamespace.<span class=\"title function_\">run</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    clsNamespace.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;logId&#x27;</span>, logId);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// controller.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">controller</span> = (<span class=\"params\">req, res, next</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> traceID = clsNamespace.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;logId&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个思路的基础上，有类似<a href=\"https://github.com/puzpuzpuz/cls-rtracer\">cls-rtracer</a>或<a href=\"https://github.com/keenondrums/cls-proxify\">cls-proxify</a>这样的库，提供针对express、koa、fastify等常见后端框架的中间件，只需简单指定配置，便可以在请求的生命周期里透传logId，免去“continuation-passing-context”的尴尬，对已有代码侵入性也很小。有需要透传logId，但并不想（或暂时不能）使用后端框架的场景下可以考虑使用这种方案。</p>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/nodejs/node-v0.x-archive/issues/5243\">context: core module to manage generic contexts for async call chains · Issue #5423</a></li>\n<li><a href=\"https://datahero.com/blog/2014/05/22/node-js-preserving-data-across-async-callbacks/\">Node.js – Preserving Data Across Async Callbacks</a></li>\n<li><a href=\"https://itnext.io/nodejs-logging-made-right-117a19e8b4ce\">NodeJS logging made right</a></li>\n</ul>\n",
            "tags": [
                "async_hooks",
                "cls-hooked",
                "logId"
            ]
        }
    ]
}
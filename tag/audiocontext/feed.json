{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"audiocontext\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2018/11/21/audio-recorder-improvement/",
            "url": "http://shenlvmeng.github.com/blog/2018/11/21/audio-recorder-improvement/",
            "title": "前端录音方案优化实践",
            "date_published": "2018-11-21T15:04:53.000Z",
            "content_html": "<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在视听类业务或重交互的业务场景下，有时需要在前端采集用户语音。前端实现录音功能可以使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder\">MediaRecorder</a>，或<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\">getUserMedia</a>结合<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\">AudioContext</a>。其中，前一种方法的支持度惨不忍睹，使用getUserMedia的方式是较为常用的选择。</p>\n<p class=\"img-tip\" data-str=\"MediaRecorder支持度\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/87e5a7855500447eb22349f29814bdf5~noop.png' height=465 width=1261/></p>\n\n<h2 id=\"现有问题\"><a href=\"#现有问题\" class=\"headerlink\" title=\"现有问题\"></a>现有问题</h2><p>在实现前端录音上，<a href=\"https://github.com/mattdiamond/Recorderjs\">Recorder.js</a>实现了一个基础可用版，不过它支持的可配置项很少，音频采样率、声道数、采样的比特位数都使用的采集配置的默认值。但在大多场景下，录音文件体积较大，4s的录音可以达到700 ~ 800KB，不利于网络传输，需要录音采集参数可配置，以优化文件体积。</p>\n<p class=\"img-tip\" data-str=\"4s录音的文件体积\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/c2f3c40147a4447fad41d3bea41c4256~noop.png' height=94 width=1178/></p>\n\n<p>另外，有些场景录制的语音需要交给算法组做语音识别，对语音有特定要求：</p>\n<ul>\n<li>采样率16000Hz</li>\n<li>单声道</li>\n<li>采样位数16bit</li>\n</ul>\n<p>这时就需要一个优化的前端录音方案，支持根据输入配置修改音频流数据。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>这里将原有录音方案的几个关键代码流程整理如下：</p>\n<p class=\"img-tip\" data-str=\"原有录音方案\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/5379450a44474160b9fa09e7dc7ee31d~noop.png' height=490 width=871/></p>\n\n<p>其中：</p>\n<ul>\n<li>先调用<code>getUserMedia</code>获取音频流，并初始化一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamAudioSourceNode\"><code>MediaStreamAudioSourceNode</code></a>。使用<code>connect</code>连接到<code>ScriptProcessorNode</code>上，并连续触发<code>audioprocess</code>事件。</li>\n<li>在<code>onaudioprocess</code>事件处理函数中，拿到录音数据。根据当前<code>recording</code>的值判断是否写入<code>recBuffers</code>中。<code>recording</code>状态可以通过<code>record</code>和<code>stop</code>方法控制。</li>\n<li><code>exportWAV</code>方法会触发导出流程，导出步骤里<ul>\n<li><code>mergeBuffers</code>将<code>recBuffers</code>数组扁平化</li>\n<li><code>interleave</code>将各声道信息数组扁平化</li>\n<li><code>encodeWAV</code>为即将生成的音频文件写入音频头</li>\n<li>最后<code>floatTo16bitPCM</code>将音频设备采集的元素范围在[0,1]之间的Float32Array，转换成一个元素是16位有符号整数的Float32Array中</li>\n</ul>\n</li>\n<li>最后拿到的Blob类型数据可以本地播放或通过FormData上传服务端使用。<br>下面分几方面介绍录音方案优化的设计和实现。</li>\n</ul>\n<h3 id=\"音频头拓展\"><a href=\"#音频头拓展\" class=\"headerlink\" title=\"音频头拓展\"></a>音频头拓展</h3><p>要支持可拓展的采样率、声道、采样比特数，wav音频头也要动态配置。</p>\n<p>WAVE格式是<a href=\"https://en.wikipedia.org/wiki/Resource_Interchange_File_Format\">Resource Interchange File Format</a>（RIFF）的一种，其基本块名称是“WAVE”，其中包含两个子块“fmt”和“data”。结构上由WAVE_HEADER、WAVE_FMT、WAVE_DATA、采样数据4个部分组成。可以看到实际上就是在PCM数据前面加了一个文件头。WAVE类型文件整体结构图如下：</p>\n<p class=\"img-tip\" data-str=\"WAVE文件头示例\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/e5c3f9bc6d3545308fb50fc10ce64790~noop.png' height=449 width=673/></p>\n\n<p>其中和采样率、声道、采样位数相关的字段有：</p>\n<ul>\n<li>NumChannels</li>\n<li>SampleRate</li>\n<li>ByteRate，等于SampleRate * BlockAlign</li>\n<li>BlockAlign，等于ChannelCount * BitsPerSample &#x2F; 8</li>\n<li>BitsPerSample</li>\n</ul>\n<p>这几个字段根据输入的配置项设置即可实现音频头拓展部分。<br>另外，需要注意的是其中字段有Big Endian和Little Endian的区分，对应在代码里，通过<code>setUint16</code>和<code>setUIint32</code>的最后一个入参决定。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">encodeWAV</span>(<span class=\"params\">samples</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBuffer</span>(<span class=\"number\">44</span> + samples.<span class=\"property\">length</span> * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> view = <span class=\"keyword\">new</span> <span class=\"title class_\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* RIFF identifier */</span></span><br><span class=\"line\">    <span class=\"title function_\">writeString</span>(view, <span class=\"number\">0</span>, <span class=\"string\">&#x27;RIFF&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* RIFF chunk length */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint32</span>(<span class=\"number\">4</span>, <span class=\"number\">36</span> + samples.<span class=\"property\">length</span> * <span class=\"number\">2</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* RIFF type */</span></span><br><span class=\"line\">    <span class=\"title function_\">writeString</span>(view, <span class=\"number\">8</span>, <span class=\"string\">&#x27;WAVE&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* format chunk identifier */</span></span><br><span class=\"line\">    <span class=\"title function_\">writeString</span>(view, <span class=\"number\">12</span>, <span class=\"string\">&#x27;fmt &#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* format chunk length, PCM use 16 */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint32</span>(<span class=\"number\">16</span>, <span class=\"number\">16</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* sample format (raw), PCM use 1 */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint16</span>(<span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* channel count */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint16</span>(<span class=\"number\">22</span>, numChannels, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* sample rate */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint32</span>(<span class=\"number\">24</span>, sampleRate, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* byte rate (sample rate * block align) */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint32</span>(<span class=\"number\">28</span>, sampleRate * numChannels * sampleBit / <span class=\"number\">8</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* block align (channel count * bytes per sample) */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint16</span>(<span class=\"number\">32</span>, numChannels * sampleBit / <span class=\"number\">8</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* bits per sample */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint16</span>(<span class=\"number\">34</span>, sampleBit, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* data chunk identifier */</span></span><br><span class=\"line\">    <span class=\"title function_\">writeString</span>(view, <span class=\"number\">36</span>, <span class=\"string\">&#x27;data&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* data chunk length */</span></span><br><span class=\"line\">    view.<span class=\"title function_\">setUint32</span>(<span class=\"number\">40</span>, samples.<span class=\"property\">length</span> * <span class=\"number\">2</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"采样率\"><a href=\"#采样率\" class=\"headerlink\" title=\"采样率\"></a>采样率</h3><p>通常前端录音的音频采样率是音频设备默认使用的44.1kHz（或48kHz）。开发者需要默认以外的采样率时（比如16kHz），可以在录音数据交给<code>encodeWAV</code>封装前根据新的采样率做重采样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compress</span>(<span class=\"params\">samples, ratio</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = samples.<span class=\"property\">length</span> / ratio;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"title class_\">Float32Array</span>(length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; length; index++) &#123;</span><br><span class=\"line\">        result[index] = samples[index * ratio];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重采样的原理上，程序根据重采样和原始采用率的比值，间隔采样音频原数据，丢弃掉其他采样点数据，从而模拟采样率的等比例下降。</p>\n<p><em>注：间隔丢弃原数据在重采样率是原采样率的整数倍分之一时（即1、1&#x2F;2、1&#x2F;3…）才不会损失用户音色。另外，重采样率比原采样率高时，需要在采样点中间额外插值，这里未实现；</em></p>\n<h3 id=\"声道数\"><a href=\"#声道数\" class=\"headerlink\" title=\"声道数\"></a>声道数</h3><p>在<code>audioprocess</code>事件中，需要根据配置项中的声道数，从inputBuffer取对应声道数据，一般的处理下，会丢弃多余的声道数据。类似地，在存储声道数据时，也要灵活考虑配置项。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"property\">onaudioprocess</span> = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">recording</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> buffer = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> channel = <span class=\"number\">0</span>; channel &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">config</span>.<span class=\"property\">numChannels</span>; channel++) &#123;</span><br><span class=\"line\">        buffer.<span class=\"title function_\">push</span>(e.<span class=\"property\">inputBuffer</span>.<span class=\"title function_\">getChannelData</span>(channel));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">record</span>(<span class=\"params\">inputBuffer</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> channel = <span class=\"number\">0</span>; channel &lt; numChannels; channel++) &#123;</span><br><span class=\"line\">        recBuffers[channel].<span class=\"title function_\">push</span>(inputBuffer[channel]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recLength += inputBuffer[<span class=\"number\">0</span>].<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在最后导出时，根据声道数判断是否需要interleave的步骤。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (numChannels === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    interleaved = <span class=\"title function_\">interleave</span>(buffers[<span class=\"number\">0</span>], buffers[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    [interleaved] = buffers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"采样位数\"><a href=\"#采样位数\" class=\"headerlink\" title=\"采样位数\"></a>采样位数</h3><p>默认的采样位数是16位，在对音质或位数没有明确要求时，可以转成8位。</p>\n<p>PCM16LE格式的采样数据的取值范围是-32768到32767，而PCM8格式的采样数据的取值范围是0到255。因此PCM16LE转换到PCM8需要将-32768到32767的16bit有符号数值转换为0到255的8bit无符号数值。实现上，见下面的对比：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">floatTo16BitPCM</span>(<span class=\"params\">output, offset, input</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initOffset = offset;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.<span class=\"property\">length</span>; i++, initOffset += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(-<span class=\"number\">1</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(<span class=\"number\">1</span>, input[i]));</span><br><span class=\"line\">        output.<span class=\"title function_\">setInt16</span>(initOffset, s &lt; <span class=\"number\">0</span> ? s * <span class=\"number\">0x8000</span> : s * <span class=\"number\">0x7FFF</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">floatTo8bitPCM</span>(<span class=\"params\">output, offset, input</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initOffset = offset;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.<span class=\"property\">length</span>; i++, initOffset++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(-<span class=\"number\">1</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(<span class=\"number\">1</span>, input[i]));</span><br><span class=\"line\">        <span class=\"keyword\">const</span> val = s &lt; <span class=\"number\">0</span> ? s * <span class=\"number\">0x8000</span> : s * <span class=\"number\">0x7FFF</span>;</span><br><span class=\"line\">        output.<span class=\"title function_\">setInt8</span>(initOffset, <span class=\"built_in\">parseInt</span>(val / <span class=\"number\">256</span> + <span class=\"number\">128</span>, <span class=\"number\">10</span>), <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上方的<code>floatTo16BitPCM</code>是转换音频采样数据到PCM数据的原始方法，下面的<code>floatTo8BitPCM</code>方法中<code>parseInt(val / 256 + 128, 10)</code>做了16位到8位的转换。最后在封装音频数据为Blob类型时，根据采样位数使用不同函数即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">encodeWAV</span>(<span class=\"params\">samples</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sampleBit === <span class=\"number\">8</span></span><br><span class=\"line\">        ? <span class=\"title function_\">floatTo8bitPCM</span>(view, <span class=\"number\">44</span>, samples)</span><br><span class=\"line\">        : <span class=\"title function_\">floatTo16BitPCM</span>(view, <span class=\"number\">44</span>, samples);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>最后，由于前端录音场景下，音频流基本都来自<code>getUserMedia</code>，为了减少模板代码，库里封装了一个static方法，快捷地直接由<code>getUserMedia</code>构造一个recorder对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">createFromUserMedia</span>(<span class=\"params\">config</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> stream = <span class=\"keyword\">await</span> navigator.<span class=\"property\">mediaDevices</span>.<span class=\"title function_\">getUserMedia</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">audio</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">mandatory</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">googEchoCancellation</span>: <span class=\"string\">&#x27;false&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">googAutoGainControl</span>: <span class=\"string\">&#x27;false&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">googNoiseSuppression</span>: <span class=\"string\">&#x27;false&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">googHighpassFilter</span>: <span class=\"string\">&#x27;false&#x27;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">optional</span>: []</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">video</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = <span class=\"keyword\">new</span> <span class=\"title class_\">AudioContext</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Recorder</span>(context.<span class=\"title function_\">createMediaStreamSource</span>(stream, config));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>在之前提到了需要算法组音频识别的场景下，只需要在构造时指定配置项即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Recorder</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./audio-recorder&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">recorder</span> = <span class=\"title class_\">Recorder</span>.<span class=\"title function_\">createFromUserMedia</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">sampleBit</span>: <span class=\"number\">16</span>, <span class=\"comment\">// 可省略</span></span><br><span class=\"line\">    <span class=\"attr\">numChannels</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">sampleRate</span>: <span class=\"number\">16000</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>此时，一个500ms的录音大概15KB，换算下来4s大约120KB，比此前的体积小了很多。在不强调音质的场景下，表现要好许多。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>上面的录音方案优化实践主要包含下面几点：</p>\n<ul>\n<li>WAVE音频头修改</li>\n<li>重采样音频数据</li>\n<li>丢弃多余的声道数据</li>\n<li>转换16位音频数据到8位</li>\n</ul>\n<p>源码在<a href=\"https://github.com/shenlvmeng/audio-recorder\">这里</a>，欢迎使用与拍砖。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mattdiamond/Recorderjs\">mattdiamond&#x2F;Recorderjs A plugin for recording&#x2F;exporting the output of Web Audio API nodes</a></li>\n<li><a href=\"https://blog.csdn.net/leixiaohua1020/article/details/50534316\">视音频数据处理入门：PCM音频采样数据处理</a></li>\n<li><a href=\"http://soundfile.sapp.org/doc/WaveFormat/\">Microsoft WAVE soundfile format</a></li>\n</ul>\n",
            "tags": [
                "录音",
                "getUserMedia",
                "AudioContext",
                "PCM",
                "WAVE"
            ]
        }
    ]
}
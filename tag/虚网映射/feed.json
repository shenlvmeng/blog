{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"虚网映射\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2016/02/27/vnm-test-learning/",
            "url": "http://shenlvmeng.github.com/blog/2016/02/27/vnm-test-learning/",
            "title": "vnm test学习",
            "date_published": "2016-02-27T13:51:39.000Z",
            "content_html": "<p>师兄给了一个虚网映射的仿真（cpp），和之前的embed-detail的C语言仿真工具很像，经过一周左右的学习，挖掘出了其中虚网映射部分的内容，在此整理，以作日后学习。鉴于之前embed-detail的学习总结很繁琐，这里的总结只做精要的介绍。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>这一部分在Utility.h中完成，是对映射种种数据容器的整理。</p>\n<h3 id=\"节点：\"><a href=\"#节点：\" class=\"headerlink\" title=\"节点：\"></a>节点：</h3><p>编号，CPU，带宽和，优先度</p>\n<h3 id=\"最短路：\"><a href=\"#最短路：\" class=\"headerlink\" title=\"最短路：\"></a>最短路：</h3><p>跳数，带宽，路径列表，下一跳</p>\n<h3 id=\"映射结果（单节点）：\"><a href=\"#映射结果（单节点）：\" class=\"headerlink\" title=\"映射结果（单节点）：\"></a>映射结果（单节点）：</h3><p>物理节点对象，虚拟节点编号，所属根节点，到根节点跳数，Node_list中序号，Node_list总数</p>\n<h3 id=\"（类）物理拓扑：\"><a href=\"#（类）物理拓扑：\" class=\"headerlink\" title=\"（类）物理拓扑：\"></a>（类）物理拓扑：</h3><p>节点总数，边总数，资源，节点资源，边资源；</p>\n<p>节点群（一维向量），边群（二维向量），最短路群（二维结构向量）；</p>\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>初始化，</li>\n<li>节点排序算法，</li>\n<li>Floyd算法,</li>\n<li>找到节点序号对应的下标，</li>\n<li>计算网络资源</li>\n</ul>\n<h3 id=\"（类）虚拟拓扑（继承物理拓扑）：\"><a href=\"#（类）虚拟拓扑（继承物理拓扑）：\" class=\"headerlink\" title=\"（类）虚拟拓扑（继承物理拓扑）：\"></a>（类）虚拟拓扑（继承物理拓扑）：</h3><p>&#x2F;&#x2F;同物理拓扑</p>\n<p>允许最大跳数，分割率，拓扑类型，起始时间，映射时间，存活时间，消耗，节点消耗，链路消耗，收入，收入支出比，是否匹配成功，是否起请求截止，是否delay过，是否失败</p>\n<p>满足约束条件的节点群（二维向量），结果群（结果向量），最短路群（二维链表向量）</p>\n<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>读入拓扑，</li>\n<li>初始化，</li>\n<li>计算最短路径和，</li>\n<li>查找结点是否已经映射，</li>\n<li>匹配节点（包含匹配边），</li>\n<li>匹配边，</li>\n<li>匹配过程（包含匹配节点），</li>\n<li>分配或释放资源（匹配过程中完成），</li>\n<li>打印结果，</li>\n<li>计算收入支出，</li>\n<li>计算收入，</li>\n<li>释放虚网的所有资源</li>\n</ul>\n<h2 id=\"核心方法分析\"><a href=\"#核心方法分析\" class=\"headerlink\" title=\"核心方法分析\"></a>核心方法分析</h2><p>这一部分在Utility.cpp中完成，是对映射种种方法的实现。</p>\n<h3 id=\"（物理网络）\"><a href=\"#（物理网络）\" class=\"headerlink\" title=\"（物理网络）\"></a>（物理网络）</h3><p>1. 初始化：开辟最短路群空间，计算链路CPU&#x2F;带宽和&#x2F;PR值</p>\n<p>2. 计算资源：节点，链路资源相加。</p>\n<h3 id=\"（虚拟网络）\"><a href=\"#（虚拟网络）\" class=\"headerlink\" title=\"（虚拟网络）\"></a>（虚拟网络）</h3><p>1. 读入文件：读入节点数，链路数，开始时间，存活时间等。</p>\n<p>2. 初始化：填充Node_list</p>\n<p>3. 查找结点是否已被映射：for 循环遍历暴力查找</p>\n<p>4. 匹配节点：读入物理网络和参照物理网络，当前结点所属根节点，已映射节点数。</p>\n<p>（1）打印</p>\n<p>（2）从可行最短跳（虚拟网络中的跳数）到最大允许跳开始循环</p>\n<p>（2.1）从可行节点（Node_list）中查找满足CPU要求的节点</p>\n<p>（2.2）查找匹配边（Match_Edge），若有打印信息并返回</p>\n<p>（3）打印失败信息返回</p>\n<p>5. 匹配链路：读入物理网络预期参照，当前结点编号和下标，已映射节点数。</p>\n<p>（1）循环寻找所有与该节点关联的节点</p>\n<p>（1.1）若有关联，清空并循环更新最短路向量</p>\n<p>（1.2）循环检测带宽是否满足要求</p>\n<p>（2）循环还原减少的带宽资源</p>\n<p>（3）返回成功标记</p>\n<p>6. 匹配：读入物理拓扑，完成一个虚网的匹配</p>\n<p>（1）建立物理拓扑最短路矩阵</p>\n<p>（2）初始化最短路群，root, chosen_num（已选中节点数）</p>\n<p>（3）初始化根节点result类实例，若无备选节点，返回 0</p>\n<p>（4）循环寻找可行的根节点直到遍历完成</p>\n<p>（4.1）以当前父节点为基础开始匹配子节点，循环</p>\n<p>（4.1.1）循环寻找父节点的关联的子节点</p>\n<p>（4.1.1.1）若某节点无匹配物理节点，循环释放资源，返回 0</p>\n<p>（4.1.1.2）若找到，更新result群向量，调用匹配节点，找到对应物理节点序号</p>\n<p>（4.1.1.2.1）若成功返回，继续更新result，最短路矩阵，更新底层资源</p>\n<p>（4.1.1.2.2）若不成功，回退chosen_num，释放资源，更新root，最短路</p>\n<p>（4.1.2）若未回退到根节点，不用调整根节点，继续从下个父节点开始匹配，直到匹配完成</p>\n<p>（4.2）若匹配未完成，释放根节点和其余资源</p>\n<p>（5）若匹配成功计算收入支出返回回退次数，否则释放资源，返回 0；</p>\n<p>7. 资源管理：通过标记值区分占用或是释放，循环更新节点和链路资源</p>\n<p>8. 打印，计算收入支出</p>\n<p>9. 释放虚网资源：循环释放，返回释放资源值</p>\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><p>这一部分在VNM.cpp中完成，是时间窗模型下虚网映射的实现。步骤如下：</p>\n<p>1. 初始化临时变量，</p>\n<p>2. 从文件中读入底层物理网络，虚网请求</p>\n<p>3.  打印初始信息，计算物理资源</p>\n<p>4. 循环到所有请求都被处理完成或是有finish标记</p>\n<p>4.1 循环计算该窗口内待映射请求数</p>\n<p>4.2 循环这些请求</p>\n<p>4.2.1 挑出未延迟且未成功的</p>\n<p>4.2.1.1 初始化虚网，打印信息</p>\n<p>4.2.1.2 开始匹配，计算时间</p>\n<p>4.2.1.3 计算收入，更改标记为映射完成或延迟</p>\n<p>4.2.1.4 计算当前物理资源，写入到文件</p>\n<p>4.2.2 挑出匹配成功且到期的请求</p>\n<p>4.2.2.1 更新它们的R&#x2F;S和完成数目</p>\n<p>4.2.2.2 释放它们的资源</p>\n<p>4.2.3 挑出delay过久的请求，置为失败，更新资源和计数器</p>\n<p>4.3 计算该时间窗内的支出，收入等数据，更新finish和计数器</p>\n<p>4.4 打印该时间窗测试数据到文件</p>\n<p>4.5 更新时间窗时间</p>\n<p>5. 关闭文件，打印当前时间</p>\n",
            "tags": [
                "算法",
                "C",
                "虚网映射"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2015/01/31/embed-c/",
            "url": "http://shenlvmeng.github.com/blog/2015/01/31/embed-c/",
            "title": "虚网映射仿真包 embed.c 代码分析",
            "date_published": "2015-01-31T05:03:23.000Z",
            "content_html": "<p>此次论文仿真中，需要对虚网映射的过程进行改进。在原先只考量CPU和带宽的基础上为链路增加VLAN属性，并在映射过程中分配VLAN、检测VLAN是否用尽。经过三天的阅读，这里把仿真包里embed.c这个主要文件的各函数分析在下面，方便日后修改。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>数据结构存储在embed.h中。</p>\n<ul>\n<li>struct_link 描述物理链路，有from、to、带宽三个属性</li>\n<li>request 虚网请求，有split, node, links, CPU[], bw等多个属性。</li>\n<li>substrate_network 底层物理网络，有nodes, struct_link links等属性</li>\n<li>s2v_node 被映射了虚网的物理节点的状态</li>\n<li>s2v_link 被映射了虚网的物理链路的状态</li>\n<li>path 逻辑链路映射成的多段物理链路</li>\n<li>req2sub 描述虚网映射的实时映射关系</li>\n<li>shortest_path 最短路径，通过Floyd算出（用于链路映射）</li>\n<li>bneck 瓶颈节点</li>\n</ul>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><h3 id=\"节点映射\"><a href=\"#节点映射\" class=\"headerlink\" title=\"节点映射\"></a>节点映射</h3><h4 id=\"find-proper-node\"><a href=\"#find-proper-node\" class=\"headerlink\" title=\"find_proper_node\"></a>find_proper_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找rest_cou最适合（rest_cpu和request CPU最近，且大于它）当前虚节点的节点。</p>\n<h4 id=\"find-MinNeighborResource-node\"><a href=\"#find-MinNeighborResource-node\" class=\"headerlink\" title=\"find_MinNeighborResource_node\"></a>find_MinNeighborResource_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找rest_cpu满足要求，且自资源最不丰富的物理节点</p>\n<p>衡量标准：节点rest_cpu * sum(rest_bw)</p>\n<h4 id=\"find-MaxNeighborResource-node\"><a href=\"#find-MaxNeighborResource-node\" class=\"headerlink\" title=\"find_MaxNeighborResource_node\"></a>find_MaxNeighborResource_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找除了exclude节点外的rest_cpu满足要求的，且自资源最丰富的物理</p>\n<p>节点</p>\n<p>衡量标准：同上</p>\n<h4 id=\"find-available-node\"><a href=\"#find-available-node\" class=\"headerlink\" title=\"find_available_node\"></a>find_available_node</h4><p><strong>目标</strong>：在当前底层物理网络中，从一随机起点出发，寻找第一个rest_cpu满足要求的物理节点</p>\n<h4 id=\"map-node-greedy\"><a href=\"#map-node-greedy\" class=\"headerlink\" title=\"map_node_greedy\"></a>map_node_greedy</h4><p><strong>目标</strong>：在当前物理网络中，为特定index的虚网映射进行节点映射，哟西按占用资源最丰富的节点，成功则更新物理网络的状态（s2v_node, s2v_link），失败则对已映射的节点进行拆除。</p>\n<h4 id=\"map-node-star\"><a href=\"#map-node-star\" class=\"headerlink\" title=\"map_node_star\"></a>map_node_star</h4><p><strong>目标</strong>：在当前物理网络中，为第一个请求节点分配资源最丰富的节点，其余逻辑节点随机分配，成功则更新物理网络的状态（s2v_node, s2v_link），失败则对已映射的节点进行拆除。</p>\n<h3 id=\"链路映射\"><a href=\"#链路映射\" class=\"headerlink\" title=\"链路映射\"></a>链路映射</h3><p>由于链路映射算法大多很复杂，这里将算法流程也一并列在下方。</p>\n<h4 id=\"unsplittable-flow\"><a href=\"#unsplittable-flow\" class=\"headerlink\" title=\"unsplittable_flow\"></a>unsplittable_flow</h4><p><strong>目标</strong>：为不可分割流进行链路映射</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0  初始化变量，位置分配内存空间</span><br><span class=\"line\">1  死循环</span><br><span class=\"line\">1.1  找到请求中状态满足要求（完成了节点映射）且收益最大的请求，直到状态全部更新</span><br><span class=\"line\">1.1.1    存储id,改变其标志位</span><br><span class=\"line\">1.2  判断该请求状态，与是否可分割</span><br><span class=\"line\">1.2.1    找到该请求的所有逻辑链路</span><br><span class=\"line\">1.2.1.1      找到它们的起始、终结物理节点</span><br><span class=\"line\">1.2.1.2      判断它们是否已找到之间的最短路，否则继续寻找</span><br><span class=\"line\">1.2.1.2.1        Floyd矩阵找下一跳</span><br><span class=\"line\">1.2.1.2.2        下一跳若不可达，break</span><br><span class=\"line\">1.2.1.2.3        寻找有没有实体链路对应Floyd的下一跳</span><br><span class=\"line\">1.2.1.2.4        如果没有，或者有但是rest_bw不够，break</span><br><span class=\"line\">1.2.1.2.5        吧路过链路的可用带宽减少，将当前链路存入到路径数组中</span><br><span class=\"line\">1.2.1.3      如果上一步失败，给sub1(底层物理网络)划分内存空间，在sub1里删除上步出现问题的链路</span><br><span class=\"line\">1.2.1.4      在sub1里算出Floyd矩阵，并存储在临时变量里</span><br><span class=\"line\">1.2.1.4.1        一个类似于1.2.1.2的循环</span><br><span class=\"line\">1.2.1.4.1.1          若还不行，break到1.2.1.4.2；若可以减少可用带宽，存入到路径</span><br><span class=\"line\">1.2.1.4.2        返回错误物理链路、虚拟链路、虚网请求id</span><br><span class=\"line\">1.2.1.5      存储当前算出的路径，与逻辑链路一一对应</span><br><span class=\"line\">2  将状态标志位全部清零</span><br><span class=\"line\">3  死循环</span><br><span class=\"line\">3.1    找到请求中状态满足要求（完成了节点映射）且收益最大的请求，直到状态全部更新</span><br><span class=\"line\">3.1.1      存储id, 改变标志位</span><br><span class=\"line\">3.2    判断该请求状态，与是否可分割</span><br><span class=\"line\">3.2.1      更新时间与链路状态值</span><br><span class=\"line\">3.2.2      为请求内的spath赋值(len, bw)</span><br><span class=\"line\">3.2.2.1        为spath内的各段物理链路赋值</span><br><span class=\"line\">3.2.2.2        更新物理网络链路状态</span><br><span class=\"line\">4  释放临时变量空间</span><br><span class=\"line\">5  返回-1(虚网请求成功标志)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"multicommodity-flow\"><a href=\"#multicommodity-flow\" class=\"headerlink\" title=\"multicommodity_flow\"></a>multicommodity_flow</h4><p><strong>目标</strong>：打印基本信息</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  打开测试文件</span><br><span class=\"line\">2  指定范围内检测有误状态符合条件的请求，</span><br><span class=\"line\">3  若没有，则返回-2并关闭文件</span><br><span class=\"line\">4  打印出满足要求的链路总数</span><br><span class=\"line\">5  打印基本信息到文件</span><br><span class=\"line\">6  打印ARC COSTS到文件</span><br><span class=\"line\">7  打印ARC CAPACITIES到文件</span><br><span class=\"line\">8  打印NODE INJECTIONS到文件</span><br><span class=\"line\">9  打印ARC MUTUAL到文件</span><br><span class=\"line\">10 打印NETWORK TOPOLOGY到文件</span><br><span class=\"line\">11 打印LOWER AND UPPER BOUNDS到文件</span><br><span class=\"line\">12 打印SIDE CONSTRAINTS到文件</span><br><span class=\"line\">13 关闭文件对象</span><br><span class=\"line\">14 运行lintest文件</span><br><span class=\"line\">15 返回 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检测\"><a href=\"#检测\" class=\"headerlink\" title=\"检测\"></a>检测</h3><h4 id=\"check-flow\"><a href=\"#check-flow\" class=\"headerlink\" title=\"check_flow\"></a>check_flow</h4><p><strong>目标</strong>：检查映射情况</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  打开test文件，初始化变量</span><br><span class=\"line\">2  查找STATUS字段，停在此处</span><br><span class=\"line\">3  若不可执行，且阶段 0，则关闭文件，返回 -3</span><br><span class=\"line\">4  若不可执行，且阶段 1，则继续</span><br><span class=\"line\">4.1    查找VARIABLE字段</span><br><span class=\"line\">4.2    在每条链路上查找已使用过的情况，为s2v_link赋值</span><br><span class=\"line\">4.3    查找SIDE CONSTRAINTS字段</span><br><span class=\"line\">4.3.1      找到过载最严重的链路</span><br><span class=\"line\">4.3.2      找到该链路占用最多贷款的租户ID，及其占用带宽，并确定请求ID和虚拟链路ID</span><br><span class=\"line\">5  其余情况，查找OPTIMAL字段，若找到，则继续</span><br><span class=\"line\">5.1    查找VARAIABLE字段</span><br><span class=\"line\">5.2    在每条链路上查找已使用过的情况，为s2v_link赋值</span><br><span class=\"line\">5.3    为v2s赋值</span><br><span class=\"line\">6  关闭文件，释放内存</span><br><span class=\"line\">7 打印租户ID或-1（成功标志）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"资源分配\"><a href=\"#资源分配\" class=\"headerlink\" title=\"资源分配\"></a>资源分配</h3><p>同样，算法复杂，将具体流程列在下面</p>\n<h4 id=\"allocate\"><a href=\"#allocate\" class=\"headerlink\" title=\"allocate\"></a>allocate</h4><p><strong>目标</strong>：整合节点、链路映射完成虚网映射的核心部分</p>\n<p><strong>算法流程：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  为变量s2v_node,s2v_link,v2s划分空间，赋初值</span><br><span class=\"line\">2  为节点数组req_count清零</span><br><span class=\"line\">3  将请求按收入大小排序，找出最大收入者，为它进行节点映射，知道请求的节点映射全部完成</span><br><span class=\"line\">4  若全部未完成节点映射，返回-1</span><br><span class=\"line\">5  初始化链路映射相关变量</span><br><span class=\"line\">6  找到瓶颈节点，并进行链路映射（尝试）</span><br><span class=\"line\">7  若映射成功或链路可分割，用新方法找到瓶颈节点</span><br><span class=\"line\">8  循环：</span><br><span class=\"line\">8.1    如果上一步尝试成功，为s2v_node, s2v_link赋值，跳出循环</span><br><span class=\"line\">8.2    否则，计算这一批次的cost之和</span><br><span class=\"line\">8.3    找出剩余资源最少的节点ID，及其剩余资源</span><br><span class=\"line\">8.4    随机从上面移除一个虚拟节点</span><br><span class=\"line\">8.5    找到这个节点以外资源最丰富的节点，成功则映射到这个新节点；否则映射请求失败</span><br><span class=\"line\">8.6    检查有误未完成链路请求的虚网请求，无则跳出循环</span><br><span class=\"line\">8.7    若时间正忙而无法映射，try=门限+1，找到未完成的请求ID</span><br><span class=\"line\">8.8    cost清零，try+1，打印try次数</span><br><span class=\"line\">8.9    若try &gt; 尝试门限，释放资源，更改状态，还原try</span><br><span class=\"line\">8.10   否则，找到瓶颈链路上的任一节点外的资源最丰富的节点</span><br><span class=\"line\">8.10.1     若找到，则映射；否则这个请求失败</span><br><span class=\"line\">8.11   检查链路映射是否完成，为s2v_node, s2v_link, v2s赋值</span><br><span class=\"line\">9  检查当前瓶颈节点，尝试链路映射</span><br><span class=\"line\">10 为s2v_node, s2v_link等赋值，用cost防止重复操作</span><br><span class=\"line\">11 检查新映射是否cost更低，是则更新</span><br><span class=\"line\">12 #允许迁移则继续向下</span><br><span class=\"line\">13 计算原始cost，释放原始映射资源，进行新的映射</span><br><span class=\"line\">14 新的映射成功则计算新cost，否则返回 0</span><br><span class=\"line\">15 新的cost是否更小，是则迁移，否则不做操作</span><br><span class=\"line\">16 还原s2v_node, ltmp</span><br><span class=\"line\">17 用unsplittable映射计算一次cost，若新的cost更小，则迁移；否则不作操作</span><br><span class=\"line\">18 更新s2v_node, s2v_link v2s</span><br><span class=\"line\">19 返回 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"辅助\"><a href=\"#辅助\" class=\"headerlink\" title=\"辅助\"></a>辅助</h3><h4 id=\"calculate-cost\"><a href=\"#calculate-cost\" class=\"headerlink\" title=\"calculate_cost\"></a>calculate_cost</h4><p><strong>目标</strong>：返回指定范围内的虚网请求cost之和。cost算法同上</p>\n<p>筛选标准：完成链路映射</p>\n<h4 id=\"exist-req\"><a href=\"#exist-req\" class=\"headerlink\" title=\"exist_req\"></a>exist_req</h4><p><strong>目标</strong>：查找是否存在完成了节点映射，未完成链路映射的请求。存在，则返回0，否则返回-1。</p>\n<h4 id=\"主函数-main\"><a href=\"#主函数-main\" class=\"headerlink\" title=\"主函数 main\"></a>主函数 main</h4><p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  为v2s, s2v_node, s2v_link, sub, req 赋初值</span><br><span class=\"line\">2  打开底层网络文件</span><br><span class=\"line\">3  为sub赋node(sub.s2v_nod(req_count,rest_cpu,cpu),sub.link(from,to,s2v_l,rest_bw))</span><br><span class=\"line\">4  关闭文件</span><br><span class=\"line\">5  循环打各req的文件</span><br><span class=\"line\">5.1   为req的revenue/nodes,links,split,time,duration,topo)赋值</span><br><span class=\"line\">5.2   循环为req的cpu,link.from,link.to,link.bw赋值</span><br><span class=\"line\">5.3   计算出revenue</span><br><span class=\"line\">6  关闭文件</span><br><span class=\"line\">7  为临时变量s2v_node/ltmp2/v2stmp2/spath分配内存空间</span><br><span class=\"line\">8  计算得到spath值</span><br><span class=\"line\">9  初始化临时变量</span><br><span class=\"line\">10 循环：</span><br><span class=\"line\">10.1   循环检测所有完成链路映射的请求，为done_count+1</span><br><span class=\"line\">10.2   更新done,rev,cost,map状态，若映射完成则释放资源</span><br><span class=\"line\">10.3   计算当前req.rev/cost/count</span><br><span class=\"line\">10.4   写入当前数据到文件</span><br><span class=\"line\">11 为当前所有请求进行映射</span><br><span class=\"line\">12 依次次检测所有请求状态，更新未请求成功的状态与错误计数器</span><br><span class=\"line\">13 打开stat文件</span><br><span class=\"line\">14 为成功的虚网请求释放资源</span><br><span class=\"line\">15 计算当前req,dev/cost/count</span><br><span class=\"line\">16 写入当前数据到stat文件/trace文件</span><br><span class=\"line\">17 关闭文件</span><br><span class=\"line\">18 返回 0</span><br></pre></td></tr></table></figure>",
            "tags": [
                "算法",
                "虚网映射"
            ]
        }
    ]
}
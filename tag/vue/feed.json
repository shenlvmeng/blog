{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"vue\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/11/17/photogallery-improvement-2/",
            "url": "http://shenlvmeng.github.com/blog/2017/11/17/photogallery-improvement-2/",
            "title": "Photogallery技术演进第2步",
            "date_published": "2017-11-17T12:56:12.000Z",
            "content_html": "<h2 id=\"构建工具升级\"><a href=\"#构建工具升级\" class=\"headerlink\" title=\"构建工具升级\"></a>构建工具升级</h2><p>因为要拆分代码，便于管理，需要使用<code>import</code>和<code>export</code>，因此必须要引入webpack这样的打包工具到gulp中，使用<a href=\"https://github.com/shama/webpack-stream\">webpack-stream</a>，具体使用方法和其他的gulp插件类似，在pipe在这样插入就行了<code>.pipe(webpack())</code>，配置方式和webpack一样。（webpack中引入babel-loader的过程就不赘述了）引入webpack后，开发流程和一起类似，<code>gulp</code>启动测试服务器，使用webpack通过<code>entry.js</code>打包代码，CSS和JSON相关流程不变。release时，增加了minify的流程，让js流程后的代码再压缩一遍。</p>\n<p>另外，引入babel后，可以用ES6语法改写<code>gulpfile.js</code>。最后的<code>gulpfile.babel.js</code>像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gulp <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> rename <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-rename&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> uglify <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-uglify&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> cleanCSS <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-clean-css&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jsonminify <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-jsonminify&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> webserver <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-webserver&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> webpack <span class=\"keyword\">from</span> <span class=\"string\">&#x27;webpack-stream&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;src/index.js&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">webpack</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">&quot;babel-loader&quot;</span> &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">rename</span>(<span class=\"string\">&quot;index.js&quot;</span>))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;minify&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;dist/index.js&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">uglify</span>())</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">rename</span>(<span class=\"string\">&quot;index.min.js&quot;</span>))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&quot;dist&quot;</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;css&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>([<span class=\"string\">&#x27;src/index.css&#x27;</span>])</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">cleanCSS</span>(&#123;<span class=\"attr\">compatibility</span>: <span class=\"string\">&#x27;ie8&#x27;</span>&#125;))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;json&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;src/meta*.json&#x27;</span>)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">jsonminify</span>())</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;webserver&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;./&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">webserver</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">livereload</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">directoryListing</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>([<span class=\"string\">&#x27;src/*.js&#x27;</span>, <span class=\"string\">&#x27;src/**/*.js&#x27;</span>, <span class=\"string\">&#x27;src/**/*.vue&#x27;</span>], [<span class=\"string\">&#x27;js&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;src/*.css&#x27;</span>, [<span class=\"string\">&#x27;css&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;src/*.json&#x27;</span>, [<span class=\"string\">&#x27;json&#x27;</span>]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;assets&#x27;</span>, [<span class=\"string\">&#x27;json&#x27;</span>, <span class=\"string\">&#x27;css&#x27;</span>, <span class=\"string\">&#x27;js&#x27;</span>]);</span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;assets&#x27;</span>, <span class=\"string\">&#x27;webserver&#x27;</span>, <span class=\"string\">&#x27;watch&#x27;</span>]);</span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&quot;release&quot;</span>, [<span class=\"string\">&#x27;assets&#x27;</span>, <span class=\"string\">&#x27;minify&#x27;</span>]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用单文件组件\"><a href=\"#使用单文件组件\" class=\"headerlink\" title=\"使用单文件组件\"></a>使用单文件组件</h2><p>引入webpack后，开始高高兴兴地分模块拆分代码，却发现分组件使用Vue时，不是单纯地定义组件配置信息，然后传给入口组件就行。必须要引入全家桶，<code>vue-loader</code>等工具，文件不得不用.vue这样的形式组织（现在开始觉得React组件的组织比Vue舒服了）。本来使用单文件的形式就是想尽量精简，可随着功能逐渐健全，看来重构也是避免不了的啊。在<a href=\"https://github.com/vuejs/vue-loader\">vue-loader</a>的介绍里，居然还要通过<code>vue-cli</code>来大一统，但是我一是想维持项目尽量轻量精简，使用gulp的工具链；二是项目已经写了很久了，全部迁移过去成本有些大。于是，通过<code>vue-cli</code>新建样本项目，对着<code>package.json</code>和<code>webpack.config.js</code>一抄了事。</p>\n<p>加上种种<code>.vue</code>文件的相关配置，<code>gulp.babel.js</code>最后长下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;src/index.js&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">webpack</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">&quot;babel-loader&quot;</span> &#125;,</span><br><span class=\"line\">          &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.vue$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;vue-loader&#x27;</span>&#125;,</span><br><span class=\"line\">          &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg|gif|svg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;file-loader&#x27;</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[name].[ext]?[hash]&#x27;</span> &#125; &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">resolve</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&#x27;vue$&#x27;</span>: <span class=\"string\">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">extensions</span>: [<span class=\"string\">&#x27;*&#x27;</span>, <span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.vue&#x27;</span>, <span class=\"string\">&#x27;.json&#x27;</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">rename</span>(<span class=\"string\">&quot;index.js&quot;</span>))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>下面需要开始拆分代码了。根据React&#x2F;Vue这样框架通常的设计经验，需要下面一些组成：</p>\n<ul>\n<li><code>actions</code>  存储状态管理的动作</li>\n<li><code>components</code>  存储相互解耦的”dumb”组件，最好和业务无关</li>\n<li><code>constants</code>  存储全局常量</li>\n<li><code>containers</code>  存储组织<code>components</code>的业务容器组件</li>\n<li><code>entry</code>  存储入口文件</li>\n<li><code>helper</code>  存储工具函数</li>\n<li><code>reducers</code>  存储状态管理的reducers</li>\n<li><code>settings</code>  存储全局配置，通常用来初始化store</li>\n<li><code>store</code>  存储全局状态</li>\n<li><code>templates</code>  存储引入js的html文件</li>\n</ul>\n<p>我的项目比较简单，一没有状态管理（后面复杂了之后可能会引入😂），二只有三个组件，只要上面的<code>components</code>, <code>constants</code>, <code>containers</code>, <code>helper</code>的就够用了。最后src下的文件目录大概像下面这样</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── App.vue</span><br><span class=\"line\">├── components</span><br><span class=\"line\">│   └── column</span><br><span class=\"line\">│       └── Column.vue</span><br><span class=\"line\">├── constants</span><br><span class=\"line\">│   └── index.js</span><br><span class=\"line\">├── containers</span><br><span class=\"line\">│   ├── info</span><br><span class=\"line\">│   │   └── Info.vue</span><br><span class=\"line\">│   └── wall</span><br><span class=\"line\">│       └── Wall.vue</span><br><span class=\"line\">├── helper</span><br><span class=\"line\">│   └── utils.js</span><br><span class=\"line\">├── index.css</span><br><span class=\"line\">└── index.js</span><br></pre></td></tr></table></figure>\n\n<p>在拆分时遇到了一些数据需要从最外层透传到子组件的情况，如<code>res</code>, <code>tag_list</code>, <code>tag_keys</code>。不过他们是只读的，而且数目很少，所以并不需要状态管理，只用通过props传下去就行了。</p>\n<h2 id=\"新功能\"><a href=\"#新功能\" class=\"headerlink\" title=\"新功能\"></a>新功能</h2><p>重构完之后，终于可以写新功能了。新功能主要是增加两个伪路由，方便页面的分享（这个需求我之前遇到过几次了）。页面是spa类型的，所以前端路由可以采用hash或history H5 API来实现。同时也有许多在这个基础上了前端路由库，提供一站式解决方案。我的需求目前其实不需要完整的路由方案：</p>\n<ul>\n<li>图片详情页可以分享</li>\n<li>搜索结果可以分享</li>\n</ul>\n<p>因此，设计上使用hash的方案，对于图片详情页，用<code>!</code>开头，后接图片序号。对于搜索结果页，则没有开头的<code>!</code>，仅使用<code>/</code>隔开每一个搜索关键字。对hash的读写上，没有什么困难的地方：</p>\n<ul>\n<li><strong>读</strong>：<code>App.vue</code>根据hash注入对应的数据，更改默认视图，对于图片详情页，更改展示组件</li>\n<li><strong>写</strong>：切换组件时，记录当前数据到<code>location.hash</code>，方便直接复制链接分享</li>\n</ul>\n<h2 id=\"后面的计划\"><a href=\"#后面的计划\" class=\"headerlink\" title=\"后面的计划\"></a>后面的计划</h2><p>现在网站还是有点单调了。只能自娱自乐，没有互动。后面应该会考虑在每张图片接入Disqus的问题。</p>\n",
            "tags": [
                "重构",
                "脚手架",
                "技改",
                "Vue",
                "gulp"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/09/08/photogallery-improvement/",
            "url": "http://shenlvmeng.github.com/blog/2017/09/08/photogallery-improvement/",
            "title": "PhotoGallery技术改造",
            "date_published": "2017-09-08T11:31:17.000Z",
            "content_html": "<p><img src=\"/blog/images/photogallery.png\"></p>\n<p>最近离职后除了准备面试，多了许多时间对以往的前端个人项目进行改造。<a href=\"http://shenlvmeng.github.io/gallery/index.html\">PhotoGallery</a>就是其中一个个人很喜欢，但由于技术原因没做到完美的例子。最近准备抽出时间进行完善。</p>\n<p>PhotoGallery是一个使用瀑布流展示电影海报以及花絮（当然都是个人比较心水的）的展示型页面。所有的电影图片也是从大一就开始收集的，一直囤积在人人上。页面的诸多功能是根据个人爱好设计的，如</p>\n<ul>\n<li>根据标签搜索</li>\n<li>相似图片</li>\n<li>基于tag的推荐等</li>\n</ul>\n<p>总体来说，就是一个展示、介绍、推荐电影的地方。内容上还是很不错的。但是，去年寒假码代码时，前端技术还有待提高，很多地方写得并不严谨甚至比较丑陋。功能上也有些影响体验必须解决的痛点。大概有下面这些</p>\n<ul>\n<li><strong>首屏渲染时间糟糕</strong>，这是因为图片过多（个人看的太多），又使用了Vue。同时Vue这种MVVM框架和精细化DOM操作一山不容二虎，因此，结合懒加载，效果依然不理想</li>\n<li><strong>图片的时序排布并不自然</strong>，当时图省事，使用纯CSS方案实现瀑布流，牺牲了图片排序。图片只能从上到下再从左到右排序，和正常的阅读顺序并不一致。同时，最老的图片在最前，也不合理</li>\n<li><strong>新增图片困难</strong>，这是由于github.io的纯静态的限制，当时采用了静态图片+meta存数据的方式来实现，后面看了电影再往里加图步骤繁琐，没有人性化的办法</li>\n<li>样式老气，细节粗糙</li>\n<li><strong>本地调试困难</strong>，只使用了gulp来压缩js，css和json代码（代码少，不需要打包），不是全家桶脚手架，本地调试困难，且不能使用ES6语法</li>\n<li><strong>代码语法和风格上不严谨</strong>，考虑结合在公司的规矩规范</li>\n</ul>\n<p>针对上面大大小小几点，以及实际情况（比如只能使用github.io），考虑像下面这样优化</p>\n<h3 id=\"瀑布流布局实现方式待优化\"><a href=\"#瀑布流布局实现方式待优化\" class=\"headerlink\" title=\"瀑布流布局实现方式待优化\"></a>瀑布流布局实现方式待优化</h3><p>放弃使用column-count的方案。原因有二：</p>\n<ol>\n<li>排布顺序是从上到下，再从左到右，和日常经验相悖。类似地，使用flex的方案也不行</li>\n<li>本身和懒加载的设计兼容性并不好，懒加载的新图片会导致整个页面的布局完全改变。类似地，使用grid的方案也不适合</li>\n</ol>\n<p>因此考虑借鉴<a href=\"http://www.zhangxinxu.com/wordpress/2012/03/%E5%A4%9A%E6%A0%8F%E5%88%97%E8%A1%A8%E5%8E%9F%E7%90%86%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80-waterfall-layout/\">张鑫旭大神的方案</a>，综合CSS和JS实现懒加载的滚动式瀑布流布局。</p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201203/2012-03-23_233114.png\"></p>\n<p>首先，根据屏幕宽度设置合理的列数，再逐列插入5张新图片，作为初始情况，同时，使用<code>flex</code>布局，设置<code>flex-grow</code>和<code>justify-content</code>等属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Wall</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">data</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">columns</span>: <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span> / columnWidth),</span><br><span class=\"line\">      <span class=\"attr\">lastFlag</span>: <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span> / columnWidth) * <span class=\"number\">5</span> - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">items</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">itemsForColumns</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ret = <span class=\"title class_\">Array</span>.<span class=\"title function_\">apply</span>(<span class=\"literal\">null</span>, <span class=\"title class_\">Array</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">columns</span>)).<span class=\"title function_\">map</span>(<span class=\"function\">() =&gt;</span> []);</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">items</span>.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span> + <span class=\"number\">1</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        ret[i % <span class=\"variable language_\">this</span>.<span class=\"property\">columns</span>].<span class=\"title function_\">push</span>(item);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"comment\">// 每列先只加载5个</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#photos</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: row wrap;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: space-around;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wall-column</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">8px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，监听可能会改变布局的所有情况，在我这个场景下，大概有三种：</p>\n<ul>\n<li>滚动（scroll）事件</li>\n<li>缩放事件（resize）事件</li>\n<li>筛选图片，在改变筛选条件，会导致图片数目的变化</li>\n</ul>\n<p>下面分情况解决之。</p>\n<p><strong>resize时</strong></p>\n<p>监听<code>window</code>的<code>resize</code>事件，当最后一列的位置变化时，意味着布局已经改变，需要触发重排。可以看到上面的<code>itemForColumns</code>中依赖<code>columns</code>和<code>lastFlag</code>两个状态。这里我们利用MVVM框架的优势，维护这两个值，就可以让Vue帮我们完成重排这样的繁琐操作。如下，当<code>columns</code>改变时，才会触发重绘。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;resize&quot;</span>, <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">columns</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span> / columnWidth);</span><br><span class=\"line\">  <span class=\"comment\">// 已经展示过的图片就不要隐藏了</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">columns</span> * <span class=\"number\">5</span> - <span class=\"number\">1</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>筛选图片时</strong></p>\n<p>同理，通过关键词筛选图片时，改变了传入Wall的prop <code>factor</code>。会同步更新依赖<code>factor</code>的<code>item</code>，触发重排。有一点有注意的是，**<code>lastFlag</code>需要重新开始累加**。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">items</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置了筛选条件后，lastFlag需要重新开始累加</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span> / columnWidth) * <span class=\"number\">5</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>scroll时</strong></p>\n<p>页面滚动时，需要加入新的图片到column中，我们要做的只是更改<code>lastFlag</code>即可，Vue会帮我们自动完成依赖<code>lastFlag</code>的<code>itemForColumns</code>更新。重点在，我们如何知道lastFlag应该增加到多少。</p>\n<p>我们回看下<code>itemForColumns</code>的逻辑，可以发现<strong>新增的图片是循环摆放的</strong>。这里额外说一句，尽管新图片放在最短列是最合理的，但是工程上并不合算（一是Vue下做这么精细的DOM操作不合适，二是获知最短列意味着DOM操作已经发生，即会有频繁的回流和重绘，这会影响渲染时间）。我们循环考虑每一列的最底部位置，如果在视口内，将图片更新到该列，直到所有列底部都在视口外。直到图片加载完毕。</p>\n<p>另外，在实践时还发现一个问题，<code>handleScroll</code>里更改了<code>lastFlag</code>后，Vue本身有batch的优化，会在microtask栈空后，才会进行耗时的DOM操作。循环添加图片时，需要通过setTimeout异步完成，避免误判，在一次递归中加载了所有图片。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">handleScroll</span>(<span class=\"params\">top</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">items</span>.<span class=\"property\">length</span> &lt;= <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> delta = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">columns</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> col = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">`wall-<span class=\"subst\">$&#123;i&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (col &amp;&amp; col.<span class=\"property\">offsetTop</span> + col.<span class=\"property\">clientHeight</span> &lt; top + (<span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">clientHeight</span>)) &#123;</span><br><span class=\"line\">      delta = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!!++delta) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span> += delta;</span><br><span class=\"line\">    <span class=\"comment\">// 直到所有列下沿都不在视口内，</span></span><br><span class=\"line\">    <span class=\"comment\">// 同时，设置时延，保证DOM操作完成后再继续handleScroll</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;  <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleScroll</span>(top); &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新增图片困难\"><a href=\"#新增图片困难\" class=\"headerlink\" title=\"新增图片困难\"></a>新增图片困难</h3><p><del>由于github.io是纯静态的页面，我并没有后台环境，这个痛点短期内只能缓解不能根除。不过后面考虑将所有图片迁移到图床上，毕竟把图片数据也存在github上感觉还是……有点怪怪的。日后新增图片应该还是通过上传图片，更新<code>meta.json</code>的形式完成。</del></p>\n<p>目前已将所有图片迁移到图床上，图床选择上参考了知乎上的推荐，使用<a href=\"https://www.qiniu.com/\">七牛云存储</a>，在个人实名认证后，免费部分有每月10G国内和国外下载流量，100万次GET和PUT请求次数，和10G存储空间。同时，它还提供对图片的压缩等管理，尽量减少流量。</p>\n<p>迁移之后，仓库体积大大减小。之后日常更新时，图片单独上传，根据外链固定前缀得到最终路径。</p>\n<p><del><code>meta.json</code>的更新上，考虑自己写一个工具，根据新看的电影生成新的content。</del></p>\n<p>已完成自动生成<code>meta.json</code>的<a href=\"https://shenlvmeng.github.io/meta-maker.html\">小工具</a>，原理很简单，就不再介绍了。</p>\n<h3 id=\"细节美化\"><a href=\"#细节美化\" class=\"headerlink\" title=\"细节美化\"></a>细节美化</h3><p>点比较细碎。整体借鉴了<a href=\"https://material.io/guidelines/material-design/introduction.html#introduction-goals\">material design</a>的思想。</p>\n<p><strong>影片详细信息的遮罩</strong></p>\n<p>考虑使用100%的遮罩，同时禁止背景滚动的形式展示图片的详细信息。起初打算用js去实现，后来发现下面的两点使得方案并不简单</p>\n<ul>\n<li>scroll事件不能被cancel，这意味着不能打断默认的滚动行为</li>\n<li>从Mouse，Keyboard，Touch相关触发scroll事件的事件劫持滚动行为倒是可以，不过要监听的事件太多</li>\n</ul>\n<p>只好作罢，通过纯CSS的方式，弹出浮层时，为body指定<code>noscroll</code>的类名。让浮层的<code>overflow</code>属性为<code>scroll</code>即可，同时设置浮层<code>position</code>属性为<code>fixed</code>即可。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#display</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用缓动函数改进回到开头</strong></p>\n<p>这里使用定义域和值域都是<code>[0,1]</code>的<code>easeInOutCubic</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">easeInOutCubic</span> = t =&gt; (t&lt;<span class=\"number\">.5</span> ? <span class=\"number\">4</span>*t*t*t : (t-<span class=\"number\">1</span>)*(<span class=\"number\">2</span>*t-<span class=\"number\">2</span>)*(<span class=\"number\">2</span>*t-<span class=\"number\">2</span>)+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有了缓动函数后，使用<code>requestAnimationFrame</code>即可高效率地绘制JS动画。这里封装了一个<code>animate</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">animate</span> = (<span class=\"params\">obj, prop, end, time, ease</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj || !obj[prop] || time &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = obj[prop],</span><br><span class=\"line\">      k = end - start,</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span>,</span><br><span class=\"line\">      tick = <span class=\"function\"><span class=\"params\">timestamp</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          timer = timestamp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> progress = timestamp - timer;</span><br><span class=\"line\">        obj[prop] = start + <span class=\"title function_\">ease</span>(progress / time) * k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (progress &lt; time) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">requestAnimationFrame</span>(tick);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(tick);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后面直接使用<code>animate(document.body, &quot;scrollTop&quot;, 0, 1000, easeInOutCubic)</code>就可以圆滑地上移了。</p>\n<p><strong>移动端的优化</strong></p>\n<ul>\n<li>使用媒体查询，在屏幕宽度更改时，隐藏一些元素</li>\n<li>在UA为移动端设备时，给出提醒</li>\n</ul>\n<p><strong>loading样式</strong></p>\n<p>在改变筛选条件时，设置loading样式提升用户体验。通过积累onload的计数和初始加载图片值进行对比，在达到该值时清除遮罩。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"title function_\">loadedCount</span>(<span class=\"params\">newCount</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCount &gt;= <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">lastFlag</span> + <span class=\"number\">1</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">items</span>.<span class=\"property\">length</span>)) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;全部加载完成&quot;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">isHidden</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&quot;Loading...&quot;);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>杂项</strong></p>\n<ul>\n<li>导航条交互优化</li>\n<li>导航条部分设置阴影，更改部分字体颜色和背景色</li>\n<li>修改触发分类方式，由<code>click</code>改为<code>mousemove</code></li>\n<li>修改tab的样式</li>\n<li>将vue和lodash的js文件下载到本地，避免CDN失效的问题（之前已经遇到过一次），增加可靠性</li>\n<li>搜索条件不区分大小写</li>\n</ul>\n<h3 id=\"本地调试困难\"><a href=\"#本地调试困难\" class=\"headerlink\" title=\"本地调试困难\"></a>本地调试困难</h3><p>因为代码较少，也只有一个文件，用不着webpack这样的全套解决方案。小巧易用的gulp就够了。针对我们需要的ES6转码，替换minify方案，本地调试等需要，都有对应的gulp插件解决问题。</p>\n<h4 id=\"gulp-babel\"><a href=\"#gulp-babel\" class=\"headerlink\" title=\"gulp-babel\"></a>gulp-babel</h4><p>使用<a href=\"https://babeljs.io/\">babel</a>来转码，<code>gulp-babel</code>依赖<code>babel-core@6</code>或以上版本，同时设置<code>preset</code>为<code>es2015</code>或ES7相关版本时也需要下载对应module。</p>\n<p>我只需要es2015即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev babel-core gulp-babel babel-preset-es2015</span><br></pre></td></tr></table></figure>\n\n<p>React和ES7的各阶段可以像下面这样选择安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev babel-preset-react</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-0</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-1</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-2</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h4><ul>\n<li>**<a href=\"https://www.npmjs.com/package/gulp-uglify\">gulp-uglify</a>**，压缩代码</li>\n<li><strong>gulp-rename</strong>，为压缩出的js重命名</li>\n<li>**<a href=\"https://www.npmjs.com/package/gulp-webserver\">gulp-webserver</a>**，开启本地服务，方便本地调试</li>\n</ul>\n<p>上面这些插件按照文档操作即可，坑比较少，使用webserver时的<code>gulp.src()</code>入参通常为<code>./</code>，指以当前目录为服务器根目录。</p>\n<p>最后还需要加一个watch，方便在调试时的修改能同步转码压缩。像下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.js&#x27;</span>, [<span class=\"string\">&#x27;js&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.css&#x27;</span>, [<span class=\"string\">&#x27;css&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.json&#x27;</span>, [<span class=\"string\">&#x27;json&#x27;</span>]);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>最后整个<code>gulpfile.js</code>是下面的样子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    babel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-babel&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    cleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-clean-css&#x27;</span>),</span><br><span class=\"line\">    jsonminify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jsonminify&#x27;</span>),</span><br><span class=\"line\">    webserver = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-webserver&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;assets/src/*.js&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">babel</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">presets</span>: [<span class=\"string\">&#x27;es2015&#x27;</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">uglify</span>())</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">rename</span>(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;css&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>([<span class=\"string\">&#x27;assets/src/*.css&#x27;</span>])</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">cleanCSS</span>(&#123;<span class=\"attr\">compatibility</span>: <span class=\"string\">&#x27;ie8&#x27;</span>&#125;))</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;json&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;assets/src/meta.json&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">jsonminify</span>())</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;dist&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;webserver&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;./&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">pipe</span>(<span class=\"title function_\">webserver</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">livereload</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">directoryListing</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.js&#x27;</span>, [<span class=\"string\">&#x27;js&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.css&#x27;</span>, [<span class=\"string\">&#x27;css&#x27;</span>]);</span><br><span class=\"line\">  gulp.<span class=\"title function_\">watch</span>(<span class=\"string\">&#x27;assets/src/*.json&#x27;</span>, [<span class=\"string\">&#x27;json&#x27;</span>]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;dev&#x27;</span>, [<span class=\"string\">&#x27;default&#x27;</span>, <span class=\"string\">&#x27;webserver&#x27;</span>, <span class=\"string\">&#x27;watch&#x27;</span>]);</span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&quot;default&quot;</span>, [<span class=\"string\">&#x27;json&#x27;</span>, <span class=\"string\">&#x27;css&#x27;</span>, <span class=\"string\">&#x27;js&#x27;</span>]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h3><p>从略。HTML和CSS部分参照以往写的<a href=\"https://shenlvmeng.github.io/blog/2017/06/23/HTML-CSS-code-style-guide/\">建议</a>即可。除此以外，优化了下面的部分：</p>\n<ul>\n<li>删除了为兼容移动端额外使用的touchend事件，增加viewport的meta标签，消除移动端chrome浏览器点击300ms延时情况</li>\n<li>由于引入了babel，删除了兼容ES6语法的自己写的polyfill部分</li>\n<li>使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\">fetch API</a>请求json</li>\n<li>优化导航条点击事件处理相关的代码</li>\n<li>减少图片数目和json体积</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000004394726\">使用gulp 进行ES6开发</a></li>\n<li><a href=\"http://blog.csdn.net/seven0404/article/details/51880162\">node.js利用gulp 启动webServer服务</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2434602/css-setting-width-height-as-percentage-minus-pixels\">CSS: Setting width&#x2F;height as Percentage minus pixels</a></li>\n<li><a href=\"http://easings.net/zh-cn\">缓动函数速查表</a></li>\n<li><a href=\"https://gist.github.com/gre/1650294\">Simple Easing Functions in Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\">window.requestAnimationFrame | MDN</a></li>\n<li><a href=\"https://dribbble.com/\">dribbble</a></li>\n<li><a href=\"https://codepen.io/sdthornton/pen/wBZdXq\">Material Design Box Shadows</a></li>\n<li><a href=\"http://tobiasahlin.com/spinkit/\">SpinKit | Simple CSS Spinners</a></li>\n<li><a href=\"https://www.zhihu.com/question/21667151\">国内有什么方便的图床？</a></li>\n</ul>\n",
            "tags": [
                "脚手架",
                "技改",
                "Vue",
                "gulp",
                "瀑布流",
                "电影"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/04/05/vue-reactive-sourcecode/",
            "url": "http://shenlvmeng.github.com/blog/2017/04/05/vue-reactive-sourcecode/",
            "title": "Vue2.0的响应式设计原理",
            "date_published": "2017-04-05T07:12:20.000Z",
            "content_html": "<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上周抽空看了看Vue的源码，设计的精巧让我这个鶸一时吸收不来。如果想写篇既大又全的文章，一劳永逸地介绍Vue2.0的源码，以我的水平显然是做不到的。于是就只取一瓢饮地，简单记录下Vue2.0在响应式原理上的设计。其他的部分等我功力深厚了（其实就是懒）再做总结吧。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>这一部分是Vue响应式原理的基础。包含Observer类，Watcher类，Dep类，事件订阅模式，还有最关键的<code>Object.defineProperty</code>方法。</p>\n<h4 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h4><p>Vue实现数据绑定的方式和其他的MVVM同侪不同，React和backbone（这货不是MVVM）采用的是典型的发布订阅模式，Angular则采用的脏值检测。</p>\n<p>Vue使用了更为隐蔽和magical的<code>Object.defineProperty</code>设置对象访问器属性（这也意味着Vue只支持到IE9+）。</p>\n<blockquote><p>把一个普通 Javascript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>\n</blockquote>\n\n<p><code>Object.defineProperty()</code>可以定义对象的访问器属性，关于访问器属性的更多介绍可以看<a href=\"https://shenlvmeng.github.io/blog/2017/03/13/js-object/\">这里</a>。其中<code>get</code>和<code>set</code>方法分别用来指定属性的getter和setter。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">_name</span>: <span class=\"string\">&#x27;&#x27;</span>,  <span class=\"comment\">//`_`表示只能通过方法访问</span></span><br><span class=\"line\">  <span class=\"attr\">nickname</span>: <span class=\"string\">&#x27;酱&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(person, <span class=\"string\">&#x27;name&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">nickname</span> = newValue + <span class=\"string\">&#x27;酱&#x27;</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = newValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过getter和setter实现数据劫持是Vue数据绑定的基础。</p>\n<h4 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\">发布订阅</a>是JavaScript中事件机制的实现方式，也是<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-1/\">JavaScript异步编程</a>的实现方式之一。</p>\n<p>发布订阅模式中的角色主要有发布者、事件对象、订阅者。发布者和事件对象是一对多的关系，事件对象和订阅者又是一对多的关系。当发布者的状态改变触发事件对象时，相关的订阅者就会收到通知。实现起来就像下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">EventUtil</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 全局事件管理</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> events = &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">    on = <span class=\"keyword\">function</span> (<span class=\"params\">type, handler</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (events[type]) &#123;</span><br><span class=\"line\">        events[type].<span class=\"title function_\">push</span>(handler);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        events[type] = [handler];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    emit = <span class=\"keyword\">function</span> (<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!events[type]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = events[type].<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">          events[type][i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Vue实现视图自动更新的原理也是如此，当然细节上就复杂多了。</p>\n<h4 id=\"Observer，Watcher，Dep\"><a href=\"#Observer，Watcher，Dep\" class=\"headerlink\" title=\"Observer，Watcher，Dep\"></a>Observer，Watcher，Dep</h4><p>这三个是相辅相成实现Vue数据绑定的组件。</p>\n<h5 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h5><p>Vue在组件(Component)初始化过程中，会将数据对象封装为Observer对象，便于监听数据的改变，并绑定依赖在上面。我们来看下<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L39-L53\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span> (<span class=\"attr\">value</span>: any) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">dep</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()  <span class=\"comment\">//一个 Dep对象实例，Watcher 和 Observer 之间的纽带</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">vmCount</span> = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">def</span>(value, <span class=\"string\">&#x27;__ob__&#x27;</span>, <span class=\"variable language_\">this</span>)  <span class=\"comment\">//把自身 this 添加到 value 的 __ob__ 属性上</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123; <span class=\"comment\">//对 value 的类型进行判断</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">      ? protoAugment</span><br><span class=\"line\">      : copyAugment</span><br><span class=\"line\">    <span class=\"title function_\">augment</span>(value, arrayMethods, arrayKeys) <span class=\"comment\">// 数组增强方法</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeArray</span>(value) <span class=\"comment\">//如果是数组则观察数组</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">walk</span>(value) <span class=\"comment\">//否则观察单个元素。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Observer对象储存在 <strong>ob</strong> 这个属性，这个属性保存了 Observer 对象自己本身。对象在转化为 Observer 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 Observer 对象。</p>\n<p>由于JavaScript本身的原因，Vue不能监测数组的变化，Vue采用的折中方法是增强数组的原生方法<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code>, <code>reverse</code>，以及建议使用者通过Vue.set的方式显示调用。通过其他方式对数组进行的修改将无法被监听到。</p>\n<h5 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h5><p>Vue中，Watcher和模板渲染紧密相连，它将Observer发生的改变反映到模板内容上。它关键部分的<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/watcher.js#L39-L85\">源码</a>是这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span> (</span><br><span class=\"line\">  <span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>,</span><br><span class=\"line\">  <span class=\"attr\">expOrFn</span>: string | <span class=\"title class_\">Function</span>,</span><br><span class=\"line\">  <span class=\"attr\">cb</span>: <span class=\"title class_\">Function</span>,</span><br><span class=\"line\">  options?: <span class=\"title class_\">Object</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">  vm.<span class=\"property\">_watchers</span>.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>)<span class=\"comment\">// 将当前 Watcher 类推送到对应的 Vue 实例中</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// parse expression for getter</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> expOrFn === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是函数，相当于指定了当前订阅者获取数据的方法，每次订阅者通过这个方法获取数据然后与之前的值进行对比</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = expOrFn</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = <span class=\"title function_\">parsePath</span>(expOrFn)<span class=\"comment\">// 否则的话将表达式解析为可执行的函数</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">lazy</span></span><br><span class=\"line\">    ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">    : <span class=\"variable language_\">this</span>.<span class=\"title function_\">get</span>()   <span class=\"comment\">//如果 lazy 不为 true，则执行 get 函数进行依赖收集</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中输入参数<code>vm</code>是监听的组件，<code>expOrFn</code>最终将交给<code>getter</code>属性，<code>cb</code>是更新时的回调函数。最后一句中的<code>this.get()</code>完成了依赖的收集工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">get () &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pushTarget</span>(<span class=\"variable language_\">this</span>)  <span class=\"comment\">// 设置全局变量 Dep.target，将 Watcher 保存在这个全局变量中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>) <span class=\"comment\">// 调用 getter 函数，进入 get 方法进行依赖收集操作</span></span><br><span class=\"line\">  <span class=\"comment\">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class=\"line\">  <span class=\"comment\">// dependencies for deep watching</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">deep</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">popTarget</span>()  <span class=\"comment\">// 将全局变量 Dep.target 置为 null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">cleanupDeps</span>()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一句的<code>pushTarget(this)</code>设置了<code>Dep.target</code>，getter函数正是通过<code>Dep.target</code>是否为<code>null</code>，判断当前处于依赖收集阶段还是普通数据读取。后面的两句去<code>touch``expOrFn</code>涉及到的每个数据项。从而将<code>expOrFn</code>的依赖收集起来。最后将dep中的内容清空，为下次收集依赖做准备。</p>\n<h5 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a>Dep</h5><p>Dep类用于连接Watcher类和Observer类，每个Observer对象中都有一个Dep实例，其中存储了订阅者Watcher。<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/dep.js#L17-L20\">源码</a>如下: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = uid++</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [] <span class=\"comment\">//存储 Watcher 实例的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>.<span class=\"title function_\">addDep</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// stablize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">slice</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.<span class=\"property\">length</span>; i &lt; l; i++) &#123;   <span class=\"comment\">//遍历 Watcher 列表，调用 update 方法进行更新操作</span></span><br><span class=\"line\">      subs[i].<span class=\"title function_\">update</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dep类比较简单，主要是一个存储Watcher实例的数组<code>this.subs</code>。<code>depend()</code>方法用于向Watcher对象中添加这个Dep。<code>notify()</code>方法将遍历Watcher列表，通知订阅者更新视图。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>下面从源码角度上看看Vue实现数据绑定的设计。</p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>Vue核心部分的代码放在<code>src</code>目录。路径下还有下面这些子文件夹：</p>\n<ul>\n<li><code>entries</code> 入口文件，根据编译环境的不同，更改一些配置</li>\n<li><code>compiler</code> 编译模板，<code>render</code>函数的实现</li>\n<li><code>core</code> 关键部分代码</li>\n<li><code>core/observer</code> 响应式设计中的Observer对象实现</li>\n<li><code>core/vdom</code> 虚拟DOM，diff算法，patch函数实现</li>\n<li><code>core/instance</code> 组件实例生命周期实现，组件初始化入口</li>\n<li><code>core/components</code> 全局组件</li>\n<li><code>core/global-api</code> 全局API</li>\n<li><code>server</code> 服务端渲染</li>\n<li><code>platform</code> 平台特定代码，分为<code>web</code>和<code>weex</code></li>\n<li><code>sfc</code> 处理单文件组件 解析.vue文件</li>\n<li><code>share</code> 工具函数</li>\n</ul>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>关于Vue的<a href=\"https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram\">生命周期</a>，这里假设你已经熟悉，就不做介绍了。了解它也将帮助你了解Vue的工作流程。</p>\n<p>源码的入口从下面一行<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/index.js#L8-L14\">代码</a>开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Vue</span> (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">    !(<span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Vue</span>)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">_init</span>(options) <span class=\"comment\">//开始初始化步骤</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">initMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入初始化代码</span></span><br><span class=\"line\"><span class=\"title function_\">stateMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入数据绑定代码</span></span><br><span class=\"line\"><span class=\"title function_\">eventsMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入事件相关代码</span></span><br><span class=\"line\"><span class=\"title function_\">lifecycleMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入生命周期代码</span></span><br><span class=\"line\"><span class=\"title function_\">renderMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入模板渲染代码</span></span><br></pre></td></tr></table></figure>\n\n<p>文件为<code>src/core/instance/index.js</code>，关键在于最后一句，通过调用<code>init.js</code>中定义的<code>_init(options)</code>方法初始化Vue实例。这个方法是在下面的<code>initMixin(Vue)</code>中导入的。这种mixin的方式不同于Vue1.x版本，更具模块化适合拓展（同时也增加了寻找代码的难度）。</p>\n<p>初始化相关的主要<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/init.js#L40-L48\">代码</a>如下；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initMixin</span> (<span class=\"title class_\">Vue</span>: <span class=\"title class_\">Class</span>&lt;<span class=\"title class_\">Component</span>&gt;) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">_init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">options?: <span class=\"built_in\">Object</span></span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"title function_\">initLifecycle</span>(vm)   <span class=\"comment\">//vm 的生命周期相关变量初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">initEvents</span>(vm)    <span class=\"comment\">// vm 的事件监控初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">initRender</span>(vm)  <span class=\"comment\">// 模板解析</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">initState</span>(vm) <span class=\"comment\">//vm 的状态初始化，prop/data/computed/method/watch 都在这里完成初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">\t  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>initLifecycle</code>主要是初始化vm实例上的一些参数；<code>initEvents</code>是事件监控的初始化；<code>initRender</code>是模板解析，2.0的版本中这一块有很大的改动，1.0的版本中Vue使用的是<code>DocumentFragment</code>来进行模板解析，而 2.0 中作者采用的John Resig的HTML Parser将模板解析成可直接执行的<code>render</code>函数。<code>initState</code>是数据绑定的主战场，我们下一节会详细讲到。<code>callHook</code>执行生命周期的钩子函数。</p>\n<h4 id=\"initState\"><a href=\"#initState\" class=\"headerlink\" title=\"initState\"></a>initState</h4><p>在初始化中，<code>initState</code>函数承担了数据绑定中的最主要的脏活累活。它的<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/state.js#L24-L36\">源码</a>像下面这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initState</span> (<span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>) &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">_watchers</span> = []  <span class=\"comment\">//新建一个订阅者列表</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> opts = vm.<span class=\"property\">$options</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">props</span>) <span class=\"title function_\">initProps</span>(vm, opts.<span class=\"property\">props</span>)  <span class=\"comment\">// 初始化 Props，与 initData 差不多</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">methods</span>) <span class=\"title function_\">initMethods</span>(vm, opts.<span class=\"property\">methods</span>)  <span class=\"comment\">// 初始化 Methods，Methods 的初始化比较简单，就是作用域的重新绑定。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">initData</span>(vm) <span class=\"comment\">// 初始化 Data，响应式关键步</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">observe</span>(vm.<span class=\"property\">_data</span> = &#123;&#125;, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>) <span class=\"comment\">//如果没有 data，则观察一个空对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">computed</span>) <span class=\"title function_\">initComputed</span>(vm, opts.<span class=\"property\">computed</span>)<span class=\"comment\">// 初始化 computed，这部分会涉及 Watcher 类以及依赖收集，computed 其实本身也是一种特殊的 Watcher</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">watch</span>) <span class=\"title function_\">initWatch</span>(vm, opts.<span class=\"property\">watch</span>)<span class=\"comment\">// 初始化 watch，这部分会涉及 Watcher 类以及依赖收集</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>initState</code>将工作拆解成观察<code>props</code>, <code>data</code>, <code>methods</code>, <code>computed</code>, <code>watch</code>几个关键部分。</p>\n<h4 id=\"initData\"><a href=\"#initData\" class=\"headerlink\" title=\"initData\"></a>initData</h4><p>以<code>initData</code>方法为例，它是如何使用上面提到的Observer, Dep, Watcher类的呢，我们看看<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/state.js#L74-L104\">源码</a>: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initData</span> (<span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = vm.<span class=\"property\">$options</span>.<span class=\"property\">data</span></span><br><span class=\"line\">  data = vm.<span class=\"property\">_data</span> = <span class=\"keyword\">typeof</span> data === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">    ? data.<span class=\"title function_\">call</span>(vm)</span><br><span class=\"line\">    : data || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isPlainObject</span>(data)) &#123;<span class=\"comment\">// 保证data必须为纯对象</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// proxy data on instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(data)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = vm.<span class=\"property\">$options</span>.<span class=\"property\">props</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = keys.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (props &amp;&amp; <span class=\"title function_\">hasOwn</span>(props, keys[i])) &#123;<span class=\"comment\">// 是props，则不代理</span></span><br><span class=\"line\">      ...... <span class=\"comment\">//如果和 props 里面的变量重了，则抛出 Warning</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 否则将属性代理的 vm 上，这样就可以通过 vm.xx 访问到 vm._data.xx</span></span><br><span class=\"line\">      <span class=\"title function_\">proxy</span>(vm, keys[i]) <span class=\"comment\">//proxy方法遍历 data 的 key，把 data 上的属性代理到 vm 实例上</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// observe data</span></span><br><span class=\"line\">  <span class=\"title function_\">observe</span>(data, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)  <span class=\"comment\">//关键一步，observe(data, this)方法来对 data 做监控</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个函数做了下面的工作：</p>\n<ul>\n<li>保证data为纯对象</li>\n<li>检查是否与<code>props</code>中属性有重复</li>\n<li>进行数据代理，便于我们直接通过vm.xxx的形式访问原本位于vm._data.xxx的属性。</li>\n<li>调用<code>observe</code>方法对<code>data</code>进行包装，使之具有响应式的特点。</li>\n</ul>\n<p>那我们看看<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L101-L126\">observe</a>方法是怎么写的吧</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回一个 Observer 对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">observe</span> (<span class=\"attr\">value</span>: any, <span class=\"attr\">asRootData</span>: ?boolean): <span class=\"title class_\">Observer</span> | <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value)) &#123;  <span class=\"comment\">//如果不是对象和数组则不监控，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">ob</span>: <span class=\"title class_\">Observer</span> | <span class=\"keyword\">void</span></span><br><span class=\"line\">  <span class=\"comment\">//判断 value 是否已经添加了 __ob__ 属性，并且属性值是 Observer 对象的实例。避免重复引用导致的死循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">hasOwn</span>(value, <span class=\"string\">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class=\"property\">__ob__</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Observer</span>) &#123;    <span class=\"comment\">//如果是就直接用</span></span><br><span class=\"line\">    ob = value.<span class=\"property\">__ob__</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    observerState.<span class=\"property\">shouldConvert</span> &amp;&amp; <span class=\"comment\">//只有 root instance props 需要创建 Observer 对象</span></span><br><span class=\"line\">    !<span class=\"title function_\">isServerRendering</span>() &amp;&amp; <span class=\"comment\">//不是服务端渲染</span></span><br><span class=\"line\">    (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value) || <span class=\"title function_\">isPlainObject</span>(value)) &amp;&amp; <span class=\"comment\">//数组或者普通对象</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value) &amp;&amp; <span class=\"comment\">//可扩展对象</span></span><br><span class=\"line\">    !value.<span class=\"property\">_isVue</span> <span class=\"comment\">// 非 Vue 组件</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>(value)  <span class=\"comment\">//关键步！在 value 满足上述条件的情况下创建一个 Observer 对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\">    ob.<span class=\"property\">vmCount</span>++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob <span class=\"comment\">// 返回一个 Observer 对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>observe方法主要就是判断value是否满足一些预设条件，并将这个对象转化为Observer对象。</p>\n<p>关于Observer类我们上面已经提到，它的构造函数做了下面几个工作：</p>\n<ul>\n<li>首先创建了一个Dep对象实例；</li>\n<li>然后把自身this添加到value的<code>__ob__</code>属性上；</li>\n<li>最后对value的类型进行判断，如果是数组则观察数组，否则观察单个元素（要理解这一步是个递归过程，即value的元素如果符合条件也需要转化为Observer对象）。</li>\n</ul>\n<p>不论是基础类型还是数组或对象，最终都会走入到<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L55-L65\">walk</a>方法，方法定义在<code>src/core/observer/index.js</code>中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">walk (<span class=\"attr\">obj</span>: <span class=\"title class_\">Object</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">defineReactive</span>(obj, keys[i], obj[keys[i]]) <span class=\"comment\">//遍历对象，结合defineReactive方法地柜将属性转化为getter和setter</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive</h4><p>在经过一系列的准备工作和铺垫后，终于可以接触到数据绑定最核心部分的<code>defineReactive</code>函数。方法也定义在<code>src/core/observer/index.js</code>中，<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L128-L184\">源码</a>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span> (</span><br><span class=\"line\">  <span class=\"attr\">obj</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">  <span class=\"attr\">key</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">val</span>: any,</span><br><span class=\"line\">  customSetter?: <span class=\"title class_\">Function</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()  <span class=\"comment\">//每个对象都会有一个 Dep 实例，用来保存依赖 (Watcher 对象)</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = <span class=\"title function_\">observe</span>(val)   <span class=\"comment\">//结合 observe 函数进行将对象的对象也变成监控对象</span></span><br><span class=\"line\">  <span class=\"comment\">// 最重点、基石、核心的部分：通过调用 Object.defineProperty 给 data 的每个属性添加 getter 和 setter 方法。</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">reactiveGetter</span> () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.<span class=\"title function_\">call</span>(obj) : val</span><br><span class=\"line\">      <span class=\"comment\">// 依赖收集的重要步骤</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;<span class=\"comment\">//如果存在Dep.target这个全局变量不为空，表示是在新建Watcher的时候调用的，代码已经保证</span></span><br><span class=\"line\">        dep.<span class=\"title function_\">depend</span>()    <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.<span class=\"property\">dep</span>.<span class=\"title function_\">depend</span>() <span class=\"comment\">// 处理好子元素的依赖 watcher</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123; <span class=\"comment\">// 如果是数组，进一步处理</span></span><br><span class=\"line\">          <span class=\"title function_\">dependArray</span>(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">reactiveSetter</span> (newVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.<span class=\"title function_\">call</span>(obj) : val</span><br><span class=\"line\">      ......</span><br><span class=\"line\">      childOb = <span class=\"title function_\">observe</span>(newVal)    <span class=\"comment\">// 对新数据重新 observe，更新数据的依赖关系</span></span><br><span class=\"line\">      dep.<span class=\"title function_\">notify</span>()   <span class=\"comment\">// 通知dep进行数据更新，这个方法在前面的 Dep 类中讲过</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defineReactive是对Object.defineProperty方法的包装，结合observe方法对数据项进行深入遍历，最终将所有的属性就转化为getter和setter。其中对于Dep的处理用于收集依赖<code>data</code>的Watcher对象。</p>\n<h4 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h4><p><img src=\"/blog/images/vue-reactive.jpg\"></p>\n<p><code>data</code>的依赖收集是在getter函数中完成的。Observer和Dep是一对一的关系，Dep用来存储依赖Observer的Watcher。Dep和Watcher是多对多的关系，一个Dep中存储了若干Watcher，一个Watcher可能同时依赖于多个Observer。</p>\n<p>可以看到Dep是连接Observer（生产者）和Watcher（消费者）的关键纽带。Watcher通过getter函数建立起和Observer中Dep的关联。在Observer的setter函数中会触发<code>dep.notify()</code>方法，根据上文对该方法的讲解，它实际上对数组中每个Watcher执行了<code>update</code>方法。在方法中根据是否同步去执行<code>run</code>方法，这个方法中通过<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/watcher.js#L157-#L191\">源码</a>可以看到实际上正是通过<code>const value = this.get()</code>获取最新的value。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update () &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dirty</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">sync</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">queueWatcher</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>模板编译过程中的指令和数据绑定都会生成 Watcher实例，watch函数中的对象也会生成 Watcher实例，在实例化的过程中，会调用watcher.js中的get函数touch这个Watcher的表达式或函数涉及的所有属性；</li>\n<li>touch开始之前Watcher会设置Dep的静态属性Dep.target指向其自身，然后开始依赖收集；</li>\n<li>touch属性的过程中，属性的getter函数会被访问；</li>\n<li>属性gette 函数中会判断Dep.target（target中保存的是第2步中设置的Watcher实例）是否存在，若存在则将 getter函数所在的Observer 实例的Dep实例保存到Watcher的列表中，并在此Dep实例中添加Watcher为订阅者；</li>\n<li>重复上述过程直至Watcher的表达式或函数涉及的所有属性均touch结束（即表达式或函数中所有的数据的getter函数都已被触发），Dep.target被置为null，依赖收集完成；</li>\n</ol>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面尝试从源码角度对Vue2.0的响应式设计做了浅析。总结一下就是下面几点：</p>\n<ul>\n<li>在生命周期的initState方法中对<code>data</code>, <code>prop</code>, <code>method</code>, <code>computed</code>, <code>watch</code>方法中的数据进行劫持，通过<code>defineReactive</code>和<code>observe</code>将之转换为Observer对象</li>\n<li><code>initRender</code>函数中解析模板，新建Watcher对象通过Dep对象和对应数据建立了依赖关系，通过<code>Dep.target</code>这个全局对象判断是否是依赖收集阶段。</li>\n<li>数据变化时，通过<code>setter</code>函数中的<code>dep.notify</code>方法执行Watcher的<code>update</code>方法更新视图</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.zybuluo.com/zhouweicsu/note/682813\">Vue2.0 源码阅读：响应式原理</a></p>\n",
            "tags": [
                "JavaScript",
                "源码",
                "Vue"
            ]
        }
    ]
}
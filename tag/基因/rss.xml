<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Shenlvmeng&#39;s Blog • Posts by &#34;基因&#34; tag</title>
        <link>http://shenlvmeng.github.com/blog</link>
        <description>Be sharp, my friend.</description>
        <language>zh-CN</language>
        <pubDate>Thu, 28 Sep 2023 19:43:09 +0800</pubDate>
        <lastBuildDate>Thu, 28 Sep 2023 19:43:09 +0800</lastBuildDate>
        <category>总结</category>
        <category>制度</category>
        <category>道德</category>
        <category>文官</category>
        <category>万历</category>
        <category>明朝</category>
        <category>读书笔记</category>
        <category>展望</category>
        <category>2018</category>
        <category>2019</category>
        <category>flag</category>
        <category>2020</category>
        <category>2021</category>
        <category>2022</category>
        <category>2023</category>
        <category>面试</category>
        <category>前端</category>
        <category>FAQ</category>
        <category>HTML</category>
        <category>CSS</category>
        <category>style guide</category>
        <category>编程</category>
        <category>范式</category>
        <category>设计</category>
        <category>艺术</category>
        <category>质量</category>
        <category>async_hooks</category>
        <category>cls-hooked</category>
        <category>logId</category>
        <category>录音</category>
        <category>getUserMedia</category>
        <category>AudioContext</category>
        <category>PCM</category>
        <category>WAVE</category>
        <category>二叉搜索树</category>
        <category>算法</category>
        <category>回忆</category>
        <category>老朋友</category>
        <category>C</category>
        <category>Hash</category>
        <category>布隆过滤器</category>
        <category>字符串检索</category>
        <category>canvas</category>
        <category>流程图</category>
        <category>d3</category>
        <category>g6</category>
        <category>zrender</category>
        <category>processOn</category>
        <category>SDN</category>
        <category>cbench</category>
        <category>安装说明</category>
        <category>绘图</category>
        <category>动画</category>
        <category>攻略</category>
        <category>流水账</category>
        <category>成都</category>
        <category>重庆</category>
        <category>武汉</category>
        <category>重构</category>
        <category>代码</category>
        <category>代码风格</category>
        <category>数据可视化</category>
        <category>爬虫</category>
        <category>chrome</category>
        <category>crx</category>
        <category>扩展</category>
        <category>CORS</category>
        <category>跨域</category>
        <category>盒模型</category>
        <category>浮动</category>
        <category>Reactive Programming</category>
        <category>JavaScript</category>
        <category>Cycle.js</category>
        <category>Dart</category>
        <category>最佳实践</category>
        <category>引流</category>
        <category>universal-link</category>
        <category>app-link</category>
        <category>脚手架</category>
        <category>degit</category>
        <category>git</category>
        <category>设计模式</category>
        <category>类</category>
        <category>接口</category>
        <category>抽象类</category>
        <category>DOM</category>
        <category>Docker</category>
        <category>ONOS</category>
        <category>控制器</category>
        <category>虚拟化</category>
        <category>笔记</category>
        <category>UX</category>
        <category>UED</category>
        <category>准则</category>
        <category>Java</category>
        <category>Ruby</category>
        <category>反射</category>
        <category>编程范式</category>
        <category>鸭子类型</category>
        <category>管理</category>
        <category>效率</category>
        <category>知识工作者</category>
        <category>卓有成效</category>
        <category>Elm</category>
        <category>框架</category>
        <category>函数式编程</category>
        <category>虚网映射</category>
        <category>Javascript</category>
        <category>并发</category>
        <category>event loop</category>
        <category>覆盖率</category>
        <category>端到端测试</category>
        <category>istanbul</category>
        <category>istanbuljs</category>
        <category>JavaSript</category>
        <category>Express</category>
        <category>源码</category>
        <category>代码覆盖率</category>
        <category>istanbul-middleware</category>
        <category>代码插桩</category>
        <category>require钩子</category>
        <category>babel-plugin-istanbul</category>
        <category>css</category>
        <category>html5</category>
        <category>flex</category>
        <category>javascript</category>
        <category>roadmap</category>
        <category>闭包</category>
        <category>Haskell</category>
        <category>monad</category>
        <category>后端</category>
        <category>管理后台</category>
        <category>egg.js</category>
        <category>工作流</category>
        <category>pull request</category>
        <category>golang</category>
        <category>语言学习</category>
        <category>黑客与画家</category>
        <category>创业</category>
        <category>骑行</category>
        <category>海南</category>
        <category>图文</category>
        <category>reflow</category>
        <category>repaint</category>
        <category>命名法</category>
        <category>成功学</category>
        <category>自我建设</category>
        <category>HTTP</category>
        <category>HTTP/2</category>
        <category>SPDY</category>
        <category>QUIC</category>
        <category>HTTPS</category>
        <category>状态码</category>
        <category>网络攻击</category>
        <category>介绍</category>
        <category>图片渲染</category>
        <category>html2canvas</category>
        <category>dom-to-image</category>
        <category>electron</category>
        <category>indexedDB</category>
        <category>异步</category>
        <category>Generator</category>
        <category>thunk</category>
        <category>async</category>
        <category>函数表达式</category>
        <category>对象</category>
        <category>继承</category>
        <category>类型转换</category>
        <category>==</category>
        <category>类型判断</category>
        <category>猫</category>
        <category>杀手</category>
        <category>管理学</category>
        <category>领导力</category>
        <category>梯队</category>
        <category>移动端</category>
        <category>UI</category>
        <category>自适应</category>
        <category>rem</category>
        <category>Electron</category>
        <category>GUI</category>
        <category>gpx</category>
        <category>template</category>
        <category>Electron Builder</category>
        <category>PWA</category>
        <category>方法论</category>
        <category>夜话</category>
        <category>多线</category>
        <category>生活</category>
        <category>密码</category>
        <category>密钥</category>
        <category>技改</category>
        <category>Vue</category>
        <category>gulp</category>
        <category>瀑布流</category>
        <category>电影</category>
        <category>PHP</category>
        <category>参考</category>
        <category>思维</category>
        <category>学习能力</category>
        <category>右脑</category>
        <category>经济学</category>
        <category>宏观经济学</category>
        <category>术语</category>
        <category>GDP</category>
        <category>CPI</category>
        <category>储蓄</category>
        <category>投资</category>
        <category>金融市场</category>
        <category>股票</category>
        <category>债券</category>
        <category>美联储</category>
        <category>失业</category>
        <category>货币</category>
        <category>现值</category>
        <category>准备金</category>
        <category>货币中性</category>
        <category>通货膨胀</category>
        <category>汇率</category>
        <category>购买力</category>
        <category>净出口</category>
        <category>资产净流出</category>
        <category>总需求</category>
        <category>总供给</category>
        <category>流动性偏好</category>
        <category>乘数效应</category>
        <category>菲利普斯曲线</category>
        <category>微观经济学</category>
        <category>供求</category>
        <category>贸易</category>
        <category>市场</category>
        <category>税</category>
        <category>剩余</category>
        <category>外部性</category>
        <category>公共物品</category>
        <category>公共资源</category>
        <category>生产成本</category>
        <category>利润</category>
        <category>垄断</category>
        <category>价格歧视</category>
        <category>寡头</category>
        <category>垄断竞争</category>
        <category>生产要素市场</category>
        <category>贫困</category>
        <category>消费者选择理论</category>
        <category>不对称信息</category>
        <category>政治经济学</category>
        <category>行为经济学</category>
        <category>VSCode</category>
        <category>编辑器</category>
        <category>IDE</category>
        <category>hybrid</category>
        <category>JSBridge</category>
        <category>Web Worker</category>
        <category>Service Worker</category>
        <category>习惯</category>
        <category>lint</category>
        <category>editorconfig</category>
        <category>commit message</category>
        <category>量子物理</category>
        <category>史话</category>
        <category>埋点</category>
        <category>raven.js</category>
        <category>前端监控</category>
        <category>文本编辑器</category>
        <category>quill</category>
        <category>结构化数据</category>
        <category>React</category>
        <category>Hooks</category>
        <category>函数组件</category>
        <category>复用</category>
        <category>状态管理</category>
        <category>redux</category>
        <category>MobX</category>
        <category>代码质量</category>
        <category>重来</category>
        <category>requestAnimationFrame</category>
        <category>TypeScript</category>
        <category>路书</category>
        <category>gpx解析</category>
        <category>EXIF</category>
        <category>人类</category>
        <category>生存</category>
        <category>基因</category>
        <category>响应式编程</category>
        <category>RxJS</category>
        <category>成长</category>
        <category>业务</category>
        <category>思想</category>
        <category>程序设计</category>
        <category>心理学</category>
        <category>自我</category>
        <category>社会思维</category>
        <category>社会影响</category>
        <category>文化</category>
        <category>性别</category>
        <category>从众</category>
        <category>说服</category>
        <category>临床诊断</category>
        <category>陪审团</category>
        <category>司法</category>
        <category>物质主义</category>
        <category>健康</category>
        <category>社会关系</category>
        <category>偏见</category>
        <category>攻击行为</category>
        <category>亲密关系</category>
        <category>友谊</category>
        <category>爱情</category>
        <category>利他</category>
        <category>冲突</category>
        <category>和解</category>
        <category>软技能</category>
        <category>理财</category>
        <category>健身</category>
        <category>自我营销</category>
        <category>学习</category>
        <category>商业模式</category>
        <category>产品</category>
        <category>校园网</category>
        <category>互联网</category>
        <category>技术</category>
        <category>web开发</category>
        <category>哲思</category>
        <category>择偶观</category>
        <category>validator</category>
        <category>大文件</category>
        <category>visibilityChange</category>
        <category>IntersectionObserver</category>
        <category>图种</category>
        <category>draggable</category>
        <category>webpack</category>
        <category>z-index</category>
        <category>git submodule</category>
        <category>object-fit</category>
        <category>object-position</category>
        <category>BroadcastChannel</category>
        <category>extract-text-webpack-plugin</category>
        <category>lottie</category>
        <category>backface-visibility</category>
        <category>egret</category>
        <category>mock</category>
        <category>SSO</category>
        <category>autoprefixer</category>
        <category>polyfill</category>
        <category>Android</category>
        <category>ffmpeg</category>
        <category>React Hooks</category>
        <category>rollup</category>
        <category>CDN</category>
        <category>DNS</category>
        <category>CNAME</category>
        <category>架构</category>
        <category>组件</category>
        <category>ssh</category>
        <category>fis-receiver</category>
        <category>tmux</category>
        <category>origami</category>
        <category>promise</category>
        <category>encodeURI</category>
        <category>encodeURIComponent</category>
        <category>axios</category>
        <category>charles</category>
        <category>黑色幽默</category>
        <category>朋友</category>
        <category>梦</category>
        <category>濒死</category>
        <category>江南</category>
        <category>苏州</category>
        <category>无锡</category>
        <category>宜兴</category>
        <category>湖州</category>
        <category>南浔</category>
        <category>游记</category>
        <category>随笔</category>
        <category>群众</category>
        <category>理论</category>
        <category>实效</category>
        <category>测试</category>
        <category>长沙</category>
        <category>杭州</category>
        <category>湖南</category>
        <category>核酸</category>
        <category>美食</category>
        <category>云南</category>
        <category>丽江</category>
        <category>大理</category>
        <category>青岛</category>
        <category>济南</category>
        <category>山东</category>
        <category>西北</category>
        <category>银川</category>
        <category>西宁</category>
        <category>青海湖</category>
        <category>西海镇</category>
        <category>茶卡盐湖</category>
        <category>厦门</category>
        <category>感受</category>
        <category>C语言</category>
        <category>树</category>
        <category>主干开发</category>
        <category>GitFlow</category>
        <category>GithubFlow</category>
        <category>typescript</category>
        <category>类型系统</category>
        <category>webrtc</category>
        <category>RTMP</category>
        <category>首屏时间</category>
        <category>性能优化</category>
        <category>公司</category>
        <category>个人发展</category>
        <category>战略</category>
        <category>晋升</category>
        <category>哲学</category>
        <category>幸福</category>
        <category>人生</category>
        <category>叔本华</category>
        <category>Unix</category>
        <category>Rollup</category>
        <category>mouseout</category>
        <category>mouseleave</category>
        <category>lint-staged</category>
        <category>吸顶</category>
        <category>图片组件</category>
        <category>形式系统</category>
        <category>不完全性</category>
        <category>隐喻</category>
        <category>哥德尔</category>
        <category>巴赫</category>
        <category>埃舍尔</category>
        <category>济州</category>
        <category>西归浦</category>
        <category>城山</category>
        <category>咸德</category>
        <category>人工智能</category>
        <category>心智</category>
        <category>自指</category>
        <category>图灵</category>
        <category>马列主义</category>
        <category>恩格斯</category>
        <category>家庭</category>
        <category>国家</category>
        <category>阶级</category>
        <category>氏族</category>
        <category>哲学史</category>
        <category>孔子</category>
        <category>老子</category>
        <category>儒家</category>
        <category>道家</category>
        <category>佛教</category>
        <category>禅宗</category>
        <category>理学</category>
        <category>心学</category>
        <category>计算机</category>
        <category>微机原理</category>
        <category>门</category>
        <category>操作系统</category>
        <category>数字电路</category>
        <category>2024</category>
        <category>政府</category>
        <category>经济</category>
        <category>消费</category>
        <category>土地金融</category>
        <category>饮食</category>
        <category>蛋白质</category>
        <category>碳水</category>
        <category>慢性病</category>
        <category>三高</category>
        <category>肿瘤</category>
        <category>启蒙</category>
        <category>社会主义</category>
        <category>当代史</category>
        <category>共产党</category>
        <item>
            <guid isPermalink="true">http://shenlvmeng.github.com/blog/2023/09/28/g-e-b-2/</guid>
            <title>GEB —— 集异璧之大成 下</title>
            <link>http://shenlvmeng.github.com/blog/2023/09/28/g-e-b-2/</link>
            <category>基因</category>
            <category>隐喻</category>
            <category>哥德尔</category>
            <category>巴赫</category>
            <category>埃舍尔</category>
            <category>人工智能</category>
            <category>心智</category>
            <category>自指</category>
            <category>图灵</category>
            <pubDate>Thu, 28 Sep 2023 19:43:09 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;下半部分对人工智能、计算机的探讨和前半部分有相通之处。&lt;/p&gt;
&lt;h2 id=&#34;描述的层次和计算机系统&#34;&gt;描述的层次和计算机系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;描述、组块化、旁效现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上半部分对WJ谜题的讨论以及对哥德尔、巴赫的赏析中，就出现过不同的层次，日常中&lt;strong&gt;描述是有层次的&lt;/strong&gt;。人由几十万亿个细胞组成，但日常行为却根本没法描述到每个细胞的层级。人工智能里也有和层次相关的追求，即如何构造一个系统，接收一个层次的描述，去生成另一个层级的描述。关于这方面的研究很久前就开始了，荷兰心理学家阿德里安·德·格鲁特发现大师对于棋局的感知是&lt;strong&gt;组块化的&lt;/strong&gt;。他感知的是整个棋局的战略态势（很类似《程序员思维修炼》里的&lt;a
href=&#34;https://shenlvmeng.github.io/blog/2020/05/31/pragmatic-thinking-and-learning/#%E6%91%98%E5%BD%95-2&#34;&gt;R型思维&lt;/a&gt;）。大师在对局期间，会识别棋局的&lt;strong&gt;模式&lt;/strong&gt;，对庞大可能性的树状结构做修剪。从而嗅出更大获胜可能的选择，这种直觉是涌现的。&lt;/p&gt;
&lt;p&gt;计算机系统其实很类似，也有层次的概念。庞大复杂的计算机系统也是基于模块化思路一层层构成的。从最底层的存储器、CPU、字，到有限的机器指令、机器语言，再到编译语言、解释语言、算法，层次一点点提高。运行着的程序也有着上面每个层面上的描述，层次越靠下，需要的描述就越多。计算机为了减少用户的负担，掩盖了绝大多数的低层的复杂度，只暴露最高的几个层次。其他系统也是如此，飞机的乘客并不需要知道当前的风速、油箱还有多少燃料。&lt;/p&gt;
&lt;p&gt;计算机这些年的发展里，涌现出更多的高级语言，向人工智能做着努力；不过&lt;strong&gt;计算机的全部潜能已经存在于它所有的机器指令集中&lt;/strong&gt;，指令集就是它的原子能力集合。每种高层次语言都使用着“能力空间”里的不同区域，语言并没有强迫程序员编写某类特定程序，但为他做某些事提供了便利。用不同的语言编程，就像使用不同的调式编曲，每种调式都有自己的感情色彩。人工智能要求的计算机层级可能比我们想象的还多不少。&lt;/p&gt;
&lt;p&gt;软件和硬件也是不同层级的一种表达，就像脑细胞是硬件，想象是软件，我们无法使我们的神经元更快或者更慢些，或控制它们重连。但我们仍然可以控制自己的思维方式。软件是无法超越硬件存在的，我们自己也能意识到。本书意在两者间需要一些调和途径。&lt;/p&gt;
&lt;p&gt;在低层和高层间还有一些中间层次，就像空气分子和气候间还有局部风暴这种描述。我们日常感知的这样的中间层次可能也只是高层的一部分。从最底层的夸克向上，原子物理学家有原子核的图景，化学家有通过电子构成的小分子图景，分子生物学家又可以构成大分子相互作用领域，细胞生物学家基于大分子组块化说明细胞的作用方式。科学间临近的层次间可能没那么“隔离”，不过两个相距较远的层次就没有太大关系了。人们相互沟通交往，可不需要了解夸克、原子理论、化学键、蛋白质、细胞、器官生理学等知识。当然，这种组块化&lt;strong&gt;牺牲了确定性来获得简单性&lt;/strong&gt;。让我们可以&lt;strong&gt;或然地估计&lt;/strong&gt;他人的感觉。一般来说也够用了。这种掩盖了复杂性的高层组块化描述，让低层像是黑盒。你甚至根本不知道低层做了什么。不过还好，稳定的低层子系统可以得出“可靠地”独立于自身系统的结论。这种结论是无法用低层词汇表描述的。&lt;/p&gt;
&lt;p&gt;本章最后抛出来一个“旁效现象”的说法，一个高层系统从不同的角度看有很多的“旁效现象”，这些现象往往是系统内各个层次成千上万因素相互作用的结果，不可能从某个低层找到一个答案。就像一个短跑运动员100米成绩10秒5，不代表身体的某处存着这个数字；一个人上当受骗也不代表他大脑某处有个“上当中枢”。&lt;/p&gt;
&lt;h3 id=&#34;蚂蚁赋格&#34;&gt;蚂蚁赋格&lt;/h3&gt;
&lt;p&gt;这篇很长的小品，借食蚁兽、螃蟹、阿基里斯围绕蚂蚁群体和个体关系的讨论，类比人的心智，借由符号、信号等概念，给读者心智模型的感性印象。在意识系统中，我们只能从符号层次感受自己，而无法在更低的层次感受到意识。要理解整个结构，就需要忽略组成结构的基本单元。&lt;/p&gt;
&lt;h2 id=&#34;大脑和思维&#34;&gt;大脑和思维&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;符号、信号、过程性知识、描述性知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章对人类大脑的思维的运行方式做了艰深难懂的探讨，首先，&lt;strong&gt;人的思维一定是依赖于大脑硬件中的客观存在的&lt;/strong&gt;，而且我们也能发现特定的记忆也是和局部区域的功能相关的。然而从神经元的底层生物反应到高层思维间的领域，却没人能说得清楚。以视觉为例，视觉细胞可以分为三层：简单的、复杂的、超复杂的。我们看到祖母出现在眼前当然也不会是有一个“祖母细胞”在发挥作用。不过正如刚才所说，没有人知道复杂细胞和超复杂细胞的输出在哪里或如何转换成对祖母形状、位置、图形、面容这些有意义的识别。&lt;/p&gt;
&lt;p&gt;视觉的形成会有一个汇集的过程，在光线射在视网膜上时，你可以感觉到有什么东西在脑海中&lt;strong&gt;结晶&lt;/strong&gt;了，这个过程是在视网膜作用的稍迟一些。为了更好描述思维过程，书里用“符号”这种抽象概念掩盖了底层神经元的作用过程。这里的&lt;strong&gt;符号&lt;/strong&gt;比较像是日常生活中可以用一个词或者一个固定短语描述出来的事物。&lt;/p&gt;
&lt;p&gt;在人的思维里，也有&lt;strong&gt;类&lt;/strong&gt;和&lt;strong&gt;例&lt;/strong&gt;的区分，思维善于从已有的类中制造新的例，如听到“乒乓球运动员张三”时，脑海里会想象出运动员的形象和乒乓球的场景，这也是人类想象力的基础，让人可以创造自己的人工宇宙；另外，思维也可以将一个实例作为一个新生类的范例，在补充更多的上下文和真实世界有更多相互作用后，从这个例（孩童状态）中创造新的类（成人状态），如听到“乒乓球运动员张三”的声音，知道他的历史成绩，看了他的比赛，甚至有了他的签名。之后，“张三”脱胎成为新的类。思维中激活张三便不需要其他类的帮助。在昆虫的世界里，书中以黄蜂为例，可能只有孤立的例，而没有类存在。&lt;/p&gt;
&lt;p&gt;在符号的激活通讯上，符号在大脑神经元中的存储可能是重叠而并非独立的，激活通讯同时在许多神经元上发生，就像水波可以同时承载多个波源一样。符号的唤醒也是交织在一起同时又能彼此区分的。单个符号并不能被隔离出来，它的个性体现在和其他符号的彼此联系上。我们目前没法用更精确的语言去描述这种彼此联系，而这种可以基于抽象符号描述的思维方式，是思维软件性的证明，也是智能“可抽取性”的基础。因为符号本身是可以做到移植性的。&lt;/p&gt;
&lt;p&gt;在人工智能的研究里，有过程性知识和描述性知识两种区分，前者是显式贮存地址读取的，后者是演绎式的。举个例子，“广州市有多少人”的问题会触发你读取知识点答出；而“房间里有多少人”则会触发你一个过程化方法被调用。我们日常感知的物理学和其他学科常识通常是过程性的，而有些问题则在这两种类型之间，如“唱一首生日快乐歌”。&lt;/p&gt;
&lt;h3 id=&#34;英法德中组曲&#34;&gt;英法德中组曲&lt;/h3&gt;
&lt;p&gt;小品中的诗中掺杂了很多自创字和短语，为下文介绍思维中的映射准备了例子。&lt;/p&gt;
&lt;h2 id=&#34;心智和思维&#34;&gt;心智和思维&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;自想国、自我意识、子系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一章中，对大脑和思维用符号进行了模拟化的描述。不同大脑间存在着一些重构，即对于可选符号的对应和符号触发模式的对应。书中以上篇小品的翻译为例，自创字的含义会通过其偏旁去猜测其意思，在英法德的翻译中也有类似的猜测。而这种猜测也意味着不同国家的读者在读这篇小品的过程中，大脑里也有粗略的同构。&lt;/p&gt;
&lt;p&gt;在之后，作者又用自想国为例，描述了一个事实——你所想象出的地图轮廓或多或少来自真实世界的地图（这里暗示人无法想象出没有经历过的东西）。以自想国作比喻，作者用意有双关。除了上面提到的引申之外，也借由自想国中的都市、城镇和公路类比思维中的符号和触发通路。人在自想国中旅游也是因为，当外界环境类似时，类似的触发通路也会触发同样的符号。当然，不同的人身上也会存在细微的差别。&lt;/p&gt;
&lt;p&gt;之后，书中话锋一转，开始讨论语言文化对母语者思维的影响。之后聊到在翻译外文作品的时候，保留文字原意意味着不完全忠于原文的本土化改造。就像本书尤其这几节所做的一样。作者借由威佛尔对翻译的理解，认为翻译应该像是解码文字中描述的客观意义，而不只是做字面的转译。在程序语言领域，不同语言写成的程序，可以在高层次上抽象出“概念骨架”。那么大脑可以这么做么？&lt;/p&gt;
&lt;p&gt;作者认为可以，因为我们可以用组块化去描述我们的意识活动，即虽然对于一个给定的符号，可能存在不止一条合理的触发通道，但在特定环境下，只会选择其中一条。人类往往是矛盾的混合体，在统一起来后，在某个特定时刻只表现出其中一个方面。&lt;/p&gt;
&lt;p&gt;上面的讨论和上一章可以说别无二致，但聊到&lt;strong&gt;自我意识&lt;/strong&gt;后，问题复杂了起来。人们是如何觉察到符号的触发过程，即自我意识呢？这是个自指的过程。作者认为意识是系统的一种性质，每当系统有触发模式的符号时，这种性质就会出现。这个描述很显然过于简单。之后文中提出&lt;strong&gt;子系统&lt;/strong&gt;的概念试图解释，子系统是过度生长的符号，可以翻译一种思维模式，从而可以自己产生符号。子系统不仅可以体现自我意识，和可以借助自己的符号去&lt;strong&gt;尽量模拟&lt;/strong&gt;他人的意识，有点像换位思考。这样的子系统一旦触发，几乎是自主的，就像有灵魂一样。不过我认为这段描述仍不够，解释不了这样的子系统是如何自生产符号的，以及它无限递归地意识到它自己存在时，符号和触发链路是如何工作的。&lt;/p&gt;
&lt;p&gt;本章最后用稍显明晰的卢卡斯文章材料收尾，文章里也提到，意识物可以无限递归地认识到它认识到什么事物，更关键的是，在思想无限进行下去的同时它还能自我运作起来。这意味着它能处理哥德尔式的自指问题，而机器却不行。也许机器的复杂度存在&lt;strong&gt;临界点&lt;/strong&gt;，就像核裂变一样。超出这个临界点，机器就可以形成心智，而我们无法预测它将如何运转。对于这种可以回答哥德尔式问题的东西，我们也许已不能用机器去叫它们。&lt;/p&gt;
&lt;h3 id=&#34;咏叹调及其种种变奏&#34;&gt;咏叹调及其种种变奏&lt;/h3&gt;
&lt;p&gt;这篇小品从巴赫创作哥德堡变奏曲的年份1742年引入了哥德巴赫猜想和乌龟猜想，讨论了命题证明中判定的有限和无限两种情况。Cantor在小品前后的前后呼应，以及金币被偷的前后呼应也很有趣。其中Cantor作为数学家名字出现在皮包上多个数学家名字的对角线里也是很绝。&lt;/p&gt;
&lt;h2 id=&#34;bloop和floop和gloop&#34;&gt;BlooP和FlooP和GlooP&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;算法、对角线法、停机问题、丘奇-图灵论题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在两章对于人类意识的讨论后，又回到对于递归可验证和计算机算法的探讨。从TNT中我们可以发现，一个&lt;strong&gt;充分复杂到可以反映自身的有序系统是不可能有序的&lt;/strong&gt;。换句话说，一个足够强力到可以验证“全部原始递归真理”的系统总会遇到一个它无法验证的命题。&lt;/p&gt;
&lt;p&gt;接着，书里带着探索事件背后规律的想法继续展开。为了讨论自然数，接着把&lt;strong&gt;数论和计算机算法关联起来&lt;/strong&gt;，首先BlooP（Bounded
loop）语言被发明出来，它的控制结构包含分支、&lt;strong&gt;有界&lt;/strong&gt;循环（for
loop），以及退出循环的QUIT、退出过程的ABORT。这样写出的BlooP过程（procedure）即BlooP函数，另外我们约定接受一个唯一的参数N且输出YES或NO的BlooP函数被称为&lt;strong&gt;测试&lt;/strong&gt;，它可以用来验证一些命题。像计算机编程里一样，之前定义过的每个BlooP过程都可以直接被拿来当做一个组块（模块化）。&lt;/p&gt;
&lt;p&gt;在这样的BlooP语言里，我们可以写一个定义质数的BlooP测试PRIME?，伪代码像下面这样&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;DEFINE PROCEDURE&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;PRIME?&amp;quot;[N]:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;BLOCK 0:BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  IF N=0,THEN:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  QUIT BLOCK 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  CELL(0)&amp;lt;-2 # 把CELL(0)置为2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  LOOP AT MOST MINUS[N,2] TIMES:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  BLOCK 1:BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    IF REMAINDER[N, CELL(0)]=0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    THEN:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    QUIT BLOCK 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    CELL(0)&amp;lt;-CELL(0)+1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  BLOCK 1:END;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  OUTPUT&amp;lt;-YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;BLOCK 0:END.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以用BlooP定义出来的过程都可以预知终止结果，这样的函数叫做&lt;strong&gt;原始递归函数&lt;/strong&gt;，而可以这么验证的性质被称为&lt;strong&gt;原始递归谓词&lt;/strong&gt;。哥德巴赫猜想也可以很轻松写出一个BlooP测试，另一方面，也可以用BlooP函数写一些计算自然数的功能，如阶乘、求余数、斐波那契数列，甚至是用哥德尔配数法表示的定理。&lt;/p&gt;
&lt;p&gt;在讨论FlooP之前，有必要再次赘述下&lt;strong&gt;可表示性&lt;/strong&gt;和&lt;strong&gt;可表现性&lt;/strong&gt;，前者是指能否将一个自然语言的性质形式化表述出来，比如可以轻易用TNT串表示出，一个数b具有“乌龟性质”（作者在上节小品里提的哥德巴赫猜想的2-1=1版本）。但是可表现性意味着，该谓词的全部为真的实例皆为定理，全部为假的实例均为非定理。这也是TNT作为一个公理系统到底有多强力的体现。虽然这种完全性在后面将被发现不存在，但TNT对于&lt;strong&gt;原始递归谓词&lt;/strong&gt;来说还是完全的，即如果数论中某个陈述的真假可以在可预知时间段内判定，那在TNT中一定也是可判定的。&lt;/p&gt;
&lt;p&gt;那么存在非原始递归么？我们可以设想一个存放所有BlooP程序的库，&lt;strong&gt;B库&lt;/strong&gt;。它必然是无穷大的。之后，我们在库里筛选出满足下面条件的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只接受1个参数&lt;/li&gt;
&lt;li&gt;返回数字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后将筛选过后的特殊程序称作蓝程序（Bloo发音近似blue，P指代Program），由于蓝程序由有限的字符集组成，我们可以按照程序代码在ASCII码中的字典序来排列，这样每一个蓝程序都可以有一个唯一的索引编号。从而用&lt;code&gt;蓝程序&amp;#123;k&amp;#125;[N]&lt;/code&gt;来表示第k个蓝程序。&lt;/p&gt;
&lt;p&gt;之后用康托尔使用的&lt;strong&gt;对角线法&lt;/strong&gt;，可以制造一些不能在BlooP中编程的函数。我们不妨称之为蓝对角，定义如下：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;蓝对角[N] = 1 + 蓝程序&amp;#123;#N&amp;#125;[N]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的蓝对角不能存在于蓝程序中，因为假如存在，它一定有一个编号，假设为X。那么根据蓝程序的定义&lt;code&gt;蓝对角[N] = 蓝程序&amp;#123;X&amp;#125;[N]&lt;/code&gt;，代入X可以得到&lt;code&gt;蓝对角[X] = 蓝程序&amp;#123;X&amp;#125;[X]&lt;/code&gt;；同时根据蓝对角的定义，代入X可以得到&lt;code&gt;蓝对角[X] = 1 + 蓝程序&amp;#123;X&amp;#125;[X]&lt;/code&gt;，两者相互矛盾。从而意味着一定存在&lt;strong&gt;非原始递归函数&lt;/strong&gt;，映射到数论中，一定存在某个数论中的函数没法在可预测的步数内被算出来。实际上，对于每个给定的N，蓝对角可以转化到蓝程序从而步数可预测，但每个N的步数预测不能结合成一个朴实的方法去预测&lt;code&gt;蓝对角[N]&lt;/code&gt;的计算步数。&lt;/p&gt;
&lt;p&gt;对角线论证源于康托尔论证如果建立一个实数登记表，那么会不可避免的排除一些实数。论证过程上，构造了一个这样的表然后按&lt;strong&gt;对角线的形式&lt;/strong&gt;取第n行第n列，之后将每个数都减1，这样得到的数总有一位和每一行都不一样，从而排除于表之外。这个证明过程实质上用了&lt;strong&gt;两种方式使用了同一个整数&lt;/strong&gt;（横向和纵向索引），在蓝对角里也是如此（程序索引序号和输入参数）。&lt;/p&gt;
&lt;p&gt;看到了BlooP的局限性，我们可以发明一个FlooP（Free
Loop）语言。它的μ算子可以包括一个无穷的循环。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;MU-LOOP&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;BLOCK n:BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;BLOCK n:END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设用它来验证妙极性（角谷猜想最后的1-4-2-1-4-2循环），那么，如果输入的N是妙极的，那么程序会返回YES，如果是非妙极的，那么要么程序返回非1-4-2的循环，要么干脆没有返回永不停歇。后面这种情况就是个&lt;strong&gt;无终止过程&lt;/strong&gt;。对于FlooP多出来的无终止过程，可以和有终止过程分成两类。那么对于每个FlooP程序，我们是否可以通过一个复杂的&lt;strong&gt;有终止过程&lt;/strong&gt;的检测可以得到它是否无终止过程呢？如果存在这种检测，我们就可以通过它的返回验证妙极性和乌龟猜想了。&lt;/p&gt;
&lt;p&gt;首先我们需要改造BlooP，让它可以接受程序而非数字。哥德尔配数可以帮我们完成。将程序的字符映射成数字即可。阿兰·图灵使用对角线法类似的思路（往这种终止检验程序中输入它自己的哥德尔数）证明不存在这样的BlooP函数。书中用另外的方法做了证明。&lt;/p&gt;
&lt;p&gt;类似蓝对角，我们构造同样的&lt;strong&gt;绿对角&lt;/strong&gt;（绿灯和free对应）：&lt;code&gt;绿对角[N]=1+绿程序&amp;#123;N&amp;#125;[N]&lt;/code&gt;。现在问题来了，由于F库中还存在无终止过程，我们需要把它们剔除。刚才提到的“终止检测器”可以帮我们实现，经过它的过滤得到的绿程序我们可以叫做红程序（总会遇到红灯停下）。之后红对角会面临和蓝对角一样的困境。&lt;/p&gt;
&lt;p&gt;要么我们用GlooP表示一个比FlooP更强大的存在，要么接受不存在这样的终止检测器。但实际上，我们现在的计算机语言只能做到FlooP的地步。阿兰·图灵和阿朗佐·丘奇定理独立论证了不存在这样的GlooP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人能计算的就是机器能计算的&lt;/li&gt;
&lt;li&gt;机器能计算的就是FlooP能计算的&lt;/li&gt;
&lt;li&gt;人能计算的也就是FlooP能计算的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;g弦上的咏叹调&#34;&gt;G弦上的咏叹调&lt;/h3&gt;
&lt;p&gt;小品里对使用-引用做了讨论，提出了自引用的说法，如“‘放在其引文形式后面得到假句子’放在其引文形式后面得到假句子”。&lt;/p&gt;
&lt;h2
id=&#34;论tnt及有关系统中形式不可判定的命题&#34;&gt;论TNT及有关系统中形式不可判定的命题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;证明对、㧟摁、算术㧟摁、哥德尔第二定理、ω不完全性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的小品引导下，本章逐步用自引用和反例构成悖论，体现TNT的ω不完全性。首先，在前面的章节里能看到，通过&lt;strong&gt;哥德尔配数法&lt;/strong&gt;，TNT有自省能力，即可以表述自身。再结合上一章中的&lt;strong&gt;对角线方法&lt;/strong&gt;，两个关键概念已经集齐。&lt;/p&gt;
&lt;p&gt;为了制造自我指涉，首先引入&lt;strong&gt;证明对&lt;/strong&gt;的概念——&lt;strong&gt;两个自然数（m和n）形成一个证明对，当且仅当m是TNT推导的哥德尔数，n是推导最后一行（即结论）的哥德尔数&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;WJ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;WJJ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;WJJJJ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;WUJ&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从而m=3131131111301和n=301时构成证明对。TNT也是一个道理。要证明一对mn是证明对是很简单的，观察m代表的推导过程有无问题，以及n是不是最后一行的结论。从而&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“是证明对”这个性质是原始递归的，即可以用一个BlooP程序测试；进一步地，&lt;strong&gt;可以被一个有两个自由变元的公式在TNT中体现&lt;/strong&gt;（这一步很关键）&lt;/li&gt;
&lt;li&gt;要断定n是一个&lt;strong&gt;定理数&lt;/strong&gt;，就是要找到一个m和n构成证明对&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面提到的BlooP测试程序写成TNT的形式，用WJU系统可以叫做&lt;code&gt;WJU-PROOF-PAIR&amp;#123;a,a&#39;&amp;#125;&lt;/code&gt;，自由变元&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;a&#39;&lt;/code&gt;可以接受2个WJU形式系统的哥德尔数，检测它们是否构成证明对。同样的，在TNT系统里叫做&lt;code&gt;TNT-PROOF-PAIR&amp;#123;a,a&#39;&amp;#125;&lt;/code&gt;。假设我们要表示&lt;code&gt;0=0&lt;/code&gt;是TNT定理，那么TNT公式可以写成&lt;span
class=&#34;math inline&#34;&gt;\(∃a:TNT-PROOF-PAIR\{a,
SSS...SSS0/a&amp;#39;\}\)&lt;/span&gt;，其中有a’的值666,111,666（&lt;code&gt;0=0&lt;/code&gt;）个S。OK，目前为止，我们已经将是TNT定理数&lt;strong&gt;表示&lt;/strong&gt;出来了&lt;/p&gt;
&lt;p&gt;&lt;span
class=&#34;math display&#34;&gt;\[∃a:TNT-PROOF-PAIR\{a,a&amp;#39;\}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但并未担保这个性质原始递归。之后，让我们将&lt;strong&gt;代入&lt;/strong&gt;引入到哥德尔数里，代入即将所有自由变元都用数字替换。同样的，哥德尔数表示后也可以做这个替换，例如将&lt;span
class=&#34;math inline&#34;&gt;\(a=a\)&lt;/span&gt;替换为&lt;span
class=&#34;math inline&#34;&gt;\(SS0=SS0\)&lt;/span&gt;，对应的哥德尔数就从262,111,262替换为123,123,666,111,123,123,666。容易看到这个&lt;code&gt;哥德尔数&amp;lt;-&amp;gt;插入的具体数字&amp;lt;-&amp;gt;结果哥德尔数&lt;/code&gt;的关系是&lt;strong&gt;原始递归&lt;/strong&gt;的，即可以写一个BlooP测试，验证给的3个数字是否满足这个关系（都翻译回TNT表示，再观察即可）。从而，可以用一个有三个自由变元的TNT公式来体现。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[SUB\{a,a&amp;#39;,a&amp;#39;&amp;#39;\}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将满足上面关系的3个数代入公式，就可以得到一个TNT定理。例如&lt;span
class=&#34;math inline&#34;&gt;\(SUB\{SSS...SSS0/a,SS0/a&amp;#39;,SSS...SSS0/a&amp;#39;&amp;#39;\}\)&lt;/span&gt;，其中第一个参数有262,111,262个S，第三参数有123,123,666,111,123,123,666个S。&lt;/p&gt;
&lt;p&gt;接下来引入“&lt;strong&gt;算术㧟摁&lt;/strong&gt;”（自引用）的概念，试图把&lt;code&gt;TNT-PROOF-PAIR&lt;/code&gt;和&lt;code&gt;SUB&lt;/code&gt;合成一个单一的TNT句子。我们定义将&lt;strong&gt;公式自身的哥德尔数代入公式&lt;/strong&gt;称为㧟摁，得到一种谈论自身的公式的感觉。首先需要一个至少一个自由变元的公式如&lt;span
class=&#34;math inline&#34;&gt;\(a=S0\)&lt;/span&gt;，接入代入它的哥德尔数262,111,123,666得到&lt;span
class=&#34;math inline&#34;&gt;\(SSS...SSS(262,111,123,666个S)0=S0\)&lt;/span&gt;。既然是代入，&lt;strong&gt;算术㧟摁&lt;/strong&gt;就可以用&lt;span
class=&#34;math inline&#34;&gt;\(SUB\{a&amp;#39;&amp;#39;,a&amp;#39;&amp;#39;,a&amp;#39;\}\)&lt;/span&gt;来表示，里面前两个参数是相同的，可以观察到对角线法的影子，这里数&lt;code&gt;a&#39;&#39;&lt;/code&gt;既作为公式的哥德尔数，又作为代入的数字。为了便于使用，我们简记为&lt;/p&gt;
&lt;p&gt;&lt;span
class=&#34;math display&#34;&gt;\[ARITHMOQUINE\{a&amp;#39;&amp;#39;,a\}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用汉语说就是，&lt;code&gt;a&#39;&lt;/code&gt;是哥德尔数为&lt;code&gt;a&#39;&#39;&lt;/code&gt;的公式做算术㧟摁（即代入&lt;code&gt;a&#39;&#39;&lt;/code&gt;）所得公式的哥德尔数，换句话说，&lt;strong&gt;a&#39;是a&#39;&#39;的算术㧟摁化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在为止，两个组件都有了。现在给出那个&lt;strong&gt;㧟摁一个提及㧟摁的句子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span
class=&#34;math display&#34;&gt;\[~∃a:∃a&amp;#39;:&amp;lt;TNT-PROOF-PAIR\{a,a&amp;#39;\}&amp;gt;∧ARITHMOQUINE&amp;lt;a&amp;#39;&amp;#39;,a&amp;#39;&amp;gt;\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个符号串当然有一个哥德尔数，叫它&lt;code&gt;u&lt;/code&gt;吧。我们现在要㧟摁这个符号串，即把唯一的自由变元&lt;code&gt;a&#39;&#39;&lt;/code&gt;替换成u。得到&lt;span
class=&#34;math inline&#34;&gt;\(~∃a:∃a&amp;#39;:&amp;lt;TNT-PROOF-PAIR\{a,a&amp;#39;\}&amp;gt;∧ARITHMOQUINE&amp;lt;SSS...SSS(u个S)/a&amp;#39;&amp;#39;,a&amp;#39;&amp;gt;\)&lt;/span&gt;。考虑到它和哥德尔的用法接近，我们叫它&lt;code&gt;G&lt;/code&gt;。好的，现在问题来了&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;G的哥德尔数是什么？&lt;/li&gt;
&lt;li&gt;G怎么解释？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，既然G是对原符号串的㧟摁化，那么&lt;strong&gt;G的哥德尔数自然是u的算术㧟摁化&lt;/strong&gt;。好，看第二个问题，从字面意义翻译可以得到“不存在数a和a’使得（1）它们形成TNT证明对，同时（2）a&#39;是u的算术㧟摁化”。根据刚才的加粗，G的哥德尔数就是u的算术㧟摁化。那么肯定是a出了问题。现在可以简化翻译成“没有一个数a能与u的算术㧟摁化形成TNT证明对”，换句话说，“以u的算术㧟摁化为哥德尔数的&lt;strong&gt;公式G不是TNT定理&lt;/strong&gt;”。那么这句话本身是谁呢？就是&lt;code&gt;G&lt;/code&gt;。因此，我们可以得到最终翻译：&lt;/p&gt;
&lt;p&gt;“G不是TNT定理”（G是这句话本身）&lt;/p&gt;
&lt;p&gt;我们构造出了一个TNT元语言句子。这句看着就有悖论意味的话可以很容易找到矛盾。如果G这句话是定理，那么G就是TNT中的真理，这和G在说的矛盾。如果G不是定理，那么就存在一个不是TNT定理的真理，也有矛盾。这个定理在TNT系统中&lt;strong&gt;无法判断真假&lt;/strong&gt;。上面这段过程用TNT和数论的语言结合自引用的思路构造出了悖论。&lt;/p&gt;
&lt;p&gt;哥德尔在论文中，对于在可以“自我反映的元数学”中证明TNT的一致性做了探讨。但最终通过类似上面的构造证明只要TNT一致——用TNT符号写出的一致性语句不是个TNT定理。可见纵然TNT在&lt;strong&gt;表示&lt;/strong&gt;事物时，反省能力很强，但要&lt;strong&gt;证明&lt;/strong&gt;这些事物，反省能力就比较差了。&lt;/p&gt;
&lt;p&gt;本书在第8章第一次介绍印符数论的的时候提到过ω不完全性，即无法从特例到规律。上面找到的G就是一个例子。将里面a&#39;&#39;替换成每个具体的数，都可以验证为真，但对G就无法判断。可以用第8章的方法，人为定义G的真假，来朝非欧几何一样的方向发展，但无论怎么加都会和我们对自然数的认识抵触。书里发明了超自然数和广义自然数的概念来解释，它们和自然数的性质没什么区别，但可以兼容&lt;span
class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt;或者&lt;span
class=&#34;math inline&#34;&gt;\(~G\)&lt;/span&gt;。G和~G的证明需要无穷步，因此不会干扰正常的自然数性质，对正常生活没有影响，但对元数学家有很重要。在本章最后，作者又将丢番图方程是否有整数解和数论中的G关联了起来。&lt;/p&gt;
&lt;h3 id=&#34;生日大合唱哇哇哇呜啊呜啊呜啊&#34;&gt;生日大合唱哇哇哇呜啊呜啊呜啊&lt;/h3&gt;
&lt;p&gt;小品里乌龟用近乎无理取闹的方式给了ω答案模式和之后的各种迭代，只为证明阿基里斯生日的事实，同时为下章试图跳出系统的构造方法设好铺垫。&lt;/p&gt;
&lt;h2 id=&#34;跳出系统&#34;&gt;跳出系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;多重分叉，本质不完全性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一章里，我们发现在TNT里存在一个“漏洞”——存在一个不可判定的句子G。那如果把这个漏洞补上呢，构造一个TNT+G的形式系统。对于TNT+G也可以同样&lt;span
class=&#34;math inline&#34;&gt;\((TNT+G)-PROOF_PAIR{a,a&amp;#39;}\)&lt;/span&gt;的思路构造一个G&#39;（用TNT+G的字符串表示我在形式系统TNT+G中不可证）来制造矛盾。这种不断给漏洞打正反命题的方式（G，~G）在TNT下形成了多重分叉的树。&lt;/p&gt;
&lt;p&gt;然而，加入补丁后的形式系统仍可以找到“我在形式系统X中不可证”的字符串。所有这些“漏洞”构造方式相似，似乎可以找到一条公理模式&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω}\)&lt;/span&gt;来表示所有这些G、G&#39;、G&#39;&#39;。那么我们把&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω}\)&lt;/span&gt;加入到TNT中呢，能否补全这个漏洞。但既然有一个模子&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω}\)&lt;/span&gt;来刻画G，也会有一种方法用算术模子来描述其对应的哥德尔数。用公式&lt;span
class=&#34;math inline&#34;&gt;\(OMEGA-AXIOM{a}\)&lt;/span&gt;描述，它的解释是&lt;strong&gt;a是出自&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω}\)&lt;/span&gt;一条公理的哥德尔数&lt;/strong&gt;。借助这个公式，就可以在&lt;span
class=&#34;math inline&#34;&gt;\(TNT+G_{ω}\)&lt;/span&gt;内部体现&lt;strong&gt;&lt;span
class=&#34;math inline&#34;&gt;\(TNT+G_{ω}\)&lt;/span&gt;证明对&lt;/strong&gt;的更复杂的概念。从而可以用一模一样的套路构造一个用来算术㧟摁的字符串，之后继续不可判定。我们叫它&lt;span
class=&#34;math inline&#34;&gt;\(TNT+G_{ω+1}\)&lt;/span&gt;。为什么&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω}\)&lt;/span&gt;没法生成出&lt;span
class=&#34;math inline&#34;&gt;\(G_{ω+1}\)&lt;/span&gt;呢？答案是它自身还没有“聪明”到意识这一点。就像乌龟制造“不能播放的唱片”一样。&lt;/p&gt;
&lt;p&gt;依照哥德尔的手段，一个系统本身的性质在证明对概念之内得到反映，然后再针对它使用这些性质，就可以“以子之矛，攻子之盾”。一个系统不论多复杂，都能进行哥德尔配数，因而就能定义证明对。这其实和康托尔的对角线法类似——&lt;strong&gt;明确地排列&lt;/strong&gt;一组实体。在康托尔的办法里，实数们的“详细梳理完毕”导致了无法自圆其说。在构造出不在列表里的数L后，把它添加进去试图弥补漏洞，只会得到一个新的漏洞L&#39;。一旦&lt;strong&gt;确定了唱机的“体系结构”&lt;/strong&gt;，唱机就必然会被找到弱点。因此TNT患上的是&lt;strong&gt;本质不完全性&lt;/strong&gt;——这种不完全性就是TNT的基础组成部分。事实上，在一个系统里，能否利用哥德尔的自指办法构造不可判定的字符串，只依赖下面三个条件：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;系统要做足够丰富，以便容纳所有关于数的描述，不管是真是假（能构造命题）&lt;/li&gt;
&lt;li&gt;所有一般递归关系都可以用系统公式体现（能进行推导）&lt;/li&gt;
&lt;li&gt;公理和根据系统规则得到的印符模式，都能通过&lt;strong&gt;有限过程&lt;/strong&gt;来辨识（能形式化证明）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任何这样的系统在内部存在“黑洞”，这种系统强得能有自指句子，也因此自我崩塌。&lt;/p&gt;
&lt;p&gt;书中后面引用了卢卡斯的观点——由于哥德尔式论证的存在，人类思想具有某种难以捉摸、不可名状的特点，这使得“机械自动机”——计算机无法达到人工智能的高度。看起来很显而易见，毕竟人们总能跳出系统，在机器身上实施哥德尔手段（思路类似于计算机依赖刻板的内部编码-&amp;gt;同构于形式系统-&amp;gt;可以完成原始递归算术-&amp;gt;上了哥德尔的“圈套”），所以我们总是知道的更多。作者并不赞同这种观点，本质在于我们总是&lt;strong&gt;处于系统之外&lt;/strong&gt;，但机器不是，就像二维生物无法想象三维生物的细节一样。看起来我们在写出哥德尔方法的公式，但我们写出哥德尔方法的过程也是机械式的从ω到ω+1，再到&lt;span
class=&#34;math inline&#34;&gt;\(ω_{ω}\)&lt;/span&gt;，&lt;span
class=&#34;math inline&#34;&gt;\(ω_{ω+1}\)&lt;/span&gt;，而无法跳出系统之外。&lt;/p&gt;
&lt;p&gt;更直观一点，人本身也无法很好处理哥德尔手段的文字圈套，即&lt;strong&gt;悖论&lt;/strong&gt;，如“我这句话是假话”、“只给不给自己理发的人理发的理发师”。人的大脑也没法做到前后一致的理解。人类无法超越自身就像计算机无法跳出自身一样。TNT可以讨论自身，却不能跳出自身——一个计算机程序可以修改自己，但不能违背自己的指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳出自身，化身观察者&lt;/strong&gt;成为了后面的论题。书里从文学作品说到禅宗。禅宗顿悟的过程也是这样的过程——&lt;strong&gt;逐步加深一个人的自我意识，逐步扩展“系统”的范围，最终感到和整个宇宙一致，突破自己达成顿悟&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;一个烟民富于启发性的思想&#34;&gt;一个烟民富于启发性的思想&lt;/h3&gt;
&lt;p&gt;小品里讨论了自我复制的病毒、尝试拍摄自身的摄影机和显示器、自我指代的马格利特的画作。&lt;/p&gt;
&lt;h2 id=&#34;自指和自复制&#34;&gt;自指和自复制&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;自复制、副本、印符遗传学、串、基、酶、氨基酸、核糖体、翻译、转录、DNA、mRNA、tRNA、蛋白质、中心法则、反馈、分化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上章借助自指构造矛盾后，这一章开头给出了很多自指或者自复制的例子，包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本句子有七个字这种自我描述的句子&lt;/li&gt;
&lt;li&gt;可以打印自身函数体的程序&lt;/li&gt;
&lt;li&gt;打印自身哥德尔数的程序&lt;/li&gt;
&lt;li&gt;凯姆式自复制（输入一条会导致打印自身的错误信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在对原件和复件做了不同层级的探讨后，引入了本章的主要内容：作者发明的印符遗传学，和遗传学相似但又有些改造的模型，在分子生物学之上、遗传学之下。印符遗传学有着和遗传学一样的&lt;strong&gt;基&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A（腺嘌呤）&lt;/li&gt;
&lt;li&gt;C（胞嘧啶）&lt;/li&gt;
&lt;li&gt;G（鸟嘌呤）&lt;/li&gt;
&lt;li&gt;T（胸腺嘧啶）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前面的章节我们已经发现了这四个字母碰巧也可以代表A（阿基里斯，Achilles），C（螃蟹，Crab），G（基因，Gene），T（乌龟，Tortoise）把这些符号连一起可以构成&lt;strong&gt;串&lt;/strong&gt;，串可以被印符酶（简称为&lt;strong&gt;酶&lt;/strong&gt;）操作，移动、插入、删除等等。另外，嘌呤（A、G）和嘧啶（C、T）可以相互配对，其中A和T、C和G。酶可以使用的指令有15种，它们都有一个3个字母的代号，就像机器语言里一样，如cut、mov、rpy等，这样一个指令称为&lt;strong&gt;氨基酸&lt;/strong&gt;，酶正是由氨基酸构成的。因此，一个串会按照氨基酸的指令逐步被处理，最终得到新串。&lt;/p&gt;
&lt;p&gt;那么串和酶还有什么关系呢？刚刚得到的新串，可以按照一个新的规则（书中叫做印符遗传密码）在核糖体里“翻译”成一个个氨基酸，并最终构成酶。例如，AC可以翻译为cut。具体可以参见下面的表格。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;G&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cut(s)&lt;/td&gt;
&lt;td&gt;del(s)&lt;/td&gt;
&lt;td&gt;swi(r)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;mvr(s)&lt;/td&gt;
&lt;td&gt;mvl(s)&lt;/td&gt;
&lt;td&gt;cop(r)&lt;/td&gt;
&lt;td&gt;off(l)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;ina(s)&lt;/td&gt;
&lt;td&gt;inc(r)&lt;/td&gt;
&lt;td&gt;ing(r)&lt;/td&gt;
&lt;td&gt;int(l)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;rpy(r)&lt;/td&gt;
&lt;td&gt;rpu(l)&lt;/td&gt;
&lt;td&gt;lpy(l)&lt;/td&gt;
&lt;td&gt;lpu(u)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意到表格单元格的最后，括号里的符号表示了氨基酸的前进方向，这也形成了酶的三级结构，s代表straight，l代表left、r代表right。之后我们把第一段氨基酸调整到指向右边，那么根据最后一段的指向，分别代表酶初始化挂载的基是A还是C、G、T。可以发现，在确定酶的三级结构上，所有氨基酸都发挥了作用。另外，AA代表标点符号，标识一段串的结尾。&lt;/p&gt;
&lt;p&gt;读串并生成新的酶的过程，实际上由核糖体完成。至此，我们就可以从最初的串生成新的酶，新的酶又可以继续作用在串上形成新的酶，如此不断往复。在印符遗传学里，中心法则就是&lt;strong&gt;酶-印符操作-&amp;gt;串-核糖体翻译-&amp;gt;酶&lt;/strong&gt;。在这个循环里，串既充当了程序的作用，又充当了数据的作用。到这里，又和TNT有点像了。&lt;/p&gt;
&lt;p&gt;生物学里的情况和这里很像。DNA就是“串”，蛋白质就是“酶”。DNA由核苷酸长链组成，核苷酸上的基标识了不同的核苷酸，正是A、C、G、T。核苷酸间通过共价键紧密连接，DNA双链间互补的核苷酸通过弱得多的氢键相连。在细胞核内部，DNA的一条链通过RNA聚合酶&lt;strong&gt;转录&lt;/strong&gt;得到信使RNA（mRNA）。RNA和DNA的不同在于U（尿嘧啶）取代了T和A配对。核糖体其实不止制造酶，而是所有蛋白质。同时氨基酸共有20多种。mRNA在核糖体上的&lt;strong&gt;翻译&lt;/strong&gt;过程和印符遗传密码类似，不过是以三个基为单位，如CAU产生组氨酸（his）。氨基酸间通过更强的共价键（肽键）组成蛋白质，蛋白质的三级结构比印符遗传学复杂得多，最终的结构和每个酶的关系目前也没有结论。在翻译过程中，需要的氨基酸，由对应的转运RNA（tRNA）运送过来。最后，UAA、UAG、UGA发挥着印符遗传学里AA的标点作用，表示一段翻译的结束。从DNA到蛋白质的过程便是如此。蛋白质和音乐有着一些相似，氨基酸就像印符，其连接起来组成的二级和三级结构就像旋律、乐章给人的乐曲感。并行工作的RNA聚合酶和核糖体产出多个蛋白质就像卡农的多个声部一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RNA聚合酶和核糖体（由蛋白质和rRNA组成）外加DNA就组成了一个自复制的最小支撑系统&lt;/strong&gt;，DNA在其中既作为待复制的“数据”，又作为需要执行什么操作的“指令”。从DNA到蛋白质的过程称为&lt;strong&gt;基因表达&lt;/strong&gt;。蛋白质再往上若干个我们无法把握的层次从遗传型跃升到表现型，从而决定人的精神、心智、物理表现。遗传学的中心法则和TNT的中心法则一一映射，其中DNA即TNT串，mRNA即数论描述，蛋白质即元TNT的陈述，遗传密码即哥德尔编码。有意思的是，数理逻辑在嘌呤一方（算术化（Arithemetization）、哥德尔（Godel）），分子生物学在嘧啶一方（翻译（Translation），克里克（Crick）），同时A和T构成基对，C和G构成基对。&lt;/p&gt;
&lt;p&gt;那么问题来了？按这个映射，哥德尔不完全定理对应什么？借《对位藏头诗》小品里的唱机和唱片，得到这样的描述&lt;/p&gt;
&lt;p&gt;&lt;em&gt;总可以设计一个DNA串，如果把它注入到细胞中，在被转录时它将促使一些将会毁掉这个细胞的蛋白质或DNA生成出来&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当然这在分子生物学家那里看来有些诡异。不过和噬菌体摧毁大肠杆菌有点像。噬菌体的DNA通过伪装绕过了大肠杆菌细胞内的酶的检查，使之可以被核糖体翻译出来。有趣的是噬菌体（T方）和细胞（Cell）的TC之争就像乌龟（Tortoise）和螃蟹（Crab）之争。&lt;strong&gt;对于能否在特定的细胞内形成的“噬菌体句子”，在数理逻辑里有对应的描述——汉肯句子&lt;/strong&gt;。隐式汉肯句子在说“存在某个符号串序列是我的推导”，显示汉肯句子是说“这里描述的符号串序列...就是我的推导”。前者就像只给DNA病毒组成编码的自组装病毒，可以自行利用化学亲和力链接，后者还加上了组装需要的酶。&lt;/p&gt;
&lt;p&gt;细胞分化形成不同功能的细胞，最终形成不同形态。这个过程是通过阻遏让基因不被表达实现的，诱导物又可以和阻遏蛋白结合，阻止阻遏的发生。整体来看，细胞里发生的这一切的机制比人为设计出来的形式系统都要深奥的多。在这各种过程里，DNA、蛋白质、核糖体、tRNA分子它们即可以作为“数据”、也可以作为“程序”、也可以作为“解释程序”或者“处理机”。巧合的是，人工智能研究里也有着把看上去不同的所有方面混为一谈的趋势。&lt;/p&gt;
&lt;h3 id=&#34;的确该赞美螃蟹&#34;&gt;的确该赞美螃蟹&lt;/h3&gt;
&lt;p&gt;小品里把TNT命题类比乐曲，命题的真假类比乐曲是否悦耳。&lt;/p&gt;
&lt;h2 id=&#34;丘奇图灵塔斯基和别的人&#34;&gt;丘奇、图灵、塔斯基和别的人&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;丘奇定理、塔斯基-丘奇-图灵定理、拉马努金、真理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一章把话题引向生物学后，这一章又回到对于思维的讨论。书中在“大脑与思维”一章里实际上已经做了很多探讨，思维有无数层面，它还有一个形式化的硬件层级（可以叫它基底）。在从下到上的不断“组块化”下，每一步都会损失严格性，直到顶层复杂到我们找不到词汇去思考规律。&lt;/p&gt;
&lt;p&gt;在小品里螃蟹似乎有一种&lt;strong&gt;直觉&lt;/strong&gt;可以区分出音乐是不是优美。然而这违背了丘奇定理：&lt;strong&gt;没有切实可靠的方法来区分TNT的定理和非定理&lt;/strong&gt;。类似地还有塔斯基-丘奇-图灵的描述：没有切实可靠的方法来区分真的数论语句和假的数论语句。它还有许多表述形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准形式：把数分成两类的任何一个心智过程都可以用FlooP程序来描述&lt;/li&gt;
&lt;li&gt;大众过程形式：把数分成两类的任何一个可以用语言完美传达的心智过程都可以用FlooP程序来描述&lt;/li&gt;
&lt;li&gt;同构形式：把数分成两类的任何一个可以用语言完美传达的心智过程都可以用FlooP程序来描述，且&lt;strong&gt;心智过程和FlooP在下面意义上同构：某个层次上，计算机和大脑执行的步骤间存在对应&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拉马努金和一些神童似乎有神谕一般突破这种限制的能力，似乎能绕过数学、分析的方法解决问题，不过这只是因为这些人的中间步骤完成的十分迅速而已，他们也不是通过某种顿悟式的闪念来得到答案。有一个简单的证据是，当数字变大时，答案出来的就慢了。&lt;/p&gt;
&lt;p&gt;大脑的神经元活动作为基质，本身并没有意义，它之上各种符号的意义是在进化环境中作为后效出现的。因此计算机在模拟神经元网络时，原则上可以用可执行的计算来描述。可以因此给出丘奇-图灵命题的另外2种形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微观形式：生物体各组成部分的行为可以用计算机来模拟，也就是说，任何元素的行为都可以用一个FlooP程序来计算到任意精确的程度&lt;/li&gt;
&lt;li&gt;简化论形式：&lt;strong&gt;全部的大脑过程可以用一个可计算的基质导出&lt;/strong&gt;，这也是人工智能可行性的理论基础；人工智能的一个意义在于可能会有一些意义重大的智能特征是漂浮在这种生物大脑基质以外的基质之上的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，人工智能绝不只是简单的大脑模拟。&lt;/p&gt;
&lt;p&gt;回到螃蟹的问题，美感是不是大脑过程；对此，作者认为大脑能做的某些事情都可以用计算机来模拟，但计算机不能代替灵魂。尽管美感是个非理性过程，但不代表它和计算机就不相容。因为，&lt;strong&gt;低层次的理性不妨碍高层次的非理性&lt;/strong&gt;。大脑都是由简单的神经元组成，但也会想出悖论，换句话说，&lt;strong&gt;大脑是理性的，但心智不是&lt;/strong&gt;。书里用类似的说法，驳斥了卢卡斯机器不如心智的观点，然后给出了丘奇-图灵论题的最后一种形式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人工智能形式：任何种类的四年制过程都可以用计算机程序模拟，而程序语言和FlooP一样强，也可以说递归函数都可以用这种语言程序化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;美来源于形式，形式通过共鸣来传达，无法语言传递。字面意义的“句法性质”很好表述，但是形式的&lt;strong&gt;语义&lt;/strong&gt;方面则需要无尽头的检验，它是经验编码的，和无数客体存在联系，且在不同人心里都可能引起不同解释器的反应。&lt;/p&gt;
&lt;h3 id=&#34;施德鲁人设计的玩具&#34;&gt;施德鲁，人设计的玩具&lt;/h3&gt;
&lt;p&gt;小品展示了“施德鲁”这个新的AI模型对语言的理解。&lt;/p&gt;
&lt;h2 id=&#34;人工智能回顾&#34;&gt;人工智能：回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;图灵测试、人工智能、知识表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图灵在自己对计算机和智能的研究中，提出过图灵测验的过程，即机器能否在交谈中向人隐藏自己是机器的能力，图灵对于机器是否能有思维的讨论在那个年代遇到了许多反对意见。在作者的年代，人工智能很显然进步了许多，后面的篇幅对于人工智能的发展现状做了简单的综述式的介绍。&lt;/p&gt;
&lt;p&gt;人工智能的起步很早，在19世纪，布尔和德·摩根就提出了“思维定律”——本质上是命题演算——因此迈出人工智能软件的第一步。随着时代的服战，越来越多“智能”的成果涌现出来。似乎&lt;strong&gt;某个心智功能被程序化之后，人们一旦习惯这种存在便不再把它当做“真正的思维”本质成分&lt;/strong&gt;。换句话说，目前为止，&lt;strong&gt;人工智能是尚未做到的部分&lt;/strong&gt;。书里列出了人工智能的下面一些领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器翻译&lt;/li&gt;
&lt;li&gt;博弈
&lt;ul&gt;
&lt;li&gt;象棋&lt;/li&gt;
&lt;li&gt;跳棋&lt;/li&gt;
&lt;li&gt;围棋&lt;/li&gt;
&lt;li&gt;五子棋&lt;/li&gt;
&lt;li&gt;扑克&lt;/li&gt;
&lt;li&gt;桥牌&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数学定理证明&lt;/li&gt;
&lt;li&gt;数学符号处理
&lt;ul&gt;
&lt;li&gt;积分&lt;/li&gt;
&lt;li&gt;化简&lt;/li&gt;
&lt;li&gt;级数求和&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;视觉
&lt;ul&gt;
&lt;li&gt;文本识别&lt;/li&gt;
&lt;li&gt;图像识别&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;听觉
&lt;ul&gt;
&lt;li&gt;词汇识别&lt;/li&gt;
&lt;li&gt;语句时别&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自然语言理解
&lt;ul&gt;
&lt;li&gt;特定领域回答问题&lt;/li&gt;
&lt;li&gt;复杂句的语法分析&lt;/li&gt;
&lt;li&gt;基于现实世界理解一段话&lt;/li&gt;
&lt;li&gt;解决有歧义的指代关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自然语言生成
&lt;ul&gt;
&lt;li&gt;抽象的诗&lt;/li&gt;
&lt;li&gt;随机的语段&lt;/li&gt;
&lt;li&gt;输出内部知识表示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;创造艺术
&lt;ul&gt;
&lt;li&gt;写诗&lt;/li&gt;
&lt;li&gt;写小说&lt;/li&gt;
&lt;li&gt;计算机绘画（AIGC）&lt;/li&gt;
&lt;li&gt;音乐创作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类比思维
&lt;ul&gt;
&lt;li&gt;启发式数学证明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;学习
&lt;ul&gt;
&lt;li&gt;形成概念&lt;/li&gt;
&lt;li&gt;参数调整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面的章节里，对各领域做了简单的介绍，在机器翻译、棋类策略、数学证明、音乐创作里都能看到，机器似乎只是把编程者的思维具体展现了出来，它本身还是做的机械式的事情。在定理证明里，人工智能使用了问题分解的手段，把一个总目标分解成要推导的局部目标，然后在不断递归，最终到可以明确看到路径的地步。不过问题分解的路径也是有讲究的，有些看似“绕远路”的路径实际上在全局上确实更近的解法。而发现这一点需要一些&lt;strong&gt;直觉&lt;/strong&gt;，也许这种直觉就是智能的灵光一闪。这也像在之前讨论过的W方式和J方式，需要W方式跳出系统观察才能发现捷径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识表示&lt;/strong&gt;在人工智能李也是重要的命题，它可以以描述性（死记硬背）的也可以是过程性（需要推导）的，前者像是DNA，存储体积更小，像是“&lt;strong&gt;数据&lt;/strong&gt;”一样；后者像是蛋白质，体积更大但有可操作性，就像“&lt;strong&gt;程序&lt;/strong&gt;”一样。组块化的知识之间也可能存在着相互联系。知识的表示和加工有&lt;strong&gt;演绎式&lt;/strong&gt;和&lt;strong&gt;类比式&lt;/strong&gt;。前者更像数理逻辑里的推导过程，后者则通过同构的思路唤起知识。当一个人在遗忘的时候，往往是指&lt;strong&gt;失去了通往相关信息的通路，而不是物理上删除或损坏了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在本章的后半段，书中对自然语言和音乐的语法做了探讨。最后对“施德鲁”里使用的高级Planner语言做了介绍，自然语言里&lt;strong&gt;句法&lt;/strong&gt;和&lt;strong&gt;语义&lt;/strong&gt;的混杂让语句的理解变得困难，一个解决办法就是通过设计Planner这样的高级语言去提供更靠近自然语言的可能性。&lt;/p&gt;
&lt;h3 id=&#34;对实&#34;&gt;对实&lt;/h3&gt;
&lt;p&gt;小品里，借由阿基里斯和螃蟹邀请乌龟和树懒来家里做客看橄榄球赛，展示了一个可以展现不同假设反应到实际的电视机，小品和电视机里都出现了矛盾的画面，比如两只左手。&lt;/p&gt;
&lt;h2 id=&#34;人工智能展望&#34;&gt;人工智能：展望&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;框架、邦加德问题、模板、同一性检测器、概念网络、元描述、酶、裂变、聚变、受迫匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在小品里，能看到一些偏离现实的虚拟场景，就像是“差一点儿”或者“万一……，那么”的这种想象。人类似乎很容易很容易在固定一些不变的场景下，想象可变部分变化后的样子。这也许这是创造力和洞察力来源的根本。同时，人们很容易区分出三种符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的符号是常量，我们默认它们不变，作为大背景出现，例如三维的世界，或者是看足球赛时候的规则&lt;/li&gt;
&lt;li&gt;有的符号是参量，在需要的时候变化，作为动态背景出现，例如天气、球赛的场地&lt;/li&gt;
&lt;li&gt;有的符号是变量，就是在心智里面最容易“滑来滑去”的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在人工智能研究中，存在&lt;strong&gt;框架&lt;/strong&gt;的概念，框架可以理解成一套上下文，在不提供更多信息时它带有默认值，如夜晚的框架就会有一个月亮，框架之间也可以相互插入。后面作者用邦加德问题来谈论了模式识别里的一些方法论，并类比人类从基因里集成的难以捉摸的性质。如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理成原子微词汇表，如三角形，原型&lt;/li&gt;
&lt;li&gt;更高层一点的描述，如上、下、大、小、平行、靠近&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;模板&lt;/strong&gt;试图构造描述，利用&lt;strong&gt;同一性检测器&lt;/strong&gt;概括模式规律。其中模板通过微词汇关联得到的&lt;strong&gt;概念网络&lt;/strong&gt;来启发式生成，而同一性检测器则去检查模板的正确性&lt;/li&gt;
&lt;li&gt;有的模式可能需要在更高层总结，这时需要用&lt;strong&gt;滑动&lt;/strong&gt;来尝试，从而“发明”一些概念&lt;/li&gt;
&lt;li&gt;更进一步的，可以在得到的模板里发现共性，从而得到&lt;strong&gt;元描述&lt;/strong&gt;，譬如，某个模板里的槽都会被填入“三次”&lt;/li&gt;
&lt;li&gt;有时还需要用集聚和过滤的办法来忽略一些细节抑或关注一些系列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后，书里将邦加德问题里的思路联系到科学研究和人类思维中，甚至是和酶做了类比，进入提出符号聚变和裂变的概念。这段意在将好几个不同领域的概念放到一起找相同点，但写得有点神神叨叨了。之后对于概念骨架（比喻对象间的共同点）和多重表示（一个概念的多种理解来跟比喻对象匹配上）的介绍也是有点陶醉在自己的世界里。&lt;/p&gt;
&lt;p&gt;在之后，书里提出了“出入口”的概念，即脑海里的意象——事件、对象、思想——都有一个“把柄”，譬如收音机的把柄可以是“音乐产生器”或者“烦恼解除器”，在这些把柄间存在精神隔板，避免人在自由联想时过于自由。但这种隔板也不百分百牢靠，就像懂得多种语言的翻译在翻译某个词的时候，就可能想到另外一种语言上的答案。&lt;/p&gt;
&lt;p&gt;在艺术作品里，&lt;strong&gt;受迫匹配&lt;/strong&gt;经常出现。即强行寻找意象和本质的深刻同构，事物的各种细节是如此之多，以至于这种同构基本都能成功。譬如在政治漫画里画了一个政治家和一头大象，观者总有办法将他们关联起来。当然受迫匹配也有优劣之分，要不能太浅显也不能太牵强才是最妙的。就像和弦一样，离得太近太远都不好听，得是恰好的距离。&lt;/p&gt;
&lt;p&gt;本章最后，作者用设问的方式抛出了10个和人工智能未来有关的问题，里面比较有意思的观点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序在有人类一样复杂的情感前，只能谱写机械式的乐曲，缺失灵魂&lt;/li&gt;
&lt;li&gt;情感无法在机器中模拟，机器只能做到哭这件事情，但没法体会到哭代表的情绪&lt;/li&gt;
&lt;li&gt;人工智能的终点做加法可能比现在的机械计算机还慢&lt;/li&gt;
&lt;li&gt;当人工智能足够智能时，人将无法精准控制它，就像人无法精准控制另一个人一样&lt;/li&gt;
&lt;li&gt;终极人工智能可能和我们想象的很不同，人看待终极人工智能时也许并不能理解，就像人无法理解另一颗星球上拥有智能的外星人一样&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树懒卡农&#34;&gt;树懒卡农&lt;/h3&gt;
&lt;p&gt;这则小品用树懒、阿基里斯、乌龟同构了巴赫的《音乐的奉献》中一首卡农，并命名树懒卡农。&lt;/p&gt;
&lt;h2 id=&#34;怪圈或缠结的层次结构&#34;&gt;怪圈。或缠结的层次结构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;缠结、怪圈、证据、心智、符号-对象、主义、无限升高的卡农&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章作为全书最后一章，试图在上面所有章节谈论的事情间寻找一种共性。在开头，作者引入了塞缪尔的机器不具有创造性的观点——“机器所表现出来的‘意向’是实现已明确化的人类程序员的意向，或是依照程序员所指定的规则从这些意向中导出的子意向”，因此对意愿的任何机械化都需要一种无穷回归，因为机器在得到指令前不会做任何事。但其实像人一样，有些最底层的规则——它们不需要依赖“元规则”——是嵌入在硬件中的。就像人的动机都来自遗传的物理基质。&lt;/p&gt;
&lt;p&gt;在之后，梳理给出了可以自我表示的跳棋、作者三角形、艾舍尔的《画手》三个例子，它们都涉及自我指代的缠结层次，但也都有一个独立在缠结层次外的“不受影响”的观察层次，就像W方式一样。自我表示的跳棋里是不变的规则，作者三角形里是看书的读者，艾舍尔的《画手》里则是画作的欣赏者。在人类大脑心智中，缠结的符号层次下也有独立的神经元层次。&lt;/p&gt;
&lt;p&gt;现实生活也有能发现这种怪圈，比如政府里相互的信用背书，又或者伪科学证伪中对于证据的无穷递归证明，最终都可以通过更低层次的限制解决争议。不过要把哥德尔映射到其他学科上时，也不能迷信的&lt;strong&gt;逐字逐句翻译&lt;/strong&gt;。它带来的只是启发价值，譬如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们人类在认识自己的心智和大脑时，是否也存在某种模糊的哥德尔式循环，限制个人认识自己心灵时所能达到的程度。&lt;/li&gt;
&lt;li&gt;所有元数学和计算理论中的限制性定理都说明：&lt;strong&gt;一旦表示自身结构的能力达到某个临界点，那就无法完整地表示自己&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;任何人都无法摆脱自我的神秘性，你可以幻想但没法跳出自己之外&lt;/li&gt;
&lt;li&gt;在科学领域经常被批评偏向主体-客体“二元论”，之前研究被观察对象很多，现在也开始更多研究观察者了，譬如量子力学里观察者相关研究和人工智能&lt;/li&gt;
&lt;li&gt;艺术中也有符号-对象二分法，符号即想表达的内容，对象即意象。在现代艺术中，也开始刻意混淆“使用”和“谈论”。譬如一些语义错觉画里赤裸地突出体现对象（马格利特作品里画之外的水果，烟斗）、Cage著名的《4分33秒》直接将空白作为符号。艺术作品本身的&lt;strong&gt;框架效应&lt;/strong&gt;会让欣赏者试图寻找里面的意义，而艺术家本意则仅仅只是对象本身，这种禅宗式的艺术对象传达了缠结的层次结构，这也是现代艺术难懂的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么哥德尔定理会限制我们的心智吗？看起来是不会的。&lt;strong&gt;我们从神经元到符号中间的层次模糊和对心智的不可捉摸背后并非一定有某种哥德尔式的缠结。这可能仅仅是命运的一个偶然结果&lt;/strong&gt;。我们大脑的进化碰巧未能强到理解它自己。但就像我们用W方式从更高角度去解释G的非定理性，也可能存在某个解释心智的高层方式，只是我们还没发现或发现不了而已。&lt;/p&gt;
&lt;p&gt;我们的意识和思想归根到底还是基于底层的&lt;strong&gt;物理因果关系&lt;/strong&gt;，不过是不同层次的“共鸣”形成了几乎不可分析的高层符号。&lt;strong&gt;也只有到符号这个层次，我们才能谈论自我意志的存在&lt;/strong&gt;，它在更下的层次只是无情的自然规律，而并非出自任何深切渴望。但这种符号并不能控制在它之下的所有内部过程，使得它的工作过程看起来是一种“直觉”，而缺乏完全的理解。&lt;/p&gt;
&lt;p&gt;本章的最后，又回到艾舍尔的《画廊》和巴赫《无限升高的卡农》，这两个作品里都有着自指的缠结。而在《无限升高的卡农》里，借助了&lt;strong&gt;谢泼德音调&lt;/strong&gt;看起来在不断升高，但最后又回到原声调，就像本书一样，以巴赫《音乐的奉献》开始，又以它做结。&lt;/p&gt;
&lt;h3 id=&#34;六部无插入赋格&#34;&gt;六部无插入赋格&lt;/h3&gt;
&lt;p&gt;最后一个小品借用阿基里斯、螃蟹、乌龟、“作者”、巴比奇、图灵6个角色，类比《六部无插入赋格》中的6个声部，最终引出本书和巴赫的《六部无插入赋格》和全书开头形成回环，实在是妙极。不仅如此，其中的内容设计也尽显精妙：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阿基里斯开头在收音机里听到的讨论自由意志和决定论的6个学者类比小品里的6个角色&lt;/li&gt;
&lt;li&gt;“没有这种噪音我照样行”共出现6次，就像6个声部，最后一次是变奏的“有这种噪音我照样行”&lt;/li&gt;
&lt;li&gt;作者直接进入小品里作为角色出场，和书中的角色对话，打破了第四面墙，形成了神奇的缠结结构&lt;/li&gt;
&lt;li&gt;“无插入赋格”在小品里通过插在句子中10次出现，其中有1次3连出现和1次倒序连带正序出现&lt;/li&gt;
&lt;li&gt;“甭提多棒了”在小品里5次出现&lt;/li&gt;
&lt;li&gt;巴比奇和图灵相互编程实现对方实现了一种缠结&lt;/li&gt;
&lt;li&gt;“作者”和乌龟的交流介绍了本小品用人物模拟声部的思路，达成了自指&lt;/li&gt;
&lt;li&gt;螃蟹主题的音符是C-Eb-G-Ab-B-B-A-B，倒过来正是Babbage,C，即巴比奇&lt;/li&gt;
&lt;li&gt;“作者”、螃蟹、巴比奇三人用几乎一样的语段类比螃蟹主题里的波音&lt;/li&gt;
&lt;li&gt;乌龟、巴比奇、图灵三人用几乎一样的语段类比三和弦&lt;/li&gt;
&lt;li&gt;在小品后半段通过拆字的方式在语段中嵌入了“侯世达”，类比了巴赫在六部无插入赋格里的最高两个声部嵌入了自己的名字[BACH]&lt;/li&gt;
&lt;li&gt;小品的最后，大家在开始阅读本书之前，准备演奏《音乐的奉献》中《六部无插入赋格》，就像全书的开头一样，所以这个小品其实也是序章的引子，就像最后一句写的那样&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;无插入赋格&lt;/strong&gt;”之后&lt;strong&gt;插入&lt;/strong&gt;导言将&lt;strong&gt;赋&lt;/strong&gt;有“无穷升高的卡农”的风&lt;strong&gt;格&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;--END--&lt;/em&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://shenlvmeng.github.com/blog/2018/11/22/selfish-gene/</guid>
            <title>《自私的基因》——生命的必然性和偶然性</title>
            <link>http://shenlvmeng.github.com/blog/2018/11/22/selfish-gene/</link>
            <category>读书笔记</category>
            <category>人类</category>
            <category>生存</category>
            <category>基因</category>
            <pubDate>Thu, 22 Nov 2018 23:36:28 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;《自私的基因》是道金斯在上世纪70年代写的一本关于生物学的经典著作。书中从“自私的”复制因子基因的角度出发，推导出生物学、社会学各个方面的规律猜想，乃至最后上升到对生命、人类产生的必然性和偶然性的大胆设想。全书从第5章起，开始引人入胜，内容渐入佳境，让人手不释卷。其中对于代际、两性出现、共生群居等方面的探讨，令我有三观再塑之感。尽管前几章对复制因子基因的“自私性”和生存机器铺垫甚多，有点拖沓，整体还是很值得一读的。另外，把《自私的基因》和《人类简史》连在一起思考，甚至有更奇妙更透彻的感觉。&lt;/p&gt;
&lt;h2 id=&#34;对“自私的基因”一词的解释&#34;&gt;&lt;a href=&#34;#对“自私的基因”一词的解释&#34; class=&#34;headerlink&#34; title=&#34;对“自私的基因”一词的解释&#34;&gt;&lt;/a&gt;对“自私的基因”一词的解释&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生物的进化的最基本单位是基因而不是生物个体&lt;/strong&gt;。因为基因有复制性，可以控制个体性状。生物的生存繁衍等一切行为的本质是基因带来的。成功基因的标志是可以在复制中不断战胜其余复制因子，&lt;strong&gt;这个过程是“盲目的”。基因是不会做选择的，做选择的是自然环境&lt;/strong&gt;。经过自然选择留下来的成功基因，自然是生存能力最强，留下复制最多的，看上去也是最“自私的”。自私一词是有些感性，但是它是对成功基因最恰当的形容了。你可以把它和&lt;strong&gt;“不被淘汰”&lt;/strong&gt;等同。&lt;/p&gt;
&lt;h2 id=&#34;复制因子&#34;&gt;&lt;a href=&#34;#复制因子&#34; class=&#34;headerlink&#34; title=&#34;复制因子&#34;&gt;&lt;/a&gt;复制因子&lt;/h2&gt;&lt;p&gt;基因作为自然界诞生的产物，更通用的说法可以叫&lt;strong&gt;复制因子&lt;/strong&gt;。在复制因子出现之前，自然界一片混沌，各种大分子在“分子汤”内自由游荡，随意组合，我们很难把它们叫做“个体”。直到有一天（说得不大严谨）出现了第一个复制因子。它们不见得是分子汤里最大的，但是它有可贵的性质——能复制自身。这个偶然性虽然非常之小，但是&lt;strong&gt;一旦出现就会不可逆的扩张开来&lt;/strong&gt;。以至于复制因子一旦出现就会占据整个分子汤的主要地位，它会必然地在海洋里疯狂复制自己的拷贝。&lt;/p&gt;
&lt;p&gt;很有可能基因只不过是一种复制因子，在基因出现前甚至出现之初，可能甚至很可能有类似基因的其他复制因子。复制因子之间必定会有胜利和失败者，因为分子汤资源是有限的，不足以维持无限量的复制。现在看来，最终基因胜利了。在基因的竞争和演化中，逐渐出现了蛋白质的保护膜，更多的基因渐渐聚合起来，蛋白质分工逐渐明确，生存机器由此产生。&lt;strong&gt;人不过也是一种生存机器罢了&lt;/strong&gt;，“操纵”这个机器的是背后的基因。&lt;/p&gt;
&lt;p&gt;另外，复制过程当然不会是完美无缺的，因此产生的多样性，让生存机器间也出现了越来越大的形态差异。&lt;/p&gt;
&lt;h2 id=&#34;基因与染色体&#34;&gt;&lt;a href=&#34;#基因与染色体&#34; class=&#34;headerlink&#34; title=&#34;基因与染色体&#34;&gt;&lt;/a&gt;基因与染色体&lt;/h2&gt;&lt;p&gt;我们生物都是同一种复制因子——DNA的生存机器，基因在染色体中，它通过蛋白酶监督着蛋白质的生成，并通过蛋白质控制生物性状。基因对生物的控制是&lt;strong&gt;“单向”的&lt;/strong&gt;，也即后天所学是无法改变基因并遗传给后代的。个体的存活时间可能很有限，但是基因不断复制和交叉会一代代传递下去。&lt;/p&gt;
&lt;p&gt;基因的复制最好是完美无缺的，自然选择对失误的复制惩罚往往很严重，如染色体丢失、倒位很容易导致个体的死亡。但是也有些复制失误不会造成那么大问题，只是在个体的一生逐渐积累，这也就是衰老。成功基因的标志除了“自私”，即能传递自身，还要保证和其他基因的通力合作下，能让生存机器的死亡至少推迟在生殖以后。有种观点认为性“促进了在单个个体内积累以往出现在不同个体内的有利突变”。&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;进化就是指基因库中某些基因变多了，而另外的变少了的过程&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;基因机器&#34;&gt;&lt;a href=&#34;#基因机器&#34; class=&#34;headerlink&#34; title=&#34;基因机器&#34;&gt;&lt;/a&gt;基因机器&lt;/h2&gt;&lt;p&gt;基因通过合成蛋白质，进而由神经控制和激素控制控制生物个体。控制下个体的每一次行为都是一次选择，在自然选择后留下的都是适于当前环境的。动物的行为无论是利己的还是利他的，都在基因控制之下，基因是主要的策略制定者，大脑则是执行者，并接管了很多决策职能。&lt;/p&gt;
&lt;p&gt;一个生存机器对另外生存机器的行为或神经系统施加影响时，前者就是在和后者联络（communication）。这也让基因的影响力能辐射到另外的个体，产生相互的影响。即下章会提到的行为。&lt;/p&gt;
&lt;h2 id=&#34;博弈论下的动物行为&#34;&gt;&lt;a href=&#34;#博弈论下的动物行为&#34; class=&#34;headerlink&#34; title=&#34;博弈论下的动物行为&#34;&gt;&lt;/a&gt;博弈论下的动物行为&lt;/h2&gt;&lt;p&gt;动物间的搏斗是&lt;strong&gt;克制且按规则&lt;/strong&gt;进行的，因为不分青红皂白地杀死对手并无明显的好处，在一个庞大复杂的竞争系统中，除掉一个对手不见得就是好事，但是把特定对手杀死或者至少搏斗一番是个好主意。在行为双方都可以做选择时，博弈论的理论告诉我们，在大量样本的情况下，会有进化上的稳定策略（ESS）。而偏离ESS的行为将会受到自然选择的惩罚。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（关于鹰和鸽子策略的探讨篇幅过长，建议网上查看，便于理解ESS）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进化中的稳定策略无处不在，且不止一种策略会留在最后的稳态中（稳定的多态性）。在行为双方能力不对称（这是常态）且行为双方有记忆时，开始个体的胜利或失败可能是完全偶然的，但是随着搏斗的进行，个体间会自动归类成等级，避免激烈的搏斗，从而产生了阶级。按照博弈论思路下的推导，一个种群内可能会从一个ESS跳到另一个ESS，伴随着环境不断进步。&lt;/p&gt;
&lt;p&gt;不过，面对和自己有着很多共同基因的近亲，这种讨论就失效了。基因 + 自然选择必然会留下特地照顾自身复制的基因。这方面讨论见下一章。&lt;/p&gt;
&lt;h2 id=&#34;亲代行为与计划生育&#34;&gt;&lt;a href=&#34;#亲代行为与计划生育&#34; class=&#34;headerlink&#34; title=&#34;亲代行为与计划生育&#34;&gt;&lt;/a&gt;亲代行为与计划生育&lt;/h2&gt;&lt;p&gt;经过自然选择的基因必然具有一个特质：最大程度的复制自身。基因有没有一些比较合情理的“识别”自身复制的方法呢？有，其中一个就是&lt;strong&gt;个体的近亲&lt;/strong&gt;。这显然是亲代对子代利他性行为普遍存在的原因。父母之爱是亲代之爱的一种特殊情况。亲代间基因的相似度显然是不同的，血缘关系越近，基因相似度越高，对应的 利他性行为也会越显著。很明显兄弟姐妹之爱不如父母之爱来得那么普遍（只从天生层面讲）。&lt;/p&gt;
&lt;p&gt;然而父母对子代的关心不会一直持续。因为父母对一个个体的关怀可以分为两个阶段：&lt;strong&gt;生育幼儿&lt;/strong&gt;，&lt;strong&gt;养育幼儿&lt;/strong&gt;。从基因“自私”的一面来讲，亲代理应最大限度生育后代。但是事实却不是这样，一大原因是野生动物生存困难，几乎永远不可能因衰老死亡，疾病、饥饿、捕食者种种隐私很容易导致野生个体死亡。而且可以观察到，野生生物通常会控制自己生育后代的数目，即“计划生育”，这是因为，计划生育在资源和生存条件恶劣的情况下，反而能最大限度增加子代的存活数。节制的剩余数目反而是当前环境的最优解。过度生育的个体会被自然选择惩罚。&lt;/p&gt;
&lt;h2 id=&#34;代际的竞争&#34;&gt;&lt;a href=&#34;#代际的竞争&#34; class=&#34;headerlink&#34; title=&#34;代际的竞争&#34;&gt;&lt;/a&gt;代际的竞争&lt;/h2&gt;&lt;p&gt;亲代对子代的投资往往是不均等的，同时对某个子代的投入，必然是以牺牲对其他子代投入为代价的。子代为了保证自己的存活，往往会竭尽所能甚至是欺骗。同时，亲代在自身随着衰老养育能力下降后，通常会有生殖能力逐渐消失的现象（尤其是雌性），因为此时对子女的投入不如对孙子孙女的投入平均回报大。雄性往往是逐渐衰退的，原因可能是，父亲对子女的投资额比不上母亲。幼儿的哺乳期不宜过长，到尚未出生的弟弟妹妹因为他继续吃奶蒙受的损失超过从他那里得来好处的数倍时，他就不应再吃下去了。广义的断奶由此出现。&lt;/p&gt;
&lt;p&gt;然而，子代为了自己利益的最大化，和亲代的目标必然有分歧，最终的结局是两方理想条件的某种妥协。我们不要指望子代个体本性里有利他主义的成分，&lt;strong&gt;道德准则和基因里的本性是两回事&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里要再强调一下，从基因到个体的“自私”表现，都是经过自然选择的必然结果，不自私的基因和个体都在激烈的竞争中被淘汰了。&lt;/p&gt;
&lt;h2 id=&#34;两性&#34;&gt;&lt;a href=&#34;#两性&#34; class=&#34;headerlink&#34; title=&#34;两性&#34;&gt;&lt;/a&gt;两性&lt;/h2&gt;&lt;p&gt;生物大多有性别之分，尤其是有性生殖个体。在生殖上，可以说每个配偶的本性都应该会设法利用对方，迫使自己少投资，对方多投资。那两性是如何出现的呢？我们知道两种生殖细胞，一种细胞（卵细胞）较大，数量少，营养物质充足，不灵活；另外一种（精子）较小，数量巨大，身材瘦小，灵活。明显卵细胞一方投资较多，看起来是精子那一方占了便宜，为什么会这样呢？假设最开始两种生殖配子是差不多的性质，&lt;strong&gt;一旦这种配子间的分歧产生，性质偏向卵细胞的一方在诞生个体上就会更有优势，而偏向精子的一方在寻找对象上（量大，灵活）也会更有优势，而性质介于两者之间的生殖配子就会收到自然选择的惩罚&lt;/strong&gt;。从而这种差异就像脱缰的野马，一发不可收拾，到两者的形态到达再继续变化就要被惩罚的稳态，即现在这个模样。&lt;/p&gt;
&lt;p&gt;而精子代表的一方就成为了雄性，卵子一方成为了雌性。从上面的理论可以自然推测出，朝着尽量多诞生复制的目标下，雄性个体数目较之雌性个体会越来越少（因为雄性个体可以很轻易产生大量精子，对应到大范围的雌性）。但是现状很显然不是这样，男女比例是很接近的。原因是，生育一个儿子的基因较之生育女儿极有可能会复制自己出现在成为大量后代中。 在基因朝着多生育儿子的趋势前进时，自然地就平衡了之前男少女多的情况。&lt;strong&gt;生育相同数目的儿女的策略是进化上的稳定策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对生育个体而言，他或她在其中投资的越少，所能生育的子女就越多。但是雌性&lt;strong&gt;由于卵细胞的存在&lt;/strong&gt;，个体往往从自己体内诞生，个体一旦死亡，自己比做父亲的要蒙受更大损失。顺便补充有趣的一点，在鱼类中情况是反过来的，有一种可能是，鱼类的交配过程是共同排出生殖细胞到水中完成交配，而不是在雌性个体内。这时情况就变了，谁先排出生殖细胞就更易把责任推给另一方（值得商榷），卵细胞相对较大，在水中不易散逸，精子则很容易散逸。所以雄鱼通常得等在雌性后面排出生殖细胞，而被迫承担养育责任。&lt;/p&gt;
&lt;p&gt;说回来，在交配完成后，双方都要冒着被对方抛弃的危险（雌性可以遗弃还未诞生的个体，所以雄性也有风险）。在这种博弈情况下，有一些常见策略，如“家庭幸福”和“大丈夫”。前者指在交配前，双方仔细观察对方忠诚和眷恋家庭生活的可能迹象，“订婚期”长对雄性个体也有利，因为他有上当受骗，抚养其他雄性个体所生子女的风险。在雄性有忠诚、薄情两种决策，雌性有忸怩、放荡两种决策下，较多忠诚和较多忸怩以及较少薄情和较少放荡会达到一种稳态。大丈夫策略下，则是根据雄性个体素质进行选择，保证子代更加健壮，从而更容易拥有交配权。素质判断的过程随着雄性偶尔的欺骗出现，会向着&lt;strong&gt;雄性某些表征愈发明显和雌性观察力愈发敏锐发展&lt;/strong&gt;。表征明显得有时甚至略显夸张，这一方面也是种“炫耀”，炫耀自己拥有一些&lt;strong&gt;累赘&lt;/strong&gt;也依然能活的很好。&lt;/p&gt;
&lt;p&gt;雌性因为卵子的自愿地位，不必像雄性个体那样，仅仅具有性吸引力就能保证自己的卵子有受精机会，所以在交配问题上更加挑剔（比如雌驴会避免和雄马交配，生育出没有生育能力的骡子），雄性则相反，需要具有更加吸引人（尤其是雌性）的种种性状。同时，凡是存在乱伦禁忌的地方，可以认为雌性会比雄性更严守此这种禁忌。&lt;/p&gt;
&lt;h2 id=&#34;共生和合作&#34;&gt;&lt;a href=&#34;#共生和合作&#34; class=&#34;headerlink&#34; title=&#34;共生和合作&#34;&gt;&lt;/a&gt;共生和合作&lt;/h2&gt;&lt;p&gt;生存机器间除了搏斗、亲代、有性参与的相互作用，还有共生和合作的存在。比如鸟群和鱼群的存在。有些群体个体会警告其余个体危险的存在等等。这些看似利他性行为实际都可以从有利自己生存的角度考虑。&lt;/p&gt;
&lt;p&gt;蚂蚁、蜜蜂、裸鼹鼠等物种的&lt;strong&gt;职虫不育性&lt;/strong&gt;是个很有趣的现象。它们的个体间营社会性生活。这其实是把生育和抚育策略结合在一起进化的结果。这个现象和雌虫的生殖特性密切相关。雌虫生育的个体都是&lt;strong&gt;单倍体&lt;/strong&gt;，兄弟姐妹间基因的相似度甚至高于自己生育的后代的相似度。相比自己繁殖养育，不如“耕耘”有生殖力的母体，趋势母体提高繁殖力，复制自己的基因。同时，往往这种生物生存的环境资源有限，外出繁育ROI较低。&lt;/p&gt;
&lt;p&gt;在共生现象中，双方都有骗子和傻瓜两种策略，但在斤斤计较策略存在的情况下，骗子策略会被渐渐战胜。有观点认为，人类细胞不过是共生微生物的结果，而我们本身也是不同基因共生的群体结果。&lt;/p&gt;
&lt;h2 id=&#34;推广到文化&#34;&gt;&lt;a href=&#34;#推广到文化&#34; class=&#34;headerlink&#34; title=&#34;推广到文化&#34;&gt;&lt;/a&gt;推广到文化&lt;/h2&gt;&lt;p&gt;正如《人类简史》里面所说，涉及到道德、规范、法律、文化的领域，就进入了人类的想象空间。复制因子的规律能否推广到“文化因子”（meme）中是个不错的尝试。不过meme本身是可以人为操纵，而不是“盲目的”。和基因不同，数学模型和概念在此很难有用武之地，试图对人类意识的探讨更易让类比有刻意引申之嫌。&lt;/p&gt;
&lt;h2 id=&#34;好人好报&#34;&gt;&lt;a href=&#34;#好人好报&#34; class=&#34;headerlink&#34; title=&#34;好人好报&#34;&gt;&lt;/a&gt;好人好报&lt;/h2&gt;&lt;p&gt;在个体合作时，基于合作和背叛两种基本元素，可以产生很多合作策略。当合作明确只能做一次时，双方会面临&lt;strong&gt;“囚徒困境”&lt;/strong&gt;，即个体的最优解不是整体的最优解。但是，&lt;strong&gt;合作明确会持续进行，且看不到终点时&lt;/strong&gt;（看不到终点很重要，因为有终点存在，整个信任就会从最后一次合作的倒推开始崩塌），这个“零和问题”变成了“&lt;strong&gt;非零和问题&lt;/strong&gt;”。这种情况下，拥有&lt;strong&gt;宽容&lt;/strong&gt;，&lt;strong&gt;善良&lt;/strong&gt;，&lt;strong&gt;不嫉妒&lt;/strong&gt;特质的合作策略会在各种策略中获胜，并最终达到稳态。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;描述过程见书第十二章，写的很有意思&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;总结来说，&lt;strong&gt;未知的&lt;/strong&gt;，&lt;strong&gt;长期的&lt;/strong&gt;，&lt;strong&gt;非零和&lt;/strong&gt;进化博弈下，好人会取得最终的胜利，并占据大多数。&lt;/p&gt;
&lt;h2 id=&#34;生命的必然和偶然&#34;&gt;&lt;a href=&#34;#生命的必然和偶然&#34; class=&#34;headerlink&#34; title=&#34;生命的必然和偶然&#34;&gt;&lt;/a&gt;生命的必然和偶然&lt;/h2&gt;&lt;p&gt;最后一章里，我们总结一下前面所有的结论，并试图给出更透彻、更明白的一些结论。首先，个体生物即载体以努力传播自己基因为任务，同时对基因有利对整个生命体也有利。基因所能影响的只有蛋白质合成，再操纵细胞乃至整个生存机器，并最终“从自身身体中逃逸出”，操作整个外部世界，如海狸的河坝。这里我们考虑一下“寄生”和“共生”的区别。通过一些例子来看，最终的区别是&lt;strong&gt;寄生个体将基因传递给后代的方式是否和宿主基因一样&lt;/strong&gt;。享有共同命运的寄生生物基因，最终会享有共同利益，停止寄生行为。比如绿色水螅和水藻的基因，以及甲虫和细菌的基因，寄生基因只能通过宿主的生殖细胞拥有未来。&lt;/p&gt;
&lt;p&gt;推广一下，&lt;strong&gt;我们自己的基因通力合作，不是因为它们共享同一个身体，而是它们共享同一条出路——精子和卵子&lt;/strong&gt;。如果能找到一条另外的出路，一些基因自然就会表现得不再合作。比如，人体内流感病毒的基因通过飞沫传递，狂犬病病毒之于狗也是这样。基因对于个体的控制比你想象得要厉害，给一个男人看女人身体的图片，便可以唤起其性冲动，甚至勃起，而这个过程中，他并没有被欺骗，认为图片是个真实的女人。虽然他知道是打印机打出的图片，他的神经系统依然有和面对真实女性一样的反应。我们的身体不过是“寄生”基因的集合体。自然选择偏向控制他人的基因，动物行为倾向于最大化此基因的生存。&lt;/p&gt;
&lt;p&gt;总结下，&lt;strong&gt;共生的基因共享离开当前基因载体的共同渠道&lt;/strong&gt;，个体如果想成为有效的基因载体，必须保证&lt;strong&gt;对所有其中的基因提供等概率的、通往未来的共同通道&lt;/strong&gt;。最后回答三个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么基因汇聚在一起，形成细胞？&lt;/strong&gt;，单个基因操纵的化学反应通常不足以合成所需的最终产物，一种蛋白酶需要在其他基因存在的情况下才能生长繁荣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么细胞会汇聚在一起，形成多细胞？&lt;/strong&gt;，一方面是体型的优势，另一方面是便于分工，让每一个部件处理特定任务时更有效率。&lt;/p&gt;
&lt;p&gt;最后一个，也是最有意思的问题。&lt;strong&gt;为什么生命体循环总有瓶颈般的受精卵阶段？&lt;/strong&gt;，不论大象、蚂蚁都是这样。原因是，从部分个体开始的繁殖只能获得很少一部分改变，彻底的改变，只能从“设计图纸”开始，&lt;strong&gt;保证每一个个体都拥有干净的起点&lt;/strong&gt;。瓶颈保证了生命循环继承的是图纸而不是成品。另外，这种瓶颈的存在，&lt;strong&gt;让生命循环定型，更有规律的重复&lt;/strong&gt;。&lt;strong&gt;基因这种精确的行为规划是胚胎得意进化形成复杂组织和器官的先决条件&lt;/strong&gt;，鹰的眼睛，燕子的翅膀，这些精确和复杂的器官不可能在没有时间规划下出现。最后，也是最关键一点，&lt;strong&gt;瓶颈的存在自然地带来的基因间的共同利益&lt;/strong&gt;，因为所有的基因都需要通过瓶颈传给下一代，别无选择。&lt;/p&gt;
&lt;p&gt;总结一下，生命循环成为“瓶颈状”，有生命的材料会渐渐聚在一起，形成独立而统一的生命体。生命材料越多，就有更多的载体细胞凝结努力，作用于特殊种类的细胞，使他们可以承载其共同的基因，通过瓶颈走向下一代。所有生命的基本单位和最初动力都是复制因子，没有任何复制过程是完美的，一些编译失去复制能力而灰飞烟灭。互惠的复制因子间可以帮助对方更好的生存，这些复制因子聚合一处形成了细胞，与而后形成的多细胞生命，由“瓶颈”生命循环进化而成的载体繁荣发展，逐渐变成愈加独立的载体。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>

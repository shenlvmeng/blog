{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"源码\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/04/23/express-js/",
            "url": "http://shenlvmeng.github.com/blog/2017/04/23/express-js/",
            "title": "Express源码阅读",
            "date_published": "2017-04-23T06:13:35.000Z",
            "content_html": "<blockquote>\n<p>本文基于<a href=\"https://github.com/shenlvmeng/express/tree/4.15.2\">Express 4.15.2</a></p>\n</blockquote>\n<blockquote>\n<p>我之前的Express学习笔记还在<a href=\"http://shenlvmeng.github.io/book.html#express\">这里</a></p>\n</blockquote>\n<p><a href=\"https://expressjs.com/\">Express</a>常被用来进行Node.js后台的快速搭建。它仅仅对Node.js进行了简单的封装，结合中间件等很自然和好用的概念，很容易上手和学习。Express的API主要包括Application，Request，Response，Router几个部分,这是Express代码主要实现的部分。在我看来，Express贵在它的中间件，它提供了足够自由的空间但也做出规范，提供<code>req</code>, <code>res</code>, <code>next</code>, <code>err</code>给中间件操作。它的生态系统也是围绕这个展开的。</p>\n<h2 id=\"创建服务器\"><a href=\"#创建服务器\" class=\"headerlink\" title=\"创建服务器\"></a>创建服务器</h2><p>让我们从头回忆，用Express创建一个简单的服务器。像下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title function_\">express</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;Hello World!&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello world!&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>先通过构造函数创建一个Express应用（Application）。接着为它指定路由规则。最后通过<code>app.listen()</code>的方式启动服务器。对比下Node.js原生的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;Hello world&#x27;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">end</span>();</span><br><span class=\"line\">&#125;).<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么Express的app究竟是什么，路由中间件又是如何绑定上去的。这些问题需要通过源码来解答。</p>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>Express代码整体设计并不复杂（相对于<a href=\"https://shenlvmeng.github.io/blog/2017/04/05/vue-reactive-sourcecode/\">Vue这样的复杂设计</a>），比较容易看懂，一些常见的功能已经事先写成依赖包抽取出来，如<a href=\"https://github.com/visionmedia/debug\">debug</a>（打印debug信息）和<a href=\"https://github.com/dougwilson/nodejs-depd\">deprecate</a>（显示API已废弃）等。Express的源码部分位于<code>lib/</code>路径下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">- lib/</span><br><span class=\"line\">  - middleware/</span><br><span class=\"line\">    - init.js</span><br><span class=\"line\">    - query.js</span><br><span class=\"line\">  - router/</span><br><span class=\"line\">    - index.js</span><br><span class=\"line\">    - layer.js</span><br><span class=\"line\">    - route.js</span><br><span class=\"line\">  - application.js</span><br><span class=\"line\">  - express.js</span><br><span class=\"line\">  - request.js</span><br><span class=\"line\">  - response.js</span><br><span class=\"line\">  - utils.js</span><br><span class=\"line\">  - view.js</span><br><span class=\"line\">...</span><br><span class=\"line\">- index.js</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./lib/express&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根目录下的<code>index.js</code>是整个项目的入口，所做的工作只是引入<code>lib/</code>中的<code>express.js</code>。<code>lib/</code>目录下<code>middleware</code>目录下放置了内置的中间件，<code>router</code>中放置中间件的功能实现。下面的几个文件中</p>\n<ul>\n<li>application.js 应用的定义，app对象的API</li>\n<li>express.js，对app，router等功能的封装</li>\n<li>request.js和response.js是对http中res以及req的封装和增强</li>\n<li>utils.js 常用工具函数的封装</li>\n<li>view.js 建立拓展名和渲染引擎的联系</li>\n</ul>\n<h2 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h2><p><code>express.js</code>和<code>Application.js</code>大致告诉我们了<code>express</code>和<code>app</code>究竟为何物。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//express.js</span></span><br><span class=\"line\"><span class=\"built_in\">exports</span> = <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = createApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createApplication</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个app</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) &#123;</span><br><span class=\"line\">    app.<span class=\"title function_\">handle</span>(req, res, next);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//继承EventEmitter和Application.js中定义的app对象</span></span><br><span class=\"line\">  <span class=\"title function_\">mixin</span>(app, <span class=\"title class_\">EventEmitter</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"title function_\">mixin</span>(app, proto, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 初始化app</span></span><br><span class=\"line\">  app.<span class=\"title function_\">init</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 一些暴露公用接口的操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 告知一些方法已废弃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面的<code>mixin</code>引入自<a href=\"https://github.com/component/merge-descriptors\">merge-description</a>，功能非常简单——通过描述符融合两个对象并返回，源码也很简单，主要由<code>getOwnPropertyDescriptor</code>及<code>defineProperty</code>方法实现，感兴趣的可以一看。</p>\n<p>app通过<code>mixin</code>继承了两个预定义对象，其中<a href=\"https://nodejs.org/docs/latest-v5.x/api/events.html#events_class_eventemitter\">EventEmitter</a>来自Node.js的API，继承后app将获得事件发布订阅功能。<code>proto</code>由<code>Application.js</code>导出定义。其中定义了<code>app.listen()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"property\">listen</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">listen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> server.<span class=\"property\">listen</span>.<span class=\"title function_\">apply</span>(server, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>综上就很明白了</p>\n<ul>\n<li>首先，<code>express()</code>返回的<code>app</code>其实是一个函数，可以接受<code>req</code>, <code>res</code>以及定义在Express中的next</li>\n<li>之后，<code>app.listen()</code>方法实际上执行了<code>http.createServer(app).listen()</code></li>\n</ul>\n<p>总结，**<code>express()</code>是个工厂函数，负责生产作为<code>http.createServer(app)</code>的参数**。之后，让我们继续深入看看<code>Application.js</code>中的代码。</p>\n<p>app的工作主要是在<code>Application.js</code>中进行的。下面介绍一些它的属性和相关方法</p>\n<ul>\n<li><code>cache</code> ，<code>Object</code>，缓存视图信息</li>\n<li><code>engine</code>，<code>Object</code>，视图渲染引擎<ul>\n<li><code>engine(ext, fn)</code>，绑定拓展名和渲染方法，返回app自身用于链式调用</li>\n</ul>\n</li>\n<li><code>settings</code>，app的设置信息，可以通过<code>set</code>，<code>get</code>方法设置和获取。<ul>\n<li><code>get(setting)</code>(或<code>set(setting)</code>)获取配置值，这里是完整的<a href=\"https://expressjs.com/en/4x/api.html#app.settings.table\">配置表</a></li>\n<li><code>set(setting, value)</code>设置配置值</li>\n<li><code>enabled(setting)</code>和<code>disabled(setting)</code>语法糖，获取Boolean类型配置值</li>\n<li><code>enable(setting)</code>和<code>disable(setting)</code>语法糖，设置Boolean类型配置值</li>\n</ul>\n</li>\n<li><code>locals</code>在app生命周期内存储用户信息</li>\n<li><code>mountpath</code> 顶级app挂载路径<ul>\n<li><code>path()</code>返回app的挂载路径</li>\n<li><code>use(fn)</code>挂载中间件时可以指定第一个参数为挂载路径</li>\n</ul>\n</li>\n<li><code>router</code> 该路由中间件属性在4.x中已废弃，由<code>route(path)</code>方法替代</li>\n<li><code>_router</code> 在<code>lazyrouter</code>内部方法中加载，Router对象，中间件的容器。详细介绍在下文的<a href=\"#router\">Router</a>一节中。</li>\n</ul>\n<p>除了这些属性外，还有一些常见或内部使用的方法</p>\n<ul>\n<li><code>defaultConfiguration</code>初始化默认配置</li>\n<li><code>lazyrouter</code>自身路由的懒加载，原因写在了<a href=\"https://github.com/expressjs/express/blob/master/lib/application.js#L132-L133\">源码注释</a>里</li>\n<li><code>handle(req, res, cb)</code>最关键的app方法，用于分发请求完成路由功能。但它实际上只是对<code>router.handle</code>做了简单的封装。并在最后通过finalhandler来做兜底。finalhandler是个很轻量级的依赖包，用于生成404页面和记录错误。详细文档见<a href=\"https://github.com/pillarjs/finalhandler\">github</a>.</li>\n<li><code>use(fn)</code>最关键的app方法，用于添加中间件，主要逻辑是将<code>arguments</code>中的<code>path</code>和<code>fn</code>列表拆开来，再调用router的<code>use</code>方法注册</li>\n<li><code>route(path)</code>调用router的<code>route</code>方法注册一个路由中间件</li>\n<li><code>param(name, fn)</code>在自身的router对象中注册参数匹配回调</li>\n<li><code>VERB(path, fn)</code>为HTTP动词绑定路径和处理函数，主要功能也是由router代劳。有意思的是，HTTP动词是通过<a href=\"https://github.com/jshttp/methods/\">methods</a>这个依赖包来返回的，这个包原理也非常简单——<code>http.METHODS</code>。</li>\n<li><code>all(path)</code>用来匹配任意一个HTTP动词，其余功能和上面相同，实现上即将该路由中间件的所有动词都绑定上处理函数。</li>\n<li><code>del</code> 已废弃</li>\n<li><code>render(name, options, cb)</code>调用渲染引擎渲染模板</li>\n<li><code>listen()</code>即上文提到的方法，对<code>http.listen</code>的封装</li>\n</ul>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>中间件是Express设计的最精妙的地方，也是工作量最大的地方。之前Express利用了<a href=\"https://github.com/senchalabs/connect\">Connect</a>来做这项工作。在当前版本中放在了router目录下去实现。整体来看，一个Express应用就是一系列的中间件首尾相接组成的。那么中间件是什么呢？用<a href=\"https://expressjs.com/en/guide/writing-middleware.html\">官网</a>的话说就是“Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle.”从code的角度来看，就是下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMiddleware = <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果是错误处理的中间件，需要将err传入为第一个参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myErrorMiddleware = <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>所以，一个请求进入Express后，处理的流程大致是下面这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       ↓</span><br><span class=\"line\">---------------</span><br><span class=\"line\">| middleware1 |</span><br><span class=\"line\">---------------</span><br><span class=\"line\">       ↓</span><br><span class=\"line\">---------------</span><br><span class=\"line\">| ... ... ... |</span><br><span class=\"line\">---------------</span><br><span class=\"line\">       ↓</span><br><span class=\"line\">---------------</span><br><span class=\"line\">| middlewareN |</span><br><span class=\"line\">---------------</span><br><span class=\"line\">       ↓</span><br></pre></td></tr></table></figure>\n\n<p>其中每个中间件能拿到<code>req</code>和<code>res</code>抑或<code>err</code>，在完成自身工作后调用<code>next()</code>执行下一个中间件。那么这些middleware是怎么放置在这条链上，请求又是如何通过<code>next()</code>一步步向下传递的呢？</p>\n<p>中间件分两种：普通中间件和路由中间件。它们都通过<code>handle</code>方法处理；前者通过<code>use</code>方法注册，后者通过<code>VERB</code>(或<code>all</code>)方法注册。其中</p>\n<ul>\n<li>前者匹配所有以<code>path</code>开始的路径，而后者会精确匹配<code>path</code>路径；</li>\n<li>前者对于请求的方法不做要求，而后者只能处理指定的请求。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/user&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/user&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"app层面\"><a href=\"#app层面\" class=\"headerlink\" title=\"app层面\"></a>app层面</h3><p>在app层面，即<code>Application.js</code>中，是由<code>app.use(fn)</code>, <code>app.VERB</code>(或<code>app.all</code>)和<code>app.handle(req, res, cb)</code>完成的。而它们只是router的同名方法的简单封装。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"property\">use</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">use</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> path = <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 由于这个API支持多参数，需要先判断第一个参数是否为路径</span></span><br><span class=\"line\">  <span class=\"comment\">// 并通过offset存储结果</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arg = fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(arg) &amp;&amp; arg.<span class=\"property\">length</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      arg = arg[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// first arg is the path</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> arg !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      offset = <span class=\"number\">1</span>;</span><br><span class=\"line\">      path = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根据offset获取中间件函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fns = <span class=\"title function_\">flatten</span>(slice.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, offset));</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用lazyrouter</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  fns.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原生函数时，调用router.use注册即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fn || !fn.<span class=\"property\">handle</span> || !fn.<span class=\"property\">set</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> router.<span class=\"title function_\">use</span>(path, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中间件为router或app时，handle方法才是我们需要的</span></span><br><span class=\"line\">    <span class=\"comment\">// 储存req和res的app属性到处理它的app</span></span><br><span class=\"line\">    router.<span class=\"title function_\">use</span>(path, <span class=\"keyword\">function</span> <span class=\"title function_\">mounted_app</span>(<span class=\"params\">req, res, next</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> orig = req.<span class=\"property\">app</span>;</span><br><span class=\"line\">      fn.<span class=\"title function_\">handle</span>(req, res, <span class=\"keyword\">function</span> (<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">setPrototypeOf</span>(req, orig.<span class=\"property\">request</span>)</span><br><span class=\"line\">        <span class=\"title function_\">setPrototypeOf</span>(res, orig.<span class=\"property\">response</span>)</span><br><span class=\"line\">        <span class=\"title function_\">next</span>(err);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中<a href=\"https://github.com/blakeembrey/array-flatten\">flatten</a>用于将多层嵌套数组扁平化为1层。可见到，app的<code>use</code>方法在做了预处理工作后，调用router的<code>use</code>完成注册工作。</p>\n<p>需要路由中间件时，我们需要使用动词对应的方法（或<code>all</code>）去注册。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span>(<span class=\"params\">method</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据形参个数避免app.get带来的歧义</span></span><br><span class=\"line\">  app[method] = <span class=\"keyword\">function</span>(<span class=\"params\">path</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method === <span class=\"string\">&#x27;get&#x27;</span> &amp;&amp; <span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// app.get(setting)</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">set</span>(path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">lazyrouter</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用router的route方法构造一个路由中间件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> route = <span class=\"variable language_\">this</span>.<span class=\"property\">_router</span>.<span class=\"title function_\">route</span>(path);</span><br><span class=\"line\">    <span class=\"comment\">// 为路由中间件特定方法指定处理函数</span></span><br><span class=\"line\">    route[method].<span class=\"title function_\">apply</span>(route, slice.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>app的<code>handle</code>方法就比较简单了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"property\">handle</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">handle</span>(<span class=\"params\">req, res, callback</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> router = <span class=\"variable language_\">this</span>.<span class=\"property\">_router</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建兜底的final handler</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> done = callback || <span class=\"title function_\">finalhandler</span>(req, res, &#123;</span><br><span class=\"line\">    <span class=\"attr\">env</span>: <span class=\"variable language_\">this</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;env&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">onerror</span>: logerror.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有路由对象时，就可以结束了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!router) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">debug</span>(<span class=\"string\">&#x27;no routes defined on app&#x27;</span>);</span><br><span class=\"line\">    <span class=\"title function_\">done</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用router的handle方法</span></span><br><span class=\"line\">  router.<span class=\"title function_\">handle</span>(req, res, done);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Router层面\"><a href=\"#Router层面\" class=\"headerlink\" title=\"Router层面\"></a>Router层面</h3><p><span id=\"router\"></span><br>Express里中间件的具体实现在Router对象中。Router包含了Express中最为核心的概念。app中的许多API都是对Router API的简单封装。可以通过<code>app._router</code>来访问app的Router对象。Router的源码位于<code>lib/router/index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proto = <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = options || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Router本身也是一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">router</span>(<span class=\"params\">req, res, next</span>) &#123;</span><br><span class=\"line\">    router.<span class=\"title function_\">handle</span>(req, res, next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将下文中所写的方法指定为router的prototype</span></span><br><span class=\"line\">  <span class=\"title function_\">setPrototypeOf</span>(router, proto)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Router的属性初始化</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 存储中间件的stack属性</span></span><br><span class=\"line\">  router.<span class=\"property\">stack</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> router;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Router对象有一个关键属性<code>stack</code>，为一个数组，存放着所有的中间件。每一个中间件都是一个Layer对象，如果该中间件是一个路由中间件，则相应的Layer对象的route属性会指向一个Route对象，表示一条路由。</p>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p>每次调用<code>app.use()</code>时，会执行<code>router.use()</code>为<code>stack</code>属性添加一个新的中间件，这个中间件是由Layer对象包装的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.<span class=\"property\">use</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">use</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理输入参数，抽出path和fn</span></span><br><span class=\"line\">  <span class=\"comment\">// 过程同app.use</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callbacks.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;Router.use() requires middleware functions&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环fn数组，添加中间件</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; callbacks.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = callbacks[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 错误检测和打印信息</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建Layer对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> layer = <span class=\"keyword\">new</span> <span class=\"title class_\">Layer</span>(path, &#123;</span><br><span class=\"line\">      <span class=\"attr\">sensitive</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">caseSensitive</span>,</span><br><span class=\"line\">      <span class=\"attr\">strict</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">end</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;, fn);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定route属性为undefined，表示是普通中间件</span></span><br><span class=\"line\">    layer.<span class=\"property\">route</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">push</span>(layer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对于路由中间件要复杂些，路由中间件是通过<code>router.route()</code>方法注册的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.<span class=\"property\">route</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">route</span>(<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建新的Route对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> route = <span class=\"keyword\">new</span> <span class=\"title class_\">Route</span>(path);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建Layer对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> layer = <span class=\"keyword\">new</span> <span class=\"title class_\">Layer</span>(path, &#123;</span><br><span class=\"line\">    <span class=\"attr\">sensitive</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">caseSensitive</span>,</span><br><span class=\"line\">    <span class=\"attr\">strict</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">strict</span>,</span><br><span class=\"line\">    <span class=\"attr\">end</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;, route.<span class=\"property\">dispatch</span>.<span class=\"title function_\">bind</span>(route)); <span class=\"comment\">// 绑定this为route对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 指定layer的route属性为当前的路由组件，表示是路由中间件</span></span><br><span class=\"line\">  layer.<span class=\"property\">route</span> = route;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">push</span>(layer);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> route;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看来，还需要去<code>route.js</code>中看看这个对象的定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Route</span>(<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">path</span> = path;</span><br><span class=\"line\">  <span class=\"comment\">// 存放路由处理函数的stack</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">debug</span>(<span class=\"string\">&#x27;new %o&#x27;</span>, path)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 方法名和对应handler的键值对</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">methods</span> = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，Route对象也有一个stack属性，为一个数组，其中的每一项也是一个Layer对象，是对路由处理函数的包装。我们可以把它理解成一个路由中间件对象。每次调用router.route()的时候，实际上是新建了一个layer放在router.stack中；并设置layer.route为新建的Route对象。</p>\n<p>之后，通过<code>route[method].apply(route, slice.call(arguments, 1))</code>为特定方法绑定handler，<code>route[method]</code>定义在<code>route.js</code>中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span>(<span class=\"params\">method</span>)&#123;</span><br><span class=\"line\">  <span class=\"title class_\">Route</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[method] = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handles = <span class=\"title function_\">flatten</span>(slice.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; handles.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// handle即用户指定的处理函数数组</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> handle = handles[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 检测handle合法性</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"comment\">// 新建layer对象</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> layer = <span class=\"title class_\">Layer</span>(<span class=\"string\">&#x27;/&#x27;</span>, &#123;&#125;, handle);</span><br><span class=\"line\">      layer.<span class=\"property\">method</span> = method;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 更新this.methods数组，并将layer入栈</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">methods</span>[method] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">push</span>(layer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>即，当调用route.VERB()的时候，新建一个layer放在route.stack中。</p>\n<p>通过上面的分析可以发现，Router其实是一个二维的结构。一个可能的router.stack结构如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------</span><br><span class=\"line\">|    layer1    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">---------------- layer2.route.stack  ------------   ------------   ------------</span><br><span class=\"line\">|    layer2    | ------------------&gt; | layer2-1 |--&gt;| layer2-2 |--&gt;| layer2-3 |</span><br><span class=\"line\">----------------                     ------------   ------------   ------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">---------------- layer3.route.stack  ------------   ------------</span><br><span class=\"line\">|    layer3    | ------------------&gt; | layer3-1 |--&gt;| layer3-2 |</span><br><span class=\"line\">----------------                     ------------   ------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    ......    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    layerN    |</span><br><span class=\"line\">----------------</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Layer\"><a href=\"#Layer\" class=\"headerlink\" title=\"Layer\"></a>Layer</h4><p>Layer对象的构造函数如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Layer</span>(<span class=\"params\">path, options, fn</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实现函数名前有无new返回相同的效果</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(<span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Layer</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Layer</span>(path, options, fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">debug</span>(<span class=\"string\">&#x27;new %o&#x27;</span>, path)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = options || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">handle</span> = fn;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = fn.<span class=\"property\">name</span> || <span class=\"string\">&#x27;&lt;anonymous&gt;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">params</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">path</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">regexp</span> = <span class=\"title function_\">pathRegexp</span>(path, <span class=\"variable language_\">this</span>.<span class=\"property\">keys</span> = [], opts);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置特殊情况的快速匹配</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">regexp</span>.<span class=\"property\">fast_star</span> = path === <span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">regexp</span>.<span class=\"property\">fast_slash</span> = path === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; opts.<span class=\"property\">end</span> === <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Layer的属性和一些方法介绍如下</p>\n<ul>\n<li><code>handle</code> 用户指定的中间件函数</li>\n<li><code>name</code> 函数名</li>\n<li><code>params</code> 参数名，在执行<code>match</code>时赋值</li>\n<li><code>path</code> 路径名，在执行<code>match</code>时赋值</li>\n<li><code>regexp</code> 路径的正则表达形式，由<a href=\"https://github.com/pillarjs/path-to-regexp\">pathRegexp</a>转换完成</li>\n<li><code>keys</code> 路径匹配结果信息</li>\n<li><code>route</code> 路由中间件的Route对象，或<code>undefined</code></li>\n</ul>\n<p>上面看到，普通中间件和路由中间件都通过Layer的形式插入在<code>stack</code>中。尽管它们都有构造函数中声明的哪些属性，这两种Layer还是有所区别：</p>\n<ul>\n<li>Router中的Layer对象具有<code>route</code>属性，如果该属性不为<code>undefined</code>，则表明为一个路由中间件；而Route中的Layer对象没有<code>route</code>属性</li>\n<li>Route中的Layer对象具有<code>method</code>属性，表明该路由函数的HTTP方法；而Router中的Layer对象没有<code>method</code>属性</li>\n<li>Route中的Layer对象的<code>keys</code>属性值均为<code>[]</code>，<code>regexp</code>属性值均为<code>/^\\/?$/i</code>，因为在Route模块中创建Layer对象时使用的是<code>Layer(&#39;/&#39;, &#123;&#125;, fn)</code></li>\n</ul>\n<h4 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h4><p>在中间件注册完成后，剩下的工作都是由<code>app.handle()</code>或者说<code>router.handle()</code>完成的。这部分<a href=\"https://github.com/expressjs/express/blob/master/lib/router/index.js#L136-L320\">代码</a>比较复杂。大致结构如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.<span class=\"property\">handle</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">handle</span>(<span class=\"params\">req, res, out</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// middleware and routes</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> stack = self.<span class=\"property\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (match !== <span class=\"literal\">true</span> &amp;&amp; idx &lt; stack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// no match</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (match !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">done</span>(layerError);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">trim_prefix</span>(<span class=\"params\">layer, layerError, layerPath, path</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在初始化和预处理后，调用了<code>next()</code>函数。在<code>next()</code>函数中，主要的部分是while语句判断是否遍历完成整个<code>stack</code>，完成后执行done()。这部分代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (match !== <span class=\"literal\">true</span> &amp;&amp; idx &lt; stack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">  layer = stack[idx++];</span><br><span class=\"line\">  match = <span class=\"title function_\">matchLayer</span>(layer, path);</span><br><span class=\"line\">  route = layer.<span class=\"property\">route</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> match !== <span class=\"string\">&#x27;boolean&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// hold on to layerError</span></span><br><span class=\"line\">    layerError = layerError || match;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (match !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!route) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// process non-route handlers normally</span></span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (layerError) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// routes do not match with a pending error</span></span><br><span class=\"line\">    match = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> method = req.<span class=\"property\">method</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> has_method = route.<span class=\"title function_\">_handles_method</span>(method);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// build up automatic options response</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!has_method &amp;&amp; method === <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">appendMethods</span>(options, route.<span class=\"title function_\">_options</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// don&#x27;t even bother matching route</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!has_method &amp;&amp; method !== <span class=\"string\">&#x27;HEAD&#x27;</span>) &#123;</span><br><span class=\"line\">    match = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>layer</code>表示当前中间件，调用<code>matchLayer</code>方法即<code>layer.match(path)</code>判断是否和当前路径匹配（这个过程会更新<code>layer</code>中的<code>path</code>和<code>params</code>）。之后的逻辑如下：</p>\n<ol>\n<li>如果<code>match</code>不为<code>true</code>，即中间件和路径不匹配，则处理下一个中间件</li>\n<li>如果<code>match</code>为<code>true</code>，<code>route</code>不存在，表示不是一个路由中间件，执行continue，之后跳出循环</li>\n<li>如果<code>match</code>为<code>true</code>，且<code>route</code>存在。说明是需要的中间件。<br>  3.1 如果<code>has_method</code>为<code>false</code>且HTTP方法为<code>OPTIONS</code>，则执行<code>appendMethods(options, route._options())</code>添加支持方法<br>  3.2 如果<code>has_method</code>为<code>false</code>且HTTP方法不为<code>HEAD</code>，则设置<code>match</code>为false，即该路由无法处理该请求，此时由于match依然满足循环条件，因此会对下一个中间件进行判断<br>  3.3 如果<code>has_method</code>为<code>true</code>，则由于<code>match</code>不再满足循环条件，因此会跳出循环</li>\n</ol>\n<p>整体来看，循环的主要作用就是从<strong>当前下标</strong>开始找出第一个能够处理该HTTP请求的中间件。如果是非路由中间件，则只要匹配路径即可；如果是路由中间件，则需要同时匹配路径和HTTP请求方法。</p>\n<p>while语句后，如果<code>match</code>为<code>true</code>，说明遍历完成，直接执行<code>done()</code>。否则将匹配中得到的<code>path</code>和<code>params</code>交给process_params方法作参数预处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.<span class=\"title function_\">process_params</span>(layer, paramcalled, req, res, <span class=\"keyword\">function</span> (<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">next</span>(layerError || err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (route) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> layer.<span class=\"title function_\">handle_request</span>(req, res, next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">trim_prefix</span>(layer, layerError, layerPath, path);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>从回调函数中可以看到，如果是路由中间件可以直接调用<code>layer.handle_request(req, res, next)</code>执行真正的中间件函数。如果是普通中间件，还需要在<code>trim_prefix</code>中对路径处理后才会调用<code>layer.handle_request(req, res, next)</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trim_prefix</span>(<span class=\"params\">layer, layerError, layerPath, path</span>) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (layerError) &#123;</span><br><span class=\"line\">    layer.<span class=\"title function_\">handle_error</span>(layerError, req, res, next);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    layer.<span class=\"title function_\">handle_request</span>(req, res, next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在路由中间件中，<code>layer.handle_request(req, res, next)</code>调用的中间函数实际上是<code>route.dispatch</code>方法，在Route对象内容分发请求，它的逻辑相对<code>router.handle</code>要简单</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">dispatch</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">dispatch</span>(<span class=\"params\">req, res, done</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stack = <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">done</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> method = req.<span class=\"property\">method</span>.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (method === <span class=\"string\">&#x27;head&#x27;</span> &amp;&amp; !<span class=\"variable language_\">this</span>.<span class=\"property\">methods</span>[<span class=\"string\">&#x27;head&#x27;</span>]) &#123;</span><br><span class=\"line\">    method = <span class=\"string\">&#x27;get&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  req.<span class=\"property\">route</span> = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// signal to exit route</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err &amp;&amp; err === <span class=\"string\">&#x27;route&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">done</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// signal to exit router</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err &amp;&amp; err === <span class=\"string\">&#x27;router&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">done</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> layer = stack[idx++];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!layer) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">done</span>(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (layer.<span class=\"property\">method</span> &amp;&amp; layer.<span class=\"property\">method</span> !== method) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">next</span>(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      layer.<span class=\"title function_\">handle_error</span>(err, req, res, next);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      layer.<span class=\"title function_\">handle_request</span>(req, res, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>next</code>函数逻辑像下面这样</p>\n<ol>\n<li>如果有错，直接调用<code>done()</code>传递错误</li>\n<li>获取<code>layer</code>，如果不存在，调用<code>done()</code></li>\n<li><code>layer</code>和当前方法不匹配时，跳过当前<code>layer</code>，执行<code>next()</code>，继续下一个route函数</li>\n<li><code>layer</code>和当前方法匹配时，根据有无错误执行<code>layer.handle_error(err, req, res, next)</code>或是<code>layer.handle_request(req, res, next)</code>。</li>\n</ol>\n<p>综上，一个请求到达时，流程顺序像下面这样</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    layer1    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    layer2    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">---------------- layer3.route.stack  ------------   ------------   ------------</span><br><span class=\"line\">|    layer3    | ------------------&gt; | layer3-1 |--&gt;| layer3-2 |--&gt;| layer3-3 | ---</span><br><span class=\"line\">----------------                     ------------   ------------   ------------   |</span><br><span class=\"line\">                                                                                  |</span><br><span class=\"line\">        ---------------------------------------------------------------------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">---------------- layer4.route.stack  ------------   ------------</span><br><span class=\"line\">|    layer4    | ------------------&gt; | layer4-1 |--&gt;| layer4-2 | ---</span><br><span class=\"line\">----------------                     ------------   ------------   |</span><br><span class=\"line\">                                                                   |</span><br><span class=\"line\">        ------------------------------------------------------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    ......    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">----------------</span><br><span class=\"line\">|    layerN    |</span><br><span class=\"line\">----------------</span><br><span class=\"line\">        ↓</span><br></pre></td></tr></table></figure>\n\n<p>每个中间件的处理过程则像下面这样</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                ↓</span><br><span class=\"line\">  No  --------------------</span><br><span class=\"line\">------|    path match    |</span><br><span class=\"line\">|     --------------------</span><br><span class=\"line\">|               ↓ Yes</span><br><span class=\"line\">|     --------------------  Yes  ---------------------  No</span><br><span class=\"line\">|     |     has route    |-------| http method match |------</span><br><span class=\"line\">|     --------------------       ---------------------     |</span><br><span class=\"line\">|               ↓ No                       | Yes           |</span><br><span class=\"line\">|     --------------------                 |               |</span><br><span class=\"line\">|     |  process params  |&lt;-----------------               |</span><br><span class=\"line\">|     --------------------                                 |</span><br><span class=\"line\">|               ↓                                          |</span><br><span class=\"line\">|     --------------------                                 |</span><br><span class=\"line\">|     | execute function |                                 |</span><br><span class=\"line\">|     --------------------                                 |</span><br><span class=\"line\">|               ↓                                          |</span><br><span class=\"line\">|     --------------------                                 |</span><br><span class=\"line\">-----&gt;|    next layer    |&lt;---------------------------------</span><br><span class=\"line\">      --------------------</span><br><span class=\"line\">                ↓</span><br></pre></td></tr></table></figure>\n\n<p>在参数处理的过程中，每个参数的处理函数只会执行一次，并将结果保存在缓存中。在处理同一个请求的过程中，如果需要处理某个参数，会首先检查缓存，如果缓存中不存在，才会执行其处理函数。</p>\n<h2 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h2><p>在<code>middleware</code>目录下，放置了两个Express内置中间件，在<code>app.lazyRouter</code>中自动加载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"property\">lazyrouter</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">lazyrouter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">_router</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_router</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">caseSensitive</span>: <span class=\"variable language_\">this</span>.<span class=\"title function_\">enabled</span>(<span class=\"string\">&#x27;case sensitive routing&#x27;</span>),</span><br><span class=\"line\">      <span class=\"attr\">strict</span>: <span class=\"variable language_\">this</span>.<span class=\"title function_\">enabled</span>(<span class=\"string\">&#x27;strict routing&#x27;</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_router</span>.<span class=\"title function_\">use</span>(<span class=\"title function_\">query</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;query parser fn&#x27;</span>)));</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_router</span>.<span class=\"title function_\">use</span>(middleware.<span class=\"title function_\">init</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中第一个的作用是解析URL query，<code>query(this.get(&#39;query parser fn&#39;))</code>用于设置URL query解析器。第二个的作用是将req和res分别暴露给对方，并让它们分别继承自express定义的<code>app.request</code>和<code>app.response</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">init</span> = <span class=\"keyword\">function</span>(<span class=\"params\">app</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">expressInit</span>(<span class=\"params\">req, res, next</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.<span class=\"title function_\">enabled</span>(<span class=\"string\">&#x27;x-powered-by&#x27;</span>)) res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&#x27;X-Powered-By&#x27;</span>, <span class=\"string\">&#x27;Express&#x27;</span>);</span><br><span class=\"line\">    req.<span class=\"property\">res</span> = res;</span><br><span class=\"line\">    res.<span class=\"property\">req</span> = req;</span><br><span class=\"line\">    req.<span class=\"property\">next</span> = next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">setPrototypeOf</span>(req, app.<span class=\"property\">request</span>)</span><br><span class=\"line\">    <span class=\"title function_\">setPrototypeOf</span>(res, app.<span class=\"property\">response</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.<span class=\"property\">locals</span> = res.<span class=\"property\">locals</span> || <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在<code>express.js</code>中，<code>req</code>和<code>res</code>分别继承自了<code>request.js</code>和<code>response.js</code>的导出对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createApplication</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on requests</span></span><br><span class=\"line\">  app.<span class=\"property\">request</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(req, &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: &#123; <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on responses</span></span><br><span class=\"line\">  app.<span class=\"property\">response</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(res, &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: &#123; <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>关于参数处理和视图渲染，我看得不是很仔细，就不再赘述了。有兴趣的可以自行去参考中的链接学习。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://expressjs.com/\">Express - Node.js Application Framework</a></li>\n<li><a href=\"https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/\">Anatomy of an HTTP Transaction | Node.js</a></li>\n<li><a href=\"http://div.io/topic/1063\">深入理解Express</a></li>\n<li><a href=\"http://div.io/topic/1403\">Express深入解读</a></li>\n<li><a href=\"https://github.com/syaning/understanding-express/blob/master/express/router/index.md\">syaning&#x2F;understanding-express</a></li>\n</ul>\n",
            "tags": [
                "JavaSript",
                "Express",
                "源码"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/04/05/vue-reactive-sourcecode/",
            "url": "http://shenlvmeng.github.com/blog/2017/04/05/vue-reactive-sourcecode/",
            "title": "Vue2.0的响应式设计原理",
            "date_published": "2017-04-05T07:12:20.000Z",
            "content_html": "<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上周抽空看了看Vue的源码，设计的精巧让我这个鶸一时吸收不来。如果想写篇既大又全的文章，一劳永逸地介绍Vue2.0的源码，以我的水平显然是做不到的。于是就只取一瓢饮地，简单记录下Vue2.0在响应式原理上的设计。其他的部分等我功力深厚了（其实就是懒）再做总结吧。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>这一部分是Vue响应式原理的基础。包含Observer类，Watcher类，Dep类，事件订阅模式，还有最关键的<code>Object.defineProperty</code>方法。</p>\n<h4 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h4><p>Vue实现数据绑定的方式和其他的MVVM同侪不同，React和backbone（这货不是MVVM）采用的是典型的发布订阅模式，Angular则采用的脏值检测。</p>\n<p>Vue使用了更为隐蔽和magical的<code>Object.defineProperty</code>设置对象访问器属性（这也意味着Vue只支持到IE9+）。</p>\n<blockquote><p>把一个普通 Javascript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>\n</blockquote>\n\n<p><code>Object.defineProperty()</code>可以定义对象的访问器属性，关于访问器属性的更多介绍可以看<a href=\"https://shenlvmeng.github.io/blog/2017/03/13/js-object/\">这里</a>。其中<code>get</code>和<code>set</code>方法分别用来指定属性的getter和setter。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">_name</span>: <span class=\"string\">&#x27;&#x27;</span>,  <span class=\"comment\">//`_`表示只能通过方法访问</span></span><br><span class=\"line\">  <span class=\"attr\">nickname</span>: <span class=\"string\">&#x27;酱&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(person, <span class=\"string\">&#x27;name&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">nickname</span> = newValue + <span class=\"string\">&#x27;酱&#x27;</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = newValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过getter和setter实现数据劫持是Vue数据绑定的基础。</p>\n<h4 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\">发布订阅</a>是JavaScript中事件机制的实现方式，也是<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-1/\">JavaScript异步编程</a>的实现方式之一。</p>\n<p>发布订阅模式中的角色主要有发布者、事件对象、订阅者。发布者和事件对象是一对多的关系，事件对象和订阅者又是一对多的关系。当发布者的状态改变触发事件对象时，相关的订阅者就会收到通知。实现起来就像下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">EventUtil</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 全局事件管理</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> events = &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">    on = <span class=\"keyword\">function</span> (<span class=\"params\">type, handler</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (events[type]) &#123;</span><br><span class=\"line\">        events[type].<span class=\"title function_\">push</span>(handler);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        events[type] = [handler];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    emit = <span class=\"keyword\">function</span> (<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!events[type]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = events[type].<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">          events[type][i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Vue实现视图自动更新的原理也是如此，当然细节上就复杂多了。</p>\n<h4 id=\"Observer，Watcher，Dep\"><a href=\"#Observer，Watcher，Dep\" class=\"headerlink\" title=\"Observer，Watcher，Dep\"></a>Observer，Watcher，Dep</h4><p>这三个是相辅相成实现Vue数据绑定的组件。</p>\n<h5 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h5><p>Vue在组件(Component)初始化过程中，会将数据对象封装为Observer对象，便于监听数据的改变，并绑定依赖在上面。我们来看下<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L39-L53\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span> (<span class=\"attr\">value</span>: any) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">dep</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()  <span class=\"comment\">//一个 Dep对象实例，Watcher 和 Observer 之间的纽带</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">vmCount</span> = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">def</span>(value, <span class=\"string\">&#x27;__ob__&#x27;</span>, <span class=\"variable language_\">this</span>)  <span class=\"comment\">//把自身 this 添加到 value 的 __ob__ 属性上</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123; <span class=\"comment\">//对 value 的类型进行判断</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">      ? protoAugment</span><br><span class=\"line\">      : copyAugment</span><br><span class=\"line\">    <span class=\"title function_\">augment</span>(value, arrayMethods, arrayKeys) <span class=\"comment\">// 数组增强方法</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeArray</span>(value) <span class=\"comment\">//如果是数组则观察数组</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">walk</span>(value) <span class=\"comment\">//否则观察单个元素。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Observer对象储存在 <strong>ob</strong> 这个属性，这个属性保存了 Observer 对象自己本身。对象在转化为 Observer 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 Observer 对象。</p>\n<p>由于JavaScript本身的原因，Vue不能监测数组的变化，Vue采用的折中方法是增强数组的原生方法<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code>, <code>reverse</code>，以及建议使用者通过Vue.set的方式显示调用。通过其他方式对数组进行的修改将无法被监听到。</p>\n<h5 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h5><p>Vue中，Watcher和模板渲染紧密相连，它将Observer发生的改变反映到模板内容上。它关键部分的<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/watcher.js#L39-L85\">源码</a>是这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span> (</span><br><span class=\"line\">  <span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>,</span><br><span class=\"line\">  <span class=\"attr\">expOrFn</span>: string | <span class=\"title class_\">Function</span>,</span><br><span class=\"line\">  <span class=\"attr\">cb</span>: <span class=\"title class_\">Function</span>,</span><br><span class=\"line\">  options?: <span class=\"title class_\">Object</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">  vm.<span class=\"property\">_watchers</span>.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>)<span class=\"comment\">// 将当前 Watcher 类推送到对应的 Vue 实例中</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// parse expression for getter</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> expOrFn === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是函数，相当于指定了当前订阅者获取数据的方法，每次订阅者通过这个方法获取数据然后与之前的值进行对比</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = expOrFn</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = <span class=\"title function_\">parsePath</span>(expOrFn)<span class=\"comment\">// 否则的话将表达式解析为可执行的函数</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">lazy</span></span><br><span class=\"line\">    ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">    : <span class=\"variable language_\">this</span>.<span class=\"title function_\">get</span>()   <span class=\"comment\">//如果 lazy 不为 true，则执行 get 函数进行依赖收集</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中输入参数<code>vm</code>是监听的组件，<code>expOrFn</code>最终将交给<code>getter</code>属性，<code>cb</code>是更新时的回调函数。最后一句中的<code>this.get()</code>完成了依赖的收集工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">get () &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pushTarget</span>(<span class=\"variable language_\">this</span>)  <span class=\"comment\">// 设置全局变量 Dep.target，将 Watcher 保存在这个全局变量中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>) <span class=\"comment\">// 调用 getter 函数，进入 get 方法进行依赖收集操作</span></span><br><span class=\"line\">  <span class=\"comment\">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class=\"line\">  <span class=\"comment\">// dependencies for deep watching</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">deep</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">popTarget</span>()  <span class=\"comment\">// 将全局变量 Dep.target 置为 null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">cleanupDeps</span>()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一句的<code>pushTarget(this)</code>设置了<code>Dep.target</code>，getter函数正是通过<code>Dep.target</code>是否为<code>null</code>，判断当前处于依赖收集阶段还是普通数据读取。后面的两句去<code>touch``expOrFn</code>涉及到的每个数据项。从而将<code>expOrFn</code>的依赖收集起来。最后将dep中的内容清空，为下次收集依赖做准备。</p>\n<h5 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a>Dep</h5><p>Dep类用于连接Watcher类和Observer类，每个Observer对象中都有一个Dep实例，其中存储了订阅者Watcher。<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/dep.js#L17-L20\">源码</a>如下: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = uid++</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [] <span class=\"comment\">//存储 Watcher 实例的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>.<span class=\"title function_\">addDep</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// stablize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">slice</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.<span class=\"property\">length</span>; i &lt; l; i++) &#123;   <span class=\"comment\">//遍历 Watcher 列表，调用 update 方法进行更新操作</span></span><br><span class=\"line\">      subs[i].<span class=\"title function_\">update</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dep类比较简单，主要是一个存储Watcher实例的数组<code>this.subs</code>。<code>depend()</code>方法用于向Watcher对象中添加这个Dep。<code>notify()</code>方法将遍历Watcher列表，通知订阅者更新视图。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>下面从源码角度上看看Vue实现数据绑定的设计。</p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>Vue核心部分的代码放在<code>src</code>目录。路径下还有下面这些子文件夹：</p>\n<ul>\n<li><code>entries</code> 入口文件，根据编译环境的不同，更改一些配置</li>\n<li><code>compiler</code> 编译模板，<code>render</code>函数的实现</li>\n<li><code>core</code> 关键部分代码</li>\n<li><code>core/observer</code> 响应式设计中的Observer对象实现</li>\n<li><code>core/vdom</code> 虚拟DOM，diff算法，patch函数实现</li>\n<li><code>core/instance</code> 组件实例生命周期实现，组件初始化入口</li>\n<li><code>core/components</code> 全局组件</li>\n<li><code>core/global-api</code> 全局API</li>\n<li><code>server</code> 服务端渲染</li>\n<li><code>platform</code> 平台特定代码，分为<code>web</code>和<code>weex</code></li>\n<li><code>sfc</code> 处理单文件组件 解析.vue文件</li>\n<li><code>share</code> 工具函数</li>\n</ul>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>关于Vue的<a href=\"https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram\">生命周期</a>，这里假设你已经熟悉，就不做介绍了。了解它也将帮助你了解Vue的工作流程。</p>\n<p>源码的入口从下面一行<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/index.js#L8-L14\">代码</a>开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Vue</span> (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">    !(<span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Vue</span>)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">_init</span>(options) <span class=\"comment\">//开始初始化步骤</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">initMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入初始化代码</span></span><br><span class=\"line\"><span class=\"title function_\">stateMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入数据绑定代码</span></span><br><span class=\"line\"><span class=\"title function_\">eventsMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入事件相关代码</span></span><br><span class=\"line\"><span class=\"title function_\">lifecycleMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入生命周期代码</span></span><br><span class=\"line\"><span class=\"title function_\">renderMixin</span>(<span class=\"title class_\">Vue</span>) <span class=\"comment\">//插入模板渲染代码</span></span><br></pre></td></tr></table></figure>\n\n<p>文件为<code>src/core/instance/index.js</code>，关键在于最后一句，通过调用<code>init.js</code>中定义的<code>_init(options)</code>方法初始化Vue实例。这个方法是在下面的<code>initMixin(Vue)</code>中导入的。这种mixin的方式不同于Vue1.x版本，更具模块化适合拓展（同时也增加了寻找代码的难度）。</p>\n<p>初始化相关的主要<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/init.js#L40-L48\">代码</a>如下；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initMixin</span> (<span class=\"title class_\">Vue</span>: <span class=\"title class_\">Class</span>&lt;<span class=\"title class_\">Component</span>&gt;) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">_init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">options?: <span class=\"built_in\">Object</span></span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"title function_\">initLifecycle</span>(vm)   <span class=\"comment\">//vm 的生命周期相关变量初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">initEvents</span>(vm)    <span class=\"comment\">// vm 的事件监控初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">initRender</span>(vm)  <span class=\"comment\">// 模板解析</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">initState</span>(vm) <span class=\"comment\">//vm 的状态初始化，prop/data/computed/method/watch 都在这里完成初始化</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">\t  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>initLifecycle</code>主要是初始化vm实例上的一些参数；<code>initEvents</code>是事件监控的初始化；<code>initRender</code>是模板解析，2.0的版本中这一块有很大的改动，1.0的版本中Vue使用的是<code>DocumentFragment</code>来进行模板解析，而 2.0 中作者采用的John Resig的HTML Parser将模板解析成可直接执行的<code>render</code>函数。<code>initState</code>是数据绑定的主战场，我们下一节会详细讲到。<code>callHook</code>执行生命周期的钩子函数。</p>\n<h4 id=\"initState\"><a href=\"#initState\" class=\"headerlink\" title=\"initState\"></a>initState</h4><p>在初始化中，<code>initState</code>函数承担了数据绑定中的最主要的脏活累活。它的<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/state.js#L24-L36\">源码</a>像下面这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initState</span> (<span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>) &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">_watchers</span> = []  <span class=\"comment\">//新建一个订阅者列表</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> opts = vm.<span class=\"property\">$options</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">props</span>) <span class=\"title function_\">initProps</span>(vm, opts.<span class=\"property\">props</span>)  <span class=\"comment\">// 初始化 Props，与 initData 差不多</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">methods</span>) <span class=\"title function_\">initMethods</span>(vm, opts.<span class=\"property\">methods</span>)  <span class=\"comment\">// 初始化 Methods，Methods 的初始化比较简单，就是作用域的重新绑定。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">initData</span>(vm) <span class=\"comment\">// 初始化 Data，响应式关键步</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">observe</span>(vm.<span class=\"property\">_data</span> = &#123;&#125;, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>) <span class=\"comment\">//如果没有 data，则观察一个空对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">computed</span>) <span class=\"title function_\">initComputed</span>(vm, opts.<span class=\"property\">computed</span>)<span class=\"comment\">// 初始化 computed，这部分会涉及 Watcher 类以及依赖收集，computed 其实本身也是一种特殊的 Watcher</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opts.<span class=\"property\">watch</span>) <span class=\"title function_\">initWatch</span>(vm, opts.<span class=\"property\">watch</span>)<span class=\"comment\">// 初始化 watch，这部分会涉及 Watcher 类以及依赖收集</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>initState</code>将工作拆解成观察<code>props</code>, <code>data</code>, <code>methods</code>, <code>computed</code>, <code>watch</code>几个关键部分。</p>\n<h4 id=\"initData\"><a href=\"#initData\" class=\"headerlink\" title=\"initData\"></a>initData</h4><p>以<code>initData</code>方法为例，它是如何使用上面提到的Observer, Dep, Watcher类的呢，我们看看<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/state.js#L74-L104\">源码</a>: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initData</span> (<span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = vm.<span class=\"property\">$options</span>.<span class=\"property\">data</span></span><br><span class=\"line\">  data = vm.<span class=\"property\">_data</span> = <span class=\"keyword\">typeof</span> data === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">    ? data.<span class=\"title function_\">call</span>(vm)</span><br><span class=\"line\">    : data || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isPlainObject</span>(data)) &#123;<span class=\"comment\">// 保证data必须为纯对象</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// proxy data on instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(data)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = vm.<span class=\"property\">$options</span>.<span class=\"property\">props</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = keys.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (props &amp;&amp; <span class=\"title function_\">hasOwn</span>(props, keys[i])) &#123;<span class=\"comment\">// 是props，则不代理</span></span><br><span class=\"line\">      ...... <span class=\"comment\">//如果和 props 里面的变量重了，则抛出 Warning</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 否则将属性代理的 vm 上，这样就可以通过 vm.xx 访问到 vm._data.xx</span></span><br><span class=\"line\">      <span class=\"title function_\">proxy</span>(vm, keys[i]) <span class=\"comment\">//proxy方法遍历 data 的 key，把 data 上的属性代理到 vm 实例上</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// observe data</span></span><br><span class=\"line\">  <span class=\"title function_\">observe</span>(data, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)  <span class=\"comment\">//关键一步，observe(data, this)方法来对 data 做监控</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个函数做了下面的工作：</p>\n<ul>\n<li>保证data为纯对象</li>\n<li>检查是否与<code>props</code>中属性有重复</li>\n<li>进行数据代理，便于我们直接通过vm.xxx的形式访问原本位于vm._data.xxx的属性。</li>\n<li>调用<code>observe</code>方法对<code>data</code>进行包装，使之具有响应式的特点。</li>\n</ul>\n<p>那我们看看<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L101-L126\">observe</a>方法是怎么写的吧</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回一个 Observer 对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">observe</span> (<span class=\"attr\">value</span>: any, <span class=\"attr\">asRootData</span>: ?boolean): <span class=\"title class_\">Observer</span> | <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value)) &#123;  <span class=\"comment\">//如果不是对象和数组则不监控，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">ob</span>: <span class=\"title class_\">Observer</span> | <span class=\"keyword\">void</span></span><br><span class=\"line\">  <span class=\"comment\">//判断 value 是否已经添加了 __ob__ 属性，并且属性值是 Observer 对象的实例。避免重复引用导致的死循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">hasOwn</span>(value, <span class=\"string\">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class=\"property\">__ob__</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Observer</span>) &#123;    <span class=\"comment\">//如果是就直接用</span></span><br><span class=\"line\">    ob = value.<span class=\"property\">__ob__</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    observerState.<span class=\"property\">shouldConvert</span> &amp;&amp; <span class=\"comment\">//只有 root instance props 需要创建 Observer 对象</span></span><br><span class=\"line\">    !<span class=\"title function_\">isServerRendering</span>() &amp;&amp; <span class=\"comment\">//不是服务端渲染</span></span><br><span class=\"line\">    (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value) || <span class=\"title function_\">isPlainObject</span>(value)) &amp;&amp; <span class=\"comment\">//数组或者普通对象</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value) &amp;&amp; <span class=\"comment\">//可扩展对象</span></span><br><span class=\"line\">    !value.<span class=\"property\">_isVue</span> <span class=\"comment\">// 非 Vue 组件</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>(value)  <span class=\"comment\">//关键步！在 value 满足上述条件的情况下创建一个 Observer 对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\">    ob.<span class=\"property\">vmCount</span>++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob <span class=\"comment\">// 返回一个 Observer 对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>observe方法主要就是判断value是否满足一些预设条件，并将这个对象转化为Observer对象。</p>\n<p>关于Observer类我们上面已经提到，它的构造函数做了下面几个工作：</p>\n<ul>\n<li>首先创建了一个Dep对象实例；</li>\n<li>然后把自身this添加到value的<code>__ob__</code>属性上；</li>\n<li>最后对value的类型进行判断，如果是数组则观察数组，否则观察单个元素（要理解这一步是个递归过程，即value的元素如果符合条件也需要转化为Observer对象）。</li>\n</ul>\n<p>不论是基础类型还是数组或对象，最终都会走入到<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L55-L65\">walk</a>方法，方法定义在<code>src/core/observer/index.js</code>中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">walk (<span class=\"attr\">obj</span>: <span class=\"title class_\">Object</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">defineReactive</span>(obj, keys[i], obj[keys[i]]) <span class=\"comment\">//遍历对象，结合defineReactive方法地柜将属性转化为getter和setter</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive</h4><p>在经过一系列的准备工作和铺垫后，终于可以接触到数据绑定最核心部分的<code>defineReactive</code>函数。方法也定义在<code>src/core/observer/index.js</code>中，<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/index.js#L128-L184\">源码</a>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span> (</span><br><span class=\"line\">  <span class=\"attr\">obj</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">  <span class=\"attr\">key</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">val</span>: any,</span><br><span class=\"line\">  customSetter?: <span class=\"title class_\">Function</span></span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()  <span class=\"comment\">//每个对象都会有一个 Dep 实例，用来保存依赖 (Watcher 对象)</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = <span class=\"title function_\">observe</span>(val)   <span class=\"comment\">//结合 observe 函数进行将对象的对象也变成监控对象</span></span><br><span class=\"line\">  <span class=\"comment\">// 最重点、基石、核心的部分：通过调用 Object.defineProperty 给 data 的每个属性添加 getter 和 setter 方法。</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">reactiveGetter</span> () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.<span class=\"title function_\">call</span>(obj) : val</span><br><span class=\"line\">      <span class=\"comment\">// 依赖收集的重要步骤</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;<span class=\"comment\">//如果存在Dep.target这个全局变量不为空，表示是在新建Watcher的时候调用的，代码已经保证</span></span><br><span class=\"line\">        dep.<span class=\"title function_\">depend</span>()    <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.<span class=\"property\">dep</span>.<span class=\"title function_\">depend</span>() <span class=\"comment\">// 处理好子元素的依赖 watcher</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123; <span class=\"comment\">// 如果是数组，进一步处理</span></span><br><span class=\"line\">          <span class=\"title function_\">dependArray</span>(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">reactiveSetter</span> (newVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.<span class=\"title function_\">call</span>(obj) : val</span><br><span class=\"line\">      ......</span><br><span class=\"line\">      childOb = <span class=\"title function_\">observe</span>(newVal)    <span class=\"comment\">// 对新数据重新 observe，更新数据的依赖关系</span></span><br><span class=\"line\">      dep.<span class=\"title function_\">notify</span>()   <span class=\"comment\">// 通知dep进行数据更新，这个方法在前面的 Dep 类中讲过</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defineReactive是对Object.defineProperty方法的包装，结合observe方法对数据项进行深入遍历，最终将所有的属性就转化为getter和setter。其中对于Dep的处理用于收集依赖<code>data</code>的Watcher对象。</p>\n<h4 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h4><p><img src=\"/blog/blog/images/vue-reactive.jpg\"></p>\n<p><code>data</code>的依赖收集是在getter函数中完成的。Observer和Dep是一对一的关系，Dep用来存储依赖Observer的Watcher。Dep和Watcher是多对多的关系，一个Dep中存储了若干Watcher，一个Watcher可能同时依赖于多个Observer。</p>\n<p>可以看到Dep是连接Observer（生产者）和Watcher（消费者）的关键纽带。Watcher通过getter函数建立起和Observer中Dep的关联。在Observer的setter函数中会触发<code>dep.notify()</code>方法，根据上文对该方法的讲解，它实际上对数组中每个Watcher执行了<code>update</code>方法。在方法中根据是否同步去执行<code>run</code>方法，这个方法中通过<a href=\"https://github.com/vuejs/vue/blob/v2.1.10/src/core/observer/watcher.js#L157-#L191\">源码</a>可以看到实际上正是通过<code>const value = this.get()</code>获取最新的value。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update () &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dirty</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">sync</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">queueWatcher</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>模板编译过程中的指令和数据绑定都会生成 Watcher实例，watch函数中的对象也会生成 Watcher实例，在实例化的过程中，会调用watcher.js中的get函数touch这个Watcher的表达式或函数涉及的所有属性；</li>\n<li>touch开始之前Watcher会设置Dep的静态属性Dep.target指向其自身，然后开始依赖收集；</li>\n<li>touch属性的过程中，属性的getter函数会被访问；</li>\n<li>属性gette 函数中会判断Dep.target（target中保存的是第2步中设置的Watcher实例）是否存在，若存在则将 getter函数所在的Observer 实例的Dep实例保存到Watcher的列表中，并在此Dep实例中添加Watcher为订阅者；</li>\n<li>重复上述过程直至Watcher的表达式或函数涉及的所有属性均touch结束（即表达式或函数中所有的数据的getter函数都已被触发），Dep.target被置为null，依赖收集完成；</li>\n</ol>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面尝试从源码角度对Vue2.0的响应式设计做了浅析。总结一下就是下面几点：</p>\n<ul>\n<li>在生命周期的initState方法中对<code>data</code>, <code>prop</code>, <code>method</code>, <code>computed</code>, <code>watch</code>方法中的数据进行劫持，通过<code>defineReactive</code>和<code>observe</code>将之转换为Observer对象</li>\n<li><code>initRender</code>函数中解析模板，新建Watcher对象通过Dep对象和对应数据建立了依赖关系，通过<code>Dep.target</code>这个全局对象判断是否是依赖收集阶段。</li>\n<li>数据变化时，通过<code>setter</code>函数中的<code>dep.notify</code>方法执行Watcher的<code>update</code>方法更新视图</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.zybuluo.com/zhouweicsu/note/682813\">Vue2.0 源码阅读：响应式原理</a></p>\n",
            "tags": [
                "JavaScript",
                "源码",
                "Vue"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"异步\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-1/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-1/",
            "title": "JavaScript中的异步编程 上",
            "date_published": "2017-03-29T06:28:06.000Z",
            "content_html": "<blockquote>\n<p>本文启发于阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2015/04/generator.html\">深入掌握 ECMAScript 6 异步编程</a></p>\n</blockquote>\n<p><span></span></p>\n<blockquote>\n<p>下篇传送门<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-2/\">JavaScript中的异步编程 下</a></p>\n</blockquote>\n<p>JavaScript是一门<strong>单线程</strong>的语言。这样的设计减少了线程间同步和统筹的代价。但是，这也意味着，同一时刻只能完成一项工作，不能“<em>多面手</em>”。多个任务出现时，后一个任务需要等待前一个任务完成才可执行。</p>\n<p>当一项任务耗时较长时，后继者往往需要等待很久。直观体现在浏览器白屏，假死等。异步执行模式便因此而生。</p>\n<h3 id=\"异步和回调\"><a href=\"#异步和回调\" class=\"headerlink\" title=\"异步和回调\"></a>异步和回调</h3><p>异步模式区分于同步模式，任务的执行顺序和排列顺序并不完全一致。在前一个任务开始执行时，将之交给环境中其他辅助线程处理，之后立即执行下一个任务。当任务完成后，再以回调的形式执行回调函数。这种执行方式实际上正是<a href=\"https://shenlvmeng.github.io/blog/2017/02/27/event-loop/\">Event Loop</a> 的体现。</p>\n<p>在<a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\">阮老师博客</a>中提到的<strong>回调函数</strong>，<strong>事件驱动</strong>，<strong>发布订阅</strong>都能很直观的看到回调的概念。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>这是最常见的实现异步编程的方式。它的大体形式是将回调函数作为输入参数传入到需要异步完成的任务中。在任务体函数内利用全局环境下内建的异步函数实现异步的目的。</p>\n<p>大概是这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里是一个需要异步完成的函数asy和回调函数cal</span></span><br><span class=\"line\"><span class=\"title function_\">asy</span>(), <span class=\"title function_\">cal</span>();</span><br><span class=\"line\"><span class=\"comment\">//它们的定义和使用像下面这样</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">asy</span> (callback) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//异步工作代码</span></span><br><span class=\"line\">        <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">cal</span> () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello!&#x27;</span>); <span class=\"comment\">//或其它什么</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">asy</span>(cal);</span><br></pre></td></tr></table></figure>\n\n<p><code>asy()</code>函数会在完成自己工作后自动调用回调函数<code>cal()</code>。而这个过程是异步完成的。</p>\n<h4 id=\"事件驱动\"><a href=\"#事件驱动\" class=\"headerlink\" title=\"事件驱动\"></a>事件驱动</h4><p>严格来说，事件驱动是一种异步编程思想。通过事件的触发来执行特定任务的代码。使得代码的执行并不按照顺序来。</p>\n<p>使用时，最典型的用法就是DOM2级事件绑定。为DOM元素绑定监听函数，在事件触发时，执行特定代码。推广开来，可以实现JavaScript中自定义事件的监听。</p>\n<p>大概是这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;someevent&#x27;</span>, handler); <span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">target.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;someevent&#x27;</span>); <span class=\"comment\">//触发事件</span></span><br></pre></td></tr></table></figure>\n\n<p>在实现时，<code>target</code>实现了（或继承）类似于下图中EventUtil类的定义。内部维护一个对象，存储事件和回调函数数组的键值对对象。在使用on，emit时，向管理器中写入事件和读取事件对应的回调数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">EventUtil</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 全局事件管理</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> events = &#123;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">        on = <span class=\"keyword\">function</span> (<span class=\"params\">type, handler</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (events[type]) &#123;</span><br><span class=\"line\">                events[type].<span class=\"title function_\">push</span>(handler);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                events[type] = [handler];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">        emit = <span class=\"keyword\">function</span> (<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!events[type]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = events[type].<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                events[type][i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h4><p>上面这种事件驱动的方式在React和Vue等MVVM框架中经常用来在组件间传递信息。当组件关系复杂时，发布订阅模式会更有利于管理信息和将信息集中化管理。</p>\n<p>也就是<a href=\"http://redux.js.org/\">Redux</a>和<a href=\"https://vuex.vuejs.org/\">Vuex</a>所做的事情。任务状态改变时，向中心传递信号，其他订阅这个信号的任务函数都会受到这个信号。</p>\n<h3 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h3><p>异步回调好是好，很好理解。但是处理错误的“<a href=\"http://callbackhell.com/\">回调地狱</a>”也为人诟病。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">async</span>(<span class=\"params\">request, callback</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something.</span></span><br><span class=\"line\">    <span class=\"title function_\">asyncA</span>(request, <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do something</span></span><br><span class=\"line\">        <span class=\"title function_\">asyncB</span>(request, <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Do something</span></span><br><span class=\"line\">            <span class=\"title function_\">asyncC</span>(request, <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Do something</span></span><br><span class=\"line\">                <span class=\"title function_\">callback</span>(data);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种在回调中嵌套其他异步函数的场景下，错误的捕获变得异常头痛。代码也会变得难以阅读和维护。</p>\n<p>ES6中的<a href=\"http://wiki.commonjs.org/wiki/Promises/A\">Promise</a>对象优雅地解决了回调地狱的问题。它由CommonJS工作组提出，通过<code>then</code>和<code>catch</code>方法指定回调函数和错误的捕获函数，<strong>同时返回一个<code>Promise</code>对象</strong>。</p>\n<p>它的使用方法像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(val);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//success handler</span></span><br><span class=\"line\">&#125;, <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//failure handler</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或是</span></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//success handler</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//error handler</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理一批次的异步任务</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([p1, p2, p3]),</span><br><span class=\"line\">    q = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n\n<p>在实现上，<code>Promise</code>其实和事件订阅模式类似。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//constructor</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Promise</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">callbacks</span> = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">construct</span>: <span class=\"title class_\">Promise</span>,</span><br><span class=\"line\">    <span class=\"attr\">resolve</span>: <span class=\"keyword\">function</span>(<span class=\"params\">result</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">complete</span>(<span class=\"string\">&quot;resolve&quot;</span>, result);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">reject</span>: <span class=\"keyword\">function</span>(<span class=\"params\">result</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">complete</span>(<span class=\"string\">&quot;reject&quot;</span>, result);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">complete</span>: <span class=\"keyword\">function</span>(<span class=\"params\">type, result</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">callbacks</span>[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">callbacks</span>.<span class=\"title function_\">shift</span>()[type](result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">then</span>: <span class=\"keyword\">function</span>(<span class=\"params\">successHandler, failedHandler</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">callbacks</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">resolve</span>: successHandler,</span><br><span class=\"line\">            <span class=\"attr\">reject</span>: failedHandler</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Promise在回调函数较少时，<code>then</code>方法的链式调用无伤大雅。当出现较多异步回调场景下，如异步<strong>陆续</strong>加载100张图片，<code>then</code>方法的使用仍显得不那么自然。</p>\n<p>有自然的使用方法么？答案是有的。下篇中介绍的Generator和async将实现异步编程的更高境界。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://segmentfault.com/a/1190000003028634\">异步编程 promise模式 的简单实现</a></p>\n",
            "tags": [
                "JavaScript",
                "异步"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-2/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/29/javascript-async-programming-2/",
            "title": "JavaScript中的异步编程 下",
            "date_published": "2017-03-29T06:28:06.000Z",
            "content_html": "<blockquote>\n<p>本文启发于阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2015/04/generator.html\">深入掌握 ECMAScript 6 异步编程</a></p>\n</blockquote>\n<p><span></span></p>\n<blockquote>\n<p>上篇传送门<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-1/\">JavaScript中的异步编程 上</a></p>\n</blockquote>\n<p>上篇说到了使用回调的思路解决JavaScript中异步编程的难题。可不论是显式的指定回调函数，通过事件绑定响应还是通过事件订阅、promise.then，都和逃不出回调的思路。写起来仍不够自然，且在批次回调任务时难以解决。</p>\n<p>有没有办法能使我们像平时写同步代码那样，来书写异步代码呢？ES6出现后，Generator对象给了我们这个机会。</p>\n<h3 id=\"生成器函数\"><a href=\"#生成器函数\" class=\"headerlink\" title=\"生成器函数\"></a>生成器函数</h3><p>提到生成器函数前，需要提到<a href=\"https://en.wikipedia.org/wiki/Coroutine\">协程</a>(coroutine)这个概念。协程是轻量级用户态的线程。用户可以手动控制协程的暂停和继续，配合线程实现异步任务。协程间通过<code>yield</code>方式切换执行权，并交换信息。就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">asyncFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行someFunc后交出执行权</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"keyword\">yield</span> <span class=\"title function_\">someFunc</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>协程在遇到<code>yield</code>关键字时交出自己的执行权，直到执行权返回。这里<code>someFunc</code>方法可以是一个异步操作。</p>\n<p>ES6中协程体现在Generator函数中。函数在<code>function</code>关键字后添加星号<code>*</code>以示和普通函数的区分。Generator函数是可以通过<code>yield</code>暂停执行的。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* gen () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>(); </span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>Generator函数的调用通过<code>next</code>方法完成。每次调用后会将函数流程移动到下一个yield语句处。yield的返回包含两个属性<code>value</code>和<code>done</code>。前者代表yield的返回值，后者代表生成器函数是否已经执行完毕。</p>\n<p>同时，每次调用<code>next</code>方法时，可以输入参数作为上个异步任务的返回值。调用<code>throw</code>方法可以向生成器函数内抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* gen () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>(); </span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\">g.<span class=\"keyword\">throw</span>(<span class=\"string\">&#x27;some error&#x27;</span>) <span class=\"comment\">// &#x27;some error&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用Generator函数封装一个异步操作，再通过执行器管理函数内部的异步流程。通过这种方式，在Generator函数中可以很方便地书写异步操作。例如，利用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch API</a>发起一次跨域请求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;http://www.example.org/data.json&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>fetch API返回一个promise对象，通过为之指定<code>then</code>，处理fetch成功后的返回值。</p>\n<h3 id=\"co和koa\"><a href=\"#co和koa\" class=\"headerlink\" title=\"co和koa\"></a>co和koa</h3><p>我们上面提到了使用Generator还缺少的一样东西——执行器。使用Generator函数在其中通过yield返回Promise，但是外层还是需要在promise的then方法中书写<code>g.next(data)</code>来通知协程继续操作。<a href=\"https://github.com/tj/co\">co</a>函数库帮助我们<strong>完成了执行器的工作</strong>。</p>\n<p>以回调函数中完成读文件操作为例（注意：其中的readFile先被改写成返回thunk函数的格式，即只接收callback作为唯一的输入参数）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;co&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readFile</span>(<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">readFile</span>(path, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf-8&#x27;</span>&#125;, cb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">co</span>(gen);</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，为<code>co</code>函数传入Generator函数，就会自动依次执行其中的异步任务，并在返回一个Promise对象。因此，可以给<code>co</code>函数通过<code>then</code>的方式添加回调函数。</p>\n<h4 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h4><p>co的代码并不复杂，核心代码只有数十行。摘录如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">co</span>(<span class=\"params\">gen</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = slice.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> gen === <span class=\"string\">&#x27;function&#x27;</span>) gen = gen.<span class=\"title function_\">apply</span>(ctx, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gen || <span class=\"keyword\">typeof</span> gen.<span class=\"property\">next</span> !== <span class=\"string\">&#x27;function&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(gen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">onFulfilled</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">onFulfilled</span>(<span class=\"params\">res</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = gen.<span class=\"title function_\">next</span>(res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">next</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">onRejected</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = gen.<span class=\"keyword\">throw</span>(err);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">next</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">ret</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret.<span class=\"property\">done</span>) <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(ret.<span class=\"property\">value</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = toPromise.<span class=\"title function_\">call</span>(ctx, ret.<span class=\"property\">value</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value &amp;&amp; <span class=\"title function_\">isPromise</span>(value)) <span class=\"keyword\">return</span> value.<span class=\"title function_\">then</span>(onFulfilled, onRejected);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">onRejected</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class=\"line\">        + <span class=\"string\">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class=\"title class_\">String</span>(ret.<span class=\"property\">value</span>) + <span class=\"string\">&#x27;&quot;&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在看co的代码前，我们不妨先想一下它的原理。Generator 函数只是一个异步操作的容器，它的流程和控制是由外部机制完成的。而<strong>thunk函数（这个在下面介绍）和Promise对象恰恰可以方便得在回调函数和then方法中交还执行权给Generator函数</strong>。</p>\n<p>这么来看就简单了，<strong>co函数库针对thunk函数和Promise对象封装了执行器</strong>。以比较好理解的Promise对象为例（co在内部也会将thunk函数转为Promise对象）。</p>\n<p>首先将readFile的thunk函数转为Promise对象。其中ctx绑定到co函数体内。（co函数库的thunkToPromise函数）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"keyword\">function</span> (<span class=\"params\">path</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span> (<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)&#123;</span><br><span class=\"line\">        readFile.<span class=\"title function_\">call</span>(ctx, <span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (err) <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">            <span class=\"title function_\">resolve</span>(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后同样使用上节中的生成器函数<code>gen()</code>，并手动执行下一步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">g.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    g.<span class=\"title function_\">next</span>(data).<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">        g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>发现规律了么？<strong>自动执行器实际上就是在<code>g.done == false</code>时，不断地在then方法中嵌套添加回调函数</strong>。结果呼之欲出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行器</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">run</span> (gen) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> g = gen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = g.<span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.<span class=\"property\">done</span>) <span class=\"keyword\">return</span> res.<span class=\"property\">value</span>;</span><br><span class=\"line\">        res.<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">next</span>(data);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">run</span>(gen);</span><br></pre></td></tr></table></figure>\n\n<p>每执行一次next，检查<code>done</code>的状态，若未结束则在then方法继续指定next方法，等待下一次返回结果。这也是co函数库的基本原理。</p>\n<h5 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h5><p>理解了原理后，回头看co的源码，就比较好理解了。前6行对传入的<code>gen</code>检测是否为Generator类型。<code>onFulfilled</code>函数和<code>onRejected</code>函数对Generator函数原有的<code>next</code>和<code>throw</code>函数进行了封装，便于错误捕获和处理。</p>\n<p>在<code>next</code>方法中，主要做了下面的4步微小的工作：</p>\n<ol>\n<li>查是否已经到Generator函数的最后一步，如果是则返回</li>\n<li>确保每次<code>yield</code>返回值都是Promise对象</li>\n<li>通过<code>then</code>方法，为返回值添加回调函数，并在回调中再次调用自身</li>\n<li>对于类型不合适的<code>gen</code>，将状态修改为<code>rejected</code></li>\n</ol>\n<p>co能接收的yield返回值类型是有限的（尽管Generator函数中的yield后不限制返回值类型），有thunk函数，array，object，Promise对象。其中array和object使co可以胜任并发的操作，即可以在yield中返回多个异步操作任务。</p>\n<h4 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h4><p>koa是建立在generator和co之上的中间件框架，由Express开发人员打造。它通过组合不同的生成器函数，避免了繁杂易出错的回调函数嵌套。koa中没有绑定任何中间件，仅仅提供了一个轻量级函数库。</p>\n<blockquote>\n<p>Koa 中间件以一种更加传统的方式级联起来, 跟你在其他系统或工具中碰到的方式非常相似。 然而在以往的 Node 开发中, 级联是通过回调实现的, 想要开发用户友好的代码是非常困难的, Koa 借助 generators 实现了真正的中间件架构, 与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的方法直到某个结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 yield next 关键字时，会被传递到下游中间件（downstream），在 yield next 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>\n</blockquote>\n<h3 id=\"thunk\"><a href=\"#thunk\" class=\"headerlink\" title=\"thunk\"></a>thunk</h3><p>上文中提到的thunk函数实际上由来已久，它是函数传名调用的一种实现方式，不同于函数的传值调用。就像下面的例子一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行器</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>(x * <span class=\"number\">3</span> + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以写成下面这样</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">thunk</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">3</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">thunk, <span class=\"number\">1</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">thunk</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript中的thunk函数有着另外的意思，它替换的不是一个输入参数，而是<strong>将多参数的函数替换成单参数的版本，且只接受回调函数作为输入参数</strong>，正如之前写到的例子一样。</p>\n<p>一个简单的thunk函数转换器写起来并不复杂，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> thunk = <span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">done</span>) &#123;</span><br><span class=\"line\">            args.<span class=\"title function_\">push</span>(done);</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/tj/node-thunkify\">node-thunkify</a>模块对此又多了一些监测，如在最内层的function添加called变量确保回调函数只执行一次。Thunkify的源码相比co就更短了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">thunkify</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">assert</span>(<span class=\"string\">&#x27;function&#x27;</span> == <span class=\"keyword\">typeof</span> fn, <span class=\"string\">&#x27;function required&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个包含thunk函数的函数，返回的thunk函数用于执行yield，而外围这个函数用于给thunk函数传递参数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存当前上下文环境，给fn提供执行环境</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 将参数类数组转化为数组（实现方式略显臃肿，可直接用Array.prototype.slice.call(arguments)实现）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; args.<span class=\"property\">length</span>; ++i) &#123;</span><br><span class=\"line\">            args[i] = <span class=\"variable language_\">arguments</span>[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 真正的thunk函数（有且只有一个参数是callback的函数，且callback的第一个参数为error）</span></span><br><span class=\"line\">        <span class=\"comment\">// 类似于：</span></span><br><span class=\"line\">        <span class=\"comment\">// function(cb) &#123;fs.readFile(path, &#123;encoding: &#x27;utf8&#125;, cb)&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">done</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> called;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 将回调函数再包裹一层，避免重复调用；同时，将包裹了的真正的回调函数push进参数数组</span></span><br><span class=\"line\">            args.<span class=\"title function_\">push</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                done.<span class=\"title function_\">apply</span>(<span class=\"literal\">null</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在ctx上下文执行fn（一般是异步函数，如：fs.readFile）</span></span><br><span class=\"line\">                <span class=\"comment\">// 并将执行thunkify之后返回的函数的参数（含done回调）传入，类似于执行：</span></span><br><span class=\"line\">                <span class=\"comment\">// fs.readFile(path, &#123;encoding: &#x27;utf8&#125;, done)</span></span><br><span class=\"line\">                <span class=\"comment\">// 关于done是做什么用，则是在co库内</span></span><br><span class=\"line\">                fn.<span class=\"title function_\">apply</span>(ctx, args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">done</span>(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>thunk函数的特点和Promise对象类似，就是将回调函数的绑定单独抽离出来，thunk函数结合Generator函数实现自动流程管理方法和Promise一样。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>从Promise对象到Generator函数，JavaScript中的异步编程越来越简单，但是还是有戴着镣铐跳舞的感觉，async函数的提出即将把这个镣铐摘掉。</p>\n<p>async函数的使用和Generator函数很像，我们改写之前的那个读取文件函数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">readFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d1 = <span class=\"keyword\">await</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file1.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d2 = <span class=\"keyword\">await</span> <span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file2.js&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然和Generator函数很像，但是它有着更清晰易懂的语法，更广的适用性（<code>await</code>后可以跟任何类型，在原始类型时等同于同步操作）。最关键的是，<strong>async函数自带执行器！！！</strong></p>\n<p>在实现上，async函数和Generator函数是一样的，不过是将执行器放在自身内部而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">args</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">spawn</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spawn</span> (genF, self) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> gen = genF.<span class=\"title function_\">call</span>(self);</span><br><span class=\"line\">    <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"title function_\">next</span>(<span class=\"literal\">undefined</span>));</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">step</span> (nextF) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> next;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        next = <span class=\"title function_\">nextF</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// finished with failure, reject the promise</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (next.<span class=\"property\">done</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// finished with success, resolve the promise</span></span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(next.<span class=\"property\">value</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// not finished, chain off the yielded promise and `step` again</span></span><br><span class=\"line\">      <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(next.<span class=\"property\">value</span>).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"title function_\">next</span>(v)),</span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> gen.<span class=\"keyword\">throw</span>(e))</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用上，async函数返回一个Promise对象。可以使用then方法添加回调函数。当遇到<code>await</code>时先返回，等待异步操作完成后再执行函数体后的语句。<code>await</code>只能用在async函数中，在普通函数中使用会报错。同时，async函数目前是ES7的标准，需要通过Babel转码使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\">This API is so Fetching!</a><br><a href=\"https://github.com/tj/co\">co</a><br><a href=\"https://nswbmw.github.io/N-club/1/1.3.html\">co和koa</a><br><a href=\"https://ponyfoo.com/articles/understanding-javascript-async-await\">Understanding JavaScript’s async await</a></p>\n",
            "tags": [
                "JavaScript",
                "异步",
                "Generator",
                "thunk",
                "async"
            ]
        }
    ]
}
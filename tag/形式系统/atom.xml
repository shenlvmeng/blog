<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;形式系统&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2023-04-23T14:23:22.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="2018" />
    <category term="2019" />
    <category term="flag" />
    <category term="2020" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="绘图" />
    <category term="动画" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="DOM" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="架构" />
    <category term="组件" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="形式系统" />
    <category term="不完全性" />
    <category term="隐喻" />
    <category term="哥德尔" />
    <category term="巴赫" />
    <category term="埃舍尔" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2023/04/23/g-e-b-1/</id>
        <title>GEB —— 集异璧之大成 上</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2023/04/23/g-e-b-1/"/>
        <content type="html">&lt;p&gt;19年得知通过豆瓣得知GEB一书时，该书初版已许多年，求之不得。幸而在21年该书再次印刷，且准备再版。于21年底果断购入。读之甚欢，虽有些艰深，但远不止镇柜神书那么简单。这一点和《失控》相比显得高下立判。&lt;/p&gt;
&lt;h2 id=&#34;引子：《逻辑的奉献》&#34;&gt;&lt;a href=&#34;#引子：《逻辑的奉献》&#34; class=&#34;headerlink&#34; title=&#34;引子：《逻辑的奉献》&#34;&gt;&lt;/a&gt;引子：《逻辑的奉献》&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;自指、怪圈、哥德尔定理、人工智能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从巴赫的《音乐的奉献》谈起，由&lt;strong&gt;卡农&lt;/strong&gt;和&lt;strong&gt;赋格&lt;/strong&gt;这种带有自指音乐形式转述至艾舍尔自指矛盾的画，并发现这种形式和&lt;strong&gt;哥德尔不完全定理&lt;/strong&gt;中构造自指怪圈有着异曲同工的感觉。这种怪圈似乎是固有的，&lt;strong&gt;系统禀赋&lt;/strong&gt;的。不论是康托集合论里的悖论还是逻辑学里的罗素悖论，都是自指在数理逻辑中“搞破坏式”的表现。在哥德尔发表他的定理之后，图灵和丘奇从不同的角度提出不完全定理在计算机领域的应用——可计算性。&lt;/p&gt;
&lt;h3 id=&#34;三部创意曲&#34;&gt;&lt;a href=&#34;#三部创意曲&#34; class=&#34;headerlink&#34; title=&#34;三部创意曲&#34;&gt;&lt;/a&gt;三部创意曲&lt;/h3&gt;&lt;p&gt;这里用小品的方式引出阿基里斯，乌龟两位主角，还顺带介绍了芝诺悖论和艾舍尔画的莫比乌斯环。&lt;/p&gt;
&lt;h2 id=&#34;WU谜题&#34;&gt;&lt;a href=&#34;#WU谜题&#34; class=&#34;headerlink&#34; title=&#34;WU谜题&#34;&gt;&lt;/a&gt;WU谜题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;形式系统、系统内外、判定过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一节以一个预设的WJU形式系统开始，用字符串替代公理、定理，让读者对形式系统有一个初步的感性认识。作者给出了一个题目，以WJ字符串为系统的起始，基于以下4条推导规则，是否能得出WU。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规则1：WJ后可以跟上U&lt;/li&gt;
&lt;li&gt;规则2：Wx可以替换为Wxx，其中x为任意字符串&lt;/li&gt;
&lt;li&gt;规则3：每处JJJ可以替换为U&lt;/li&gt;
&lt;li&gt;规则4：每处UU可以被直接去掉&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形式系统内的变换类似上面这样的字符变换。以此聊开去，对比人和机器，人在做一段时间运算后，会发现其中的&lt;strong&gt;性质&lt;/strong&gt;，通过&lt;strong&gt;洞察力&lt;/strong&gt;可以理解这里面的&lt;strong&gt;模式&lt;/strong&gt;，可以灵活地跳出&lt;strong&gt;系统&lt;/strong&gt;的边界之外。而对于机器，除非你告诉它这么做，它会不厌其烦地，从WJ开始，一直往下&lt;strong&gt;机械地&lt;/strong&gt;计算出所有的字符串组合，完全不会意识到自己在做什么。人类在做事时，不需要刻意去区分系统内外，就可以很自然做到意识到系统的存在。而这也是机器做不到的一点。&lt;/p&gt;
&lt;p&gt;回到这个WJU形式系统，你可以用机器的方式推导（J方式），也可以用人类的形式思考（W方式），譬如发现规则1和2增大字符串长度，3和4则是缩短字符串长度。最后的U形式对应禅宗的处事态度。判定过程意味着，在WJU这样的形式系统中，可以在有限时间内给出定理的判定结果。然而两条缩短规则让某条定理（如WU）的证明变得困难甚至不能完成。&lt;/p&gt;
&lt;h3 id=&#34;二部创意曲&#34;&gt;&lt;a href=&#34;#二部创意曲&#34; class=&#34;headerlink&#34; title=&#34;二部创意曲&#34;&gt;&lt;/a&gt;二部创意曲&lt;/h3&gt;&lt;p&gt;用循环嵌套命题的形式引出下一周即将提到的形式系统、&lt;/p&gt;
&lt;h2 id=&#34;数学中的意义和形式&#34;&gt;&lt;a href=&#34;#数学中的意义和形式&#34; class=&#34;headerlink&#34; title=&#34;数学中的意义和形式&#34;&gt;&lt;/a&gt;数学中的意义和形式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;形式系统、公理模式、同构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一节WU谜题的之外，用另一个pq系统来介绍形式系统。pq系统有无数个公理。但这些公理可以用一个共同的模式生成，即x-qxp-，其中x只由横杠-组成，在公理以外，有着一条简洁的推导规则，得到所有的定理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若xqypz是一条定理，那么x-qypz-也是一条定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这么一个形式系统下，经过观察可以发现其中的&lt;strong&gt;模式&lt;/strong&gt;：加法的遗传特性。且这个系统只有简单的一条增长规则，即在定理不断枚举的同时，也在不断变长，这使得pq系统不同于WJU系统，可以通过从顶向下的回溯或从底向上的生成来判定每一条定理是否属于系统。&lt;/p&gt;
&lt;p&gt;实际上，作者发明的pq系统是和现实世界的加法法则是&lt;strong&gt;同构&lt;/strong&gt;的，q即equals，p即plus，-即1，在这个映射下，pq系统即一个描述加法的形式系统。这种同构也是对形式系统的一种“&lt;strong&gt;解释&lt;/strong&gt;”。在高层次存在一个真理和定理的对应，这种对应在你选取对于p、q、-符号的解释前不容易发现。对于形式系统的&lt;strong&gt;解释&lt;/strong&gt;选取也是很有讲究的，存在着能类比到现实世界的有意义的解释和无意义的解释。&lt;/p&gt;
&lt;p&gt;形式系统本无意义，需要解读者赋予意义，这和语言中的意义就不一样。语言中的意义是&lt;strong&gt;主动的&lt;/strong&gt;，围绕符号的意义可以让我们创建新的规则，譬如—-q-p-p-p，代表4&amp;#x3D;1+1+1+1；形式系统里的意义是&lt;strong&gt;被动的&lt;/strong&gt;，你可以根据意义去解读字符串，但是只能在给定规则里行动，不能创造新的。对于逐字符解读可以产生合语法句子的字符串，就可以称为&lt;strong&gt;良构字符串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现实和形式系统是&lt;strong&gt;相互独立&lt;/strong&gt;的，并不依赖于两者间的同构关系。除了简单的加法法则，几乎整个现实世界也都可以用形式系统来抽象。这里仅以数学为例，我们所熟知的算术规则也是形式系统里的定理，映射到现实世界里，仅通过有穷情况下的验证是不够的。借助一些推导规则，可以应用到所有的数上。关于数的定理，对于“两个整数的和”这种，我们还能通过计数去同构现实世界，但对于“有无穷个素数”这种，就需要借助符号的推理。这个证明过程由许多滴水不漏的步骤联系在一起，这也暗示着存在一个&lt;strong&gt;结构模式&lt;/strong&gt;可以把这些陈述串起来，这个模式可以用特定风格的词汇或符号来展示。浓缩之后，看起来平滑过渡的每一句话里包含了许多“原子化”的推理过程。&lt;/p&gt;
&lt;h3 id=&#34;无伴奏阿基里斯奏鸣曲&#34;&gt;&lt;a href=&#34;#无伴奏阿基里斯奏鸣曲&#34; class=&#34;headerlink&#34; title=&#34;无伴奏阿基里斯奏鸣曲&#34;&gt;&lt;/a&gt;无伴奏阿基里斯奏鸣曲&lt;/h3&gt;&lt;p&gt;借字谜和艾舍尔的镶嵌画，讨论图案和衬底，引出下节的话题。&lt;/p&gt;
&lt;h2 id=&#34;图形和衬底&#34;&gt;&lt;a href=&#34;#图形和衬底&#34; class=&#34;headerlink&#34; title=&#34;图形和衬底&#34;&gt;&lt;/a&gt;图形和衬底&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;印符规则、非定理、图形、衬底、递归可枚举集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上节pq系统的基础上，让我们设想一个Px的定理，其中x代表素数长度的横杠。首先回归WJU系统和pq系统，里面生成代表定理的字符串时，用到下面这样的&lt;strong&gt;印符规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入并识别有限字符集中任意一个符号&lt;/li&gt;
&lt;li&gt;写入任意一个符号&lt;/li&gt;
&lt;li&gt;把任意&lt;strong&gt;一些&lt;/strong&gt;符号从一处搬到另一处&lt;/li&gt;
&lt;li&gt;删除任意一些符号&lt;/li&gt;
&lt;li&gt;检查一个符号是否和另一个相同&lt;/li&gt;
&lt;li&gt;保存并使用之前得到的定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用和加法规则相同的思路，可以制造一个tq系统，同样地，用一个&lt;strong&gt;公理模式&lt;/strong&gt;开始：对于任意x，xqxt-，其中x仅由-组成；再加上一个推理规则：对于任意x、y、z，如果xqytz，那么可以得到xyqytz-，其中x、y、z仅由-组成。随便选取几个例子，站在“系统”外面观察下模式就能看出乘法的模式了。如果看了pq系统一节，可以很容易做到。在tq系统基础上，也可以定义能够刻画合数的定理：x、y、z仅由短杠-组成，如果xqy-tz-是定理，那么Cx是定理。使用W方式就能看到，&lt;code&gt;x = (y+1) * (z+1)&lt;/code&gt;的模式，x的短杠数目即是合数。另外，使用J方式，不考虑短杠背后的含义，可以机械式验证一个Cx是不是定理。&lt;/p&gt;
&lt;p&gt;现在，我们考虑如何定义一个刻画素数的定理。一个最简单的想法就是给出上面的否定形式，即x仅由-组成，如果Cx&lt;strong&gt;不是&lt;/strong&gt;一个定理，那么Px是一个定理。但是其中Cx是否是一个定理并不在我们的印符规则中。印符规则只能让你看到定理是否在之前得出的定理集中，并没有一个“&lt;strong&gt;非定理集&lt;/strong&gt;”给你查询。到目前为止，刻画素数的定理还只是作为Cx系统的“空洞”出现，并不能看到其中的形式。&lt;/p&gt;
&lt;p&gt;作者在这里举了艾舍尔的一些绘画例子，有些图案在构成图形的同时，其衬底也可以作为一种图形存在。当然了，大多数情况下，可识别的形状外，其&lt;strong&gt;负空间&lt;/strong&gt;不可识别。类比到作者提出的印符数论（TNT），既有所有定理集合的负空间，也有定理空间的变形副本（通过否定每个定理得到）。这两者是否能等价呢？结果先预告下，不可以。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非定理集中存在真理&lt;/li&gt;
&lt;li&gt;否定每个定理得到的集合之外存在假理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，在素数这个具体case下，是可以用一个“正空间”等价到“负空间”上的。不过更普遍的情况下，&lt;strong&gt;存在一个形式系统，其负空间（非定理集）不是任何一个形式系统的正空间（定理集）&lt;/strong&gt;。换句话说，&lt;strong&gt;存在非递归的递归可枚举集&lt;/strong&gt;。其中递归即指艾舍尔画中那种相呼应特性，递归可枚举即可以发现其中的模式。其实以自然数为例，我们以固定模式抠出其中的元素，剩余元素构成的空洞就像一幅画的负空间，大概率很难找到一种显而易见的模式来定义。&lt;/p&gt;
&lt;p&gt;回过头来说素数，实际上是可以找到这么样的定理的。首先我们正面定义出刻画&lt;strong&gt;不可整除&lt;/strong&gt;的定理。给出起始的公理模式，x、y仅由-组成，xyBZCx为公理；再给出推理规则，如果xBZCy是定理，那么xBZCxy也是定理。其中BZC就代表不整除的性质。使用W方式就能理解了。在BZC的基础上，定义素数，素数不能被1和自身以外的数整除，所以从2开始，公理模式：如果–BZCz，那么zMY–是个定理；再给出推理规则：如果zMYx和x-BZCz都是定理，那么zMYx-也是定理。这两步已经构造出了无因子性。再补充一个规则，如果z-MYz是定理，那么Pz-是个定理；同时设置一个公理P–。之后的素数就可以一个个向后推广。素数的情况还比较简单，形式系统的复杂性，有向前向后推导的各种情况，导致了哥德尔定理、图灵的停机问题出现。&lt;/p&gt;
&lt;h3 id=&#34;对位藏头诗&#34;&gt;&lt;a href=&#34;#对位藏头诗&#34; class=&#34;headerlink&#34; title=&#34;对位藏头诗&#34;&gt;&lt;/a&gt;对位藏头诗&lt;/h3&gt;&lt;p&gt;用藏头的对话致敬了巴赫将BACH嵌入《赋格的艺术》的尾巴。同时阿基里斯和乌龟关于所有唱机总有播放不了的唱片的讨论，同构暗示哥德尔不完全定理。&lt;/p&gt;
&lt;h2 id=&#34;一致性、完全性和几何学&#34;&gt;&lt;a href=&#34;#一致性、完全性和几何学&#34; class=&#34;headerlink&#34; title=&#34;一致性、完全性和几何学&#34;&gt;&lt;/a&gt;一致性、完全性和几何学&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;完全性、一致性、非欧几何、未定义项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第三章的末尾，作者从龟的角色给出了唱片和唱机的小品。在这个小品上，对于任何一种唱机都有自己播放不了的唱片，播放会导致自己的摧毁。这个故事用同构的方式给哥德尔不完备定理一个感性的秒描绘。哥德尔的定理说明不存在这么一个形式系统：任何一个真陈述都可以作为系统中的定理。这段陈述涉及对&lt;strong&gt;一致性&lt;/strong&gt;和&lt;strong&gt;完全性&lt;/strong&gt;的描述。为了解释这两种属性，我们还是从pq系统来看，我们为最初的pq系统增加一种公理模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xqxp-，其中x由-组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前的加法解释在现在的pq系统下出现了错位的现象，–q-p-和-q-p-都是定理，在加法解释下，系统有不一致性。我们可以调整一下解释，把q解释为小于等于，挽回之前的同构，使系统重新具有一致性。&lt;/p&gt;
&lt;p&gt;几何学里也有类似的情形。在欧几里得的《几何原理》中，从最基本的概念和定义开始，构建了庞大的严格的欧几里得几何体系。不过欧几里得对其中最基本的“点”，“线”，“圆”下的定义，没有办法和现实世界里的“点”，“线”，“圆”区分出来。因此一些下意识就潜入了他的证明。当然这只是经典著作里的些微瑕疵。欧几里得在公设上的缺乏严格也导致后续非欧几何的出现。《几何原理》的前4个公设简洁和优美：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直线段可以连接两个点&lt;/li&gt;
&lt;li&gt;直线上的任意直线段可以任意眼神&lt;/li&gt;
&lt;li&gt;任意直线段可以以一个端点为圆心，自己为半径做一个圆&lt;/li&gt;
&lt;li&gt;一切直角彼此相等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而第5条公设相比之下就显得格格不入的“丑陋”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两条直线和第三条直线相交时，在第三条直线的一侧，三条直线所夹成的内角和如果小于两个直角的和，那么在这一侧，那两条直线延长足够远后一定会相交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用更好懂的说法，即给定一条直线，和直线外一点，过该点有且只有一条直线和给定直线平行。欧几里得本人在几何证明中也尽量避免使用第5条公设。他之后的许多数学家尝试用前4条公设去推理第5条公设失败后，转换思路去否定第5条公设，之后试图寻找系统内的矛盾。最终导致非欧几何的诞生，实际上，当你摆脱现实世界中“直线”的先入为主的理解后，就能获得非欧几何的新视角。例如，在椭圆几何中，过直线外一点，没有直线与该线平行。椭圆几何中的点和线，分别可以理解为一个球上的一对&lt;strong&gt;对径点&lt;/strong&gt;（球内直径的两个点）和球上的一个&lt;strong&gt;大圆&lt;/strong&gt;。像这样，赋予“点”，“线”新的解释，我们就朝着几何的形式化又进了一步。这种抽离日常意义的词，就叫做&lt;strong&gt;未定义项&lt;/strong&gt;。他们的意义是我们另外灌注进去的。&lt;/p&gt;
&lt;p&gt;几何的完全形式化，需要我们把每个词都抽离成上面那样的未定义项。形式系统中这些符号的被动意义，需要人们观察者寻找一套可以同构联系符号的概念。符号可能有很多有意义的解释，例如pq系统中，将p解释成“等于”，q解释成“减”。回头来看形式系统（在某个解释下）的&lt;strong&gt;一致性&lt;/strong&gt;，这里可以给一个严格的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中&lt;strong&gt;每个&lt;/strong&gt;定理经过解释后，都是一个真陈述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一致性也分&lt;strong&gt;内部一致性&lt;/strong&gt;，和&lt;strong&gt;外部一致性&lt;/strong&gt;。前者是说所有定理经过解释后，是彼此相容没有相互矛盾；后者是说每个定理解释后，是&lt;strong&gt;真的&lt;/strong&gt;，那么系统加上解释是与外部世界一致的。当然这个“外部世界”不一定是我们生活的这个世界，可以是任何想象的世界，在其中的文学规则、生物规则、物理规则、数学规则甚至逻辑规则都可以和现实世界不一样。通常我们会尽量保留数学规则、逻辑规则和现实一样。&lt;/p&gt;
&lt;p&gt;回头看非欧几何的启示，我们在构造几何学的时候，有些词具有不变的意义，作为&lt;strong&gt;骨骼&lt;/strong&gt;；另一些则可以调整，即未定义项，作为血肉。调整未定义项添加新的规则公理，就可以在固定符号意义的形式系统A的基础上，构造一个形式系统B、C、D……。&lt;strong&gt;我们获得新知识、新词汇、感知不熟悉的事物时，也是以类似这种分层的形式进行的&lt;/strong&gt;。在看到艾舍尔那些视错觉的画时，这种分层的认识遇到了困境，局部的认识没法凑成一个一致性的完整解释。但其实，这时还有一种办法，就是放弃每层对符号的解释，让画面里的每一处线条都是无意义的符号。这种彻底的&lt;strong&gt;逃避&lt;/strong&gt;途径，有点像禅宗式的&lt;strong&gt;U方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么数论是不是也和欧几里得几何一样，对未定义项给出不同解释，就可以得到不同分支。实际上，我们还是需要保留一些最基本的不可变的部分，和逻辑一起构成“核心数论”（类似前四条公设组成的“核心几何学”），这也被称为皮亚诺算术。在这个基础上，数论也是分叉的理论，有标准和非标准的，且有无穷多个。当然在实际应用中，无需感知它们。&lt;/p&gt;
&lt;p&gt;如果一致性是符号获得被动意义的&lt;strong&gt;最低条件&lt;/strong&gt;，那么&lt;strong&gt;完全性&lt;/strong&gt;就是最高条件。一致性在说“系统中的每个东西都是真的”，完全性则是倒过来“所有由系统中的符号构成的真陈述（良构字符串）都可以由系统产生”。最初的pq系统在解释下，是一个只有两数加法的想象世界，具备完全性和一致性。增加了一个公设解释后，我们给出的小于等于解释就是一致但不完全的，尽管定理产生的都是真陈述，但-q–p—这种真陈述，就没有办法在系统里生产出来。这里我们有2种解决办法，&lt;strong&gt;往系统增加规则&lt;/strong&gt;让系统更“强”或&lt;strong&gt;紧缩解释&lt;/strong&gt;。这里我们选择后者——把小于等于解释中的q改成“等于或加1后等于”，此时系统重新恢复完全性。可以看到，&lt;strong&gt;解释会改变系统的完全性和一致性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在形式化数论中，也会面临不完全性，在那里我们会被迫采用增加规则的手段来让系统完全。哥德尔不完全定理就在说任何&lt;strong&gt;强有力&lt;/strong&gt;的系统，由于能力较强，反而是不完全的。&lt;/p&gt;
&lt;h3 id=&#34;和声小迷宫&#34;&gt;&lt;a href=&#34;#和声小迷宫&#34; class=&#34;headerlink&#34; title=&#34;和声小迷宫&#34;&gt;&lt;/a&gt;和声小迷宫&lt;/h3&gt;&lt;p&gt;小品中用推入露、弹出锅酥、煮调饮等印象模拟程序中的入栈、出栈。同时糅合了艾舍尔的凸和凹作品，引出鬼神、元鬼神、元元鬼神关于无限递归的场景。在鬼神部分的故事中，有两点最是妙趣至极：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于造物神的递归定义（造物神——物色的——神怪）&lt;/li&gt;
&lt;li&gt;向鬼神给出的悖论愿望（我这个愿望不被实现）导致系统停机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;递归结构和递归过程&#34;&gt;&lt;a href=&#34;#递归结构和递归过程&#34; class=&#34;headerlink&#34; title=&#34;递归结构和递归过程&#34;&gt;&lt;/a&gt;递归结构和递归过程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;递归、RTN、人工智能、不可预知性、侯世达定律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归是计算机领域里很常用的一个概念，每次递归&lt;strong&gt;进栈&lt;/strong&gt;（push）后，新的工作是低一个层次的更简单的原工作，在完成新工作后&lt;strong&gt;出栈&lt;/strong&gt;（pop）回到原来的上下文。堆栈在这个过程中会记录打断当前工作的位置还有所处的环境。在音乐中也有相同的应用，每一次的变调都相当于把一个新的调式推入堆栈，在回到主调时，会有种“如释重负”的感觉（栈空）。&lt;strong&gt;紧张和解决是音乐的核心&lt;/strong&gt;。然而对于普通的音乐听众，并没有一个非常可靠和很深的堆栈。在巴赫的《和声小迷宫》中，听众就很容易在急剧变化的调子中迷失方向。&lt;/p&gt;
&lt;p&gt;语言中也存在递归，我们在理解语言时，大脑也在维护着一个心理堆栈。作者这里给出了一个递归迁移网（RTN)的例子，展示构造自然语言时也有递归过程。递归可以是自己调用自身，或者借助两个过程相互调用，但一定有一个&lt;strong&gt;终结条件&lt;/strong&gt;，避免递归进入无限循环。&lt;/p&gt;
&lt;p&gt;之后，作者由用递归的图像模式给出了和斐波那契数列的联系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图像的递归模式：G(n) &amp;#x3D; n - G(G(n-1)), G(0)) &amp;#x3D; 0&lt;/li&gt;
&lt;li&gt;斐波那契数列：F(n) &amp;#x3D; F(n-1) + F(n-2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在递归的规则复杂起来之后，就不再能那么明显地感受到斐波那契这样明显的模式。比如Q(n) &amp;#x3D; Q(n-Q(n-1))+Q(n-Q(n-2))这种。从磁场强度和粒子变换中也能看到同样的递归规律。我们在重温下递归的意义——&lt;strong&gt;递归是在不同层次上出现“同一”事物，但它们又不是完全相同的&lt;/strong&gt;。这些事物有着映射关系，虽然它们不完全相同，但有着相同的功能关系让每次递归看起来“&lt;strong&gt;风格&lt;/strong&gt;”相同，就像艾舍尔的画一样。&lt;/p&gt;
&lt;p&gt;在弈棋程序的超前搜索树中，也有着递归的过程，AI在计算下一步的时候，要站在对方的角度考虑走一步之后如何计算，这个递归足够复杂时，就像上面的Q(n)序列，AI变得难以找到一种模式，体现出&lt;strong&gt;智能&lt;/strong&gt;的特点。程序甚至可以设计成可以修改自身，或者修复、扩展自身。递归的神奇特点在&lt;strong&gt;侯世达定律&lt;/strong&gt;中也有体现：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做事花费的时间总比预期要长，即使你在预期时考虑了侯世达定律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;音程增长的卡农&#34;&gt;&lt;a href=&#34;#音程增长的卡农&#34; class=&#34;headerlink&#34; title=&#34;音程增长的卡农&#34;&gt;&lt;/a&gt;音程增长的卡农&lt;/h3&gt;&lt;p&gt;小品以俳句为引子，找到了BACH音程和CAGE音程的联系，巧合的是Bach和Cage也是两个音乐家的名字。&lt;/p&gt;
&lt;h2 id=&#34;意义位于何处&#34;&gt;&lt;a href=&#34;#意义位于何处&#34; class=&#34;headerlink&#34; title=&#34;意义位于何处&#34;&gt;&lt;/a&gt;意义位于何处&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;信息、意义、遗传型、表现型、自动唱机、外在消息、内在消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这章主要聊了&lt;strong&gt;意义是一条消息所固有的，还是智能或是机器和消息交互后产生的&lt;/strong&gt;。首先，意义被提取的过程一定有一个信息携带者，等待信息揭示者发现某种同构关系来提取或解释消息。就像唱片的槽纹模式和声音的同构被唱机提取出来一样。DNA的遗传型和表现型也是相似但又不完全一样的例子。相对唱机演绎声音，DNA表现遗传特征要复杂了太多太多，以至于没有人能讲明白之间的关系。因此唱片和声音的同构可以叫做&lt;strong&gt;平凡同构&lt;/strong&gt;，DNA的遗传型和表现型间的同构可以称作&lt;strong&gt;异常同构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们先看唱片，音乐并没有隐藏在唱机中，而且我们也能以任意精确程度去匹配唱片的片段和输出的音乐，唱片和唱机也能很好地分离开。这么看，消息的意义似乎是固有的，唱片所蕴含的意义不随唱机转移。再看DNA，情况不一样了起来，DNA必然也包含了遗传信息，但是它依赖必须的化学环境来表现这些遗传信息，缺少了环境，DNA的意义就不能被揭示出来。&lt;/p&gt;
&lt;p&gt;唱片的意义在于播放时，声音激活大脑中的适当结构，激发听者的一些情感。似乎对于唱片的释读早就&lt;strong&gt;内置&lt;/strong&gt;在我们的大脑里。如果信息在本质上具有足够的内在逻辑，一旦遇到足够智能的生物，环境就能自动的建立起来。这样的话，我们就可以说消息的意义是一种固有性质。在这个假设下，信息可以分为3层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内在消息&lt;/strong&gt;：理解内在消息就是抽取发送人要传递的意义&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;框架消息&lt;/strong&gt;：就是确认需要一种解码机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外在消息&lt;/strong&gt;：理解外在消息就是建造或知道如何建造能够解译内在消息的解码机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息必须具有某种&lt;strong&gt;触发器&lt;/strong&gt;一样的东西，传递出它包含有意义，就像罗塞塔石碑上的重复符号一样。从某个角度看，欣赏音乐、艺术作品也是一个解译内在消息的过程。其中作品传递的&lt;strong&gt;风格&lt;/strong&gt;和外在消息以及解码技术表述的是一件事情。外在消息的“触发器”能否被人发现是无法预知的，在消息内写上“这是一条需要破译的消息”也是不行的。外在消息的本性就决定了它们无法被任何显式语言所传达，解码过程是个启发式的，就像是涌现出来的一样。&lt;/p&gt;
&lt;p&gt;这么看来，消息内的意义能否被发现，和解读它的智能关系甚密，譬如发现唱片内的螺线型沟槽又或者发现图案上使用了日文字母。&lt;strong&gt;智能似乎自带发现外在消息触发器的能力，并且一旦发现就可以对这些消息进行解码&lt;/strong&gt;。在这个基础上，如果我们承认意义是消息所固有的，只等着智能去发现，就是在承认消息的释读机制是具有普遍性、自然界中的基本形式。然而，这样的话分布在宇宙各处的智能生物对于消息处理也要具有不变性。这显然有些&lt;strong&gt;人类沙文主义&lt;/strong&gt;或是&lt;strong&gt;地球沙文主义&lt;/strong&gt;。我们无从知道其他智能会不会像人类智能一样解读我们看起来很显然的消息。&lt;/p&gt;
&lt;p&gt;如果我们要像外星智能传达消息表达斐波那契数列的规律信息，仅仅在金属板上蚀刻2个星号，肯定不如刻上前n项更容易暴露触发器。后者的长遗传型传送的外在消息更多，这就使内在消息得以被读出。再举个例子，我们往外星发送巴赫和Cage的唱片，Cage的曲子就难理解了许多，因为能够欣赏Cage作品需要熟知固定音乐在近几十年的发展轨迹，这样的听众本身就内赋了作品的独立反叛意义，唱片只是简单起个触发作用。而这仅限于地球。相反，讽刺的是，欣赏巴赫的作品就远不需要那么多文化知识。这也体现出了奇妙的一点：&lt;strong&gt;智能喜好模式化，厌恶随机性&lt;/strong&gt;。回到DNA的例子里，要恢复遗传型蕴含的信息，需要极大程度地理解DNA需要的环境，才能完好地表现出表现型。那么，在恢复的过程，什么时候才能说已经达到或者隐含了表现型呢？这在某些国家是个高度敏感的话题（堕胎）。&lt;/p&gt;
&lt;h3 id=&#34;半音阶幻想曲，及互格&#34;&gt;&lt;a href=&#34;#半音阶幻想曲，及互格&#34; class=&#34;headerlink&#34; title=&#34;半音阶幻想曲，及互格&#34;&gt;&lt;/a&gt;半音阶幻想曲，及互格&lt;/h3&gt;&lt;p&gt;小品里阿基里斯尝试用命题演算证明乌龟所说自己的壳是&amp;#x2F;不是绿色的矛盾，这也引出了下章的讨论内容。&lt;/p&gt;
&lt;h2 id=&#34;命题演算&#34;&gt;&lt;a href=&#34;#命题演算&#34; class=&#34;headerlink&#34; title=&#34;命题演算&#34;&gt;&lt;/a&gt;命题演算&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;命题演算、形式化、半解释、元理论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小品里阿基里斯朴素的命题演算并没有说服乌龟，这章用符号化的形式系统来模拟命题演算。我们用P、Q、R这样的符号表标识一个原子，将由&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;∧&lt;/code&gt;、&lt;code&gt;∨&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;→&lt;/code&gt;符号和原子按指定规则组成的串成为良构串（即命题）。同时给出&lt;strong&gt;合并&lt;/strong&gt;（&lt;code&gt;P∧Q&lt;/code&gt;是定理可以得到&lt;code&gt;P&lt;/code&gt;和&lt;code&gt;Q&lt;/code&gt;都是定理）、&lt;strong&gt;分隔&lt;/strong&gt;（&lt;code&gt;P&lt;/code&gt;和&lt;code&gt;Q&lt;/code&gt;都是定理可以得到&lt;code&gt;P∧Q&lt;/code&gt;是定理）、&lt;strong&gt;双重反转&lt;/strong&gt;规则作为串生成的基本规则来产生更多良构串（命题）。对于包含&lt;code&gt;→&lt;/code&gt;符号的串，也有一个&lt;strong&gt;幻想规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;预设一个良构串X，把它当成定理，根据已有规则推导，生成另一个良构串Y，那么可以说X就是Y的前提，Y就是X的结果。记作&lt;code&gt;&amp;lt;x-&amp;gt;y&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这个基础上，借助双重反转规则，可以很容易得到&lt;code&gt;&amp;lt;P→~~P&amp;gt;&lt;/code&gt;这样的定理。在幻想规则的层级不止一层时，还有一个&lt;strong&gt;搬入规则&lt;/strong&gt;，即在一个“幻想”中，更高层级“幻想”里的定理都可以拿来并使用，借助这个规则，又可以生成&lt;code&gt;&amp;lt;P→&amp;lt;Q→&amp;lt;P∧Q&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;这样的定理（可以发现，这正是分隔规则的符号化，幻想规则就是命题演算的符号化过程）。&lt;/p&gt;
&lt;p&gt;当然，除了上面这些规则，还有很多别的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离规则&lt;/strong&gt;：如果&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;&amp;lt;x→y&amp;gt;&lt;/code&gt;都是定理，那么&lt;code&gt;y&lt;/code&gt;也是定理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异位规则&lt;/strong&gt;：&lt;code&gt;&amp;lt;x→y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;~y→~x&amp;gt;&lt;/code&gt;是可以互换的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;德摩根规则&lt;/strong&gt;：&lt;code&gt;&amp;lt;~x∧~y&amp;gt;&lt;/code&gt;和&lt;code&gt;~&amp;lt;x∨y&amp;gt;&lt;/code&gt;是可以互换的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思维陀螺规则&lt;/strong&gt;：&lt;code&gt;&amp;lt;x∨y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;~x→y&amp;gt;&lt;/code&gt;是可以互换的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以很容易发现，&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;∧&lt;/code&gt;、&lt;code&gt;∨&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;→&lt;/code&gt;这些符号和逻辑符号的关系。从上面规则生成出来的定理也可以轻松对应现实世界中的逻辑命题。当一个人解释命题演算里的定理，&lt;strong&gt;而不解释其中的原子&lt;/strong&gt;时，作者称之为&lt;strong&gt;半解释&lt;/strong&gt;。例如&lt;code&gt;P∨~P&lt;/code&gt;可以半解释为P或者非P。可以发现，命题演算中生成的定理被半解释时，会被人们视作普遍为真的句子。&lt;/p&gt;
&lt;p&gt;在命题演算的帮助下，可以用印符规则生成普遍为真的语句，这些宇宙里的核心真理似乎是有规律的。在上面的解释下，命题演算里的定理都是真语句。那么我们能证明这一点吗？又或者说，我们知道系统是否一致吗？是否有可能有一个定理&lt;code&gt;x&lt;/code&gt;按照规则推导可以得到&lt;code&gt;~x&lt;/code&gt;。这个问题的证明等效去证明上面那些规则，可以想到，随之而来的还会有证明的证明，证明的证明的证明……最外层系统总是需要一个未经证明的假设，是凭我们的信仰接受的。就像阿基里斯和乌龟谈话里，要从&lt;code&gt;&amp;lt;&amp;lt;A∧B&amp;gt;→Z&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;A∧B&amp;gt;&lt;/code&gt;证明到&lt;code&gt;Z&lt;/code&gt;，需要先证明符号化的&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;A∧B&amp;gt;→Z&amp;gt;∧&amp;lt;A∧B&amp;gt;&amp;gt;→Z&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;让我们再回头审视那些规则，我们在用推导出来的&lt;strong&gt;定理图式&lt;/strong&gt;作为导出规则生成其他定理时，使用的是&lt;strong&gt;W方式&lt;/strong&gt;，这种关于命题演算的理论可以叫做“元定理”，即关于定理（可导出的串）的定理（被证明的结果）。在使用W方式时实际上已经失去的系统的形式性，W方式是在系统之外的。只有J方式是在系统里的。然后要生成更多的定理，必然需要这种“捷径”。即使把元理论抽象成形式系统，也依然会有元元理论去加快命题演算中的定理推导。&lt;/p&gt;
&lt;p&gt;那么一个推理理论能否包含自己的元理论呢？事情并不简单，因为系统“对自身思考”时，实际上也是运用了W方式站在&lt;strong&gt;系统外边&lt;/strong&gt;做的观察。然而后面的章节里会提出一个系统可以达成这样的目标，当然，在推演时也是要十分小心J方式和W方式的不同的。&lt;/p&gt;
&lt;p&gt;命题演算很像以某种方式进行的推理，但是推理的规则和人的思维是不一样的。一个证明是非形式化的东西，是思维的产物，本身包含了思维各种复杂的特点，最终“感觉是对的”。而推导是证明的人造对应物，用意是去使用逻辑结构形式化达到同样的目标。&lt;strong&gt;任何一种简单性都会带来一种特殊类型的复杂性&lt;/strong&gt;。就像证明就依赖了人思维语言的复杂性。书中在这里使用了&lt;code&gt;&amp;lt;P∧~P&amp;gt;&lt;/code&gt;构造出&lt;code&gt;&amp;lt;&amp;lt;P∧~P&amp;gt;→Q&amp;gt;&lt;/code&gt;这样一个矛盾。在数学中，人们通常通过修正系统来应对矛盾。譬如在这里可以通过限制幻想规则使用要求新增命题的关联性来限制Q的加入。后一章中通过构造一个更大的系统，来将这种不完全或不一致从子系统的命题演算错误转移为较大系统的毛病。&lt;/p&gt;
&lt;h3 id=&#34;螃蟹卡农&#34;&gt;&lt;a href=&#34;#螃蟹卡农&#34; class=&#34;headerlink&#34; title=&#34;螃蟹卡农&#34;&gt;&lt;/a&gt;螃蟹卡农&lt;/h3&gt;&lt;p&gt;小品借互文的形式（即全文对称）致敬的巴赫的螃蟹卡农作品，同时螃蟹提到的DNA双螺旋结构也和互文有呼应。此外引入DNA里的CGTA碱基对，和螃蟹（Crab）、基因（Gene）、乌龟（Tortoise）、阿基里斯（Achilles）的首字母一一对应，实在妙绝。&lt;/p&gt;
&lt;h2 id=&#34;印符数论&#34;&gt;&lt;a href=&#34;#印符数论&#34; class=&#34;headerlink&#34; title=&#34;印符数论&#34;&gt;&lt;/a&gt;印符数论&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;TNT、自由变元、量化变元、ω不完全系统、形式推理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;印符数论（TNT，Typographical Number Theory）预期把数论形式化在印刷符号中。在TNT中先要定义一些原子；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字：0、S0、SS0、SSS0，其中S标识是它后面那个东西的后继&lt;/li&gt;
&lt;li&gt;变元和术语：用a、b、c、d、e这样的小写字母表示不确定的数，+和·标识加和乘，&amp;#x3D;表示相等&lt;/li&gt;
&lt;li&gt;上一章命题演算中的&lt;strong&gt;符号&lt;/strong&gt;也可以拿来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样我们就能构成一些基本的句子了，句子一般都有真假。但像$(b+S0)&amp;#x3D;SS0$这样的则不具有，因为其中有&lt;strong&gt;自由变元&lt;/strong&gt;b，这样的公式也被称为&lt;strong&gt;开公式&lt;/strong&gt;。使用&lt;code&gt;∃&lt;/code&gt;和&lt;code&gt;∀&lt;/code&gt;&lt;strong&gt;量词&lt;/strong&gt;可以将开公式转化为可以判断真假的&lt;strong&gt;闭公式&lt;/strong&gt;。譬如$∃b:(b+S0)&amp;#x3D;SS0$这样的存在断言和$∀b:(b+S0)&amp;#x3D;SS0$这样的全称断言。在量词管辖下的变元称为&lt;strong&gt;量化变元&lt;/strong&gt;。结合上量词，我们可以表示更加丰富的数论命题。譬如，“5是素数”可以表示为：&lt;/p&gt;
&lt;p&gt;$$~∃a:∃b:SSSS0&amp;#x3D;(SSa·SSa)$$&lt;/p&gt;
&lt;p&gt;现在我们已经能&lt;strong&gt;形式化&lt;/strong&gt;地给出命题的串描述了，我们怎么判断他们的真假性呢，即给出一个&lt;strong&gt;良构串&lt;/strong&gt;的形式。首先看良构串的部件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字：0和前面加上了S的0&lt;/li&gt;
&lt;li&gt;变元：a、b、c、d、e或者字母上面加&lt;code&gt;&amp;#39;&lt;/code&gt;的形式&lt;/li&gt;
&lt;li&gt;项：数字或变元或前面加了S的项，如$SSa’$、$S(Sa·(Sb·Sc))$，根据是否有变元，项可以分为确定项和非确定项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用上面的部件，下面是一些组成规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子：如果s和t是项，那么$s&amp;#x3D;t$是原子&lt;/li&gt;
&lt;li&gt;否定：前面加了&lt;code&gt;~&lt;/code&gt;的良构公式也是良构的&lt;/li&gt;
&lt;li&gt;复合：x和y是良构公式的话，那么&lt;code&gt;&amp;lt;x∨y&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;x∧y&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;x→y&amp;gt;&lt;/code&gt;也是良构&lt;/li&gt;
&lt;li&gt;量化：如果u是变元，x是一个包含自由变元u的良构公式，那么$∃u:x$和$∀u:x$也是良构公式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样我们就得到了可以判断真假的TNT良构公式形成规则表，举例：不同的自然数有不同的后继可以表示为$&amp;lt;∀a:∀b:&amp;lt;a≠b→Sa≠Sb&amp;gt;&amp;gt;$。当然，用这样原始的形式表述“b是2的某次方”这样的命题时还是很吃力的。不过最起码现在已经有了一个基础。在这个基础上，我们要补充公理和推理规则，首先，我们将命题演算中所有规则接纳进来，之后给出下面5条公理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公理1：$∀a:~Sa&amp;#x3D;0$&lt;/li&gt;
&lt;li&gt;公理2：$∀a:(a+0)&amp;#x3D;0$&lt;/li&gt;
&lt;li&gt;公理3：$∀a:∀b:(a+Sb)&amp;#x3D;S(a+b)$&lt;/li&gt;
&lt;li&gt;公理4：$∀a:(a·0)&amp;#x3D;0$&lt;/li&gt;
&lt;li&gt;公理5：$∀a:∀b:(a·Sb)&amp;#x3D;((a·b)+a)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1是关于0的性质，2、3关于加法、4、5关于乘法。看起来和皮亚诺公设很像，但并不一样，作者用鬼神的比喻给了出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怪物是一个神怪（0是一个自然数）&lt;/li&gt;
&lt;li&gt;每一个神怪都有一个元（所有自然数都有后继）&lt;/li&gt;
&lt;li&gt;怪物不是任何神怪的元（0不是任何自然数的后继）&lt;/li&gt;
&lt;li&gt;不同的神怪有不同的元（不同自然数的后继不同）&lt;/li&gt;
&lt;li&gt;如果怪物有X，并且每个神怪都把X传给它的元，那么所有神怪都得到X（数学归纳法）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后，我们可以继续给出一些可以操作TNT元素的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特称规则：如果u是串x中的一个变元，且$∀u&amp;#x3D;x$是一个定理，那么x也是定理，而且任意替换x中的u为其他串也都是定理，但要保证替换规则一样，且替换u的项不能包含在x中被量化的变元&lt;/li&gt;
&lt;li&gt;概括规则：和特称规则相反，我们可以把全程量词放回到定理中，即x是定理u是串x中的一个变元，那么$∀u&amp;#x3D;x$是一个定理，当然，在幻想规则中，不允许对自由出现在幻想中的变元应用概括&lt;/li&gt;
&lt;li&gt;互换规则：如果u是一个变元，那么$∀u:&lt;del&gt;$和$&lt;/del&gt;∃u:$在定理中任意位置都可以互换&lt;/li&gt;
&lt;li&gt;存在规则：一个项如果在定理中出现任何次，那么可以用一个&lt;strong&gt;还未出现&lt;/strong&gt;在定理中的变元替代，之后在最前面补充上它的存在量词&lt;code&gt;∃&lt;/code&gt;，例如$∀a:&lt;del&gt;Sa&amp;#x3D;0$可以把里面的0替换成$∃b:∀a:&lt;/del&gt;Sa&amp;#x3D;b$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;围绕&lt;code&gt;=&lt;/code&gt;还有下面这些规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称：如果$r&amp;#x3D;s$是一个定理，那么$s&amp;#x3D;r$也是一个定理&lt;/li&gt;
&lt;li&gt;传递：如果$r&amp;#x3D;s$和$s&amp;#x3D;t$都是定理，那么$r&amp;#x3D;t$也是定理&lt;/li&gt;
&lt;li&gt;后继：如果$r&amp;#x3D;t$是一个定理，那么$Sr&amp;#x3D;St$是一个定理；相反如果$Sr&amp;#x3D;St$是一个定理，那么$r&amp;#x3D;t$是一个定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面这些基础上已经可以推导出很多基础但丰富的定理了，不过一些尝试发现，这个体系还缺少了&lt;strong&gt;概括&lt;/strong&gt;的能力。例如，我们可以从0+0&amp;#x3D;0，推出0+S0&amp;#x3D;S0，再继续往后推，但却没法得到$∀a:(0+a)&amp;#x3D;0$。这时我们急需一个规则：如果这样一个金字塔的所有串都是定理，那么用来概括它们的全称量化的串也是定理。然而这没法在J方式下使用，它是在系统外思考的W方式。这种系统的缺陷被称为&lt;strong&gt;ω不完全性&lt;/strong&gt;。一个看起来很显然的定理却没法在ω不完全系统中证明。就像非欧几何里面也是对未完全定义的“点”和“线”不补全了定义一样。&lt;/p&gt;
&lt;p&gt;我们补上一条归纳规则：设u是一个变元，X{u}是一个u在其中自由出现的良构公式，如果$∀u:&amp;lt;X{u}→X{Su&amp;#x2F;u}&amp;gt;$以及X{0&amp;#x2F;u}二者都是定理，那么$∀u:X{u}$也是一个定理。这样整个形式推理似乎补全了。我们可以用彻底形式化的方式来推理，当然这么做是十分费力的，结合W方式会让它更好用。那么要证明TNT系统的一致性，有没有可能有比TNT系统更简单的方式呢？结果是没有。最起码要和TNT一样完全。&lt;/p&gt;
&lt;h3 id=&#34;一首无的奉献&#34;&gt;&lt;a href=&#34;#一首无的奉献&#34; class=&#34;headerlink&#34; title=&#34;一首无的奉献&#34;&gt;&lt;/a&gt;一首无的奉献&lt;/h3&gt;&lt;p&gt;小品借由禅宗的探讨，对系统完全性和一致性上做了探讨。禅宗中的无门和和对佛性的追求和围绕系统一致性和完全性的追求也有共同之处。&lt;/p&gt;
&lt;h2 id=&#34;无门和哥德尔&#34;&gt;&lt;a href=&#34;#无门和哥德尔&#34; class=&#34;headerlink&#34; title=&#34;无门和哥德尔&#34;&gt;&lt;/a&gt;无门和哥德尔&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无门、整体论、WU谜题、哥德尔配数、编码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禅宗的基本教条就是：没有任何方法能刻画禅宗是什么。词语和真理是不相通的，至少词语无法捕捉到真理。文中对于禅宗公案的展示，表现出禅宗对二元论的反对，推崇整体论。而对词语的普通使用，甚至包括自己的知觉都表示你把自己当做世界&lt;strong&gt;当中&lt;/strong&gt;的一个客体，从而远离了“道”。然而禅宗也是一个系统，不可能成为自己的元系统，总有东西处在禅宗之外，是无法用禅宗完全了解或说清楚的。&lt;/p&gt;
&lt;p&gt;这时，我们回头看WU谜题，我们把WJU中的J看成1个&lt;strong&gt;洞&lt;/strong&gt;，起始定理是1个洞，要判断是否有没有洞的情况。WJU系统中的4条规则分别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规则1：不改变洞的数目&lt;/li&gt;
&lt;li&gt;规则2：让洞的数目翻倍&lt;/li&gt;
&lt;li&gt;规则3：让洞减少3&lt;/li&gt;
&lt;li&gt;规则4：不改变洞的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此看到，仅借助规则2和3没有办法让洞从1个变为3的倍数，自然无法推导出WU的答案。然而并非所有谜题都像WU这么好解。借助&lt;strong&gt;哥德尔配数&lt;/strong&gt;，我们可以把所有形式系统的问题都转为数论描述，从而可以使用更为强大的数论。以WJU系统为例，我们可以把每个符号映射为1个数字，按照形状相似分别可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;W &amp;lt;-&amp;gt; 3&lt;/li&gt;
&lt;li&gt;J &amp;lt;-&amp;gt; 1&lt;/li&gt;
&lt;li&gt;U &amp;lt;-&amp;gt; 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，31就是起始的公理，规则1、2、3、4也分别可以用数字规则描述，譬如规则1可以表示为31后可以追加1，即31 -&amp;gt; 31 * 10 + 1。这样用哥德尔配数表示出来的形式系统就具有&lt;strong&gt;二重性&lt;/strong&gt;，一重是印符规则的理解，一重的数字背后的数论理解。印符和算术规则是可以等价的。&lt;/p&gt;
&lt;p&gt;再联想我们上节中的TNT系统。「30是一个WJU数」也可以翻译成TNT记号（尽管它极其复杂）。同样地，这个TNT符号也有印符和数论的两重意义。有人可能会说理解哥德尔配数后的编码需要额外知道编码的知识，但只要是无损编码，现实中不存在什么未编码的消息，只有我们熟悉和不熟悉的编码。&lt;/p&gt;
&lt;p&gt;形式化表述数论的TNT系统本身也可以哥德尔配数，将TNT中用到的原子符号都使用数字组成的密码子表述，类似$(S0+S0)&amp;#x3D;SS0$也可以用数字表述出来。从而&lt;strong&gt;一串数字是不是一个TNT数的另一层含义就是一个数论语句是不是一个TNT定理&lt;/strong&gt;。这也导致了一个结论：TNT的一个串有一个数论中的解释，而数论中的一个陈述的第二意义是TNT的一个陈述。&lt;/p&gt;
&lt;p&gt;那么我们现在要找到一个TNT串，称之为G，它是关于它自己的，具体来说G的被动含义是「G不是TNT的定理」（当然G也有哥德尔配数的数论含义）。那么我们只要创造出这么一个G，根据TNT的完备性，G是一个真理，则「G不是一个定理」，反之亦然。这个TNT串反应的某个自然数的算属性值无法被TNT确定既真又假。从而违背了一致性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上篇结&lt;/em&gt;&lt;/p&gt;
</content>
        <category term="形式系统" />
        <category term="不完全性" />
        <category term="隐喻" />
        <category term="哥德尔" />
        <category term="巴赫" />
        <category term="埃舍尔" />
        <updated>2023-04-23T14:23:22.000Z</updated>
    </entry>
</feed>

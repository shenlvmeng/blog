{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"质量\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2022/08/25/all-about-code-2/",
            "url": "http://shenlvmeng.github.com/blog/2022/08/25/all-about-code-2/",
            "title": "关于编码的一切 ——《代码大全》 下",
            "date_published": "2022-08-25T14:37:19.000Z",
            "content_html": "<blockquote>\n<p>文接<a href=\"https://shenlvmeng.github.io/blog/2022/03/03/all-about-code/\">关于编码的一切 ——《代码大全》 下</a></p>\n</blockquote>\n<h2 id=\"软件质量\"><a href=\"#软件质量\" class=\"headerlink\" title=\"软件质量\"></a>软件质量</h2><p>在了解最基本的变量和语句组织后，这一部分围绕提高软件质量展开。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>软件的外在质量特性体现在：</p>\n<ul>\n<li>正确性</li>\n<li>可用性</li>\n<li>效率</li>\n<li>可靠性</li>\n<li>健壮性</li>\n<li>适应性</li>\n<li>完整性</li>\n<li>精确性</li>\n</ul>\n<p>内在质量特性体现在：</p>\n<ul>\n<li>可维护性</li>\n<li>可扩展性</li>\n<li>可移植性</li>\n<li>可读性</li>\n<li>可测试性</li>\n<li>可理解性</li>\n</ul>\n<p>而改善软件质量可以有很多技术：</p>\n<ul>\n<li>确定目标</li>\n<li>测试策略</li>\n<li>非正式走查</li>\n<li>正式技术复查</li>\n<li>外部审查</li>\n</ul>\n<p>开发过程中可以通过量化结果、制作原型、控制变更等手段提升质量。</p>\n<ul>\n<li>不同的质量保障手段效率各不相同，多种缺陷检测办法结合、人工和计算机检测结合，效果会比单打独斗要好；然而没有任何一种错误检测办法可以解决全部问题</li>\n<li>越早引入软件的问题，修正代价越大，尽早开始代码质量保障工作</li>\n<li>需求或架构上的错误相比编码阶段会带来更广泛的影响</li>\n<li>改善质量可以降低开发成本</li>\n</ul>\n<h3 id=\"协同构建\"><a href=\"#协同构建\" class=\"headerlink\" title=\"协同构建\"></a>协同构建</h3><p>协同构建即在同行的帮助下完成代码构建。方式包括但不限于结对编程、正式检查、非正式技术复查、文档阅读等等。<strong>结对编程</strong>和<strong>技术性复查</strong>可以缩短开发周期，排查出更多错误，减少代码的维护时间。同时，同行间的协同构建也有助于快速提升公司开发者的开发水平。</p>\n<ul>\n<li>结对编程<ul>\n<li>结对编程中，一名程序员敲代码，另外一名注意有没有出现错误，以及考虑策略性问题</li>\n<li>成功秘诀<ul>\n<li>事先确定编程规范，避免琐碎争吵</li>\n<li>不编程的成员不能变成旁观者</li>\n<li>不需要在简单问题上使用结对编程</li>\n<li>灵活对结对成员轮换，让大家熟悉不同系统</li>\n<li>避免新手组队</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>正式检查<ul>\n<li>一种特殊的复查，与会主持人负责组织事宜，按计划、概述、准备、与会人（非作者）阐述代码、详查报告、跟进等步骤推进</li>\n<li>针对代码而非作者</li>\n<li>最终由作者负责如何处理缺陷</li>\n</ul>\n</li>\n<li>走查<ul>\n<li>走查是形式和流程都比较宽松的代码复查方式，时间较短，重点也在检查错误而非修正它们</li>\n</ul>\n</li>\n<li>代码阅读<ul>\n<li>类似Code Review，关注点主要在代码本身，而非会议</li>\n</ul>\n</li>\n<li>公开演示：类似showcase</li>\n</ul>\n<h3 id=\"开发者测试\"><a href=\"#开发者测试\" class=\"headerlink\" title=\"开发者测试\"></a>开发者测试</h3><p>测试分单元测试、组件测试、集成测试、回归测试、系统测试，前两部分通常由开发者进行，后三部分由专门的测试人员进行。测试按是否了解测试对象内部工作原理也可以分为黑盒测试和白盒测试。最后要注意，<strong>测试 ≠ 调试</strong>。</p>\n<p>对于开发者而言，测试天生有些特别：</p>\n<ul>\n<li>测试的目标是找出错误而非实现功能</li>\n<li>测试绝不可能彻底证明程序里没有错误</li>\n<li>测试无法改善软件质量，它本身只是一个指示器</li>\n</ul>\n<p>开发者测试在整个项目时间中大概占8% - 25%，在测试时有一些tips：</p>\n<ul>\n<li>写代码前先写测试用例，不会比后写多花功夫</li>\n<li>不止进行“干净测试”，也要考虑“肮脏测试”</li>\n<li>很容易对测试覆盖率过度乐观</li>\n</ul>\n<p>在现实世界中，要穷尽所有可能的输入是不可能的，<strong>测试不可能完全</strong>，有些方法会起到作用：</p>\n<ul>\n<li>使用<strong>路径数</strong>计算计算用例的<strong>最少</strong>数目，它可以保证所有代码的执行<ul>\n<li>通过子程序时，开始记1</li>\n<li>遇到<code>if</code>、<code>while</code>、<code>repeat</code>、<code>for</code>、<code>and</code>、<code>or</code>或等价物时，+1</li>\n<li>遇到每一个<code>case</code>语句，+1；没有缺省分支时，再+1</li>\n</ul>\n</li>\n<li><strong>数据流测试</strong>可以覆盖到数据的变化情况<ul>\n<li>数据有<strong>已定义</strong>、<strong>已使用</strong>、<strong>已销毁</strong>状态</li>\n<li>子程序控制流有<strong>已进入</strong>、<strong>已退出</strong>状态</li>\n<li>测试所有的<strong>已定义</strong>、<strong>已定义-已使用</strong>组合，注意其他的组合顺序</li>\n</ul>\n</li>\n<li>一个好的测试用例可以覆盖可数据数据的一大部分</li>\n<li>用启发式方法去<strong>猜测错误</strong></li>\n<li>留意<strong>边界值</strong>，如数组边界的off-by-one错误</li>\n<li>考察<strong>好数据</strong>和<strong>坏数据</strong><ul>\n<li>好数据：期望输入、最小正常值、最大正常值、旧数据兼容性</li>\n<li>坏数据：没有数据、过多数据、无效数据、长度错误、未初始化</li>\n</ul>\n</li>\n<li>使用容易验证结果的测试数据</li>\n</ul>\n<p>关于错误，也有一些先验的规律：</p>\n<ul>\n<li>符合八二法则、<strong>绝大多数错误通常和几个具有严重缺陷的子程序有关</strong></li>\n<li>大多数错误影响范围有限</li>\n<li>大多数构建错误来自编程人员的错误，多从自身想问题</li>\n<li>笔误是一个常见的问题根源</li>\n<li>错误理解需求也是常见原因</li>\n<li>大多数的错误都较易修正</li>\n<li>业界经验是，平均1000行代码发现1-25个错误，发布产品大概是1000行代码0.5个，</li>\n<li>同样留意，测试用例本身是否有误</li>\n</ul>\n<p>在当前的编程环境和工作条件下，容易找到很多测试框架，它们会包含脚手架、diff工具、测试数据生成器、覆盖率监测、日志记录、系统干扰器等。另外，自动化测试、测试问题复盘等对测试质量也有提升帮助。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>调试（debug）是寻找错误根本原因和纠正错误的过程。它和测试一样，本身不是提升代码质量的方法，而是诊断代码缺陷的手段。</p>\n<ul>\n<li>调试の误区<ul>\n<li>纯靠猜测找到问题所在</li>\n<li>不去花时间理解程序和问题</li>\n<li>暂时性的掩盖问题</li>\n<li>把问题推给硬件，而不思考是不是出在自己身上</li>\n</ul>\n</li>\n<li>寻找缺陷的步骤<ul>\n<li>让错误状态稳定下来 &#x3D;&gt; 稳定复现</li>\n<li>收集相关数据，构造错误原因假说</li>\n<li>通过测试或检查代码证实或证伪假说</li>\n</ul>\n</li>\n<li>一个无法稳定重现的问题，可能和初始化或和时间有关系</li>\n<li>寻找缺陷的tips<ul>\n<li>构建缺陷假说时，要能合理解释所有测试用例</li>\n<li>定位缺陷困难时，及时补充更多的测试用例复现问题，用<strong>多视图</strong>的方式盲人摸象定位缺陷</li>\n<li>测试用例过于发散时，及时用用例否定一些假说</li>\n<li><strong>二分法</strong>缩小嫌疑范围</li>\n<li>检查<strong>最近修改</strong>或<strong>最近出过错</strong>的代码</li>\n<li>小黄鸭调试法</li>\n<li>暂时休息一下</li>\n<li>蛮力调试<ul>\n<li>抛弃有问题的代码，从头设计和编码</li>\n<li>抛弃整个程序，从头开始设计和编码</li>\n<li>不放过任何一个编译器错误</li>\n<li>手动遍历所有的循环</li>\n<li>更换编译环境或比那一起</li>\n<li>持续自动化测试</li>\n<li>显示代码中所有的打印日志信息</li>\n</ul>\n</li>\n<li>给启发式调试法一个deadline</li>\n<li>调试中避免心理惯性：人们总期望一个新现象类似他们见过的某种现象</li>\n</ul>\n</li>\n<li>修正缺陷<ul>\n<li>修正问题前确保已经很好地理解了</li>\n<li>理解程序而不仅是问题</li>\n<li>验证对错误的分析或理解</li>\n<li>保留最初的源代码</li>\n<li>治本，而不要治标</li>\n<li>一次只改一个地方</li>\n<li>搜寻代码中还有没有类似的缺陷</li>\n</ul>\n</li>\n<li>调试工具<ul>\n<li>源代码diff</li>\n<li>编译警告信息</li>\n<li>lint和代码自动修正</li>\n<li>性能剖测（profile）</li>\n<li>测试脚手架</li>\n<li>调试器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h3><blockquote>\n<p>更多重构介绍可以参考这篇blog<a href=\"https://shenlvmeng.github.io/blog/2020/08/17/refactoring-design-improvement/\">重构 —— 代码的实用性与艺术性</a></p>\n</blockquote>\n<p>重构即在<strong>不改变软件外部行为的基础上，改变其内部结构</strong>。即便是管理完善的项目，每个月都会发生需求变化，稳定不变的需求是个童话。</p>\n<p>代码出现以下“坏味道”（smell）时，代表需要重构了。</p>\n<ul>\n<li>代码重复</li>\n<li>子程序冗长</li>\n<li>嵌套过深</li>\n<li>内聚性差</li>\n<li>参数列表过长</li>\n<li>类和继承关系不合理</li>\n<li>基本数据类型过多</li>\n<li>“流浪数据”传递</li>\n<li>无所事事的类</li>\n<li>命名不当</li>\n<li>难理解的注释</li>\n<li>全局变量</li>\n<li>子程序需要前置或后置处理</li>\n<li>过早设计或过度设计</li>\n<li>…</li>\n</ul>\n<p>重构分级别有下面一些手段</p>\n<ul>\n<li>数据级<ul>\n<li>具名常量</li>\n<li>更可读的变量</li>\n<li>函数替代表达式</li>\n<li>中间变量</li>\n<li>减少重复使用变量</li>\n<li>类型码转成类或枚举类型</li>\n<li>类封装</li>\n</ul>\n</li>\n<li>语句级<ul>\n<li>分解布尔表达式</li>\n<li>用可读名字的布尔函数替代布尔表达式</li>\n<li>合并条件语句中的重复代码片段</li>\n<li><code>break</code>或<code>return</code>替代循环控制变量</li>\n<li>多态替换条件语句</li>\n<li>null对象替代空值检测</li>\n</ul>\n</li>\n<li>子程序<ul>\n<li>内莲花</li>\n<li>提炼子程序</li>\n<li>转化为类</li>\n<li>增&#x2F;删参数</li>\n<li>合并&#x2F;拆分子程序</li>\n<li>读写操作分离</li>\n<li>传递成员&#x2F;类</li>\n</ul>\n</li>\n<li>类实现<ul>\n<li>值&#x2F;引用对象转化</li>\n<li>成员函数&#x2F;成员数据位置移动</li>\n<li>相似代码提炼到基类</li>\n<li>差异代码拆分到派生类</li>\n</ul>\n</li>\n<li>类接口<ul>\n<li>类拆分&#x2F;合并</li>\n<li>删除类</li>\n<li>去掉中间人</li>\n<li>继承替代委托</li>\n<li>委托替代继承</li>\n<li>引入外部成员函数</li>\n<li>引入扩展类</li>\n<li>封装不使用的成员函数</li>\n</ul>\n</li>\n<li>系统级<ul>\n<li>为无法控制的数据创建索引源</li>\n<li>工厂模式</li>\n<li>异常&#x2F;错误处理代码选型</li>\n</ul>\n</li>\n</ul>\n<p>要想让重构不影响日常功能开发，需要考虑</p>\n<ul>\n<li>有一个代码版本管理工具</li>\n<li>重构步伐小一点</li>\n<li>同一时间只做一个重构</li>\n<li><strong>重新测试</strong></li>\n<li>增加测试用例</li>\n<li>检查代码更改</li>\n<li>根据重构风险选择重构方法</li>\n<li>不要把重构当成糟糕设计的挡箭牌</li>\n<li>避免用重构代替重写</li>\n</ul>\n<p>重构可以在修改代码的时候进行，不论是增加修改子程序还是类，或者是修复缺陷。对于从未重构的糟糕代码，可以用一部分混乱的代码隔离复杂度，把理想规整的代码和混乱不堪的真实世界隔离开。</p>\n<h3 id=\"代码调整策略\"><a href=\"#代码调整策略\" class=\"headerlink\" title=\"代码调整策略\"></a>代码调整策略</h3><p>代码调整指出于<strong>性能</strong>考虑，对代码进行实现上的调整。本章主要讨论策略。</p>\n<ul>\n<li>动手前的考虑<ul>\n<li><strong>性能≠代码速度</strong></li>\n<li>想清楚你确实在解决一个需要解决的问题</li>\n</ul>\n</li>\n<li>调整考量<ul>\n<li>程序设计：设计架构时考虑整体性能，再为每个子系统、类设计要达到的资源占用目标</li>\n<li>和操作系统的交互</li>\n<li>代码编译</li>\n<li>硬件</li>\n<li>类和子程序设计</li>\n<li>代码调整</li>\n</ul>\n</li>\n<li>帕累托法则，又称八二法则，程序中20%的子程序耗费了80%的执行时间</li>\n<li>一些<strong>错误认知</strong><ul>\n<li>减少代码行数就可以减少资源占用</li>\n<li>特定的写法会比其他的更快，代码也会更小（<em>要看编译环境</em>）</li>\n<li>应当随时随地优化（<em>不成熟的优化不如不优化</em>）</li>\n<li>运行速度和正确性同样重要</li>\n</ul>\n</li>\n<li>先提升代码可维护性，在程序完成且表现正确后，再去提升系统性能</li>\n<li>常见的低效率来源<ul>\n<li>IO操作</li>\n<li>内存分页</li>\n<li>系统API调用</li>\n<li>脚本语言</li>\n</ul>\n</li>\n<li>性能测量：没有准确的性能测量就不要去做优化</li>\n<li>代码调整需要反复尝试，才能达到理想的性能提高</li>\n</ul>\n<h3 id=\"代码调整技术\"><a href=\"#代码调整技术\" class=\"headerlink\" title=\"代码调整技术\"></a>代码调整技术</h3><p>文接上章，本章讨论具体调整手段。</p>\n<ul>\n<li>代码调整和重构相反，大多数情况下是以牺牲程序可读性为代价换取更高的性能</li>\n<li>调整手段<ul>\n<li>逻辑<ul>\n<li>知道答案后停止判断</li>\n<li>按照出现频率调整判断顺序，把容易为真的判断放在最前面</li>\n<li>表驱动法代替复杂表达式</li>\n<li>惰性求值</li>\n</ul>\n</li>\n<li>循环<ul>\n<li>把判断提出循环体</li>\n<li>展开小循环</li>\n<li>合并循环</li>\n<li>减少循环体内的操作</li>\n<li>用哨兵值提前结束循环</li>\n<li>把最忙的循环放在最内侧</li>\n<li>用低强度的计算代替高强度计算，如加法替代乘法，乘法代替幂运算</li>\n</ul>\n</li>\n<li>数据<ul>\n<li>使用整型而非浮点数</li>\n<li>减少数组维度</li>\n<li>使用辅助索引</li>\n<li>使用缓存</li>\n</ul>\n</li>\n<li>表达式<ul>\n<li>利用恒等式简化代码复杂度</li>\n<li>削弱计算强度</li>\n<li>编译期初始化</li>\n<li>小心系统函数，为了兼容最糟情况，系统函数会比较复杂</li>\n<li>事先算出结果</li>\n<li>删除公共表达式</li>\n</ul>\n</li>\n<li>子程序<ul>\n<li>子程序改为内联</li>\n</ul>\n</li>\n<li>用低级语言重写</li>\n</ul>\n</li>\n<li>再次强调，<strong>没有性能优化测量就没有代码调整</strong></li>\n</ul>\n<h2 id=\"系统考虑\"><a href=\"#系统考虑\" class=\"headerlink\" title=\"系统考虑\"></a>系统考虑</h2><p>这一部分站在系统的角度考虑构建过程中的程序规模、集成、工具等问题。</p>\n<h3 id=\"程序规模带来的影响\"><a href=\"#程序规模带来的影响\" class=\"headerlink\" title=\"程序规模带来的影响\"></a>程序规模带来的影响</h3><p>软件规模的扩大可能会为你带来意料之外的大量问题。</p>\n<ul>\n<li>如果你习惯于开发小项目，那么你的第一个大型项目很可能会严重失控</li>\n<li><strong>沟通交流</strong>：项目成员的扩大带来的交流路径不是加性的，是<strong>乘性</strong>的</li>\n<li><strong>错误</strong>：项目规模的扩大也会带来更高的缺陷密度</li>\n<li><strong>生产率</strong>：大项目会带来更低的生产率</li>\n<li><strong>工作量</strong>：软件构建的工作量和项目大小是线性关系，而其他活动的工作量则是非线性增加</li>\n<li>不同规模的代码从小到大可以称作程序、产品、系统、系统产品，没能意识到它们间的不同也是估算偏差的出现来源</li>\n<li>项目越正规，就越重视<strong>方法论</strong>，不得不写的文档也会更多，撰写的文档也会更正规</li>\n</ul>\n<h3 id=\"构建管理\"><a href=\"#构建管理\" class=\"headerlink\" title=\"构建管理\"></a>构建管理</h3><p>构建管理是软件管理中的一部分。</p>\n<ul>\n<li>鼓励良好的编程实践<ul>\n<li>逐行复查</li>\n<li>代码签名</li>\n<li>鼓励最佳实践</li>\n</ul>\n</li>\n<li>配置管理：系统化定义项目工件和处理流程<ul>\n<li>需求和设计变更<ul>\n<li>遵循系统化的变更手续</li>\n<li>成组变更</li>\n<li>评估变更成本</li>\n<li>坏味道：频繁大量变更</li>\n</ul>\n</li>\n<li>软件变更：版本控制软件</li>\n<li>机器配置变更：机器镜像</li>\n</ul>\n</li>\n<li>评估构建进度表<ul>\n<li>评估项目规模和工作量是软件项目管理中最具挑战性的部分，平均水平的大型软件都要超时1年，超预算100%才能完成</li>\n<li>清楚说明软件需求</li>\n<li>使用不同方法评估再对比</li>\n<li>定期更新评估</li>\n<li>以下因素会影响软件开发进度，但不易被量化<ul>\n<li>开发者的经验和能力</li>\n<li>团队的动力</li>\n<li>管理质量</li>\n<li>可重用的代码数目</li>\n<li>人员流动性</li>\n<li>需求变更</li>\n<li>文档量</li>\n<li>分级安全环境</li>\n</ul>\n</li>\n<li>如果进度落后了要怎么办<ul>\n<li>扩充团队在<strong>项目任务不能分割并一一击破</strong>时，只会增加项目交流复杂度，并加速项目延期</li>\n<li>缩减项目范围，有限保证核心功能</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>度量：对项目特征进行度量可以评估项目进度和风险，当然保证ddl比收集度量数据更重要</li>\n<li>把程序员当人看<ul>\n<li>程序员1天大概有30%时间花费在“对项目没有直接好处”的非技术活动中</li>\n<li><strong>不同程序员间的努力和能力差异很大</strong>，不同团队在软件质量和生产率的差异上也很大，好的和坏的程序员都倾向于聚集在一起</li>\n<li>在代码风格的信仰问题上，使用“建议”或大多数人达成统一的指导规范</li>\n<li>优良的物理工作环境有助于提升程序员的生产率和生产质量</li>\n</ul>\n</li>\n<li>管理你的管理者：向上管理</li>\n</ul>\n<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><p>集成方式也会影响到集成的质量。从频率上分，有<strong>阶段式集成</strong>和<strong>增量集成</strong>，在阶段式集成中，分为单元开发和系统集成两个阶段。增量集成中，程序是一点一点写出来并一点点拼接起来的。对比阶段式集成，增量集成有下面一些好处：</p>\n<ul>\n<li>易于定位错误</li>\n<li>更早在项目中取得系统级结果</li>\n<li>对项目结果更好的监控</li>\n<li>能在更短的开发计划中建造出整个系统</li>\n</ul>\n<p>而增量集成有下面一些常见策略：</p>\n<ul>\n<li><strong>自顶向下集成</strong>：先集成系统设计，再集成具体实现；优点是能更早有整个系统的大局观，缺点是在前期会加入很多底层的mock代码，且将调试过程推迟到项目后期</li>\n<li><strong>自底向上集成</strong>：和自顶向下相反，优点是很容易定位错误，缺点是丧失全局的认识，系统设计的问题在后期修改成本较高</li>\n<li><strong>三明治集成</strong>：先集成顶部的高层业务对象和底部的基础工具类，再集成中间层代码，整合了自顶向下和自底向上</li>\n<li><strong>风险导向的集成</strong>：鉴别不同类的风险级别，先集成风险高的</li>\n<li><strong>功能导向的集成</strong>：一次集成一组功能，它基本上不需要脚手架，且每次集成都能增强系统的功能性，且和面向对象设计比较好协同工作</li>\n<li><strong>T型集成</strong>：在集成高层对象后，先选中某个特定功能块，完成一次所有类的集成，这样可以作为MVP演练整个系统</li>\n</ul>\n<p>结合<strong>冒烟测试</strong>的“<strong>每日构建</strong>”（daily build）是软件集成的一种最佳实践。它能让产品每天都有进步，且让项目保持一个固定的脉搏。做好daily build，有下面一些建议</p>\n<ul>\n<li>不放过失败的build，保证每次build都能通过冒烟测试</li>\n<li>每天进行冒烟测试</li>\n<li>冒烟测试需要和代码一样“与时俱进”</li>\n<li>让daily build和冒烟测试<strong>自动化</strong></li>\n<li>要求开发人员构建前进行冒烟测试</li>\n<li>将修订保持合适的合并节奏，不要太密，也不要太疏</li>\n<li>在早上发布build，给潜在问题留下修复时间</li>\n<li>顶住需求压力，保证daily build和冒烟测试</li>\n</ul>\n<p>在daily build的基础上，可以很轻易地做到1日多次的<strong>持续集成</strong>。</p>\n<h3 id=\"编程工具\"><a href=\"#编程工具\" class=\"headerlink\" title=\"编程工具\"></a>编程工具</h3><blockquote>\n<p>工欲善其事，必先利其器</p>\n</blockquote>\n<p>现代化的编程环境下，有很多可以采用的编程工具：</p>\n<ul>\n<li>设计工具</li>\n<li>源代码工具<ul>\n<li>IDE</li>\n<li>文本替换工具</li>\n<li>diff工具</li>\n<li>merge工具</li>\n<li>源代码美化器</li>\n<li>接口文档生成</li>\n<li>代码模板&#x2F;代码生成</li>\n<li>命令行</li>\n<li>代码质量分析<ul>\n<li>linter</li>\n<li>metrics报告</li>\n</ul>\n</li>\n<li>重构代码<ul>\n<li>重构器</li>\n<li>代码翻译器</li>\n</ul>\n</li>\n<li>版本控制工具</li>\n<li>数据字典</li>\n</ul>\n</li>\n<li>可执行码工具<ul>\n<li>目标码生成<ul>\n<li>编译器、链接器</li>\n<li>build工具，如make、ant</li>\n</ul>\n</li>\n<li>程序库&#x2F;第三方库</li>\n<li>代码生成向导</li>\n<li>安装指引</li>\n</ul>\n</li>\n<li>调试</li>\n<li>测试</li>\n<li>代码调整<ul>\n<li>性能剖测</li>\n<li>汇编和反汇编</li>\n</ul>\n</li>\n</ul>\n<p>在Unix这样的工具导向环境下就更容易孕育编程工具，如grep、diff、sort、make、tar、line、sed、awk、vi等。几乎所有的大型组织都有自己的内部工具和支持团队，不少比市面上的还要优秀。针对特定项目，有时候也会开发特定的项目工具，如航天、保险、医疗等。对于个人开发，也可以使用脚本这种自动执行重复性杂务的工具。</p>\n<p>最后要澄清一个事实，<strong>编程工具并不能消灭人在编程里的核心地位</strong>，只是不断<strong>重塑</strong>（reshape）编程的含义。连接到其他软硬件的复杂接口，规章制度、业务规则这些计算机编程之外的复杂之源还是要人来应对。而被用来填补真实世界和解决问题的计算机之间鸿沟的人，被称作程序员。</p>\n<h2 id=\"软件工艺\"><a href=\"#软件工艺\" class=\"headerlink\" title=\"软件工艺\"></a>软件工艺</h2><p>编程是硬件与艺术的融合体，软件工艺是编程美学的一种体现。</p>\n<h3 id=\"布局与风格\"><a href=\"#布局与风格\" class=\"headerlink\" title=\"布局与风格\"></a>布局与风格</h3><p>编排出色的代码会带来<strong>视觉</strong>上和<strong>思维</strong>上的愉悦。</p>\n<ul>\n<li>基本原则<ul>\n<li>好的布局可以凸显程序的逻辑结构，也更符合人类直觉</li>\n<li><strong>傻子都会写计算机理解的代码，而优秀程序员写的是人能看懂的代码</strong></li>\n<li>高手的机型并非天生优于新手，而是高手具备某种知识结构，这种结构有助于高手记住特定类型的信息；因此当信息符合这些结构时，就可以被轻易的理解</li>\n<li>布局非信仰，要保持头脑开放，接受已被证实更好的方法</li>\n</ul>\n</li>\n<li>布局技术<ul>\n<li><strong>空白</strong><ul>\n<li>分组</li>\n<li>空行</li>\n<li>缩进</li>\n</ul>\n</li>\n<li>括号</li>\n</ul>\n</li>\n<li>布局风格：同一层级的语句缩进相同<ul>\n<li>纯块结构</li>\n<li>模仿块结构</li>\n<li>花括号指定边界</li>\n<li>行尾布局（不推荐）</li>\n</ul>\n</li>\n<li>控制结构布局<ul>\n<li>段落间的空行</li>\n<li>复杂的表达式拆分条件到多行</li>\n<li>不用<code>goto</code></li>\n</ul>\n</li>\n<li>单行语句布局<ul>\n<li>控制长度</li>\n<li>使用空格</li>\n<li>后续行缩进统一</li>\n<li>后续行结尾统一</li>\n<li><strong>一行一条语句</strong><ul>\n<li>减少复杂度</li>\n<li>读代码仅需自上而下</li>\n<li>不要在单行中多个操作</li>\n</ul>\n</li>\n<li>一行一个声明</li>\n</ul>\n</li>\n<li>注释风格<ul>\n<li>缩进和代码一致</li>\n<li>用空行和代码隔开</li>\n</ul>\n</li>\n<li>子程序布局<ul>\n<li>空行分段</li>\n<li>参数按标准缩进</li>\n</ul>\n</li>\n<li>类布局<ul>\n<li>头部注释 -&gt; 构造函数&#x2F;析构函数 -&gt; public子程序 -&gt; protected子程序 -&gt; private子程序和成员</li>\n<li>文件布局<ul>\n<li>一个文件一个类</li>\n<li>文件命名和类有关</li>\n<li>在文件中清晰分隔各子程序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自说明代码\"><a href=\"#自说明代码\" class=\"headerlink\" title=\"自说明代码\"></a>自说明代码</h3><p>本节专注于文档的特殊补充形式，即“注释”。</p>\n<ul>\n<li>在代码中起主要作用的并非注释，而是<strong>好的编程风格</strong></li>\n<li>注释的哲学<ul>\n<li>注释能提供更高层级的抽象</li>\n<li>重复注释根本没用</li>\n<li>注释写的不合适只会起反作用</li>\n</ul>\n</li>\n<li>注释类别：在代码完工后，只允许出现后三种<ul>\n<li>重复代码（Bad case）</li>\n<li>解释代码：当代码过于复杂到需要解释时，最好是改进代码，而不是添加注释</li>\n<li>代码标记，如<code>TODO</code>，<code>FIXME</code></li>\n<li>概述代码</li>\n<li>意图说明</li>\n<li>传达代码以外的信息，如版权声明、保密要求</li>\n</ul>\n</li>\n<li>高效注释<ul>\n<li>用伪代码法减少注释时间</li>\n<li>将注释如何到开发风格中</li>\n</ul>\n</li>\n<li>注释技术<ul>\n<li>注释单行<ul>\n<li>去掉无关注是</li>\n<li>减少行尾注释</li>\n<li>行尾注释只用于数据声明、维护标记、标记行尾等场景</li>\n</ul>\n</li>\n<li>注释代码段<ul>\n<li>应表达<strong>why</strong>而非<strong>how</strong></li>\n<li>代码本身应尽力组做好说明</li>\n<li>注明非常规用法</li>\n<li>错误或语言环境独特点要加注释</li>\n</ul>\n</li>\n<li>注释数据声明<ul>\n<li>数值单位</li>\n<li>允许范围</li>\n<li>输入限制</li>\n<li>全局数据</li>\n</ul>\n</li>\n<li>注释控制结构<ul>\n<li>循环结束的行尾注释是代码太复杂的征兆</li>\n</ul>\n</li>\n<li>注释子程序<ul>\n<li>注释要靠近说明的代码</li>\n<li>用简短的话进行说明</li>\n<li>注释声明参数</li>\n<li>可以使用Javadoc这种工具</li>\n<li>说明子程序的全局作用</li>\n</ul>\n</li>\n<li>注释类、文件、程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"个人性格\"><a href=\"#个人性格\" class=\"headerlink\" title=\"个人性格\"></a>个人性格</h3><p>软件工程是纯粹的脑力劳动。软件工程师研究工具和原材料的本质时，实际上是在研究人的智力、性格这种无形的东西。</p>\n<ul>\n<li>编程工作本质上是项难以监督的工作，你也需要对自己负责</li>\n<li>聪明和谦虚</li>\n<li>求知欲<ul>\n<li>形成自我意识</li>\n<li>实验</li>\n<li>学习成功项目</li>\n<li>阅读文档</li>\n<li>和同行交流</li>\n</ul>\n</li>\n<li>不屈不挠的诚实感</li>\n<li>交流和合作：<strong>编程首先是与人交流，然后才是和计算机交流</strong></li>\n<li>创造力和纪律</li>\n<li>懒惰：避免“实在懒”，追求“开明懒”和“一劳永逸的懒”</li>\n<li>可能不那么明显的性格<ul>\n<li>坚持：要时不时抬头开清方向</li>\n<li>经验：不同于其他行业，<strong>软件开发行业的经验比书本知识价值要小，基础知识变化很快</strong>，不存在越老越吃香的情况。不持续学习跟上潮流，仅靠经验吃饭，会被逐渐淘汰。</li>\n</ul>\n</li>\n<li>习惯<ul>\n<li>好习惯很重要</li>\n<li>不要用“没有习惯”替代“坏习惯”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"软件工艺探讨的话题\"><a href=\"#软件工艺探讨的话题\" class=\"headerlink\" title=\"软件工艺探讨的话题\"></a>软件工艺探讨的话题</h3><p>《代码大全》全书都着重于软件构建的细节，本章从抽象的关注点出发，看看哪些方面会影响软件的工艺。</p>\n<ul>\n<li>软件开发的核心是致力于<strong>降低复杂度</strong>，管理复杂度是软件的核心使命，之前各章节提过了很多具体办法。各种形式的抽象都是管理复杂度的强大工具。<ul>\n<li>划分子系统</li>\n<li>仔细定义类接口</li>\n<li>保持接口抽象性</li>\n<li>避免全局变量</li>\n<li>避免深层次继承</li>\n<li>避免深度嵌套和循环</li>\n<li>不用<code>goto</code></li>\n<li>子程序短小精悍</li>\n<li>使用清晰明了的变量名</li>\n<li>使用规范和约定减少理解负担</li>\n</ul>\n</li>\n<li>软件开发和其<strong>过程</strong>密不可分，在多程序员参与的项目里，组织性的重要性超过了个人技能<ul>\n<li>坏的过程只会损耗脑力，好的过程则可以开发脑力到极限</li>\n</ul>\n</li>\n<li>首先为人写程序，然后才是机器，强调代码可读性，便于与同行沟通</li>\n<li>深入一门语言去编程，不浮于表面<ul>\n<li>杰出的程序员会考虑他们要干什么，然后才是怎么用手头的工具实现目标</li>\n</ul>\n</li>\n<li>借助<strong>规范</strong>集中注意力</li>\n<li>基于问题域编程<ul>\n<li>将程序划分为不同层级的抽象<ul>\n<li>第0层：操作系统的操作和机器指令</li>\n<li>第1层：编程语言结构和工具</li>\n<li>第2层：底层实现结构，如算法和数据结构</li>\n<li>第3层：低层问题域，这一层已经有问题域相关的操作原语可以使用</li>\n<li>第4层：高层问题域，你的非技术用户某种程度也应该可以看懂你的代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编程是科学和艺术融合的一门工程学科</li>\n<li><strong>迭代</strong>在软件开发中是很正常的现象。软件设计是一个逐步精化的过程。</li>\n<li>将软件和信仰分离开<ul>\n<li>不要盲目跟风</li>\n<li>保持折中态度</li>\n<li>权衡各种技术，再做决定</li>\n<li>基于实验，保持开放心态</li>\n</ul>\n</li>\n</ul>\n<p>–END–</p>\n",
            "tags": [
                "编程",
                "范式",
                "设计",
                "艺术",
                "质量"
            ]
        }
    ]
}
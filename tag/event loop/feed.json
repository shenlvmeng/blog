{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"event loop\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/02/27/event-loop/",
            "url": "http://shenlvmeng.github.com/blog/2017/02/27/event-loop/",
            "title": "Javascript事件并发与Event Loop浅析",
            "date_published": "2017-02-27T07:12:38.000Z",
            "content_html": "<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>首先我们先来看下面一段代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;result&#x27;</span>;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>尽管结构复杂，但是只要对JavaScript的异步和回调有点了解，就能知道它的输出结果是’1 2 3 4 “result” 5 6 7 8’。</p>\n<h2 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h2><p>JavaScript中的异步和回调是语言本身的一种特色。包括上文中的setTimeout函数，Promise对象以及node.js的<a href=\"https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback\">fs.readFile</a>等。将耗时的操作非阻塞地完成，可以大大提高程序的执行效率。而这些都和JavaScript的并发模型密切相关。与C++, Java多线程处理方式不同，<b>JavaScript中的并发是基于事件循环（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\">Event Loop</a>）的</b>。</p>\n<blockquote><p>Event loop is a programming construct that waits for and dispatches events or messages in a program.</p>\n</blockquote>\n\n<h3 id=\"执行图\"><a href=\"#执行图\" class=\"headerlink\" title=\"执行图\"></a>执行图</h3><p><img src=\"/blog/images/event-loop-graph-1.png\"></p>\n<h4 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h4><p>函数调用时所用的执行环境栈。当函数被调用时，会进入一个执行环境（execution context）。当在函数内部调用其他函数（或自身调用）时，会进入新的执行环境，并在函数返回时回到原来的执行环境，并将原先的执行环境销毁。根据ECMA定义的概念，代码在执行环境中，还会创建变量对象的作用域链，以确保当前执行环境的有序性。最外层执行环境是全局环境（如<code>window</code>）。具体作用域链和执行环境的介绍，将放在其他文章中进行。</p>\n<p>函数执行过程中的执行环境栈即Stack。如下面的代码中，调用g时，形成第一个堆栈帧，包括参数21和局部变量m等。g调用f后，会创建第二个堆栈帧，置于其上，包含f的参数84和局部变量12等。f返回后，第二层栈帧出栈，g返回后，栈就空了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">b</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b+<span class=\"number\">35</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> m = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">f</span>(m*x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">g</span>(<span class=\"number\">21</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Heap\"><a href=\"#Heap\" class=\"headerlink\" title=\"Heap\"></a>Heap</h4><p>存放JS中引用类型的堆，JS的引用类型通过类似于图的形式存储，方便进行垃圾回收。具体介绍可以参考红宝书，这里从略。</p>\n<h4 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h4><p>JavaScript运行时的待处理消息队列，其中的每个消息都与对应的回调函数绑定（未绑定的消息不会进入队列）。当栈空时，会从栈中取出消息进行处理，这个过程包括调用回调函数，形成调用栈等。当栈在此为空时，代表这个消息处理完成。</p>\n<p>首先我们要明确一点，<b>JavaScript的并发是单线程的</b>。在程序中（如浏览器）运行时，JS引擎跑着两个线程。一个负责运行本身的程序，叫做主线程。另一个负责主线程与其他线程的的通信，即Event Loop。当遇到异步的任务时，主线程将交由其他线程处理，并根据情况将对应的消息入队到信息队列（Message Queue）等待处理，如果消息未绑定回调函数，则不入队。</p>\n<p><b>当调用栈清空后，队首消息依次出队，并调用绑定的回调函数，产生函数执行环境和调用栈等。直到消息队列清空为止</b>。以上就是JavaScript中的事件循环。</p>\n<p>不同的web worker或跨域的iframe都有各自的栈、堆以及消息队列。不同的环境通过<a href=\"https://developer.mozilla.org/en-US/docs/DOM/window.postMessage\">postMessage</a>方法进行通信（需要双方监听message事件）。</p>\n<h3 id=\"setTimeout和setInterval\"><a href=\"#setTimeout和setInterval\" class=\"headerlink\" title=\"setTimeout和setInterval\"></a>setTimeout和setInterval</h3><p>在明白什么是时间循环后，setTimeout和setInterval这两个定时器函数就比较容易理解了。由于JavaScript运行在单线程的环境里，setTimeout和setInterval的定时时机实际上并不能得到保障。</p>\n<p><em>定时器对队列的工作方式是，在在当前时间过去特定的时间后将代码插入，这并不意味着之后会立即执行，而只能保证尽早执行。</em>。如下面的代码中，设定的250ms延时并不代表在onclick事件触发后的250ms立即执行。实际上，如果onclick的事件处理程序执行超过了250ms，定时器的设置将不再有意义（因为匿名函数的执行时机由onclick事件处理程序何时结束决定）。由此可见，setTimeout的时间间隔往往会比设计时长。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;my-btn&quot;</span>);</span><br><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;message&quot;</span>).<span class=\"property\">style</span>.<span class=\"property\">visibility</span> = <span class=\"string\">&quot;visible&quot;</span>;</span><br><span class=\"line\">    &#125;, <span class=\"number\">250</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setInterval道理类似，和setTimeout不同的是，setInterval函数会将回调函数定时地插入消息队列的末端。为了避免定时器代码在执行完成前就有新的相同代码插入，造成严重性能问题，聪明的JavaScript引擎<b>仅在队列中没有其他定时器实例时才会插入新的定时器代码</b>。</p>\n<p>但是这么做却也带来了一个问题，那就是</p>\n<ol>\n<li>某些间隔会被跳过</li>\n<li>多个定时器间的间隔会比预期的要小。</li>\n</ol>\n<p>后者可以通过循环调用setTimeout来避免。</p>\n<p>另外，微软在IE 10中实现了<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate\">setImmediate</a>方法，来实现真正的回调函数“立即执行”，而在实际运行中似乎和setTimeout的时间类似。</p>\n<h2 id=\"Macrotask-和-Microtask\"><a href=\"#Macrotask-和-Microtask\" class=\"headerlink\" title=\"Macrotask 和 Microtask\"></a>Macrotask 和 Microtask</h2><p>首先我们还是先来看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">setImmediate</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">process.<span class=\"title function_\">nextTick</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<p>它的结果是什么呢。这里我们就要知道setTimeout, setImmediate, Promise.then, process.nextTick这些异步操作的优先级了。回答这个问题之前，我们先了解一下<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#task-queue\">Macrotask和Microtask两个概念</a>。</p>\n<p>Macrotask又叫task，是消息队列中一个个的message，一次event loop里面可能会有多个task，task有自己的task source，比如说setTimeout来自于timer task source，又或者和用户交互相关的来自user interaction task source。</p>\n<p>Microtask和Macrotask类似，区别在于它更轻量级，并非每次都在task末尾才执行，只要函数栈为空掉，Microtask就会执行。由此可见它的优先级要更高些。</p>\n<p>总结一下，它们的特点如下：</p>\n<ul>\n<li>一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue</li>\n<li>每一个 event loop 都有一个 microtask queue</li>\n<li>task queue &#x3D;&#x3D; macrotask queue !&#x3D; microtask queue</li>\n<li>一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中</li>\n<li>当一个 task 被放入队列 queue(macro或micro) 那这个 task 就可以被立即执行了</li>\n</ul>\n<p>简单点总结事件循环就是</p>\n<ol>\n<li>在 macrotask 队列中执行最早的那个 task ，执行浏览器渲染，然后移出</li>\n<li>执行 microtask 队列中所有可用的任务，然后移出</li>\n<li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步，直到没有task和microtask)</li>\n</ol>\n<p>在实现上，macrotask主要有setTimeout setInterval setImmediate I&#x2F;O UI渲染；microtask主要有Promise process.nextTick Object.observe MutationObserver。由于microtask会耽误task的执行，尤其是在较多时甚至无法执行消息队列中的task，包括UI刷新。因此process.nextTick默认上限为1000，避免上述情况的出现。当调用次数过多时，会抛出栈溢出错误。</p>\n<p>所以，上面的执行结果将是<span style=\"background-color: #333; color: #333;\">3 4 6 8 7 5 2 1</span></p>\n",
            "tags": [
                "Javascript",
                "并发",
                "event loop"
            ]
        }
    ]
}
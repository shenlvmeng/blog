<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;密码&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2018-10-29T16:07:43.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="2018" />
    <category term="2019" />
    <category term="flag" />
    <category term="2020" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="绘图" />
    <category term="动画" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="DOM" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="架构" />
    <category term="组件" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="形式系统" />
    <category term="不完全性" />
    <category term="隐喻" />
    <category term="哥德尔" />
    <category term="巴赫" />
    <category term="埃舍尔" />
    <category term="济州" />
    <category term="西归浦" />
    <category term="城山" />
    <category term="咸德" />
    <category term="人工智能" />
    <category term="心智" />
    <category term="自指" />
    <category term="图灵" />
    <category term="马列主义" />
    <category term="恩格斯" />
    <category term="家庭" />
    <category term="国家" />
    <category term="阶级" />
    <category term="氏族" />
    <category term="哲学史" />
    <category term="孔子" />
    <category term="老子" />
    <category term="儒家" />
    <category term="道家" />
    <category term="佛教" />
    <category term="禅宗" />
    <category term="理学" />
    <category term="心学" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/</id>
        <title>《图解密码技术》总结整理</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&#34;https://book.douban.com/subject/26265544/&#34;&gt;《图解密码技术》&lt;/a&gt;一书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;&lt;a href=&#34;#基本概念&#34; class=&#34;headerlink&#34; title=&#34;基本概念&#34;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;信源、信宿、信道&lt;/li&gt;
&lt;li&gt;加密、解密、密钥&lt;/li&gt;
&lt;li&gt;对称密码、公钥密码、混合密码&lt;/li&gt;
&lt;li&gt;单向散列（hash）函数、信息认证&lt;/li&gt;
&lt;li&gt;数字签名 &amp;#x2F; 篡改和否认&lt;/li&gt;
&lt;li&gt;伪随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信息传递时面临的风险：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窃听 -&amp;gt; 对称、公钥密码&lt;/li&gt;
&lt;li&gt;篡改 -&amp;gt; 散列函数、消息认证、数字签名&lt;/li&gt;
&lt;li&gt;伪装 -&amp;gt; 消息认证、数字签名&lt;/li&gt;
&lt;li&gt;否认 -&amp;gt; 数字签名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有悖常识的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要使用保密的加密算法&lt;/li&gt;
&lt;li&gt;使用低强度密码不如不用&lt;/li&gt;
&lt;li&gt;任何密码都有可能被破解&lt;/li&gt;
&lt;li&gt;密码只是安全的一部分（社工）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;入门&#34;&gt;&lt;a href=&#34;#入门&#34; class=&#34;headerlink&#34; title=&#34;入门&#34;&gt;&lt;/a&gt;入门&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;凯撒密码 &amp;#x2F; 平移 &amp;#x2F; 暴力破解&lt;/li&gt;
&lt;li&gt;简单替换密码 &amp;#x2F; 替换 &amp;#x2F; 频率分析&lt;/li&gt;
&lt;li&gt;Enigma &amp;#x2F; 加密密码的密码 &amp;#x2F; 针对每日密钥的破解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对称密码&#34;&gt;&lt;a href=&#34;#对称密码&#34; class=&#34;headerlink&#34; title=&#34;对称密码&#34;&gt;&lt;/a&gt;对称密码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编码和异或&lt;/li&gt;
&lt;li&gt;一次性密码和它的问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用对称密码时，我们通常默认密钥配送问题已解决&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;DES&#34;&gt;&lt;a href=&#34;#DES&#34; class=&#34;headerlink&#34; title=&#34;DES&#34;&gt;&lt;/a&gt;DES&lt;/h3&gt;&lt;p&gt;全称Data Encryption Standard。于1977年在美国发明并使用。目前可以被暴力破解，因此不应再使用了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES以&lt;strong&gt;64bit&lt;/strong&gt;为一个单位，使用和明文等长的密钥。&lt;/li&gt;
&lt;li&gt;密钥每8位包含1位纠错码&lt;/li&gt;
&lt;li&gt;基本结构使用Feistel网络&lt;ul&gt;
&lt;li&gt;加密&amp;#x2F;解密步骤以轮为单位，DES有16轮&lt;/li&gt;
&lt;li&gt;每轮运算不加密右半侧，同时右半侧比特和该轮密钥通过轮函数得到本轮加密左侧的密钥，和左侧做异或得到左侧密文&lt;/li&gt;
&lt;li&gt;每轮加密后，进行左右对调，保证右侧的保密&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解密时用相同结构&lt;/strong&gt;，反向使用子密钥和轮函数即可&lt;/li&gt;
&lt;li&gt;轮函数可以任意复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;差分分析和线性分析衡量分组密码强度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;三重DES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由IBM开发，步骤为DES加密 -&amp;gt; DES解密 -&amp;gt; DES加密。密钥长度是原来三倍，即168比特。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三步使用同一密钥，即向下兼容DES&lt;/li&gt;
&lt;li&gt;根据1、3步是否使用同一密钥，分为DES-EDE2和DES-EDE3&lt;/li&gt;
&lt;li&gt;处理速度慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;AES&#34;&gt;&lt;a href=&#34;#AES&#34; class=&#34;headerlink&#34; title=&#34;AES&#34;&gt;&lt;/a&gt;AES&lt;/h3&gt;&lt;p&gt;全称Advanced Encrytion Standard，用来取代DES。由NIST开于1997年开始募集，将作为国家标准。算法要求开源免费，并在社群里公开评审，最终于2000年确定为Rijndael。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本结构为SPN结构&lt;/li&gt;
&lt;li&gt;明文分组长度固定为&lt;strong&gt;128bit&lt;/strong&gt;、密钥长度可以是128、192、256比特三种&lt;/li&gt;
&lt;li&gt;每轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey四步&lt;ul&gt;
&lt;li&gt;SubBytes，将4字节 * 4字节的矩阵与一个转换矩阵相乘，得到替换后的矩阵&lt;/li&gt;
&lt;li&gt;ShiftRows，逐行做平移&lt;/li&gt;
&lt;li&gt;MixColumns，逐列做矩阵运算&lt;/li&gt;
&lt;li&gt;AddRoundKey，和轮密钥矩阵做对应位上的异或运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解密时，除了AddRoundKey一步，其余均需要做逆运算&lt;/li&gt;
&lt;li&gt;目前还没有针对Rijndael的有效攻击&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免使用DES，选择AES&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分组密码的迭代模式&#34;&gt;&lt;a href=&#34;#分组密码的迭代模式&#34; class=&#34;headerlink&#34; title=&#34;分组密码的迭代模式&#34;&gt;&lt;/a&gt;分组密码的迭代模式&lt;/h2&gt;&lt;p&gt;分组密码只能加密&lt;strong&gt;固定长度&lt;/strong&gt;的密码。因此，需要有&lt;strong&gt;模式&lt;/strong&gt;来迭代加密任意长度的明文。与分组密码相对的是流密码，对数据进行连续处理。&lt;/p&gt;
&lt;h3 id=&#34;ECB&#34;&gt;&lt;a href=&#34;#ECB&#34; class=&#34;headerlink&#34; title=&#34;ECB&#34;&gt;&lt;/a&gt;ECB&lt;/h3&gt;&lt;p&gt;全称为Electronic CodeBook。是最简单直接的分组方式。将明文分组加密后直接得到对应位置的密文。不足的位用特定数据&lt;strong&gt;填充&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题很明显，&lt;strong&gt;不要使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;相同的明文分组会得到相同的密文分组&lt;/li&gt;
&lt;li&gt;攻击者无需破译密码也可通过修改密文操纵明文，比如替换或删除分组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CBC&#34;&gt;&lt;a href=&#34;#CBC&#34; class=&#34;headerlink&#34; title=&#34;CBC&#34;&gt;&lt;/a&gt;CBC&lt;/h3&gt;&lt;p&gt;全称Cipher Block Chaining。和ECB的最大不同在于明文分组加密前会和上一个密文分组做一次异或运算。开头的明文分组会和一个随机序列做XOR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个密文分组的损坏会影响关联的两个分组的解密&lt;/li&gt;
&lt;li&gt;比特的缺失将会影响整个密文的解密&lt;/li&gt;
&lt;li&gt;操纵初始化向量反转某一位比特可以反转第一个密文分组的某一位&lt;/li&gt;
&lt;li&gt;填充提示攻击，攻击padding部分&lt;/li&gt;
&lt;li&gt;SSL&amp;#x2F;TLS使用CBC模式保证通信机密&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CTS&lt;/strong&gt;使用最后一个密文填充不足的明文部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CFB&#34;&gt;&lt;a href=&#34;#CFB&#34; class=&#34;headerlink&#34; title=&#34;CFB&#34;&gt;&lt;/a&gt;CFB&lt;/h3&gt;&lt;p&gt;全程Cipher FeedBack模式。和CBC模式的区别在密文分组先加密，再和下一个明文做异或运算。实际上明文分组和密文分组间只相差了一个异或运算。很类似一次性密码本的模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解密时，需要对密文分组和初始向量做&lt;strong&gt;加密&lt;/strong&gt;操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重放&lt;/strong&gt;攻击，替换密文分组为原有分组，可使得解密出的明文为原有明文&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;OFB&#34;&gt;&lt;a href=&#34;#OFB&#34; class=&#34;headerlink&#34; title=&#34;OFB&#34;&gt;&lt;/a&gt;OFB&lt;/h3&gt;&lt;p&gt;全称Output-FeedBack模式。和CFB很像，区别在于OFB每次做XOR的密钥流仅来自于上一次的密钥，&lt;strong&gt;和密文分组无关&lt;/strong&gt;。因为密钥流可以提前准备好，分组加密过程可以是并行的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次的密钥来自初始化向量&lt;/li&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;li&gt;如果碰巧密钥加密后和加密前一样，那么之后的密钥就会是同一个值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CTR&#34;&gt;&lt;a href=&#34;#CTR&#34; class=&#34;headerlink&#34; title=&#34;CTR&#34;&gt;&lt;/a&gt;CTR&lt;/h3&gt;&lt;p&gt;全称CounTeR。CTR和OFB类似，区别在于它的密钥流来自于累加的计数器。密文分组来自于密钥流和明文分组的XOR运算。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计数器由nonce和序号两部分各8字节组成，nonce是随机生成的，序号是从1累加的。&lt;/li&gt;
&lt;li&gt;和OFB一样，加密解密速度快，结构简单&lt;/li&gt;
&lt;li&gt;CTR的密钥流在选定nonce后就确定了，因此可以以&lt;strong&gt;任意顺序并行&lt;/strong&gt;加密、解密&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;公钥密码&#34;&gt;&lt;a href=&#34;#公钥密码&#34; class=&#34;headerlink&#34; title=&#34;公钥密码&#34;&gt;&lt;/a&gt;公钥密码&lt;/h2&gt;&lt;p&gt;解决了对称密码的密钥配送问题。&lt;/p&gt;
&lt;h3 id=&#34;密钥配送问题&#34;&gt;&lt;a href=&#34;#密钥配送问题&#34; class=&#34;headerlink&#34; title=&#34;密钥配送问题&#34;&gt;&lt;/a&gt;密钥配送问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;事先共享&lt;/strong&gt;，在现实生活中传送&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥配送中心&lt;/strong&gt;，集中式管理用户密钥，用其加密临时的会话密钥&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用Diffie-Hellman密钥交换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用公钥密码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;公钥密码-1&#34;&gt;&lt;a href=&#34;#公钥密码-1&#34; class=&#34;headerlink&#34; title=&#34;公钥密码&#34;&gt;&lt;/a&gt;公钥密码&lt;/h3&gt;&lt;p&gt;使用加密密钥（公钥）加密，使用解密密钥（私钥）解密，避免密钥的泄露。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送者使用加密密钥&lt;/li&gt;
&lt;li&gt;接收者使用解密密钥&lt;/li&gt;
&lt;li&gt;加密密钥可以公开&lt;/li&gt;
&lt;li&gt;解密密钥一定要保密&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前所使用的公钥密码RSA来自于1978年的发明。流程上，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接收者&lt;/strong&gt;生成公私钥对，发送公钥给发送者&lt;/li&gt;
&lt;li&gt;发送者使用公钥加密明文&lt;/li&gt;
&lt;li&gt;接收者使用私钥解密密文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公钥密码有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认证公钥的合法性&lt;/li&gt;
&lt;li&gt;处理速度慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;RSA&#34;&gt;&lt;a href=&#34;#RSA&#34; class=&#34;headerlink&#34; title=&#34;RSA&#34;&gt;&lt;/a&gt;RSA&lt;/h3&gt;&lt;p&gt;利用了数论中求解离散对数困难且耗时的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加密&lt;/strong&gt;，使用&lt;code&gt;密文=明文 ^ E mod N&lt;/code&gt;。E和N组合成公钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解密&lt;/strong&gt;，使用&lt;code&gt;明文=密文 ^ D mod N&lt;/code&gt;。D和N组合成密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成N、E、D和顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找互质的两个大数p和q，N为二者的乘积&lt;/li&gt;
&lt;li&gt;p-1和q-1的最小公倍数记为L&lt;/li&gt;
&lt;li&gt;寻找比L小的和L互质的数，即为E&lt;/li&gt;
&lt;li&gt;寻找比L小的和E乘积取模L为1的数，即为D&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为解密时有对N取模操作，因此加密的明文不能大于N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;攻击方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;破解密文 -&amp;gt; 求解离散对数很难&lt;/li&gt;
&lt;li&gt;暴力破解D -&amp;gt; 比特位太长，很难破解&lt;/li&gt;
&lt;li&gt;通过E求解D，只要知道p和q就能算出D -&amp;gt; 不知道p和q的组合 -&amp;gt; &lt;strong&gt;对N质因数分解很难&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;中间人攻击&lt;/strong&gt;里，攻击者可以替换掉原本的公钥，发送给接收者，使用自己的私钥解密，从而实现攻击。这时需要&lt;strong&gt;证书&lt;/strong&gt;保证公钥的权威性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择密文攻击&lt;/strong&gt;里，攻击者可以利用服务端返回的错误消息收集加密算法信息。RSA-OAEP会在明文开头加上明文散列值和填充位，解密时发现散列值和内容对不上时，会隐藏错误信息。&lt;/p&gt;
&lt;p&gt;除了RSA外，还有ElGamal方式、Robin方式、ECC（椭圆曲线密码）等公钥密码。它们分别利用了mod N下求离散对数，mod N下求平方根，和椭圆曲线上做乘法运算逆运算在数学上很难求解的特点。&lt;/p&gt;
&lt;h3 id=&#34;FAQ&#34;&gt;&lt;a href=&#34;#FAQ&#34; class=&#34;headerlink&#34; title=&#34;FAQ&#34;&gt;&lt;/a&gt;FAQ&lt;/h3&gt;&lt;p&gt;Q: 和对称密码的强度对比&lt;br&gt;A: 达到同等强度，RSA大致需要密钥是AES长度的20倍&lt;/p&gt;
&lt;p&gt;Q: RSA使用的质数会用完么&lt;br&gt;A: 512bit的质数数目大约是10 ^ 150。足够使用。&lt;/p&gt;
&lt;p&gt;Q: RSA破解难度如何？&lt;br&gt;A: 和大整数质因数分解一样难度&lt;/p&gt;
&lt;p&gt;Q: 要保证RSA强度，N的长度要达到多少位&lt;br&gt;A: 2048bit，4096bit更好&lt;/p&gt;
&lt;h2 id=&#34;混合密码系统&#34;&gt;&lt;a href=&#34;#混合密码系统&#34; class=&#34;headerlink&#34; title=&#34;混合密码系统&#34;&gt;&lt;/a&gt;混合密码系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用对称密码加密明文&lt;/li&gt;
&lt;li&gt;用公钥密码加密上述对称密码的密钥（通常用随机数生成器得到，只用于此次会话）&lt;/li&gt;
&lt;li&gt;公钥密码的密钥由外部赋予（证书）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;密码软件PGP、HTTPS中使用的SSL&amp;#x2F;TLS就使用了混合密码系统。当然它们还包含数字签名、认证、私钥管理等更多处理。&lt;/p&gt;
&lt;p&gt;类似混合密码系统，后面要介绍的数字签名、证书、消息认证、伪随机数生成也都是&lt;strong&gt;基础密码技术的组合&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;单向散列函数&#34;&gt;&lt;a href=&#34;#单向散列函数&#34; class=&#34;headerlink&#34; title=&#34;单向散列函数&#34;&gt;&lt;/a&gt;单向散列函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将任意长度的消息转换到&lt;strong&gt;固定长度&lt;/strong&gt;散列&lt;/li&gt;
&lt;li&gt;具有抗碰撞性，即找到具有相同散列函数的消息很困难&lt;/li&gt;
&lt;li&gt;单向性，即无法从三列中还原原信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;MD4、MD5&#34;&gt;&lt;a href=&#34;#MD4、MD5&#34; class=&#34;headerlink&#34; title=&#34;MD4、MD5&#34;&gt;&lt;/a&gt;MD4、MD5&lt;/h3&gt;&lt;p&gt;全称Message Digest。由Rivest设计于1990和1991年。能够产生&lt;strong&gt;128bit&lt;/strong&gt;的散列值。它们的强抗碰撞性已被攻破，&lt;strong&gt;不建议使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;RIPEMD-160&#34;&gt;&lt;a href=&#34;#RIPEMD-160&#34; class=&#34;headerlink&#34; title=&#34;RIPEMD-160&#34;&gt;&lt;/a&gt;RIPEMD-160&lt;/h3&gt;&lt;p&gt;1996年设计，是欧盟RIPE项目的修订版，能产生160bit长度的散列值。比特币中使用的散列函数就是RIPEMD-160。&lt;/p&gt;
&lt;h3 id=&#34;SHA&#34;&gt;&lt;a href=&#34;#SHA&#34; class=&#34;headerlink&#34; title=&#34;SHA&#34;&gt;&lt;/a&gt;SHA&lt;/h3&gt;&lt;p&gt;SHA于1993年由NIST设计，在1995年发布了SHA-1修订版，能够产生&lt;strong&gt;160bit&lt;/strong&gt;的散列值。它的强抗碰撞性已被攻破，&lt;strong&gt;也不建议使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;SHA-2于2002年发布，它是包括SHA-256，SHA-384和SHA-512的集合，分别产生&lt;strong&gt;256、384和512bit&lt;/strong&gt;的散列值。目前未被攻破。SHA-2的几种散列长度来自SHA-256和SHA-512的组合。&lt;/p&gt;
&lt;p&gt;SHA-3作为SHA-1的升级替代算法，和AES一样，由NIST公开选拔，并在2012年确定为一个叫&lt;strong&gt;Keccak&lt;/strong&gt;的算法。之后会和SHA-2并存一段时间。&lt;/p&gt;
&lt;h3 id=&#34;Keccak&#34;&gt;&lt;a href=&#34;#Keccak&#34; class=&#34;headerlink&#34; title=&#34;Keccak&#34;&gt;&lt;/a&gt;Keccak&lt;/h3&gt;&lt;p&gt;Keccak可以输入&lt;strong&gt;任意长度&lt;/strong&gt;的数据，产生&lt;strong&gt;任意长度&lt;/strong&gt;的散列值。实现上，Keccak采用海绵结构，有&lt;strong&gt;吸收&lt;/strong&gt;和&lt;strong&gt;挤出&lt;/strong&gt;两阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吸收阶段，按分组长度r逐段读入消息内容，和内部状态做异或运算，之后和长度为c的内部状态一起交给函数f做“搅拌”。完成一轮处理，输出作为内部状态继读入输入的消息分组。&lt;/li&gt;
&lt;li&gt;挤出阶段，内部消息r和c逐段和函数f做运算，一段段输出散列值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keccak的双工结构下，输入和输出可以同时进行。Keccak内部状态由5 * 5 * z的一个三维比特数组组成，共有b个bit。Keccak的本质就是实现一个充分搅拌上述数组的函数f。SHA-3中使用的是Keccak-f[1600]函数。其中b就是内部状态的bit数。函数的每一轮包含θ、ρ、π、χ、ι5步。循环轮数为12 + 2 * log2(b &amp;#x2F; 25)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;θ，将不同两个column的各5个bit通过异或运算加起来，再和当前位做异或替换&lt;/li&gt;
&lt;li&gt;ρ，各比特沿z轴方向进行平移&lt;/li&gt;
&lt;li&gt;π，对一个slice上的5 * 5个比特做旋转、轮换操作&lt;/li&gt;
&lt;li&gt;χ，对一个row上的各位做某个逻辑运算&lt;/li&gt;
&lt;li&gt;ι，用某个轮常数对所有比特做异或运算，避免对称性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keccak采用的海绵结构和此前各散列算法使用的MD结构（循环执行压缩函数）方法截然不同，这也是它最后成为标准的一个原因。目前还未出现针对Keccak的有效攻击手段。&lt;/p&gt;
&lt;h3 id=&#34;攻击方式&#34;&gt;&lt;a href=&#34;#攻击方式&#34; class=&#34;headerlink&#34; title=&#34;攻击方式&#34;&gt;&lt;/a&gt;攻击方式&lt;/h3&gt;&lt;p&gt;利用文件的冗余性，构造&lt;strong&gt;一大堆&lt;/strong&gt;和想要内容一样的数据，找到和原内容散列值一样的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原像攻击，给定散列值，找到具有该散列值的任意消息&lt;/li&gt;
&lt;li&gt;第二原像攻击，给定消息1，找到和消息1有相同散列值的消息2&lt;/li&gt;
&lt;li&gt;生日攻击，攻击散列算法的“强抗碰撞性”（寻找两个具有相同散列值的消息），利用了从有N个元素的集合中依次取并放回M个元素，两次取到同一元素的概率约为根号N的特点。大大减少暴力破解需要的次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息认证&#34;&gt;&lt;a href=&#34;#消息认证&#34; class=&#34;headerlink&#34; title=&#34;消息认证&#34;&gt;&lt;/a&gt;消息认证&lt;/h2&gt;&lt;p&gt;可以同时防止消息的伪装和篡改。消息认证码简称MAC（Message Authentication Code）。可以简单理解成&lt;strong&gt;需要密钥参与的单向散列过程&lt;/strong&gt;。在使用时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送者伴随消息发送计算出的MAC&lt;/li&gt;
&lt;li&gt;接受者对消息通过共享密钥计算出MAC值，进行对比，一致则表示认证成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个密钥不能被中间人获取！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用消息认证码（MAC）机制的场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SWIFT&lt;/li&gt;
&lt;li&gt;IPSec&lt;/li&gt;
&lt;li&gt;SSL&amp;#x2F;TLS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在认证加密时，Encrypt-then-MAC表示对密文计算MAC值，从而能判断密文是由知道明文和密钥的人生成的。除了Encrypt-then-MAC外，还有Encrypt-and-MAC和MAC-then-Encrypt两种方式。&lt;/p&gt;
&lt;h3 id=&#34;HMAC&#34;&gt;&lt;a href=&#34;#HMAC&#34; class=&#34;headerlink&#34; title=&#34;HMAC&#34;&gt;&lt;/a&gt;HMAC&lt;/h3&gt;&lt;p&gt;HMAC即Hash MAC，是使用单向散列函数构造认证码的方法。分为下面几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在密钥后填充0到长度达到单向散列函数的分组长度&lt;/li&gt;
&lt;li&gt;填充后的密钥和ipad序列做XOR运算，ipad序列是00110110为单位循环的比特序列&lt;/li&gt;
&lt;li&gt;组合在消息&lt;strong&gt;头部&lt;/strong&gt;，并计算出散列值&lt;/li&gt;
&lt;li&gt;填充后的密钥和opad做XOR运算，opad是01011100位单位循环的比特序列&lt;/li&gt;
&lt;li&gt;结果拼在散列值&lt;strong&gt;后面&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据5的结果计算最终的散列值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应对攻击方式&#34;&gt;&lt;a href=&#34;#应对攻击方式&#34; class=&#34;headerlink&#34; title=&#34;应对攻击方式&#34;&gt;&lt;/a&gt;应对攻击方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;消息认证需要解决&lt;strong&gt;重放攻击&lt;/strong&gt;的问题，即再次发送相同的消息和MAC值。可以在消息中额外带上序号、时间戳，或先发送一个nonce一次性随机数保证相同的消息也会有完全不同的MAC值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥推测攻击&lt;/strong&gt;，应保证不能根据MAC值推测出双方使用的密钥，必须使用安全、高强度的伪随机数生成器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，消息认证无法解决下面的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向第三方证明，密钥的共享只在通信的双方，无法证明给第三方&lt;/li&gt;
&lt;li&gt;同样的，不能防止通信的一方&lt;strong&gt;否认&lt;/strong&gt;消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数字签名&#34;&gt;&lt;a href=&#34;#数字签名&#34; class=&#34;headerlink&#34; title=&#34;数字签名&#34;&gt;&lt;/a&gt;数字签名&lt;/h2&gt;&lt;p&gt;和公钥密码&lt;strong&gt;相反&lt;/strong&gt;的使用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布者使用私钥加密消息，私钥保密&lt;/li&gt;
&lt;li&gt;使用发布者的公钥可以解密消息，公钥公开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;签名有两种方式：&lt;strong&gt;对消息签名&lt;/strong&gt;和&lt;strong&gt;对消息的散列值签名&lt;/strong&gt;。它们主要区别在签名的对象不同。基本过程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成公、私钥对，发送公钥给接收者&lt;/li&gt;
&lt;li&gt;使用私钥加密消息&amp;#x2F;消息的hash值，得到签名&lt;/li&gt;
&lt;li&gt;发送消息和签名给接收者&lt;/li&gt;
&lt;li&gt;接收者使用公钥解密，对比消息&amp;#x2F;消息hash值，验证发送者身份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在签名中，密钥只是起着“保证消息发送者的可靠来源目的的”，被复制并不影响它发挥作用。同时，由于不知道私钥，修改消息后无法伪造消息的签名。&lt;/p&gt;
&lt;p&gt;实际应用数字签名的地方有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全信息公告&lt;/li&gt;
&lt;li&gt;软件下载&lt;/li&gt;
&lt;li&gt;公钥证书，确保公钥的合法来源&lt;/li&gt;
&lt;li&gt;SSL&amp;#x2F;TLS，交换公钥的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数字签名基于公钥密码，因此数字签名的实现方式因采用的公钥密码而异，如RSA、ElGamal、ECDSA（椭圆曲线密码）。对数字签名的攻击可以基于单向散列函数或是公钥密码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不要对不清楚来源的数据做数字签名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对消息的散列值函数做数字签名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数字签名无法解决&lt;strong&gt;验证签名正确性的公钥被伪造&lt;/strong&gt;的问题，因为公钥正确性也依赖于数字签名技术。这里需要&lt;strong&gt;证书&lt;/strong&gt;以及&lt;strong&gt;公钥基础设施PKI&lt;/strong&gt;这种社会学的基础设施辅助。&lt;/p&gt;
&lt;h2 id=&#34;证书&#34;&gt;&lt;a href=&#34;#证书&#34; class=&#34;headerlink&#34; title=&#34;证书&#34;&gt;&lt;/a&gt;证书&lt;/h2&gt;&lt;p&gt;证书即&lt;strong&gt;公钥证书&lt;/strong&gt;，用来验证公钥密码和数字签名的公钥，由认证机构（CA）发布，认证机构可以是政府机关、一般企业或个人。证书的发布过程包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请人生成一对密钥，并把公钥发送给CA&lt;/li&gt;
&lt;li&gt;CA验证申请人身份&lt;/li&gt;
&lt;li&gt;通过验证后，CA使用自己的私钥对公钥施加数字签名并生成证书&lt;/li&gt;
&lt;li&gt;使用申请人证书的使用者通过CA的公钥验证申请人的公钥是否合法&lt;/li&gt;
&lt;li&gt;验证通过后，使用公钥完成公钥密码或数字签名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PKI是为了能够更有效运用公钥制定的一系列规范的总称。PKI组成要素有3个：使用PKI的用户、认证机构、仓库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户，分为注册公钥的用户和使用注册公钥的用户&lt;/li&gt;
&lt;li&gt;CA，包括生成密钥、验证本人身份、验证公钥合法性、作废证书&lt;/li&gt;
&lt;li&gt;仓库，是保存证书的数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中认证机构做了以下事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生成密钥对&lt;/strong&gt;，可以由用户或是CA生成，若是CA生成，需要根据规范发送私钥给用户&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册证书&lt;/strong&gt;，用户根据规范申请证书，认证机构根据业务准则生成符合X.509规范的证书&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作废证书&lt;/strong&gt;，因为私钥丢失等原因需要作废证书时，需要认证机构制作CRL（Certificate Revocation List，证书作废清单），PKI用户总需要从CA获取最新的CRL，以确认自己拿到的公钥证书是否有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;认证机构的证书认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;认证机构的公钥证书可以由其他的认证机构施加数字签名。这个关系可以嵌套很多层，比如部门认证机构、分公司认证机构、总公司认证机构。一直往上直到根CA，可以对自己的公钥做自签名。&lt;/p&gt;
&lt;p&gt;从而，在验证证书合法性上，也会出现&lt;strong&gt;从上至下&lt;/strong&gt;的验证过程。&lt;/p&gt;
&lt;h3 id=&#34;证书的攻击&#34;&gt;&lt;a href=&#34;#证书的攻击&#34; class=&#34;headerlink&#34; title=&#34;证书的攻击&#34;&gt;&lt;/a&gt;证书的攻击&lt;/h3&gt;&lt;p&gt;对证书的攻击即对数字签名的攻击。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对施加数字签名前的公钥攻击&lt;/li&gt;
&lt;li&gt;注册相似人名进行攻击&lt;/li&gt;
&lt;li&gt;窃取CA的私钥&lt;/li&gt;
&lt;li&gt;伪装成CA发放证书进行攻击，认证机构本身的可信度也很重要&lt;/li&gt;
&lt;li&gt;利用发送CRL的时间间隔，窃取了使用者的私钥，当使用者联系CA发布CRL时，有一定的时间间隔&lt;/li&gt;
&lt;li&gt;同样利用CRL，使用合法私钥发送消息后，发送CRL作废自己的公钥，&lt;strong&gt;否认&lt;/strong&gt;自己之前发送的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不可能在完全不可信的状态下创建出信任关系，除非以已经存在的信任关系为基础。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;密钥&#34;&gt;&lt;a href=&#34;#密钥&#34; class=&#34;headerlink&#34; title=&#34;密钥&#34;&gt;&lt;/a&gt;密钥&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;密钥长度（DES：56bit，三重DES：112bit或168bit，AES：128、192、256bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对称密码和公钥密码&lt;strong&gt;用于确保机密性&lt;/strong&gt;，消息认证码和数字签名使用的密码&lt;strong&gt;用于认证，防止篡改内容和伪装身份&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只使用一次的密钥称为&lt;strong&gt;会话密钥&lt;/strong&gt;，重复使用的密钥称为&lt;strong&gt;主密钥&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;密码学用途的随机数生成器必须为密码学用途专门设计&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定期改变会话密钥可以减少密钥泄露的损失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存密钥时，使用KEK（Key Encrypting Key）方式保存密钥可以减少管理密钥的数目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Diffie-Hellman密钥交换&#34;&gt;&lt;a href=&#34;#Diffie-Hellman密钥交换&#34; class=&#34;headerlink&#34; title=&#34;Diffie-Hellman密钥交换&#34;&gt;&lt;/a&gt;Diffie-Hellman密钥交换&lt;/h3&gt;&lt;p&gt;Diffie-Hellman密钥交换里，通信的双方通过交换一些可以公开的消息，就能够生成共享的密钥。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定一个非常大的质数P，寻找P的生成元（原根）G&lt;/li&gt;
&lt;li&gt;通信双方各自找1个1 ~ P-2的随机数A、B，生成G ^ A mod P与G ^ B mod P，发送给对方&lt;/li&gt;
&lt;li&gt;对方用收到的数字根据自己选的随机数做乘方运算，得到相等的值作为密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它同样利用了离散对数问题难以快速求解的特点。这种交换方法可以做中间人攻击，可以用数字签名、证书等方式应对。&lt;/p&gt;
&lt;h3 id=&#34;基于口令的密码（PBE）&#34;&gt;&lt;a href=&#34;#基于口令的密码（PBE）&#34; class=&#34;headerlink&#34; title=&#34;基于口令的密码（PBE）&#34;&gt;&lt;/a&gt;基于口令的密码（PBE）&lt;/h3&gt;&lt;p&gt;基于口令的密码避免了：记忆CEK -&amp;gt; 记忆KEK -&amp;gt; 记忆KEK的KEK的死循环。使用好记忆的口令配合盐生成CEK。使用过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用随机数生成器生成盐（随机数），加上用户口令，使用单向散列函数得到KEK&lt;/li&gt;
&lt;li&gt;使用KEK加密会话使用的CEK&lt;/li&gt;
&lt;li&gt;保存好盐以及使用KEK加密的会话秘钥&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;盐的目的是避免字典攻击&lt;/li&gt;
&lt;li&gt;口令虽然便于生成，但是强度不高，因此需要格外地小心保管&lt;/li&gt;
&lt;li&gt;可以对KEK迭代使用单向散列函数得到最后的KEK（拉伸），这将加大攻击者的攻击负担&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成安全的口令&#34;&gt;&lt;a href=&#34;#生成安全的口令&#34; class=&#34;headerlink&#34; title=&#34;生成安全的口令&#34;&gt;&lt;/a&gt;生成安全的口令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;只有自己&lt;/strong&gt;知道的信息&lt;ul&gt;
&lt;li&gt;不包括别人见过的信息&lt;/li&gt;
&lt;li&gt;不包括可以很容易推测的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不应该重复使用口令，容易受牵连影响&lt;/li&gt;
&lt;li&gt;物理保存是可以的，但要注意安全&lt;/li&gt;
&lt;li&gt;可以使用口令生成和管理工具（比如1Password）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;随机数生成&#34;&gt;&lt;a href=&#34;#随机数生成&#34; class=&#34;headerlink&#34; title=&#34;随机数生成&#34;&gt;&lt;/a&gt;随机数生成&lt;/h2&gt;&lt;p&gt;随机数生成在密码学中很常用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成密钥&lt;/li&gt;
&lt;li&gt;生成分组密码的初始化向量&lt;/li&gt;
&lt;li&gt;生成CTR模式的nonce&lt;/li&gt;
&lt;li&gt;生成盐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随机数至少需要具有下面的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机等概性&lt;/li&gt;
&lt;li&gt;无状态，即无法从上一个推测下一个，生成序列无法重现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于计算机构成的抽象世界是&lt;strong&gt;离散的&lt;/strong&gt;，内部状态有限，不能满足无状态的特点，因此只能称作&lt;strong&gt;伪随机数生成器&lt;/strong&gt;。基于计算机硬件的随机数生成器可以认为是“真”随机数，它通常提前储存在一个随机数池中，在需要的时候直接从池中取用。伪随机数生成器根据随机的种子（seed）通过算法将内部状态转化为最终的随机数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性同余法&lt;/strong&gt;，以当前随机数为内部状态（初始值为种子），(A x Rn + C) mod M，计算下一个值。其中A、C、M都需要事先选好，线性同余法生成的随机数数列具有可预测性，即不需要知道种子也可以推测下随机数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单向散列函数&lt;/strong&gt;，利用单向散列函数保护内部状态，以种子为初始值，逐次递加得到新的内部状态，再通过单向散列函数输出为随机数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密码法&lt;/strong&gt;，类似单向散列函数，使用密钥加密内部状态输出也可以作为随机数，此时保护内部状态的加密算法和密钥&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ANSI X9.17&lt;/strong&gt;中，使用AES和三重DES作为密码算法&lt;ol&gt;
&lt;li&gt;初始化内部状态&lt;/li&gt;
&lt;li&gt;使用当前时间生成掩码&lt;/li&gt;
&lt;li&gt;掩码和内部状态做XOR&lt;/li&gt;
&lt;li&gt;加密3的输出，作为随机数输出&lt;/li&gt;
&lt;li&gt;对加密后的输出与掩码做XOR&lt;/li&gt;
&lt;li&gt;加密5的结果作为新的内部状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PGP介绍&#34;&gt;&lt;a href=&#34;#PGP介绍&#34; class=&#34;headerlink&#34; title=&#34;PGP介绍&#34;&gt;&lt;/a&gt;PGP介绍&lt;/h2&gt;&lt;p&gt;PGP全程Pretty Good Privacy，编写于1990年，具备现代密码软件所需的几乎所有功能。OpenPGP是一对密文和数字签名进行定义的标准规格。&lt;/p&gt;
&lt;h3 id=&#34;加密和解密&#34;&gt;&lt;a href=&#34;#加密和解密&#34; class=&#34;headerlink&#34; title=&#34;加密和解密&#34;&gt;&lt;/a&gt;加密和解密&lt;/h3&gt;&lt;p&gt;加密时，使用混合密码系统的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用伪随机数生成会话密钥&lt;/li&gt;
&lt;li&gt;用&lt;strong&gt;接收者&lt;/strong&gt;的公钥加密会话密钥&lt;/li&gt;
&lt;li&gt;压缩消息，并使用对称密码加密，密钥为上面生成的会话密钥&lt;/li&gt;
&lt;li&gt;将加密后的密钥和密文拼接在一起&lt;/li&gt;
&lt;li&gt;将4的结果转换为文本数据，即为报文数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解密时，PGP的私钥通过用户口令加密保存。在收到密文时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入接收者的口令&lt;/li&gt;
&lt;li&gt;求口令的散列值，生成用户解密私钥的秘钥&lt;/li&gt;
&lt;li&gt;解密得到私钥&lt;/li&gt;
&lt;li&gt;将报文数据转换为二进制，并拆解成加密的会话密钥和压缩的密文&lt;/li&gt;
&lt;li&gt;用自己的私钥解密得到会话密钥&lt;/li&gt;
&lt;li&gt;用会话密钥解密密文&lt;/li&gt;
&lt;li&gt;解压缩明文得到原始消息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;生成数字签名&#34;&gt;&lt;a href=&#34;#生成数字签名&#34; class=&#34;headerlink&#34; title=&#34;生成数字签名&#34;&gt;&lt;/a&gt;生成数字签名&lt;/h3&gt;&lt;p&gt;同样，生成数字签名时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入接收者的口令&lt;/li&gt;
&lt;li&gt;求口令的散列值，生成用户解密私钥的秘钥&lt;/li&gt;
&lt;li&gt;解密得到私钥&lt;/li&gt;
&lt;li&gt;使用单向散列函数计算消息散列值&lt;/li&gt;
&lt;li&gt;对散列值签名，即使用私钥加密&lt;/li&gt;
&lt;li&gt;拼合签名和消息，进行压缩&lt;/li&gt;
&lt;li&gt;&lt;em&gt;（可选）&lt;/em&gt;转换二进制为文本数据，即最后的报文数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似地，验证时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转换为二进制文件，解压缩数据&lt;/li&gt;
&lt;li&gt;分解出签名和消息两部分&lt;/li&gt;
&lt;li&gt;使用公钥解密签名，得到散列值&lt;/li&gt;
&lt;li&gt;使用单向散列函数计算消息散列值，对比3中的散列值&lt;/li&gt;
&lt;li&gt;相等即验证成功&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;生成数字签名并加密&#34;&gt;&lt;a href=&#34;#生成数字签名并加密&#34; class=&#34;headerlink&#34; title=&#34;生成数字签名并加密&#34;&gt;&lt;/a&gt;生成数字签名并加密&lt;/h3&gt;&lt;p&gt;实际情况下，我们往往需要使用加密算法加密数字签名中的原消息。实现步骤是上两节的组合。即先进行数字签名，再对签名结果加密。&lt;/p&gt;
&lt;p&gt;验证过程是相反的，先解密密文得到签名结果，再验证数字签名。&lt;/p&gt;
&lt;h3 id=&#34;信任网&#34;&gt;&lt;a href=&#34;#信任网&#34; class=&#34;headerlink&#34; title=&#34;信任网&#34;&gt;&lt;/a&gt;信任网&lt;/h3&gt;&lt;p&gt;PGP确认公钥合法性的方法不依赖于认证机构颁发证书，而是采用所有者信任级别构成信任网（也叫信任圈、朋友圈）的方式，让用户自己决定该信任谁。建立信任有三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过自己的签名来确认。用户在通过其他方式（比如线下）确认公钥可信任后，对该公钥加上自己的数字签名。由于PGP中，使用者本人的公钥是绝对信任，被施加签名的公钥因此可信任。&lt;em&gt;注意：这并不代表被施加签名的公钥所有者被&lt;strong&gt;完全&lt;/strong&gt;信任&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通过自己完全信任的数字签名进行确认。即&lt;strong&gt;完全信任&lt;/strong&gt;某个公钥进行的数字签名，用户可对当前信任的每个公钥所有者设置信任级别，级别为&lt;strong&gt;完全信任&lt;/strong&gt;时，所有者公钥施加签名的公钥也会被信任。&lt;/li&gt;
&lt;li&gt;通过有限信任的多个数字签名进行确认。在设置信任级别为&lt;strong&gt;有限信任&lt;/strong&gt;时，有限信任的公钥&lt;strong&gt;都&lt;/strong&gt;施加数字签名后，新的公钥才会被信任。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上面三种方式，PGP使用者可以构建起自己的信任网，从而根据自己的决定信任某个公钥。&lt;/p&gt;
&lt;h2 id=&#34;SSL-x2F-TLS&#34;&gt;&lt;a href=&#34;#SSL-x2F-TLS&#34; class=&#34;headerlink&#34; title=&#34;SSL&amp;#x2F;TLS&#34;&gt;&lt;/a&gt;SSL&amp;#x2F;TLS&lt;/h2&gt;&lt;p&gt;TLS是SSL的后续版本，但在大多数情况下，可以统一写成SSL&amp;#x2F;TLS。&lt;strong&gt;SSL&amp;#x2F;TLS可以承载应用层协议，保证应用层传输的安全性，HTTP就是其中一种&lt;/strong&gt;。其余SSL&amp;#x2F;TLS可以承载的应用层协议还包括SMTP、POP3等等。&lt;/p&gt;
&lt;p&gt;SSL于1994年在网景公司开发，在1995年发布了SSL3.0版本，后被发现会导致POODLE攻击。TLS是IETF在1999年作为SSL3.1发布。2006年发布TLS1.1，之后又发布了TLS1.2。&lt;/p&gt;
&lt;p&gt;HTTPS中SSL&amp;#x2F;TLS要保证以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证消息传输中&lt;strong&gt;不被窃听&lt;/strong&gt; -&amp;gt; &lt;strong&gt;对称密码&lt;/strong&gt;加密消息，&lt;strong&gt;公钥密码&lt;/strong&gt;加密对称密码的密钥&lt;/li&gt;
&lt;li&gt;保证消息传输中&lt;strong&gt;不被篡改&lt;/strong&gt; -&amp;gt; &lt;strong&gt;消息认证&lt;/strong&gt;码&lt;/li&gt;
&lt;li&gt;保证消息传输&lt;strong&gt;双方的合法性&lt;/strong&gt; -&amp;gt; &lt;strong&gt;数字签名&lt;/strong&gt;生成证书&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通信过程&#34;&gt;&lt;a href=&#34;#通信过程&#34; class=&#34;headerlink&#34; title=&#34;通信过程&#34;&gt;&lt;/a&gt;通信过程&lt;/h3&gt;&lt;p&gt;下面的流程以TLS1.2为例。TLS协议分为两层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TLS握手协议&lt;/strong&gt;，位于上层，处理除加密的部分。可以进一步分为：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;握手协议&lt;/strong&gt;，负责在客户端和服务器间协商密码算法和共享密钥&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密码规格变更协议&lt;/strong&gt;，向通信对象传达变更密码方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;警告协议&lt;/strong&gt;，在发生错误时将错误传达给对方&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用数据协议&lt;/strong&gt;，将TLS上承载的应用数据传达给通信对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TLS记录协议&lt;/strong&gt;，位于底层，处理加密的部分。使用了对称密码和消息认证码，但具体的算法和密钥需要通信双方具体协商&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;TLS记录协议&#34;&gt;&lt;a href=&#34;#TLS记录协议&#34; class=&#34;headerlink&#34; title=&#34;TLS记录协议&#34;&gt;&lt;/a&gt;TLS记录协议&lt;/h3&gt;&lt;p&gt;记录协议负责数据的压缩、加密、数据认证，工作方式如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分割消息为较小的片段，再分段压缩，&lt;strong&gt;压缩方式需要协商决定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对压缩过的消息进行消息认证，加上MAC值。为了避免重放攻击，在计算MAC值时，加上了片段的编号。其中的&lt;strong&gt;单向散列函数的算法、使用的密钥都需要协商确定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;把MAC值和压缩过的消息片段组合在一起，使用对称密码加密。迭代模式使用CBC模式，CBC模式的初始化向量通过主密码生成。&lt;strong&gt;对称密码的算法、密钥则需要协商决定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上述经过加密的数据，再加上&lt;strong&gt;数据类型、版本号、压缩后的长度&lt;/strong&gt;，构成最终的报文数据。数据类型就是之前提到的TLS握手协议的4类子协议&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;握手协议&#34;&gt;&lt;a href=&#34;#握手协议&#34; class=&#34;headerlink&#34; title=&#34;握手协议&#34;&gt;&lt;/a&gt;握手协议&lt;/h3&gt;&lt;p&gt;握手协议负责生成对称密码中的共享密钥以及交换证书。因为握手的整个过程都是明文进行的，因此需要使用公钥密码或是Diffie-Hellman密钥交换。整个握手协议有下面几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ClientHello&lt;/strong&gt;，客户端发送一些信息给服务器，便于协商算法和密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;可用版本号，即支持的SSL&amp;#x2F;TLS版本号&lt;/li&gt;
&lt;li&gt;客户端生成的随机数，在后面的步骤会用到&lt;/li&gt;
&lt;li&gt;会话ID，在需要重新使用以前的会话时用到&lt;/li&gt;
&lt;li&gt;客户端可用的密码套件清单&lt;/li&gt;
&lt;li&gt;客户端可用的压缩方式清单&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;ServerHello&lt;/strong&gt;，服务器根据客户端传来的信息，选择合适的算法和密码套件，返回的消息中带有下面几条&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用的版本号&lt;/li&gt;
&lt;li&gt;服务端生成的随机数，后面步骤会用到&lt;/li&gt;
&lt;li&gt;会话ID，作用同上&lt;/li&gt;
&lt;li&gt;使用的密码套件&lt;/li&gt;
&lt;li&gt;使用的压缩方式&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Certificate&lt;/strong&gt;，&lt;strong&gt;非匿名通信&lt;/strong&gt;时，服务器发送自己的证书，以及对服务器证书签名的CA的证书&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ServerKeyExchange&lt;/strong&gt;，当Certificate消息不足时，服务器通过此消息传递额外信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CertificateRequest&lt;/strong&gt;，需要进行&lt;strong&gt;客户端认证&lt;/strong&gt;时，服务端发送此消息，并带上服务器能理解的证书类型、CA名称清单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ServerHelloDone&lt;/strong&gt;，服务器发送此消息结束服务器的返回&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certificate&lt;/strong&gt;，作为CertificateRequest的回应，客户端发送自己的证书，交给服务器验证&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ClientKeyExchange&lt;/strong&gt;，密码套件包含RSA时，会发送&lt;strong&gt;经过服务器公钥加密的预备主密码&lt;/strong&gt;；密码套件包含Diffie-Hellman密钥交换时，会发送Diffie-Hellman密钥交换中的公开值。&lt;strong&gt;预备主密码（pre-master secret）&lt;/strong&gt;是客户端生成的随机数，之后会用做生成主密码的种子。根据预备主密码，通信双方计算出&lt;strong&gt;相同的主密码&lt;/strong&gt;。主密码会用做以下用途：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对称密码的密钥&lt;/li&gt;
&lt;li&gt;消息认证码的密钥&lt;/li&gt;
&lt;li&gt;CBC模式中的初始化向量&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;strong&gt;CertificateVerify&lt;/strong&gt;，在服务器发送CertificateRequest时，通过此消息发送客户端使用自己私钥签名的主密码和握手协议传输消息的散列值。证明自己是客户端证书的持有人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ChangeCipherSpec&lt;/strong&gt;，客户端发送，表示切换密码开始，实际上是密码规格变更协议的一类报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Finished&lt;/strong&gt;，握手结束，此时已使用切换后的密码套件来加密发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ChangeCipherSpec&lt;/strong&gt;，&lt;strong&gt;Finished&lt;/strong&gt;。来自服务器，作用同上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过上面的步骤，双方达成了下面的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端获得了服务器的公钥，完成了服务器认证&lt;/li&gt;
&lt;li&gt;服务器获得了客户端公钥，完成了客户端认证（如果需要的话）&lt;/li&gt;
&lt;li&gt;生成了对称密码的密钥&lt;/li&gt;
&lt;li&gt;生成了消息认证码中的共享密钥&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;密码规格变更协议&#34;&gt;&lt;a href=&#34;#密码规格变更协议&#34; class=&#34;headerlink&#34; title=&#34;密码规格变更协议&#34;&gt;&lt;/a&gt;密码规格变更协议&lt;/h3&gt;&lt;p&gt;用于在一开始从明文通信切换到使用密码套件沟通。&lt;/p&gt;
&lt;h3 id=&#34;警告协议&#34;&gt;&lt;a href=&#34;#警告协议&#34; class=&#34;headerlink&#34; title=&#34;警告协议&#34;&gt;&lt;/a&gt;警告协议&lt;/h3&gt;&lt;p&gt;用在握手协议异常、消息认证码错误、无法解压数据等异常情况。&lt;/p&gt;
&lt;h3 id=&#34;应用数据协议&#34;&gt;&lt;a href=&#34;#应用数据协议&#34; class=&#34;headerlink&#34; title=&#34;应用数据协议&#34;&gt;&lt;/a&gt;应用数据协议&lt;/h3&gt;&lt;p&gt;通信对象间传递应用数据。&lt;/p&gt;
&lt;h3 id=&#34;主密码&#34;&gt;&lt;a href=&#34;#主密码&#34; class=&#34;headerlink&#34; title=&#34;主密码&#34;&gt;&lt;/a&gt;主密码&lt;/h3&gt;&lt;p&gt;主密码根据预备主密码（pre-master secret）或Diffie-Hellman密钥交换的公开值生成。生成的主密码用于生成&lt;strong&gt;对称密码的密钥、消息认证码的密钥、CBC模式的初始化向量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;对SSL-x2F-TLS的攻击&#34;&gt;&lt;a href=&#34;#对SSL-x2F-TLS的攻击&#34; class=&#34;headerlink&#34; title=&#34;对SSL&amp;#x2F;TLS的攻击&#34;&gt;&lt;/a&gt;对SSL&amp;#x2F;TLS的攻击&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;SSL&amp;#x2F;TLS框架性的特点让它不依赖于某个特定的密码技术，因此对特定密码技术的攻击对SSL&amp;#x2F;TLS本身影响不大&lt;/li&gt;
&lt;li&gt;心脏出血漏洞，发现于2014年，利用TLS心跳拓展对请求的数据大小没有检查，可以获取内存中与请求无关的信息。是OpenSSL实现的漏洞。&lt;/li&gt;
&lt;li&gt;POODLE攻击，利用CBC中的填充提示攻击，发现于2014年SSL3.0中。&lt;/li&gt;
&lt;li&gt;FREAK攻击，可以在密码套件协商时，利用中间人攻击，强制使用强度很低的RSA Export Suites。从而在加密后，暴力破解明文。&lt;/li&gt;
&lt;li&gt;对伪随机数生成器的攻击&lt;/li&gt;
&lt;li&gt;利用之前提过的CRL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;密码技术因为人类的不完美而必定不会完美。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对称密码&lt;/strong&gt;，使用相同密钥加密、解密，保证消息&lt;strong&gt;机密性&lt;/strong&gt;。目前主要使用AES。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公钥密码&lt;/strong&gt;，使用不同密钥加密、解密，作用同上。使用最广泛的是RSA，还有相关的Diffie-Hellman密钥交换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单向散列函数&lt;/strong&gt;，将消息转为固定长度散列值的技术，保证消息&lt;strong&gt;完整性&lt;/strong&gt;，目前使用SHA2和SHA3（Keccak）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息认证码&lt;/strong&gt;，结合单向散列函数和对称密码，保证消息&lt;strong&gt;完整性&lt;/strong&gt;并&lt;strong&gt;认证消息&lt;/strong&gt;，但无法防御&lt;strong&gt;否认&lt;/strong&gt;。目前主要使用HMAC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字签名&lt;/strong&gt;，结合单向散列函数和公钥秘钥，保证&lt;strong&gt;完整性&lt;/strong&gt;，&lt;strong&gt;不可否认性&lt;/strong&gt;和&lt;strong&gt;认证消息&lt;/strong&gt;。是公钥证书采用的技术&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪随机数生成器&lt;/strong&gt;，配合上述技术使用，需要保证&lt;strong&gt;不可预测性&lt;/strong&gt;和&lt;strong&gt;不可重现性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;密码技术从某种角度看是一种压缩技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥是机密性的压缩&lt;/li&gt;
&lt;li&gt;散列值是消息完整性的压缩&lt;/li&gt;
&lt;li&gt;认证值时认证的压缩&lt;/li&gt;
&lt;li&gt;随机数种子是不可预测性的压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;比特币&#34;&gt;&lt;a href=&#34;#比特币&#34; class=&#34;headerlink&#34; title=&#34;比特币&#34;&gt;&lt;/a&gt;比特币&lt;/h3&gt;&lt;p&gt;比特币来自于Satoshi Nakamoto（中本聪，化名）的一篇论文，并于2009年开始实际运用。比特币是一种&lt;strong&gt;基于P2P网络的支付结算系统&lt;/strong&gt;。用户通过它进行进行价值转移。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;地址&lt;/strong&gt;，将公钥使用散列函数求散列值得到，地址都以1开头，剩下内容 不包含O，0,1和I。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;钱包&lt;/strong&gt;，即比特币客户端，可以生成密钥对，公钥用于收款，密钥用于付款&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区块链&lt;/strong&gt;，保存了比特币所有交易记录的账簿，若干交易组成一个区块，在区块头有所有交易的散列值，以及上一个区块的散列值，有交易添加时会触发区块头的散列值变化，并链式传递下去&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交易&lt;/strong&gt;，收、付款方各自生成密钥对，付款方创建交易“地址A向地址B转账x BTC”，&lt;strong&gt;并用自己的私钥签署数字签名&lt;/strong&gt;，之后广播至P2P网络中，完成交易。比特币使用的数字签名基于椭圆曲线DSA，方程为x^2 &amp;#x3D; y^3 + 7&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挖矿&lt;/strong&gt;，向区块链中添加新区块的行为被称为挖矿，第一个挖矿成功的矿工会获得挖矿奖励和区块所有交易的手续费。为了证明自己确实完成了规定工作，矿工需要进行&lt;strong&gt;工作量证明&lt;/strong&gt;（PoW），即生成的区块头中，前一区块头的散列值必须以若干位的0开头，这个工作需要投入大量的计算资源。区块大约每10分钟添加一个，为了避免通货膨胀，所需的0的个数会不断调整。&lt;ul&gt;
&lt;li&gt;根据协议规定，挖矿奖励每4年减少一半&lt;/li&gt;
&lt;li&gt;当区块链上同时出现分支时，P2P网络会选择计算量大的分支进行工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比特币的匿名性只限于交易地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附录：椭圆曲线&#34;&gt;&lt;a href=&#34;#附录：椭圆曲线&#34; class=&#34;headerlink&#34; title=&#34;附录：椭圆曲线&#34;&gt;&lt;/a&gt;附录：椭圆曲线&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;椭圆曲线（EC）源自于求椭圆弧长的椭圆积分的反函数。&lt;/li&gt;
&lt;li&gt;定义椭圆曲线上的加法运算&lt;/li&gt;
&lt;li&gt;椭圆曲线上的离散对数（ECDLP） - 已知点G和点xG，求整数x&lt;/li&gt;
&lt;li&gt;有限域上的离散对数，对点进行模运算&lt;/li&gt;
&lt;li&gt;椭圆曲线Diffie-Hellman密钥交换&lt;/li&gt;
&lt;li&gt;椭圆曲线ElGamal密码&lt;/li&gt;
&lt;li&gt;椭圆曲线DSA（ECDSA）&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="算法" />
        <category term="密码" />
        <category term="密钥" />
        <updated>2018-10-29T16:07:43.000Z</updated>
    </entry>
</feed>

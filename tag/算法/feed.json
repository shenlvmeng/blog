{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"算法\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/",
            "url": "http://shenlvmeng.github.com/blog/2018/10/30/password-tech-note/",
            "title": "《图解密码技术》总结整理",
            "date_published": "2018-10-29T16:07:43.000Z",
            "content_html": "<blockquote>\n<p>本文来自<a href=\"https://book.douban.com/subject/26265544/\">《图解密码技术》</a>一书</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>信源、信宿、信道</li>\n<li>加密、解密、密钥</li>\n<li>对称密码、公钥密码、混合密码</li>\n<li>单向散列（hash）函数、信息认证</li>\n<li>数字签名 &#x2F; 篡改和否认</li>\n<li>伪随机数</li>\n</ul>\n<p>信息传递时面临的风险：</p>\n<ul>\n<li>窃听 -&gt; 对称、公钥密码</li>\n<li>篡改 -&gt; 散列函数、消息认证、数字签名</li>\n<li>伪装 -&gt; 消息认证、数字签名</li>\n<li>否认 -&gt; 数字签名</li>\n</ul>\n<p>有悖常识的几点：</p>\n<ul>\n<li>不要使用保密的加密算法</li>\n<li>使用低强度密码不如不用</li>\n<li>任何密码都有可能被破解</li>\n<li>密码只是安全的一部分（社工）</li>\n</ul>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><ul>\n<li>凯撒密码 &#x2F; 平移 &#x2F; 暴力破解</li>\n<li>简单替换密码 &#x2F; 替换 &#x2F; 频率分析</li>\n<li>Enigma &#x2F; 加密密码的密码 &#x2F; 针对每日密钥的破解</li>\n</ul>\n<h2 id=\"对称密码\"><a href=\"#对称密码\" class=\"headerlink\" title=\"对称密码\"></a>对称密码</h2><ul>\n<li>编码和异或</li>\n<li>一次性密码和它的问题</li>\n<li><strong>使用对称密码时，我们通常默认密钥配送问题已解决</strong></li>\n</ul>\n<h3 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h3><p>全称Data Encryption Standard。于1977年在美国发明并使用。目前可以被暴力破解，因此不应再使用了。</p>\n<ul>\n<li>DES以<strong>64bit</strong>为一个单位，使用和明文等长的密钥。</li>\n<li>密钥每8位包含1位纠错码</li>\n<li>基本结构使用Feistel网络<ul>\n<li>加密&#x2F;解密步骤以轮为单位，DES有16轮</li>\n<li>每轮运算不加密右半侧，同时右半侧比特和该轮密钥通过轮函数得到本轮加密左侧的密钥，和左侧做异或得到左侧密文</li>\n<li>每轮加密后，进行左右对调，保证右侧的保密</li>\n<li><strong>解密时用相同结构</strong>，反向使用子密钥和轮函数即可</li>\n<li>轮函数可以任意复杂</li>\n</ul>\n</li>\n<li>差分分析和线性分析衡量分组密码强度</li>\n</ul>\n<p><strong>三重DES</strong></p>\n<p>由IBM开发，步骤为DES加密 -&gt; DES解密 -&gt; DES加密。密钥长度是原来三倍，即168比特。</p>\n<ul>\n<li>三步使用同一密钥，即向下兼容DES</li>\n<li>根据1、3步是否使用同一密钥，分为DES-EDE2和DES-EDE3</li>\n<li>处理速度慢</li>\n</ul>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p>全称Advanced Encrytion Standard，用来取代DES。由NIST开于1997年开始募集，将作为国家标准。算法要求开源免费，并在社群里公开评审，最终于2000年确定为Rijndael。</p>\n<ul>\n<li>基本结构为SPN结构</li>\n<li>明文分组长度固定为<strong>128bit</strong>、密钥长度可以是128、192、256比特三种</li>\n<li>每轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey四步<ul>\n<li>SubBytes，将4字节 * 4字节的矩阵与一个转换矩阵相乘，得到替换后的矩阵</li>\n<li>ShiftRows，逐行做平移</li>\n<li>MixColumns，逐列做矩阵运算</li>\n<li>AddRoundKey，和轮密钥矩阵做对应位上的异或运算</li>\n</ul>\n</li>\n<li>解密时，除了AddRoundKey一步，其余均需要做逆运算</li>\n<li>目前还没有针对Rijndael的有效攻击</li>\n<li><strong>避免使用DES，选择AES</strong></li>\n</ul>\n<h2 id=\"分组密码的迭代模式\"><a href=\"#分组密码的迭代模式\" class=\"headerlink\" title=\"分组密码的迭代模式\"></a>分组密码的迭代模式</h2><p>分组密码只能加密<strong>固定长度</strong>的密码。因此，需要有<strong>模式</strong>来迭代加密任意长度的明文。与分组密码相对的是流密码，对数据进行连续处理。</p>\n<h3 id=\"ECB\"><a href=\"#ECB\" class=\"headerlink\" title=\"ECB\"></a>ECB</h3><p>全称为Electronic CodeBook。是最简单直接的分组方式。将明文分组加密后直接得到对应位置的密文。不足的位用特定数据<strong>填充</strong>。</p>\n<ul>\n<li>问题很明显，<strong>不要使用</strong></li>\n<li>相同的明文分组会得到相同的密文分组</li>\n<li>攻击者无需破译密码也可通过修改密文操纵明文，比如替换或删除分组</li>\n</ul>\n<h3 id=\"CBC\"><a href=\"#CBC\" class=\"headerlink\" title=\"CBC\"></a>CBC</h3><p>全称Cipher Block Chaining。和ECB的最大不同在于明文分组加密前会和上一个密文分组做一次异或运算。开头的明文分组会和一个随机序列做XOR。</p>\n<ul>\n<li>一个密文分组的损坏会影响关联的两个分组的解密</li>\n<li>比特的缺失将会影响整个密文的解密</li>\n<li>操纵初始化向量反转某一位比特可以反转第一个密文分组的某一位</li>\n<li>填充提示攻击，攻击padding部分</li>\n<li>SSL&#x2F;TLS使用CBC模式保证通信机密</li>\n<li><strong>CTS</strong>使用最后一个密文填充不足的明文部分</li>\n</ul>\n<h3 id=\"CFB\"><a href=\"#CFB\" class=\"headerlink\" title=\"CFB\"></a>CFB</h3><p>全程Cipher FeedBack模式。和CBC模式的区别在密文分组先加密，再和下一个明文做异或运算。实际上明文分组和密文分组间只相差了一个异或运算。很类似一次性密码本的模式。</p>\n<ul>\n<li>解密时，需要对密文分组和初始向量做<strong>加密</strong>操作</li>\n<li><strong>重放</strong>攻击，替换密文分组为原有分组，可使得解密出的明文为原有明文</li>\n</ul>\n<h3 id=\"OFB\"><a href=\"#OFB\" class=\"headerlink\" title=\"OFB\"></a>OFB</h3><p>全称Output-FeedBack模式。和CFB很像，区别在于OFB每次做XOR的密钥流仅来自于上一次的密钥，<strong>和密文分组无关</strong>。因为密钥流可以提前准备好，分组加密过程可以是并行的。</p>\n<ul>\n<li>第一次的密钥来自初始化向量</li>\n<li>速度快</li>\n<li>如果碰巧密钥加密后和加密前一样，那么之后的密钥就会是同一个值</li>\n</ul>\n<h3 id=\"CTR\"><a href=\"#CTR\" class=\"headerlink\" title=\"CTR\"></a>CTR</h3><p>全称CounTeR。CTR和OFB类似，区别在于它的密钥流来自于累加的计数器。密文分组来自于密钥流和明文分组的XOR运算。</p>\n<ul>\n<li>计数器由nonce和序号两部分各8字节组成，nonce是随机生成的，序号是从1累加的。</li>\n<li>和OFB一样，加密解密速度快，结构简单</li>\n<li>CTR的密钥流在选定nonce后就确定了，因此可以以<strong>任意顺序并行</strong>加密、解密</li>\n</ul>\n<h2 id=\"公钥密码\"><a href=\"#公钥密码\" class=\"headerlink\" title=\"公钥密码\"></a>公钥密码</h2><p>解决了对称密码的密钥配送问题。</p>\n<h3 id=\"密钥配送问题\"><a href=\"#密钥配送问题\" class=\"headerlink\" title=\"密钥配送问题\"></a>密钥配送问题</h3><ul>\n<li><strong>事先共享</strong>，在现实生活中传送</li>\n<li><strong>密钥配送中心</strong>，集中式管理用户密钥，用其加密临时的会话密钥</li>\n<li><strong>使用Diffie-Hellman密钥交换</strong></li>\n<li><strong>使用公钥密码</strong></li>\n</ul>\n<h3 id=\"公钥密码-1\"><a href=\"#公钥密码-1\" class=\"headerlink\" title=\"公钥密码\"></a>公钥密码</h3><p>使用加密密钥（公钥）加密，使用解密密钥（私钥）解密，避免密钥的泄露。</p>\n<ul>\n<li>发送者使用加密密钥</li>\n<li>接收者使用解密密钥</li>\n<li>加密密钥可以公开</li>\n<li>解密密钥一定要保密</li>\n</ul>\n<p>目前所使用的公钥密码RSA来自于1978年的发明。流程上，</p>\n<ul>\n<li><strong>接收者</strong>生成公私钥对，发送公钥给发送者</li>\n<li>发送者使用公钥加密明文</li>\n<li>接收者使用私钥解密密文</li>\n</ul>\n<p>公钥密码有两个问题：</p>\n<ul>\n<li>认证公钥的合法性</li>\n<li>处理速度慢</li>\n</ul>\n<h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>利用了数论中求解离散对数困难且耗时的特点。</p>\n<ul>\n<li><strong>加密</strong>，使用<code>密文=明文 ^ E mod N</code>。E和N组合成公钥。</li>\n<li><strong>解密</strong>，使用<code>明文=密文 ^ D mod N</code>。D和N组合成密钥。</li>\n</ul>\n<p>生成N、E、D和顺序如下：</p>\n<ol>\n<li>寻找互质的两个大数p和q，N为二者的乘积</li>\n<li>p-1和q-1的最小公倍数记为L</li>\n<li>寻找比L小的和L互质的数，即为E</li>\n<li>寻找比L小的和E乘积取模L为1的数，即为D</li>\n</ol>\n<p>因为解密时有对N取模操作，因此加密的明文不能大于N。</p>\n<p><strong>攻击方式</strong></p>\n<ul>\n<li>破解密文 -&gt; 求解离散对数很难</li>\n<li>暴力破解D -&gt; 比特位太长，很难破解</li>\n<li>通过E求解D，只要知道p和q就能算出D -&gt; 不知道p和q的组合 -&gt; <strong>对N质因数分解很难</strong></li>\n</ul>\n<p><strong>中间人攻击</strong>里，攻击者可以替换掉原本的公钥，发送给接收者，使用自己的私钥解密，从而实现攻击。这时需要<strong>证书</strong>保证公钥的权威性。</p>\n<p><strong>选择密文攻击</strong>里，攻击者可以利用服务端返回的错误消息收集加密算法信息。RSA-OAEP会在明文开头加上明文散列值和填充位，解密时发现散列值和内容对不上时，会隐藏错误信息。</p>\n<p>除了RSA外，还有ElGamal方式、Robin方式、ECC（椭圆曲线密码）等公钥密码。它们分别利用了mod N下求离散对数，mod N下求平方根，和椭圆曲线上做乘法运算逆运算在数学上很难求解的特点。</p>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p>Q: 和对称密码的强度对比<br>A: 达到同等强度，RSA大致需要密钥是AES长度的20倍</p>\n<p>Q: RSA使用的质数会用完么<br>A: 512bit的质数数目大约是10 ^ 150。足够使用。</p>\n<p>Q: RSA破解难度如何？<br>A: 和大整数质因数分解一样难度</p>\n<p>Q: 要保证RSA强度，N的长度要达到多少位<br>A: 2048bit，4096bit更好</p>\n<h2 id=\"混合密码系统\"><a href=\"#混合密码系统\" class=\"headerlink\" title=\"混合密码系统\"></a>混合密码系统</h2><ul>\n<li>用对称密码加密明文</li>\n<li>用公钥密码加密上述对称密码的密钥（通常用随机数生成器得到，只用于此次会话）</li>\n<li>公钥密码的密钥由外部赋予（证书）</li>\n</ul>\n<p>密码软件PGP、HTTPS中使用的SSL&#x2F;TLS就使用了混合密码系统。当然它们还包含数字签名、认证、私钥管理等更多处理。</p>\n<p>类似混合密码系统，后面要介绍的数字签名、证书、消息认证、伪随机数生成也都是<strong>基础密码技术的组合</strong>。</p>\n<h2 id=\"单向散列函数\"><a href=\"#单向散列函数\" class=\"headerlink\" title=\"单向散列函数\"></a>单向散列函数</h2><ul>\n<li>将任意长度的消息转换到<strong>固定长度</strong>散列</li>\n<li>具有抗碰撞性，即找到具有相同散列函数的消息很困难</li>\n<li>单向性，即无法从三列中还原原信息</li>\n</ul>\n<h3 id=\"MD4、MD5\"><a href=\"#MD4、MD5\" class=\"headerlink\" title=\"MD4、MD5\"></a>MD4、MD5</h3><p>全称Message Digest。由Rivest设计于1990和1991年。能够产生<strong>128bit</strong>的散列值。它们的强抗碰撞性已被攻破，<strong>不建议使用</strong>。</p>\n<h3 id=\"RIPEMD-160\"><a href=\"#RIPEMD-160\" class=\"headerlink\" title=\"RIPEMD-160\"></a>RIPEMD-160</h3><p>1996年设计，是欧盟RIPE项目的修订版，能产生160bit长度的散列值。比特币中使用的散列函数就是RIPEMD-160。</p>\n<h3 id=\"SHA\"><a href=\"#SHA\" class=\"headerlink\" title=\"SHA\"></a>SHA</h3><p>SHA于1993年由NIST设计，在1995年发布了SHA-1修订版，能够产生<strong>160bit</strong>的散列值。它的强抗碰撞性已被攻破，<strong>也不建议使用</strong>。</p>\n<p>SHA-2于2002年发布，它是包括SHA-256，SHA-384和SHA-512的集合，分别产生<strong>256、384和512bit</strong>的散列值。目前未被攻破。SHA-2的几种散列长度来自SHA-256和SHA-512的组合。</p>\n<p>SHA-3作为SHA-1的升级替代算法，和AES一样，由NIST公开选拔，并在2012年确定为一个叫<strong>Keccak</strong>的算法。之后会和SHA-2并存一段时间。</p>\n<h3 id=\"Keccak\"><a href=\"#Keccak\" class=\"headerlink\" title=\"Keccak\"></a>Keccak</h3><p>Keccak可以输入<strong>任意长度</strong>的数据，产生<strong>任意长度</strong>的散列值。实现上，Keccak采用海绵结构，有<strong>吸收</strong>和<strong>挤出</strong>两阶段。</p>\n<ul>\n<li>吸收阶段，按分组长度r逐段读入消息内容，和内部状态做异或运算，之后和长度为c的内部状态一起交给函数f做“搅拌”。完成一轮处理，输出作为内部状态继读入输入的消息分组。</li>\n<li>挤出阶段，内部消息r和c逐段和函数f做运算，一段段输出散列值。</li>\n</ul>\n<p>Keccak的双工结构下，输入和输出可以同时进行。Keccak内部状态由5 * 5 * z的一个三维比特数组组成，共有b个bit。Keccak的本质就是实现一个充分搅拌上述数组的函数f。SHA-3中使用的是Keccak-f[1600]函数。其中b就是内部状态的bit数。函数的每一轮包含θ、ρ、π、χ、ι5步。循环轮数为12 + 2 * log2(b &#x2F; 25)。</p>\n<ul>\n<li>θ，将不同两个column的各5个bit通过异或运算加起来，再和当前位做异或替换</li>\n<li>ρ，各比特沿z轴方向进行平移</li>\n<li>π，对一个slice上的5 * 5个比特做旋转、轮换操作</li>\n<li>χ，对一个row上的各位做某个逻辑运算</li>\n<li>ι，用某个轮常数对所有比特做异或运算，避免对称性</li>\n</ul>\n<p>Keccak采用的海绵结构和此前各散列算法使用的MD结构（循环执行压缩函数）方法截然不同，这也是它最后成为标准的一个原因。目前还未出现针对Keccak的有效攻击手段。</p>\n<h3 id=\"攻击方式\"><a href=\"#攻击方式\" class=\"headerlink\" title=\"攻击方式\"></a>攻击方式</h3><p>利用文件的冗余性，构造<strong>一大堆</strong>和想要内容一样的数据，找到和原内容散列值一样的结果。</p>\n<ul>\n<li>原像攻击，给定散列值，找到具有该散列值的任意消息</li>\n<li>第二原像攻击，给定消息1，找到和消息1有相同散列值的消息2</li>\n<li>生日攻击，攻击散列算法的“强抗碰撞性”（寻找两个具有相同散列值的消息），利用了从有N个元素的集合中依次取并放回M个元素，两次取到同一元素的概率约为根号N的特点。大大减少暴力破解需要的次数。</li>\n</ul>\n<h2 id=\"消息认证\"><a href=\"#消息认证\" class=\"headerlink\" title=\"消息认证\"></a>消息认证</h2><p>可以同时防止消息的伪装和篡改。消息认证码简称MAC（Message Authentication Code）。可以简单理解成<strong>需要密钥参与的单向散列过程</strong>。在使用时：</p>\n<ul>\n<li>发送者伴随消息发送计算出的MAC</li>\n<li>接受者对消息通过共享密钥计算出MAC值，进行对比，一致则表示认证成功</li>\n<li><strong>这个密钥不能被中间人获取！</strong></li>\n</ul>\n<p>使用消息认证码（MAC）机制的场景有：</p>\n<ul>\n<li>SWIFT</li>\n<li>IPSec</li>\n<li>SSL&#x2F;TLS</li>\n</ul>\n<p>在认证加密时，Encrypt-then-MAC表示对密文计算MAC值，从而能判断密文是由知道明文和密钥的人生成的。除了Encrypt-then-MAC外，还有Encrypt-and-MAC和MAC-then-Encrypt两种方式。</p>\n<h3 id=\"HMAC\"><a href=\"#HMAC\" class=\"headerlink\" title=\"HMAC\"></a>HMAC</h3><p>HMAC即Hash MAC，是使用单向散列函数构造认证码的方法。分为下面几步：</p>\n<ol>\n<li>在密钥后填充0到长度达到单向散列函数的分组长度</li>\n<li>填充后的密钥和ipad序列做XOR运算，ipad序列是00110110为单位循环的比特序列</li>\n<li>组合在消息<strong>头部</strong>，并计算出散列值</li>\n<li>填充后的密钥和opad做XOR运算，opad是01011100位单位循环的比特序列</li>\n<li>结果拼在散列值<strong>后面</strong></li>\n<li>根据5的结果计算最终的散列值</li>\n</ol>\n<h3 id=\"应对攻击方式\"><a href=\"#应对攻击方式\" class=\"headerlink\" title=\"应对攻击方式\"></a>应对攻击方式</h3><ul>\n<li>消息认证需要解决<strong>重放攻击</strong>的问题，即再次发送相同的消息和MAC值。可以在消息中额外带上序号、时间戳，或先发送一个nonce一次性随机数保证相同的消息也会有完全不同的MAC值。</li>\n<li><strong>密钥推测攻击</strong>，应保证不能根据MAC值推测出双方使用的密钥，必须使用安全、高强度的伪随机数生成器。</li>\n</ul>\n<p>另外，消息认证无法解决下面的问题：</p>\n<ul>\n<li>向第三方证明，密钥的共享只在通信的双方，无法证明给第三方</li>\n<li>同样的，不能防止通信的一方<strong>否认</strong>消息</li>\n</ul>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>和公钥密码<strong>相反</strong>的使用方式：</p>\n<ul>\n<li>发布者使用私钥加密消息，私钥保密</li>\n<li>使用发布者的公钥可以解密消息，公钥公开</li>\n</ul>\n<p>签名有两种方式：<strong>对消息签名</strong>和<strong>对消息的散列值签名</strong>。它们主要区别在签名的对象不同。基本过程是：</p>\n<ol>\n<li>生成公、私钥对，发送公钥给接收者</li>\n<li>使用私钥加密消息&#x2F;消息的hash值，得到签名</li>\n<li>发送消息和签名给接收者</li>\n<li>接收者使用公钥解密，对比消息&#x2F;消息hash值，验证发送者身份</li>\n</ol>\n<p>在签名中，密钥只是起着“保证消息发送者的可靠来源目的的”，被复制并不影响它发挥作用。同时，由于不知道私钥，修改消息后无法伪造消息的签名。</p>\n<p>实际应用数字签名的地方有很多：</p>\n<ul>\n<li>安全信息公告</li>\n<li>软件下载</li>\n<li>公钥证书，确保公钥的合法来源</li>\n<li>SSL&#x2F;TLS，交换公钥的过程</li>\n</ul>\n<p>数字签名基于公钥密码，因此数字签名的实现方式因采用的公钥密码而异，如RSA、ElGamal、ECDSA（椭圆曲线密码）。对数字签名的攻击可以基于单向散列函数或是公钥密码。</p>\n<ul>\n<li><strong>不要对不清楚来源的数据做数字签名</strong></li>\n<li><strong>对消息的散列值函数做数字签名</strong></li>\n</ul>\n<p>数字签名无法解决<strong>验证签名正确性的公钥被伪造</strong>的问题，因为公钥正确性也依赖于数字签名技术。这里需要<strong>证书</strong>以及<strong>公钥基础设施PKI</strong>这种社会学的基础设施辅助。</p>\n<h2 id=\"证书\"><a href=\"#证书\" class=\"headerlink\" title=\"证书\"></a>证书</h2><p>证书即<strong>公钥证书</strong>，用来验证公钥密码和数字签名的公钥，由认证机构（CA）发布，认证机构可以是政府机关、一般企业或个人。证书的发布过程包括：</p>\n<ol>\n<li>申请人生成一对密钥，并把公钥发送给CA</li>\n<li>CA验证申请人身份</li>\n<li>通过验证后，CA使用自己的私钥对公钥施加数字签名并生成证书</li>\n<li>使用申请人证书的使用者通过CA的公钥验证申请人的公钥是否合法</li>\n<li>验证通过后，使用公钥完成公钥密码或数字签名</li>\n</ol>\n<p>PKI是为了能够更有效运用公钥制定的一系列规范的总称。PKI组成要素有3个：使用PKI的用户、认证机构、仓库。</p>\n<ul>\n<li>用户，分为注册公钥的用户和使用注册公钥的用户</li>\n<li>CA，包括生成密钥、验证本人身份、验证公钥合法性、作废证书</li>\n<li>仓库，是保存证书的数据库</li>\n</ul>\n<p>其中认证机构做了以下事情：</p>\n<ul>\n<li><strong>生成密钥对</strong>，可以由用户或是CA生成，若是CA生成，需要根据规范发送私钥给用户</li>\n<li><strong>注册证书</strong>，用户根据规范申请证书，认证机构根据业务准则生成符合X.509规范的证书</li>\n<li><strong>作废证书</strong>，因为私钥丢失等原因需要作废证书时，需要认证机构制作CRL（Certificate Revocation List，证书作废清单），PKI用户总需要从CA获取最新的CRL，以确认自己拿到的公钥证书是否有效。</li>\n</ul>\n<p><strong>认证机构的证书认证</strong></p>\n<p>认证机构的公钥证书可以由其他的认证机构施加数字签名。这个关系可以嵌套很多层，比如部门认证机构、分公司认证机构、总公司认证机构。一直往上直到根CA，可以对自己的公钥做自签名。</p>\n<p>从而，在验证证书合法性上，也会出现<strong>从上至下</strong>的验证过程。</p>\n<h3 id=\"证书的攻击\"><a href=\"#证书的攻击\" class=\"headerlink\" title=\"证书的攻击\"></a>证书的攻击</h3><p>对证书的攻击即对数字签名的攻击。</p>\n<ul>\n<li>对施加数字签名前的公钥攻击</li>\n<li>注册相似人名进行攻击</li>\n<li>窃取CA的私钥</li>\n<li>伪装成CA发放证书进行攻击，认证机构本身的可信度也很重要</li>\n<li>利用发送CRL的时间间隔，窃取了使用者的私钥，当使用者联系CA发布CRL时，有一定的时间间隔</li>\n<li>同样利用CRL，使用合法私钥发送消息后，发送CRL作废自己的公钥，<strong>否认</strong>自己之前发送的消息</li>\n</ul>\n<p><strong>不可能在完全不可信的状态下创建出信任关系，除非以已经存在的信任关系为基础。</strong></p>\n<h2 id=\"密钥\"><a href=\"#密钥\" class=\"headerlink\" title=\"密钥\"></a>密钥</h2><ul>\n<li><p>密钥长度（DES：56bit，三重DES：112bit或168bit，AES：128、192、256bit</p>\n</li>\n<li><p>对称密码和公钥密码<strong>用于确保机密性</strong>，消息认证码和数字签名使用的密码<strong>用于认证，防止篡改内容和伪装身份</strong></p>\n</li>\n<li><p>只使用一次的密钥称为<strong>会话密钥</strong>，重复使用的密钥称为<strong>主密钥</strong>。</p>\n</li>\n<li><p><strong>密码学用途的随机数生成器必须为密码学用途专门设计</strong></p>\n</li>\n<li><p>定期改变会话密钥可以减少密钥泄露的损失</p>\n</li>\n<li><p>保存密钥时，使用KEK（Key Encrypting Key）方式保存密钥可以减少管理密钥的数目。</p>\n</li>\n</ul>\n<h3 id=\"Diffie-Hellman密钥交换\"><a href=\"#Diffie-Hellman密钥交换\" class=\"headerlink\" title=\"Diffie-Hellman密钥交换\"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换里，通信的双方通过交换一些可以公开的消息，就能够生成共享的密钥。</p>\n<ol>\n<li>确定一个非常大的质数P，寻找P的生成元（原根）G</li>\n<li>通信双方各自找1个1 ~ P-2的随机数A、B，生成G ^ A mod P与G ^ B mod P，发送给对方</li>\n<li>对方用收到的数字根据自己选的随机数做乘方运算，得到相等的值作为密钥</li>\n</ol>\n<p>它同样利用了离散对数问题难以快速求解的特点。这种交换方法可以做中间人攻击，可以用数字签名、证书等方式应对。</p>\n<h3 id=\"基于口令的密码（PBE）\"><a href=\"#基于口令的密码（PBE）\" class=\"headerlink\" title=\"基于口令的密码（PBE）\"></a>基于口令的密码（PBE）</h3><p>基于口令的密码避免了：记忆CEK -&gt; 记忆KEK -&gt; 记忆KEK的KEK的死循环。使用好记忆的口令配合盐生成CEK。使用过程如下：</p>\n<ol>\n<li>使用随机数生成器生成盐（随机数），加上用户口令，使用单向散列函数得到KEK</li>\n<li>使用KEK加密会话使用的CEK</li>\n<li>保存好盐以及使用KEK加密的会话秘钥</li>\n</ol>\n<ul>\n<li>盐的目的是避免字典攻击</li>\n<li>口令虽然便于生成，但是强度不高，因此需要格外地小心保管</li>\n<li>可以对KEK迭代使用单向散列函数得到最后的KEK（拉伸），这将加大攻击者的攻击负担</li>\n</ul>\n<h3 id=\"生成安全的口令\"><a href=\"#生成安全的口令\" class=\"headerlink\" title=\"生成安全的口令\"></a>生成安全的口令</h3><ul>\n<li>使用<strong>只有自己</strong>知道的信息<ul>\n<li>不包括别人见过的信息</li>\n<li>不包括可以很容易推测的信息</li>\n</ul>\n</li>\n<li>不应该重复使用口令，容易受牵连影响</li>\n<li>物理保存是可以的，但要注意安全</li>\n<li>可以使用口令生成和管理工具（比如1Password）</li>\n</ul>\n<h2 id=\"随机数生成\"><a href=\"#随机数生成\" class=\"headerlink\" title=\"随机数生成\"></a>随机数生成</h2><p>随机数生成在密码学中很常用：</p>\n<ul>\n<li>生成密钥</li>\n<li>生成分组密码的初始化向量</li>\n<li>生成CTR模式的nonce</li>\n<li>生成盐</li>\n</ul>\n<p>随机数至少需要具有下面的属性：</p>\n<ul>\n<li>随机等概性</li>\n<li>无状态，即无法从上一个推测下一个，生成序列无法重现</li>\n</ul>\n<p>由于计算机构成的抽象世界是<strong>离散的</strong>，内部状态有限，不能满足无状态的特点，因此只能称作<strong>伪随机数生成器</strong>。基于计算机硬件的随机数生成器可以认为是“真”随机数，它通常提前储存在一个随机数池中，在需要的时候直接从池中取用。伪随机数生成器根据随机的种子（seed）通过算法将内部状态转化为最终的随机数。</p>\n<ul>\n<li><strong>线性同余法</strong>，以当前随机数为内部状态（初始值为种子），(A x Rn + C) mod M，计算下一个值。其中A、C、M都需要事先选好，线性同余法生成的随机数数列具有可预测性，即不需要知道种子也可以推测下随机数值</li>\n<li><strong>单向散列函数</strong>，利用单向散列函数保护内部状态，以种子为初始值，逐次递加得到新的内部状态，再通过单向散列函数输出为随机数</li>\n<li><strong>密码法</strong>，类似单向散列函数，使用密钥加密内部状态输出也可以作为随机数，此时保护内部状态的加密算法和密钥</li>\n<li><strong>ANSI X9.17</strong>中，使用AES和三重DES作为密码算法<ol>\n<li>初始化内部状态</li>\n<li>使用当前时间生成掩码</li>\n<li>掩码和内部状态做XOR</li>\n<li>加密3的输出，作为随机数输出</li>\n<li>对加密后的输出与掩码做XOR</li>\n<li>加密5的结果作为新的内部状态</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"PGP介绍\"><a href=\"#PGP介绍\" class=\"headerlink\" title=\"PGP介绍\"></a>PGP介绍</h2><p>PGP全程Pretty Good Privacy，编写于1990年，具备现代密码软件所需的几乎所有功能。OpenPGP是一对密文和数字签名进行定义的标准规格。</p>\n<h3 id=\"加密和解密\"><a href=\"#加密和解密\" class=\"headerlink\" title=\"加密和解密\"></a>加密和解密</h3><p>加密时，使用混合密码系统的流程：</p>\n<ol>\n<li>用伪随机数生成会话密钥</li>\n<li>用<strong>接收者</strong>的公钥加密会话密钥</li>\n<li>压缩消息，并使用对称密码加密，密钥为上面生成的会话密钥</li>\n<li>将加密后的密钥和密文拼接在一起</li>\n<li>将4的结果转换为文本数据，即为报文数据</li>\n</ol>\n<p>解密时，PGP的私钥通过用户口令加密保存。在收到密文时：</p>\n<ol>\n<li>输入接收者的口令</li>\n<li>求口令的散列值，生成用户解密私钥的秘钥</li>\n<li>解密得到私钥</li>\n<li>将报文数据转换为二进制，并拆解成加密的会话密钥和压缩的密文</li>\n<li>用自己的私钥解密得到会话密钥</li>\n<li>用会话密钥解密密文</li>\n<li>解压缩明文得到原始消息</li>\n</ol>\n<h3 id=\"生成数字签名\"><a href=\"#生成数字签名\" class=\"headerlink\" title=\"生成数字签名\"></a>生成数字签名</h3><p>同样，生成数字签名时：</p>\n<ol>\n<li>输入接收者的口令</li>\n<li>求口令的散列值，生成用户解密私钥的秘钥</li>\n<li>解密得到私钥</li>\n<li>使用单向散列函数计算消息散列值</li>\n<li>对散列值签名，即使用私钥加密</li>\n<li>拼合签名和消息，进行压缩</li>\n<li><em>（可选）</em>转换二进制为文本数据，即最后的报文数据</li>\n</ol>\n<p>类似地，验证时：</p>\n<ol>\n<li>转换为二进制文件，解压缩数据</li>\n<li>分解出签名和消息两部分</li>\n<li>使用公钥解密签名，得到散列值</li>\n<li>使用单向散列函数计算消息散列值，对比3中的散列值</li>\n<li>相等即验证成功</li>\n</ol>\n<h3 id=\"生成数字签名并加密\"><a href=\"#生成数字签名并加密\" class=\"headerlink\" title=\"生成数字签名并加密\"></a>生成数字签名并加密</h3><p>实际情况下，我们往往需要使用加密算法加密数字签名中的原消息。实现步骤是上两节的组合。即先进行数字签名，再对签名结果加密。</p>\n<p>验证过程是相反的，先解密密文得到签名结果，再验证数字签名。</p>\n<h3 id=\"信任网\"><a href=\"#信任网\" class=\"headerlink\" title=\"信任网\"></a>信任网</h3><p>PGP确认公钥合法性的方法不依赖于认证机构颁发证书，而是采用所有者信任级别构成信任网（也叫信任圈、朋友圈）的方式，让用户自己决定该信任谁。建立信任有三种方式：</p>\n<ul>\n<li>通过自己的签名来确认。用户在通过其他方式（比如线下）确认公钥可信任后，对该公钥加上自己的数字签名。由于PGP中，使用者本人的公钥是绝对信任，被施加签名的公钥因此可信任。<em>注意：这并不代表被施加签名的公钥所有者被<strong>完全</strong>信任</em></li>\n<li>通过自己完全信任的数字签名进行确认。即<strong>完全信任</strong>某个公钥进行的数字签名，用户可对当前信任的每个公钥所有者设置信任级别，级别为<strong>完全信任</strong>时，所有者公钥施加签名的公钥也会被信任。</li>\n<li>通过有限信任的多个数字签名进行确认。在设置信任级别为<strong>有限信任</strong>时，有限信任的公钥<strong>都</strong>施加数字签名后，新的公钥才会被信任。</li>\n</ul>\n<p>通过上面三种方式，PGP使用者可以构建起自己的信任网，从而根据自己的决定信任某个公钥。</p>\n<h2 id=\"SSL-x2F-TLS\"><a href=\"#SSL-x2F-TLS\" class=\"headerlink\" title=\"SSL&#x2F;TLS\"></a>SSL&#x2F;TLS</h2><p>TLS是SSL的后续版本，但在大多数情况下，可以统一写成SSL&#x2F;TLS。<strong>SSL&#x2F;TLS可以承载应用层协议，保证应用层传输的安全性，HTTP就是其中一种</strong>。其余SSL&#x2F;TLS可以承载的应用层协议还包括SMTP、POP3等等。</p>\n<p>SSL于1994年在网景公司开发，在1995年发布了SSL3.0版本，后被发现会导致POODLE攻击。TLS是IETF在1999年作为SSL3.1发布。2006年发布TLS1.1，之后又发布了TLS1.2。</p>\n<p>HTTPS中SSL&#x2F;TLS要保证以下三点：</p>\n<ul>\n<li>保证消息传输中<strong>不被窃听</strong> -&gt; <strong>对称密码</strong>加密消息，<strong>公钥密码</strong>加密对称密码的密钥</li>\n<li>保证消息传输中<strong>不被篡改</strong> -&gt; <strong>消息认证</strong>码</li>\n<li>保证消息传输<strong>双方的合法性</strong> -&gt; <strong>数字签名</strong>生成证书</li>\n</ul>\n<h3 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h3><p>下面的流程以TLS1.2为例。TLS协议分为两层：</p>\n<ul>\n<li><strong>TLS握手协议</strong>，位于上层，处理除加密的部分。可以进一步分为：<ul>\n<li><strong>握手协议</strong>，负责在客户端和服务器间协商密码算法和共享密钥</li>\n<li><strong>密码规格变更协议</strong>，向通信对象传达变更密码方式</li>\n<li><strong>警告协议</strong>，在发生错误时将错误传达给对方</li>\n<li><strong>应用数据协议</strong>，将TLS上承载的应用数据传达给通信对象</li>\n</ul>\n</li>\n<li><strong>TLS记录协议</strong>，位于底层，处理加密的部分。使用了对称密码和消息认证码，但具体的算法和密钥需要通信双方具体协商</li>\n</ul>\n<h3 id=\"TLS记录协议\"><a href=\"#TLS记录协议\" class=\"headerlink\" title=\"TLS记录协议\"></a>TLS记录协议</h3><p>记录协议负责数据的压缩、加密、数据认证，工作方式如下：</p>\n<ol>\n<li>分割消息为较小的片段，再分段压缩，<strong>压缩方式需要协商决定</strong></li>\n<li>对压缩过的消息进行消息认证，加上MAC值。为了避免重放攻击，在计算MAC值时，加上了片段的编号。其中的<strong>单向散列函数的算法、使用的密钥都需要协商确定</strong></li>\n<li>把MAC值和压缩过的消息片段组合在一起，使用对称密码加密。迭代模式使用CBC模式，CBC模式的初始化向量通过主密码生成。<strong>对称密码的算法、密钥则需要协商决定</strong></li>\n<li>上述经过加密的数据，再加上<strong>数据类型、版本号、压缩后的长度</strong>，构成最终的报文数据。数据类型就是之前提到的TLS握手协议的4类子协议</li>\n</ol>\n<h3 id=\"握手协议\"><a href=\"#握手协议\" class=\"headerlink\" title=\"握手协议\"></a>握手协议</h3><p>握手协议负责生成对称密码中的共享密钥以及交换证书。因为握手的整个过程都是明文进行的，因此需要使用公钥密码或是Diffie-Hellman密钥交换。整个握手协议有下面几步：</p>\n<ol>\n<li><strong>ClientHello</strong>，客户端发送一些信息给服务器，便于协商算法和密钥</li>\n</ol>\n<ul>\n<li>可用版本号，即支持的SSL&#x2F;TLS版本号</li>\n<li>客户端生成的随机数，在后面的步骤会用到</li>\n<li>会话ID，在需要重新使用以前的会话时用到</li>\n<li>客户端可用的密码套件清单</li>\n<li>客户端可用的压缩方式清单</li>\n<li>当前时间</li>\n</ul>\n<ol start=\"2\">\n<li><strong>ServerHello</strong>，服务器根据客户端传来的信息，选择合适的算法和密码套件，返回的消息中带有下面几条</li>\n</ol>\n<ul>\n<li>使用的版本号</li>\n<li>服务端生成的随机数，后面步骤会用到</li>\n<li>会话ID，作用同上</li>\n<li>使用的密码套件</li>\n<li>使用的压缩方式</li>\n<li>当前时间</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Certificate</strong>，<strong>非匿名通信</strong>时，服务器发送自己的证书，以及对服务器证书签名的CA的证书</li>\n<li><strong>ServerKeyExchange</strong>，当Certificate消息不足时，服务器通过此消息传递额外信息</li>\n<li><strong>CertificateRequest</strong>，需要进行<strong>客户端认证</strong>时，服务端发送此消息，并带上服务器能理解的证书类型、CA名称清单。</li>\n<li><strong>ServerHelloDone</strong>，服务器发送此消息结束服务器的返回</li>\n<li><strong>Certificate</strong>，作为CertificateRequest的回应，客户端发送自己的证书，交给服务器验证</li>\n<li><strong>ClientKeyExchange</strong>，密码套件包含RSA时，会发送<strong>经过服务器公钥加密的预备主密码</strong>；密码套件包含Diffie-Hellman密钥交换时，会发送Diffie-Hellman密钥交换中的公开值。<strong>预备主密码（pre-master secret）</strong>是客户端生成的随机数，之后会用做生成主密码的种子。根据预备主密码，通信双方计算出<strong>相同的主密码</strong>。主密码会用做以下用途：</li>\n</ol>\n<ul>\n<li>对称密码的密钥</li>\n<li>消息认证码的密钥</li>\n<li>CBC模式中的初始化向量</li>\n</ul>\n<ol start=\"9\">\n<li><strong>CertificateVerify</strong>，在服务器发送CertificateRequest时，通过此消息发送客户端使用自己私钥签名的主密码和握手协议传输消息的散列值。证明自己是客户端证书的持有人。</li>\n<li><strong>ChangeCipherSpec</strong>，客户端发送，表示切换密码开始，实际上是密码规格变更协议的一类报文</li>\n<li><strong>Finished</strong>，握手结束，此时已使用切换后的密码套件来加密发送。</li>\n<li><strong>ChangeCipherSpec</strong>，<strong>Finished</strong>。来自服务器，作用同上。</li>\n</ol>\n<p>通过上面的步骤，双方达成了下面的目标：</p>\n<ul>\n<li>客户端获得了服务器的公钥，完成了服务器认证</li>\n<li>服务器获得了客户端公钥，完成了客户端认证（如果需要的话）</li>\n<li>生成了对称密码的密钥</li>\n<li>生成了消息认证码中的共享密钥</li>\n</ul>\n<h3 id=\"密码规格变更协议\"><a href=\"#密码规格变更协议\" class=\"headerlink\" title=\"密码规格变更协议\"></a>密码规格变更协议</h3><p>用于在一开始从明文通信切换到使用密码套件沟通。</p>\n<h3 id=\"警告协议\"><a href=\"#警告协议\" class=\"headerlink\" title=\"警告协议\"></a>警告协议</h3><p>用在握手协议异常、消息认证码错误、无法解压数据等异常情况。</p>\n<h3 id=\"应用数据协议\"><a href=\"#应用数据协议\" class=\"headerlink\" title=\"应用数据协议\"></a>应用数据协议</h3><p>通信对象间传递应用数据。</p>\n<h3 id=\"主密码\"><a href=\"#主密码\" class=\"headerlink\" title=\"主密码\"></a>主密码</h3><p>主密码根据预备主密码（pre-master secret）或Diffie-Hellman密钥交换的公开值生成。生成的主密码用于生成<strong>对称密码的密钥、消息认证码的密钥、CBC模式的初始化向量</strong>。</p>\n<h3 id=\"对SSL-x2F-TLS的攻击\"><a href=\"#对SSL-x2F-TLS的攻击\" class=\"headerlink\" title=\"对SSL&#x2F;TLS的攻击\"></a>对SSL&#x2F;TLS的攻击</h3><ul>\n<li>SSL&#x2F;TLS框架性的特点让它不依赖于某个特定的密码技术，因此对特定密码技术的攻击对SSL&#x2F;TLS本身影响不大</li>\n<li>心脏出血漏洞，发现于2014年，利用TLS心跳拓展对请求的数据大小没有检查，可以获取内存中与请求无关的信息。是OpenSSL实现的漏洞。</li>\n<li>POODLE攻击，利用CBC中的填充提示攻击，发现于2014年SSL3.0中。</li>\n<li>FREAK攻击，可以在密码套件协商时，利用中间人攻击，强制使用强度很低的RSA Export Suites。从而在加密后，暴力破解明文。</li>\n<li>对伪随机数生成器的攻击</li>\n<li>利用之前提过的CRL</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>密码技术因为人类的不完美而必定不会完美。</p>\n<ul>\n<li><strong>对称密码</strong>，使用相同密钥加密、解密，保证消息<strong>机密性</strong>。目前主要使用AES。</li>\n<li><strong>公钥密码</strong>，使用不同密钥加密、解密，作用同上。使用最广泛的是RSA，还有相关的Diffie-Hellman密钥交换</li>\n<li><strong>单向散列函数</strong>，将消息转为固定长度散列值的技术，保证消息<strong>完整性</strong>，目前使用SHA2和SHA3（Keccak）</li>\n<li><strong>消息认证码</strong>，结合单向散列函数和对称密码，保证消息<strong>完整性</strong>并<strong>认证消息</strong>，但无法防御<strong>否认</strong>。目前主要使用HMAC</li>\n<li><strong>数字签名</strong>，结合单向散列函数和公钥秘钥，保证<strong>完整性</strong>，<strong>不可否认性</strong>和<strong>认证消息</strong>。是公钥证书采用的技术</li>\n<li><strong>伪随机数生成器</strong>，配合上述技术使用，需要保证<strong>不可预测性</strong>和<strong>不可重现性</strong></li>\n</ul>\n<p>密码技术从某种角度看是一种压缩技术：</p>\n<ul>\n<li>密钥是机密性的压缩</li>\n<li>散列值是消息完整性的压缩</li>\n<li>认证值时认证的压缩</li>\n<li>随机数种子是不可预测性的压缩</li>\n</ul>\n<h3 id=\"比特币\"><a href=\"#比特币\" class=\"headerlink\" title=\"比特币\"></a>比特币</h3><p>比特币来自于Satoshi Nakamoto（中本聪，化名）的一篇论文，并于2009年开始实际运用。比特币是一种<strong>基于P2P网络的支付结算系统</strong>。用户通过它进行进行价值转移。</p>\n<ul>\n<li><strong>地址</strong>，将公钥使用散列函数求散列值得到，地址都以1开头，剩下内容 不包含O，0,1和I。</li>\n<li><strong>钱包</strong>，即比特币客户端，可以生成密钥对，公钥用于收款，密钥用于付款</li>\n<li><strong>区块链</strong>，保存了比特币所有交易记录的账簿，若干交易组成一个区块，在区块头有所有交易的散列值，以及上一个区块的散列值，有交易添加时会触发区块头的散列值变化，并链式传递下去</li>\n<li><strong>交易</strong>，收、付款方各自生成密钥对，付款方创建交易“地址A向地址B转账x BTC”，<strong>并用自己的私钥签署数字签名</strong>，之后广播至P2P网络中，完成交易。比特币使用的数字签名基于椭圆曲线DSA，方程为x^2 &#x3D; y^3 + 7</li>\n<li><strong>挖矿</strong>，向区块链中添加新区块的行为被称为挖矿，第一个挖矿成功的矿工会获得挖矿奖励和区块所有交易的手续费。为了证明自己确实完成了规定工作，矿工需要进行<strong>工作量证明</strong>（PoW），即生成的区块头中，前一区块头的散列值必须以若干位的0开头，这个工作需要投入大量的计算资源。区块大约每10分钟添加一个，为了避免通货膨胀，所需的0的个数会不断调整。<ul>\n<li>根据协议规定，挖矿奖励每4年减少一半</li>\n<li>当区块链上同时出现分支时，P2P网络会选择计算量大的分支进行工作</li>\n</ul>\n</li>\n<li>比特币的匿名性只限于交易地址</li>\n</ul>\n<h2 id=\"附录：椭圆曲线\"><a href=\"#附录：椭圆曲线\" class=\"headerlink\" title=\"附录：椭圆曲线\"></a>附录：椭圆曲线</h2><ul>\n<li>椭圆曲线（EC）源自于求椭圆弧长的椭圆积分的反函数。</li>\n<li>定义椭圆曲线上的加法运算</li>\n<li>椭圆曲线上的离散对数（ECDLP） - 已知点G和点xG，求整数x</li>\n<li>有限域上的离散对数，对点进行模运算</li>\n<li>椭圆曲线Diffie-Hellman密钥交换</li>\n<li>椭圆曲线ElGamal密码</li>\n<li>椭圆曲线DSA（ECDSA）</li>\n</ul>\n",
            "tags": [
                "算法",
                "密码",
                "密钥"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2016/05/16/binary-tree/",
            "url": "http://shenlvmeng.github.com/blog/2016/05/16/binary-tree/",
            "title": "优化二叉搜索树的科普",
            "date_published": "2016-05-16T04:36:51.000Z",
            "content_html": "<p>本文目的在日后再看到这些名词时能有扫盲的作用，所以未做深入探讨。</p>\n<p>二叉搜索树的查询时间复杂度为O(h)，但是h的大小和数据密切相关，随机构建二叉搜索树可以保证期望高度h为O(lgn)，但是我们并不总能随机地构造二叉搜索树。所以就有二叉搜索树的变体来保证基本操作具有好的最坏情况性能，如AVL树，红黑树，treap树，splay树等。它们在二叉搜索树的基础上增加了额外的约束，操作更加复杂，但是保证最坏情况的动态集合操作时间复杂度为O(lgn)。下面按照时间介绍之。</p>\n<h2 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h2><p>AVL树是最早发明的自平衡二叉搜索树，查找、插入、删除在平均和最坏情况下都是O(lgn)，自平衡是通过插入和删除时一次或多次树旋转来完成的。节点的平衡因子是左子树减去右子树的高度，1、0、-1被认为是平衡的，-2或2被认为是不平衡的，需要重新平衡树。平衡因子储存在节点中，或是通过计算算出。</p>\n<p>根据不平衡的情况，AVL分成左左、右右、左右、右左四种情况，分别需要1、1、2、2次旋转调整。图略。</p>\n<p>由于AVL是高度平衡树，所以节点插入、删除后，重新平衡需要的旋转次数较多，但是因此带来的搜索效率更高。</p>\n<h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><p>最常见的平衡二叉树，统计性能最好的二叉搜索树。红黑树是满足下列性质的二叉搜索树：</p>\n<ul>\n<li>每个节点都是黑色或是红色</li>\n<li>根节点是黑色</li>\n<li>每个叶节点都是黑色</li>\n<li>如果一个节点是红色，那么它的两个子节点都是黑色</li>\n<li>对于每个节点，从它到其所有子孙叶节点的路径包含的黑色节点数目相同</li>\n</ul>\n<p>由于没有AVL树对平衡的高度要求，红黑树在节点插入、删除时，只需最多3次旋转操作即可完成。虽然牺牲了查找效率，但是在经常改动的动态数据集合中，红黑树的性能要更好。可以说红黑树在复杂度和旋转次数上有比较好的折中，因此常用作数据结构的设计。</p>\n<h2 id=\"Treap树\"><a href=\"#Treap树\" class=\"headerlink\" title=\"Treap树\"></a>Treap树</h2><p>Treap树得名于搜索树trea和堆reap，是有一个附加域满足堆特征的二叉搜索树，结构相当于随机插入数据的二叉搜索树，相较其他平衡二叉树，特点是实现简单，且能基本实现随机平衡。</p>\n<p>在构成Treap树时，还需要满足堆特征，在插入、删除维护堆性质时，只需要两种旋转，相比Splay，编程复杂度要更小。性能在平衡二叉树和二叉搜索树之间。</p>\n<h2 id=\"Splay树\"><a href=\"#Splay树\" class=\"headerlink\" title=\"Splay树\"></a>Splay树</h2><p>Splay树又叫伸展树，发明于1985年。它是一种自调整形式的二叉搜索树，利用了频繁查找的数据集有限，在二叉搜索树的每次搜索后，将搜索条目通过一系列旋转搬移到离树根更近的地方。它的优势在于不需要记录平衡树的冗余信息，且编程复杂度小很多。</p>\n<p>Splay的操作为旋转，分单旋转、一字型、之字形几种。</p>\n<p>这些树的编码都较为复杂，这里略去。</p>\n",
            "tags": [
                "二叉搜索树",
                "算法"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2016/02/27/vnm-test-learning/",
            "url": "http://shenlvmeng.github.com/blog/2016/02/27/vnm-test-learning/",
            "title": "vnm test学习",
            "date_published": "2016-02-27T13:51:39.000Z",
            "content_html": "<p>师兄给了一个虚网映射的仿真（cpp），和之前的embed-detail的C语言仿真工具很像，经过一周左右的学习，挖掘出了其中虚网映射部分的内容，在此整理，以作日后学习。鉴于之前embed-detail的学习总结很繁琐，这里的总结只做精要的介绍。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>这一部分在Utility.h中完成，是对映射种种数据容器的整理。</p>\n<h3 id=\"节点：\"><a href=\"#节点：\" class=\"headerlink\" title=\"节点：\"></a>节点：</h3><p>编号，CPU，带宽和，优先度</p>\n<h3 id=\"最短路：\"><a href=\"#最短路：\" class=\"headerlink\" title=\"最短路：\"></a>最短路：</h3><p>跳数，带宽，路径列表，下一跳</p>\n<h3 id=\"映射结果（单节点）：\"><a href=\"#映射结果（单节点）：\" class=\"headerlink\" title=\"映射结果（单节点）：\"></a>映射结果（单节点）：</h3><p>物理节点对象，虚拟节点编号，所属根节点，到根节点跳数，Node_list中序号，Node_list总数</p>\n<h3 id=\"（类）物理拓扑：\"><a href=\"#（类）物理拓扑：\" class=\"headerlink\" title=\"（类）物理拓扑：\"></a>（类）物理拓扑：</h3><p>节点总数，边总数，资源，节点资源，边资源；</p>\n<p>节点群（一维向量），边群（二维向量），最短路群（二维结构向量）；</p>\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>初始化，</li>\n<li>节点排序算法，</li>\n<li>Floyd算法,</li>\n<li>找到节点序号对应的下标，</li>\n<li>计算网络资源</li>\n</ul>\n<h3 id=\"（类）虚拟拓扑（继承物理拓扑）：\"><a href=\"#（类）虚拟拓扑（继承物理拓扑）：\" class=\"headerlink\" title=\"（类）虚拟拓扑（继承物理拓扑）：\"></a>（类）虚拟拓扑（继承物理拓扑）：</h3><p>&#x2F;&#x2F;同物理拓扑</p>\n<p>允许最大跳数，分割率，拓扑类型，起始时间，映射时间，存活时间，消耗，节点消耗，链路消耗，收入，收入支出比，是否匹配成功，是否起请求截止，是否delay过，是否失败</p>\n<p>满足约束条件的节点群（二维向量），结果群（结果向量），最短路群（二维链表向量）</p>\n<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>读入拓扑，</li>\n<li>初始化，</li>\n<li>计算最短路径和，</li>\n<li>查找结点是否已经映射，</li>\n<li>匹配节点（包含匹配边），</li>\n<li>匹配边，</li>\n<li>匹配过程（包含匹配节点），</li>\n<li>分配或释放资源（匹配过程中完成），</li>\n<li>打印结果，</li>\n<li>计算收入支出，</li>\n<li>计算收入，</li>\n<li>释放虚网的所有资源</li>\n</ul>\n<h2 id=\"核心方法分析\"><a href=\"#核心方法分析\" class=\"headerlink\" title=\"核心方法分析\"></a>核心方法分析</h2><p>这一部分在Utility.cpp中完成，是对映射种种方法的实现。</p>\n<h3 id=\"（物理网络）\"><a href=\"#（物理网络）\" class=\"headerlink\" title=\"（物理网络）\"></a>（物理网络）</h3><p>1. 初始化：开辟最短路群空间，计算链路CPU&#x2F;带宽和&#x2F;PR值</p>\n<p>2. 计算资源：节点，链路资源相加。</p>\n<h3 id=\"（虚拟网络）\"><a href=\"#（虚拟网络）\" class=\"headerlink\" title=\"（虚拟网络）\"></a>（虚拟网络）</h3><p>1. 读入文件：读入节点数，链路数，开始时间，存活时间等。</p>\n<p>2. 初始化：填充Node_list</p>\n<p>3. 查找结点是否已被映射：for 循环遍历暴力查找</p>\n<p>4. 匹配节点：读入物理网络和参照物理网络，当前结点所属根节点，已映射节点数。</p>\n<p>（1）打印</p>\n<p>（2）从可行最短跳（虚拟网络中的跳数）到最大允许跳开始循环</p>\n<p>（2.1）从可行节点（Node_list）中查找满足CPU要求的节点</p>\n<p>（2.2）查找匹配边（Match_Edge），若有打印信息并返回</p>\n<p>（3）打印失败信息返回</p>\n<p>5. 匹配链路：读入物理网络预期参照，当前结点编号和下标，已映射节点数。</p>\n<p>（1）循环寻找所有与该节点关联的节点</p>\n<p>（1.1）若有关联，清空并循环更新最短路向量</p>\n<p>（1.2）循环检测带宽是否满足要求</p>\n<p>（2）循环还原减少的带宽资源</p>\n<p>（3）返回成功标记</p>\n<p>6. 匹配：读入物理拓扑，完成一个虚网的匹配</p>\n<p>（1）建立物理拓扑最短路矩阵</p>\n<p>（2）初始化最短路群，root, chosen_num（已选中节点数）</p>\n<p>（3）初始化根节点result类实例，若无备选节点，返回 0</p>\n<p>（4）循环寻找可行的根节点直到遍历完成</p>\n<p>（4.1）以当前父节点为基础开始匹配子节点，循环</p>\n<p>（4.1.1）循环寻找父节点的关联的子节点</p>\n<p>（4.1.1.1）若某节点无匹配物理节点，循环释放资源，返回 0</p>\n<p>（4.1.1.2）若找到，更新result群向量，调用匹配节点，找到对应物理节点序号</p>\n<p>（4.1.1.2.1）若成功返回，继续更新result，最短路矩阵，更新底层资源</p>\n<p>（4.1.1.2.2）若不成功，回退chosen_num，释放资源，更新root，最短路</p>\n<p>（4.1.2）若未回退到根节点，不用调整根节点，继续从下个父节点开始匹配，直到匹配完成</p>\n<p>（4.2）若匹配未完成，释放根节点和其余资源</p>\n<p>（5）若匹配成功计算收入支出返回回退次数，否则释放资源，返回 0；</p>\n<p>7. 资源管理：通过标记值区分占用或是释放，循环更新节点和链路资源</p>\n<p>8. 打印，计算收入支出</p>\n<p>9. 释放虚网资源：循环释放，返回释放资源值</p>\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><p>这一部分在VNM.cpp中完成，是时间窗模型下虚网映射的实现。步骤如下：</p>\n<p>1. 初始化临时变量，</p>\n<p>2. 从文件中读入底层物理网络，虚网请求</p>\n<p>3.  打印初始信息，计算物理资源</p>\n<p>4. 循环到所有请求都被处理完成或是有finish标记</p>\n<p>4.1 循环计算该窗口内待映射请求数</p>\n<p>4.2 循环这些请求</p>\n<p>4.2.1 挑出未延迟且未成功的</p>\n<p>4.2.1.1 初始化虚网，打印信息</p>\n<p>4.2.1.2 开始匹配，计算时间</p>\n<p>4.2.1.3 计算收入，更改标记为映射完成或延迟</p>\n<p>4.2.1.4 计算当前物理资源，写入到文件</p>\n<p>4.2.2 挑出匹配成功且到期的请求</p>\n<p>4.2.2.1 更新它们的R&#x2F;S和完成数目</p>\n<p>4.2.2.2 释放它们的资源</p>\n<p>4.2.3 挑出delay过久的请求，置为失败，更新资源和计数器</p>\n<p>4.3 计算该时间窗内的支出，收入等数据，更新finish和计数器</p>\n<p>4.4 打印该时间窗测试数据到文件</p>\n<p>4.5 更新时间窗时间</p>\n<p>5. 关闭文件，打印当前时间</p>\n",
            "tags": [
                "算法",
                "C",
                "虚网映射"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2015/01/31/embed-c/",
            "url": "http://shenlvmeng.github.com/blog/2015/01/31/embed-c/",
            "title": "虚网映射仿真包 embed.c 代码分析",
            "date_published": "2015-01-31T05:03:23.000Z",
            "content_html": "<p>此次论文仿真中，需要对虚网映射的过程进行改进。在原先只考量CPU和带宽的基础上为链路增加VLAN属性，并在映射过程中分配VLAN、检测VLAN是否用尽。经过三天的阅读，这里把仿真包里embed.c这个主要文件的各函数分析在下面，方便日后修改。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>数据结构存储在embed.h中。</p>\n<ul>\n<li>struct_link 描述物理链路，有from、to、带宽三个属性</li>\n<li>request 虚网请求，有split, node, links, CPU[], bw等多个属性。</li>\n<li>substrate_network 底层物理网络，有nodes, struct_link links等属性</li>\n<li>s2v_node 被映射了虚网的物理节点的状态</li>\n<li>s2v_link 被映射了虚网的物理链路的状态</li>\n<li>path 逻辑链路映射成的多段物理链路</li>\n<li>req2sub 描述虚网映射的实时映射关系</li>\n<li>shortest_path 最短路径，通过Floyd算出（用于链路映射）</li>\n<li>bneck 瓶颈节点</li>\n</ul>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><h3 id=\"节点映射\"><a href=\"#节点映射\" class=\"headerlink\" title=\"节点映射\"></a>节点映射</h3><h4 id=\"find-proper-node\"><a href=\"#find-proper-node\" class=\"headerlink\" title=\"find_proper_node\"></a>find_proper_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找rest_cou最适合（rest_cpu和request CPU最近，且大于它）当前虚节点的节点。</p>\n<h4 id=\"find-MinNeighborResource-node\"><a href=\"#find-MinNeighborResource-node\" class=\"headerlink\" title=\"find_MinNeighborResource_node\"></a>find_MinNeighborResource_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找rest_cpu满足要求，且自资源最不丰富的物理节点</p>\n<p>衡量标准：节点rest_cpu * sum(rest_bw)</p>\n<h4 id=\"find-MaxNeighborResource-node\"><a href=\"#find-MaxNeighborResource-node\" class=\"headerlink\" title=\"find_MaxNeighborResource_node\"></a>find_MaxNeighborResource_node</h4><p><strong>目标</strong>：在当前底层物理网络中寻找除了exclude节点外的rest_cpu满足要求的，且自资源最丰富的物理</p>\n<p>节点</p>\n<p>衡量标准：同上</p>\n<h4 id=\"find-available-node\"><a href=\"#find-available-node\" class=\"headerlink\" title=\"find_available_node\"></a>find_available_node</h4><p><strong>目标</strong>：在当前底层物理网络中，从一随机起点出发，寻找第一个rest_cpu满足要求的物理节点</p>\n<h4 id=\"map-node-greedy\"><a href=\"#map-node-greedy\" class=\"headerlink\" title=\"map_node_greedy\"></a>map_node_greedy</h4><p><strong>目标</strong>：在当前物理网络中，为特定index的虚网映射进行节点映射，哟西按占用资源最丰富的节点，成功则更新物理网络的状态（s2v_node, s2v_link），失败则对已映射的节点进行拆除。</p>\n<h4 id=\"map-node-star\"><a href=\"#map-node-star\" class=\"headerlink\" title=\"map_node_star\"></a>map_node_star</h4><p><strong>目标</strong>：在当前物理网络中，为第一个请求节点分配资源最丰富的节点，其余逻辑节点随机分配，成功则更新物理网络的状态（s2v_node, s2v_link），失败则对已映射的节点进行拆除。</p>\n<h3 id=\"链路映射\"><a href=\"#链路映射\" class=\"headerlink\" title=\"链路映射\"></a>链路映射</h3><p>由于链路映射算法大多很复杂，这里将算法流程也一并列在下方。</p>\n<h4 id=\"unsplittable-flow\"><a href=\"#unsplittable-flow\" class=\"headerlink\" title=\"unsplittable_flow\"></a>unsplittable_flow</h4><p><strong>目标</strong>：为不可分割流进行链路映射</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0  初始化变量，位置分配内存空间</span><br><span class=\"line\">1  死循环</span><br><span class=\"line\">1.1  找到请求中状态满足要求（完成了节点映射）且收益最大的请求，直到状态全部更新</span><br><span class=\"line\">1.1.1    存储id,改变其标志位</span><br><span class=\"line\">1.2  判断该请求状态，与是否可分割</span><br><span class=\"line\">1.2.1    找到该请求的所有逻辑链路</span><br><span class=\"line\">1.2.1.1      找到它们的起始、终结物理节点</span><br><span class=\"line\">1.2.1.2      判断它们是否已找到之间的最短路，否则继续寻找</span><br><span class=\"line\">1.2.1.2.1        Floyd矩阵找下一跳</span><br><span class=\"line\">1.2.1.2.2        下一跳若不可达，break</span><br><span class=\"line\">1.2.1.2.3        寻找有没有实体链路对应Floyd的下一跳</span><br><span class=\"line\">1.2.1.2.4        如果没有，或者有但是rest_bw不够，break</span><br><span class=\"line\">1.2.1.2.5        吧路过链路的可用带宽减少，将当前链路存入到路径数组中</span><br><span class=\"line\">1.2.1.3      如果上一步失败，给sub1(底层物理网络)划分内存空间，在sub1里删除上步出现问题的链路</span><br><span class=\"line\">1.2.1.4      在sub1里算出Floyd矩阵，并存储在临时变量里</span><br><span class=\"line\">1.2.1.4.1        一个类似于1.2.1.2的循环</span><br><span class=\"line\">1.2.1.4.1.1          若还不行，break到1.2.1.4.2；若可以减少可用带宽，存入到路径</span><br><span class=\"line\">1.2.1.4.2        返回错误物理链路、虚拟链路、虚网请求id</span><br><span class=\"line\">1.2.1.5      存储当前算出的路径，与逻辑链路一一对应</span><br><span class=\"line\">2  将状态标志位全部清零</span><br><span class=\"line\">3  死循环</span><br><span class=\"line\">3.1    找到请求中状态满足要求（完成了节点映射）且收益最大的请求，直到状态全部更新</span><br><span class=\"line\">3.1.1      存储id, 改变标志位</span><br><span class=\"line\">3.2    判断该请求状态，与是否可分割</span><br><span class=\"line\">3.2.1      更新时间与链路状态值</span><br><span class=\"line\">3.2.2      为请求内的spath赋值(len, bw)</span><br><span class=\"line\">3.2.2.1        为spath内的各段物理链路赋值</span><br><span class=\"line\">3.2.2.2        更新物理网络链路状态</span><br><span class=\"line\">4  释放临时变量空间</span><br><span class=\"line\">5  返回-1(虚网请求成功标志)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"multicommodity-flow\"><a href=\"#multicommodity-flow\" class=\"headerlink\" title=\"multicommodity_flow\"></a>multicommodity_flow</h4><p><strong>目标</strong>：打印基本信息</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  打开测试文件</span><br><span class=\"line\">2  指定范围内检测有误状态符合条件的请求，</span><br><span class=\"line\">3  若没有，则返回-2并关闭文件</span><br><span class=\"line\">4  打印出满足要求的链路总数</span><br><span class=\"line\">5  打印基本信息到文件</span><br><span class=\"line\">6  打印ARC COSTS到文件</span><br><span class=\"line\">7  打印ARC CAPACITIES到文件</span><br><span class=\"line\">8  打印NODE INJECTIONS到文件</span><br><span class=\"line\">9  打印ARC MUTUAL到文件</span><br><span class=\"line\">10 打印NETWORK TOPOLOGY到文件</span><br><span class=\"line\">11 打印LOWER AND UPPER BOUNDS到文件</span><br><span class=\"line\">12 打印SIDE CONSTRAINTS到文件</span><br><span class=\"line\">13 关闭文件对象</span><br><span class=\"line\">14 运行lintest文件</span><br><span class=\"line\">15 返回 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检测\"><a href=\"#检测\" class=\"headerlink\" title=\"检测\"></a>检测</h3><h4 id=\"check-flow\"><a href=\"#check-flow\" class=\"headerlink\" title=\"check_flow\"></a>check_flow</h4><p><strong>目标</strong>：检查映射情况</p>\n<p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  打开test文件，初始化变量</span><br><span class=\"line\">2  查找STATUS字段，停在此处</span><br><span class=\"line\">3  若不可执行，且阶段 0，则关闭文件，返回 -3</span><br><span class=\"line\">4  若不可执行，且阶段 1，则继续</span><br><span class=\"line\">4.1    查找VARIABLE字段</span><br><span class=\"line\">4.2    在每条链路上查找已使用过的情况，为s2v_link赋值</span><br><span class=\"line\">4.3    查找SIDE CONSTRAINTS字段</span><br><span class=\"line\">4.3.1      找到过载最严重的链路</span><br><span class=\"line\">4.3.2      找到该链路占用最多贷款的租户ID，及其占用带宽，并确定请求ID和虚拟链路ID</span><br><span class=\"line\">5  其余情况，查找OPTIMAL字段，若找到，则继续</span><br><span class=\"line\">5.1    查找VARAIABLE字段</span><br><span class=\"line\">5.2    在每条链路上查找已使用过的情况，为s2v_link赋值</span><br><span class=\"line\">5.3    为v2s赋值</span><br><span class=\"line\">6  关闭文件，释放内存</span><br><span class=\"line\">7 打印租户ID或-1（成功标志）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"资源分配\"><a href=\"#资源分配\" class=\"headerlink\" title=\"资源分配\"></a>资源分配</h3><p>同样，算法复杂，将具体流程列在下面</p>\n<h4 id=\"allocate\"><a href=\"#allocate\" class=\"headerlink\" title=\"allocate\"></a>allocate</h4><p><strong>目标</strong>：整合节点、链路映射完成虚网映射的核心部分</p>\n<p><strong>算法流程：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  为变量s2v_node,s2v_link,v2s划分空间，赋初值</span><br><span class=\"line\">2  为节点数组req_count清零</span><br><span class=\"line\">3  将请求按收入大小排序，找出最大收入者，为它进行节点映射，知道请求的节点映射全部完成</span><br><span class=\"line\">4  若全部未完成节点映射，返回-1</span><br><span class=\"line\">5  初始化链路映射相关变量</span><br><span class=\"line\">6  找到瓶颈节点，并进行链路映射（尝试）</span><br><span class=\"line\">7  若映射成功或链路可分割，用新方法找到瓶颈节点</span><br><span class=\"line\">8  循环：</span><br><span class=\"line\">8.1    如果上一步尝试成功，为s2v_node, s2v_link赋值，跳出循环</span><br><span class=\"line\">8.2    否则，计算这一批次的cost之和</span><br><span class=\"line\">8.3    找出剩余资源最少的节点ID，及其剩余资源</span><br><span class=\"line\">8.4    随机从上面移除一个虚拟节点</span><br><span class=\"line\">8.5    找到这个节点以外资源最丰富的节点，成功则映射到这个新节点；否则映射请求失败</span><br><span class=\"line\">8.6    检查有误未完成链路请求的虚网请求，无则跳出循环</span><br><span class=\"line\">8.7    若时间正忙而无法映射，try=门限+1，找到未完成的请求ID</span><br><span class=\"line\">8.8    cost清零，try+1，打印try次数</span><br><span class=\"line\">8.9    若try &gt; 尝试门限，释放资源，更改状态，还原try</span><br><span class=\"line\">8.10   否则，找到瓶颈链路上的任一节点外的资源最丰富的节点</span><br><span class=\"line\">8.10.1     若找到，则映射；否则这个请求失败</span><br><span class=\"line\">8.11   检查链路映射是否完成，为s2v_node, s2v_link, v2s赋值</span><br><span class=\"line\">9  检查当前瓶颈节点，尝试链路映射</span><br><span class=\"line\">10 为s2v_node, s2v_link等赋值，用cost防止重复操作</span><br><span class=\"line\">11 检查新映射是否cost更低，是则更新</span><br><span class=\"line\">12 #允许迁移则继续向下</span><br><span class=\"line\">13 计算原始cost，释放原始映射资源，进行新的映射</span><br><span class=\"line\">14 新的映射成功则计算新cost，否则返回 0</span><br><span class=\"line\">15 新的cost是否更小，是则迁移，否则不做操作</span><br><span class=\"line\">16 还原s2v_node, ltmp</span><br><span class=\"line\">17 用unsplittable映射计算一次cost，若新的cost更小，则迁移；否则不作操作</span><br><span class=\"line\">18 更新s2v_node, s2v_link v2s</span><br><span class=\"line\">19 返回 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"辅助\"><a href=\"#辅助\" class=\"headerlink\" title=\"辅助\"></a>辅助</h3><h4 id=\"calculate-cost\"><a href=\"#calculate-cost\" class=\"headerlink\" title=\"calculate_cost\"></a>calculate_cost</h4><p><strong>目标</strong>：返回指定范围内的虚网请求cost之和。cost算法同上</p>\n<p>筛选标准：完成链路映射</p>\n<h4 id=\"exist-req\"><a href=\"#exist-req\" class=\"headerlink\" title=\"exist_req\"></a>exist_req</h4><p><strong>目标</strong>：查找是否存在完成了节点映射，未完成链路映射的请求。存在，则返回0，否则返回-1。</p>\n<h4 id=\"主函数-main\"><a href=\"#主函数-main\" class=\"headerlink\" title=\"主函数 main\"></a>主函数 main</h4><p><strong>算法流程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  为v2s, s2v_node, s2v_link, sub, req 赋初值</span><br><span class=\"line\">2  打开底层网络文件</span><br><span class=\"line\">3  为sub赋node(sub.s2v_nod(req_count,rest_cpu,cpu),sub.link(from,to,s2v_l,rest_bw))</span><br><span class=\"line\">4  关闭文件</span><br><span class=\"line\">5  循环打各req的文件</span><br><span class=\"line\">5.1   为req的revenue/nodes,links,split,time,duration,topo)赋值</span><br><span class=\"line\">5.2   循环为req的cpu,link.from,link.to,link.bw赋值</span><br><span class=\"line\">5.3   计算出revenue</span><br><span class=\"line\">6  关闭文件</span><br><span class=\"line\">7  为临时变量s2v_node/ltmp2/v2stmp2/spath分配内存空间</span><br><span class=\"line\">8  计算得到spath值</span><br><span class=\"line\">9  初始化临时变量</span><br><span class=\"line\">10 循环：</span><br><span class=\"line\">10.1   循环检测所有完成链路映射的请求，为done_count+1</span><br><span class=\"line\">10.2   更新done,rev,cost,map状态，若映射完成则释放资源</span><br><span class=\"line\">10.3   计算当前req.rev/cost/count</span><br><span class=\"line\">10.4   写入当前数据到文件</span><br><span class=\"line\">11 为当前所有请求进行映射</span><br><span class=\"line\">12 依次次检测所有请求状态，更新未请求成功的状态与错误计数器</span><br><span class=\"line\">13 打开stat文件</span><br><span class=\"line\">14 为成功的虚网请求释放资源</span><br><span class=\"line\">15 计算当前req,dev/cost/count</span><br><span class=\"line\">16 写入当前数据到stat文件/trace文件</span><br><span class=\"line\">17 关闭文件</span><br><span class=\"line\">18 返回 0</span><br></pre></td></tr></table></figure>",
            "tags": [
                "算法",
                "虚网映射"
            ]
        }
    ]
}
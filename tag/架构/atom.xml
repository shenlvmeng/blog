<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://shenlvmeng.github.com/blog</id>
    <title>Shenlvmeng&#39;s Blog • Posts by &#34;架构&#34; tag</title>
    <link href="http://shenlvmeng.github.com/blog" />
    <updated>2021-03-22T15:47:20.000Z</updated>
    <category term="总结" />
    <category term="制度" />
    <category term="道德" />
    <category term="文官" />
    <category term="万历" />
    <category term="明朝" />
    <category term="读书笔记" />
    <category term="展望" />
    <category term="flag" />
    <category term="2019" />
    <category term="2020" />
    <category term="2018" />
    <category term="2021" />
    <category term="2022" />
    <category term="2023" />
    <category term="面试" />
    <category term="前端" />
    <category term="FAQ" />
    <category term="HTML" />
    <category term="CSS" />
    <category term="style guide" />
    <category term="编程" />
    <category term="范式" />
    <category term="设计" />
    <category term="艺术" />
    <category term="质量" />
    <category term="回忆" />
    <category term="老朋友" />
    <category term="async_hooks" />
    <category term="cls-hooked" />
    <category term="logId" />
    <category term="二叉搜索树" />
    <category term="算法" />
    <category term="C" />
    <category term="Hash" />
    <category term="布隆过滤器" />
    <category term="字符串检索" />
    <category term="录音" />
    <category term="getUserMedia" />
    <category term="AudioContext" />
    <category term="PCM" />
    <category term="WAVE" />
    <category term="canvas" />
    <category term="流程图" />
    <category term="d3" />
    <category term="g6" />
    <category term="zrender" />
    <category term="processOn" />
    <category term="绘图" />
    <category term="动画" />
    <category term="SDN" />
    <category term="cbench" />
    <category term="安装说明" />
    <category term="攻略" />
    <category term="流水账" />
    <category term="成都" />
    <category term="重庆" />
    <category term="武汉" />
    <category term="架构" />
    <category term="组件" />
    <category term="重构" />
    <category term="代码" />
    <category term="代码风格" />
    <category term="CORS" />
    <category term="跨域" />
    <category term="数据可视化" />
    <category term="爬虫" />
    <category term="chrome" />
    <category term="crx" />
    <category term="扩展" />
    <category term="盒模型" />
    <category term="浮动" />
    <category term="Reactive Programming" />
    <category term="JavaScript" />
    <category term="Cycle.js" />
    <category term="Dart" />
    <category term="最佳实践" />
    <category term="引流" />
    <category term="universal-link" />
    <category term="app-link" />
    <category term="脚手架" />
    <category term="degit" />
    <category term="git" />
    <category term="设计模式" />
    <category term="类" />
    <category term="接口" />
    <category term="抽象类" />
    <category term="Docker" />
    <category term="ONOS" />
    <category term="控制器" />
    <category term="虚拟化" />
    <category term="DOM" />
    <category term="笔记" />
    <category term="UX" />
    <category term="UED" />
    <category term="准则" />
    <category term="Java" />
    <category term="Ruby" />
    <category term="反射" />
    <category term="编程范式" />
    <category term="鸭子类型" />
    <category term="管理" />
    <category term="效率" />
    <category term="知识工作者" />
    <category term="卓有成效" />
    <category term="Elm" />
    <category term="框架" />
    <category term="函数式编程" />
    <category term="虚网映射" />
    <category term="Javascript" />
    <category term="并发" />
    <category term="event loop" />
    <category term="JavaSript" />
    <category term="Express" />
    <category term="源码" />
    <category term="覆盖率" />
    <category term="端到端测试" />
    <category term="istanbul" />
    <category term="istanbuljs" />
    <category term="代码覆盖率" />
    <category term="istanbul-middleware" />
    <category term="代码插桩" />
    <category term="require钩子" />
    <category term="babel-plugin-istanbul" />
    <category term="css" />
    <category term="html5" />
    <category term="flex" />
    <category term="javascript" />
    <category term="roadmap" />
    <category term="闭包" />
    <category term="Haskell" />
    <category term="monad" />
    <category term="后端" />
    <category term="管理后台" />
    <category term="egg.js" />
    <category term="工作流" />
    <category term="pull request" />
    <category term="黑客与画家" />
    <category term="创业" />
    <category term="golang" />
    <category term="语言学习" />
    <category term="骑行" />
    <category term="海南" />
    <category term="图文" />
    <category term="reflow" />
    <category term="repaint" />
    <category term="命名法" />
    <category term="成功学" />
    <category term="自我建设" />
    <category term="HTTP" />
    <category term="HTTP/2" />
    <category term="SPDY" />
    <category term="QUIC" />
    <category term="HTTPS" />
    <category term="状态码" />
    <category term="网络攻击" />
    <category term="介绍" />
    <category term="图片渲染" />
    <category term="html2canvas" />
    <category term="dom-to-image" />
    <category term="electron" />
    <category term="indexedDB" />
    <category term="异步" />
    <category term="Generator" />
    <category term="thunk" />
    <category term="async" />
    <category term="函数表达式" />
    <category term="对象" />
    <category term="继承" />
    <category term="类型转换" />
    <category term="==" />
    <category term="类型判断" />
    <category term="猫" />
    <category term="杀手" />
    <category term="管理学" />
    <category term="领导力" />
    <category term="梯队" />
    <category term="移动端" />
    <category term="UI" />
    <category term="自适应" />
    <category term="rem" />
    <category term="Electron" />
    <category term="GUI" />
    <category term="gpx" />
    <category term="template" />
    <category term="Electron Builder" />
    <category term="PWA" />
    <category term="方法论" />
    <category term="夜话" />
    <category term="多线" />
    <category term="生活" />
    <category term="密码" />
    <category term="密钥" />
    <category term="技改" />
    <category term="Vue" />
    <category term="gulp" />
    <category term="瀑布流" />
    <category term="电影" />
    <category term="PHP" />
    <category term="参考" />
    <category term="思维" />
    <category term="学习能力" />
    <category term="右脑" />
    <category term="经济学" />
    <category term="宏观经济学" />
    <category term="术语" />
    <category term="GDP" />
    <category term="CPI" />
    <category term="储蓄" />
    <category term="投资" />
    <category term="金融市场" />
    <category term="股票" />
    <category term="债券" />
    <category term="美联储" />
    <category term="失业" />
    <category term="货币" />
    <category term="现值" />
    <category term="准备金" />
    <category term="货币中性" />
    <category term="通货膨胀" />
    <category term="汇率" />
    <category term="购买力" />
    <category term="净出口" />
    <category term="资产净流出" />
    <category term="总需求" />
    <category term="总供给" />
    <category term="流动性偏好" />
    <category term="乘数效应" />
    <category term="菲利普斯曲线" />
    <category term="微观经济学" />
    <category term="供求" />
    <category term="贸易" />
    <category term="市场" />
    <category term="税" />
    <category term="剩余" />
    <category term="外部性" />
    <category term="公共物品" />
    <category term="公共资源" />
    <category term="生产成本" />
    <category term="利润" />
    <category term="垄断" />
    <category term="价格歧视" />
    <category term="寡头" />
    <category term="垄断竞争" />
    <category term="生产要素市场" />
    <category term="贫困" />
    <category term="消费者选择理论" />
    <category term="不对称信息" />
    <category term="政治经济学" />
    <category term="行为经济学" />
    <category term="VSCode" />
    <category term="编辑器" />
    <category term="IDE" />
    <category term="习惯" />
    <category term="lint" />
    <category term="editorconfig" />
    <category term="commit message" />
    <category term="hybrid" />
    <category term="JSBridge" />
    <category term="Web Worker" />
    <category term="Service Worker" />
    <category term="文本编辑器" />
    <category term="quill" />
    <category term="结构化数据" />
    <category term="埋点" />
    <category term="raven.js" />
    <category term="前端监控" />
    <category term="React" />
    <category term="Hooks" />
    <category term="函数组件" />
    <category term="复用" />
    <category term="量子物理" />
    <category term="史话" />
    <category term="状态管理" />
    <category term="redux" />
    <category term="MobX" />
    <category term="代码质量" />
    <category term="重来" />
    <category term="requestAnimationFrame" />
    <category term="TypeScript" />
    <category term="路书" />
    <category term="gpx解析" />
    <category term="EXIF" />
    <category term="人类" />
    <category term="生存" />
    <category term="基因" />
    <category term="响应式编程" />
    <category term="RxJS" />
    <category term="成长" />
    <category term="业务" />
    <category term="思想" />
    <category term="程序设计" />
    <category term="心理学" />
    <category term="自我" />
    <category term="社会思维" />
    <category term="社会影响" />
    <category term="文化" />
    <category term="性别" />
    <category term="从众" />
    <category term="说服" />
    <category term="临床诊断" />
    <category term="陪审团" />
    <category term="司法" />
    <category term="物质主义" />
    <category term="健康" />
    <category term="软技能" />
    <category term="理财" />
    <category term="健身" />
    <category term="自我营销" />
    <category term="学习" />
    <category term="社会关系" />
    <category term="偏见" />
    <category term="攻击行为" />
    <category term="亲密关系" />
    <category term="友谊" />
    <category term="爱情" />
    <category term="利他" />
    <category term="冲突" />
    <category term="和解" />
    <category term="商业模式" />
    <category term="产品" />
    <category term="校园网" />
    <category term="互联网" />
    <category term="技术" />
    <category term="web开发" />
    <category term="哲思" />
    <category term="择偶观" />
    <category term="validator" />
    <category term="大文件" />
    <category term="visibilityChange" />
    <category term="IntersectionObserver" />
    <category term="图种" />
    <category term="draggable" />
    <category term="webpack" />
    <category term="z-index" />
    <category term="git submodule" />
    <category term="object-fit" />
    <category term="object-position" />
    <category term="BroadcastChannel" />
    <category term="extract-text-webpack-plugin" />
    <category term="lottie" />
    <category term="backface-visibility" />
    <category term="egret" />
    <category term="mock" />
    <category term="SSO" />
    <category term="autoprefixer" />
    <category term="polyfill" />
    <category term="Android" />
    <category term="ffmpeg" />
    <category term="React Hooks" />
    <category term="rollup" />
    <category term="Rollup" />
    <category term="mouseout" />
    <category term="mouseleave" />
    <category term="lint-staged" />
    <category term="吸顶" />
    <category term="图片组件" />
    <category term="CDN" />
    <category term="DNS" />
    <category term="CNAME" />
    <category term="ssh" />
    <category term="fis-receiver" />
    <category term="tmux" />
    <category term="origami" />
    <category term="promise" />
    <category term="encodeURI" />
    <category term="encodeURIComponent" />
    <category term="axios" />
    <category term="charles" />
    <category term="黑色幽默" />
    <category term="朋友" />
    <category term="梦" />
    <category term="濒死" />
    <category term="江南" />
    <category term="苏州" />
    <category term="无锡" />
    <category term="宜兴" />
    <category term="湖州" />
    <category term="南浔" />
    <category term="游记" />
    <category term="随笔" />
    <category term="群众" />
    <category term="理论" />
    <category term="实效" />
    <category term="测试" />
    <category term="长沙" />
    <category term="杭州" />
    <category term="湖南" />
    <category term="核酸" />
    <category term="美食" />
    <category term="青岛" />
    <category term="济南" />
    <category term="山东" />
    <category term="云南" />
    <category term="丽江" />
    <category term="大理" />
    <category term="西北" />
    <category term="银川" />
    <category term="西宁" />
    <category term="青海湖" />
    <category term="西海镇" />
    <category term="茶卡盐湖" />
    <category term="厦门" />
    <category term="感受" />
    <category term="C语言" />
    <category term="树" />
    <category term="主干开发" />
    <category term="GitFlow" />
    <category term="GithubFlow" />
    <category term="typescript" />
    <category term="类型系统" />
    <category term="首屏时间" />
    <category term="性能优化" />
    <category term="webrtc" />
    <category term="RTMP" />
    <category term="公司" />
    <category term="个人发展" />
    <category term="战略" />
    <category term="晋升" />
    <category term="哲学" />
    <category term="幸福" />
    <category term="人生" />
    <category term="叔本华" />
    <category term="Unix" />
    <entry>
        <id>http://shenlvmeng.github.com/blog/2021/03/22/clean-architecture/</id>
        <title>《架构整洁之道》—— 软件设计的思考</title>
        <link rel="alternate" href="http://shenlvmeng.github.com/blog/2021/03/22/clean-architecture/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;全文参考自马丁大叔的《架构整洁之道》，书中文笔清爽易懂，不过在后半段有点条理不清流于术而非道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编程领域，问题就像一个生命体一样，是在不断繁殖和进化的。它甚至经常不会人们预期中一般发展。作为一名出色的软件工程师或架构师，你需要有超出普通程序员的视角，考虑系统宏观的未来的发展。你的使命是，在这种恶劣的开发环境下，绘制一幅相对最优的图纸，用最少的时间、人力、金钱构建和维护一个随时可能融化在熵增热汤里的软件系统。和现实物理世界里的架构师类似，你需要了解编程世界里的一般规律，帮助你挑选武器（技术），修炼秘籍（方法论），在不同的江湖里（业务）打造不同的门派（软件系统）。&lt;/p&gt;
&lt;p&gt;开卷有益，祝你练武愉快~&lt;/p&gt;
&lt;h2 id=&#34;你要做什么&#34;&gt;&lt;a href=&#34;#你要做什么&#34; class=&#34;headerlink&#34; title=&#34;你要做什么&#34;&gt;&lt;/a&gt;你要做什么&lt;/h2&gt;&lt;p&gt;简而言之，架构师的终极目标就是&lt;strong&gt;用最少的人力成本来满足构建和维护软件系统的需求&lt;/strong&gt;。糟糕的架构设计会让软件在成功之前，就带来高昂的边际人力成本，即开发新需求的开支越来越大（因为程序员的时间都耗费在系统的修修补补上了）。然而，这种日益增长的边际人力成本现象并不少见。来源于类似龟兔赛跑中兔子的盲目自信，实际上，&lt;strong&gt;无论从短期还是长期看，胡乱编写代码的工作速度其实比循规蹈矩更慢&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;架构师存在的一个必要性就是，软件存在着两种价值维度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行为价值（现在时）&lt;/strong&gt;：即实现功能和弥补bug。这类价值是&lt;strong&gt;紧急却并不总是重要的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;架构价值（将来时）&lt;/strong&gt;：即软件是否足够“软”（易于被修改），这类价值是&lt;strong&gt;重要却并不总是紧急的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很现实的一点是，在公司中，&lt;strong&gt;团队之间的抗争本来就是无穷无尽的&lt;/strong&gt;。你作为研发团队的一员，职责的一部分就是避免你的代码在抗争的风吹雨打下变成一坨没人爱的shit。&lt;/p&gt;
&lt;h2 id=&#34;编程范式&#34;&gt;&lt;a href=&#34;#编程范式&#34; class=&#34;headerlink&#34; title=&#34;编程范式&#34;&gt;&lt;/a&gt;编程范式&lt;/h2&gt;&lt;p&gt;没错，架构师们也有祖师爷。在1958到1968年期间，3大编程范式就已经陆续出现了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结构化编程&lt;/strong&gt;，由Dijkstra在1968年提出，并发扬光大，&lt;strong&gt;它对程序控制权的直接转移（程序语句）进行了限制和规范&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;，最早在1966年提出，Ole Johan Dahl和Kriste Nygaard注意到，函数调用堆栈可以被放到堆内存中，从而在函数返回后继续保留。&lt;strong&gt;它对程序控制权的间接转移（函数调用）进行了限制和规范&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;，启发自Alonzo Church于1936年发明的lambda演算，发扬于1958年的LISP语言。&lt;strong&gt;它对程序的赋值进行了限制和规范&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得思考是，三大范式做的都是&lt;strong&gt;限制和规范&lt;/strong&gt;，即告诉我们&lt;strong&gt;不能做什么&lt;/strong&gt;，而不是可以做什么。另外，多态带来的架构边界飞跃，函数式编程带来的数据访问限制，结构化编程带来的算法拆解为我们架构软件提供了强大武器。这也与软件架构的三个关注点所契合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能性&lt;/strong&gt;，即完整的功能实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组件独立性&lt;/strong&gt;，即合适的耦合度与细粒度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据管理&lt;/strong&gt;，即良好的数据结构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结构化编程&#34;&gt;&lt;a href=&#34;#结构化编程&#34; class=&#34;headerlink&#34; title=&#34;结构化编程&#34;&gt;&lt;/a&gt;结构化编程&lt;/h3&gt;&lt;p&gt;Dijkstra在1950年代思考编程时，得出过一个结论：编程是一项&lt;strong&gt;难度很大&lt;/strong&gt;的活动。他倾向于把编程类比为数学推导过程，并发现&lt;code&gt;goto&lt;/code&gt;的&lt;strong&gt;某些使用&lt;/strong&gt;会导致&lt;strong&gt;模块无法被递归拆解成更小的单元&lt;/strong&gt;。然而，去掉这些使用的&lt;code&gt;goto&lt;/code&gt;可以被&lt;strong&gt;顺序结构、分支结构、循环结构这三种最小集&lt;/strong&gt;等价表示出来。从而，大问题可以被逐步拆解为小问题。&lt;/p&gt;
&lt;p&gt;不过，事情也并非这么理想，当程序复杂后，我们不可能像Dijkstra一样，用严格的数学推导形式化证明编程的正确性。相反，类似实验学科的&lt;strong&gt;无法被证伪即正确&lt;/strong&gt;，我们现今依旧使用着Dijkstra的结构化编程思路将大问题拆解为小问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有趣的是，“无法被证伪即正确”和Dijkstra的一个观点&lt;strong&gt;“测试只能展示bug的存在，并不能证明不存在bug”&lt;/strong&gt;不谋而合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，去掉goto糟粕诞生的结构化编程中，最有价值的地方就是，它赋予我们创造&lt;strong&gt;可证伪程序单元&lt;/strong&gt;的能力，从而架构起大程序。在架构设计领域，&lt;strong&gt;功能性拆解仍然是最佳实践之一&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么？什么叫做可证伪？你应该写过单元测试吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;面向对象编程&#34;&gt;&lt;a href=&#34;#面向对象编程&#34; class=&#34;headerlink&#34; title=&#34;面向对象编程&#34;&gt;&lt;/a&gt;面向对象编程&lt;/h3&gt;&lt;p&gt;什么是面向对象？有人说面向对象是“数据和函数的组合”，也有人说是“对真实世界的一种建模方式”。但这两种理解要么片面，要么虚无缥缈。为了总结这种范式，我们先从它的3大特征入手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;，即将一组关联数据和函数圈起来。然而这种特性，从C语言起就支持（struct + 头文件），很难说它是面向对象编程的必要条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;，即可以在某个作用域对外部定义的一组变量与函数进行覆盖。不过C语言也能模拟出这种能力，看起来也比较勉强。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;，即在同一接口描述下的不同具体实现形式，C语言起也做了支持（STDOUT），然而使用函数指针显式实现多态问题就在于指针的&lt;strong&gt;危险性&lt;/strong&gt;。而面向对象编程对这种程序间接控制权的转移做了约束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的函数调用树中，系统行为决定了自上而下的控制流，而控制流决定了&lt;strong&gt;源代码依赖&lt;/strong&gt;（代码实现）是自上而下的，比如在C中会使用&lt;code&gt;#include&lt;/code&gt;引入依赖。此时不论是代码实现还是代码执行都是自上而下的。然而在&lt;strong&gt;多态&lt;/strong&gt;的帮助下，底层函数需要依赖高层接口实现，作为高层函数的插件引入，从而将这种依赖关系和控制流反向，即&lt;strong&gt;依赖反转&lt;/strong&gt;。实际上，借助安全便利的多态实现，可以轻松将依赖关系反转。&lt;/p&gt;
&lt;p&gt;从而架构师可以&lt;strong&gt;完全控制&lt;/strong&gt;这种方式下，系统中所有的源代码依赖关系，进而随意更改源代码依赖关系。让每个组件都有&lt;strong&gt;独立部署&lt;/strong&gt;和&lt;strong&gt;独立开发&lt;/strong&gt;能力。好了，我们现在可以说明面向对象编程的含义了：&lt;/p&gt;
&lt;p&gt;面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力。这种能力让架构师可以构建&lt;strong&gt;插件式架构&lt;/strong&gt;，让高层&lt;strong&gt;策略性组件&lt;/strong&gt;和底层&lt;strong&gt;实现性组件&lt;/strong&gt;相分离。借助接口，底层实现性组件作为插件，可以独立于高层组件开发和部署。&lt;/p&gt;
&lt;h3 id=&#34;函数式编程&#34;&gt;&lt;a href=&#34;#函数式编程&#34; class=&#34;headerlink&#34; title=&#34;函数式编程&#34;&gt;&lt;/a&gt;函数式编程&lt;/h3&gt;&lt;p&gt;函数式编程依据的原理早在编程之前就已出现，相对前两种范式，函数式编程的风格可能相对陌生一点。在这类风格中，变量都是不可变的。从而让竞争问题、死锁问题、并发更新问题不复存在。一个架构良好的系统，需要将状态修改的部分和不需要修改的部分隔离开，然后用类似事务型内存的方式来保护可变量。另外，架构师应该着力于将大部分逻辑归于不可变组件中，可变组件的逻辑越少越好。&lt;/p&gt;
&lt;p&gt;书中还提到了只包含CR的事件溯源存储逻辑，即通过事务日志的方式保存当前状态。因为不存在更改和删除，从而不存在并发问题。也是一种很新颖的思路。&lt;/p&gt;
&lt;p&gt;回顾上面的三种编程范式，都在说什么&lt;strong&gt;不应该做&lt;/strong&gt;。也即编程好似在充满死路的熵增旷野中，只有沿着相对安全的几个大方向才可拨开迷雾。&lt;/p&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;&lt;a href=&#34;#设计原则&#34; class=&#34;headerlink&#34; title=&#34;设计原则&#34;&gt;&lt;/a&gt;设计原则&lt;/h2&gt;&lt;p&gt;软件的中层需要具有良好的可读性、可扩展性。这里就不得不提到SOLID原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP：&lt;strong&gt;单一职责原则&lt;/strong&gt;，每个模块有且只有一个需要被改变的理由&lt;/li&gt;
&lt;li&gt;OCP：&lt;strong&gt;开闭原则&lt;/strong&gt;，对扩展开放，对修改封闭&lt;/li&gt;
&lt;li&gt;LSP：&lt;strong&gt;里氏替换原则&lt;/strong&gt;，子类型应该能够无无缝替换类型使用&lt;/li&gt;
&lt;li&gt;ISP：&lt;strong&gt;接口隔离原则&lt;/strong&gt;，依赖的模块不要包含不需要的接口&lt;/li&gt;
&lt;li&gt;DIP：&lt;strong&gt;依赖反转原则&lt;/strong&gt;，高层策略性代码不要依赖底层实现性代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;SRP&#34;&gt;&lt;a href=&#34;#SRP&#34; class=&#34;headerlink&#34; title=&#34;SRP&#34;&gt;&lt;/a&gt;SRP&lt;/h3&gt;&lt;p&gt;任何一个软件模块（一组紧密相关的函数和数据结构）都应该只对一个行为者负责。实际上，代码和数据就是靠着和某一类行为者的相关性组合起来的。我们需要&lt;strong&gt;将服务不同行为者的代码进行切分&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;OCP&#34;&gt;&lt;a href=&#34;#OCP&#34; class=&#34;headerlink&#34; title=&#34;OCP&#34;&gt;&lt;/a&gt;OCP&lt;/h3&gt;&lt;p&gt;设计良好的软件应该易于扩展，同时抗拒修改。实现方式可以通过将系统划分为一系列组件，并且将依赖关系按层次组织，使得高阶组件不会因为低阶组件修改受到影响。&lt;/p&gt;
&lt;h3 id=&#34;LSP&#34;&gt;&lt;a href=&#34;#LSP&#34; class=&#34;headerlink&#34; title=&#34;LSP&#34;&gt;&lt;/a&gt;LSP&lt;/h3&gt;&lt;p&gt;里氏替换原则表示，子类型应该能够被当做父类型使用。它实际上表示了一种面向接口设计的设计原则。一旦违背了这种可替换性，就会不得不在系统架构中增加大量复杂的应对机制。&lt;/p&gt;
&lt;h3 id=&#34;ISP&#34;&gt;&lt;a href=&#34;#ISP&#34; class=&#34;headerlink&#34; title=&#34;ISP&#34;&gt;&lt;/a&gt;ISP&lt;/h3&gt;&lt;p&gt;ISP告诉我们任何软件设计如果依赖了不需要的东西，都是不好的迹象，很容易带来不必要的麻烦。&lt;/p&gt;
&lt;h3 id=&#34;DIP&#34;&gt;&lt;a href=&#34;#DIP&#34; class=&#34;headerlink&#34; title=&#34;DIP&#34;&gt;&lt;/a&gt;DIP&lt;/h3&gt;&lt;p&gt;DIP告诉我们，应该多引用抽象类型，而不是具体实现。因为软件是经常变动的，而抽象出共性的接口则是较少变化的。从而可以衍生出一些守则，譬如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应该多使用抽象接口，避免使用多变的实现类&lt;/li&gt;
&lt;li&gt;不要在实现类上创建衍生类&lt;/li&gt;
&lt;li&gt;不要覆盖具体实现的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过当然了，还是得有人做实现的脏活累活的&lt;/p&gt;
&lt;h2 id=&#34;组件构建&#34;&gt;&lt;a href=&#34;#组件构建&#34; class=&#34;headerlink&#34; title=&#34;组件构建&#34;&gt;&lt;/a&gt;组件构建&lt;/h2&gt;&lt;h3 id=&#34;组件&#34;&gt;&lt;a href=&#34;#组件&#34; class=&#34;headerlink&#34; title=&#34;组件&#34;&gt;&lt;/a&gt;组件&lt;/h3&gt;&lt;p&gt;组件是构建软件的最小单元，同时也是源代码的集合。在早期会使用链接技术将程序和库函数链接起来，而后随着机器性能的增长，我们会在程序运行中插入动态链接文件，如今这种组件化插件式架构是最常见的软件构建形式。&lt;/p&gt;
&lt;h3 id=&#34;组件聚合&#34;&gt;&lt;a href=&#34;#组件聚合&#34; class=&#34;headerlink&#34; title=&#34;组件聚合&#34;&gt;&lt;/a&gt;组件聚合&lt;/h3&gt;&lt;p&gt;和类相似，组件也有一些原则指引我们的构建工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REP：复用&amp;#x2F;发布原则，即可以一起发布的最小粒度就是复用的最小粒度，也即按可以同时发布聚合&lt;/li&gt;
&lt;li&gt;CCP：共同闭包原则，即因为同一原因修改的放在一起，反之不要放在一起，也即按变更原因聚合&lt;/li&gt;
&lt;li&gt;CRP：共同复用原则，即会被一起复用的放在一起，反之不要放在一起，也即按减少无用耦合聚合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三大原则相互牵制，在项目的不同阶段，某一原则重要性也会不同；比如在项目早期CCP就会更重要，而后REP会比较重要。&lt;/p&gt;
&lt;h3 id=&#34;组合耦合&#34;&gt;&lt;a href=&#34;#组合耦合&#34; class=&#34;headerlink&#34; title=&#34;组合耦合&#34;&gt;&lt;/a&gt;组合耦合&lt;/h3&gt;&lt;p&gt;本节提出了一些可以定量衡量耦合健康度的指标，比较新颖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无依赖环原则：依赖关系中不能有环，会不利于厘清依赖关系；可以通过&lt;strong&gt;依赖反转&lt;/strong&gt;或&lt;strong&gt;创建第三方依赖组件&lt;/strong&gt;解决。循环依赖关系务必持续监控。&lt;/li&gt;
&lt;li&gt;稳定依赖原则：依赖关系必须指向稳定的方向，简单点说就是让经常变更的组件依赖于不经常变更的组件。一个组件的位置稳定性可以通过入向和出向依赖算出，它要能和组件的实际稳定性匹配。&lt;/li&gt;
&lt;li&gt;稳定抽象原则：抽象化程度需要和稳定性程度一直，即经常变更的组件要容易变更，即更具体实现；反之，稳定的组件要不容易变更，即更抽象。结合上条看，依赖关系应该指向更抽象的方向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用位置稳定性指标I和抽象程度A，可以绘制一个坐标系。在主序列上的是最健康的，相反的两块痛苦区和无用区则是不健康的表现。用偏离主序列线的距离可以大致衡量依赖关系的健康程度。结合发布版本的变化来看，还可以得到变化趋势。&lt;/p&gt;
&lt;h2 id=&#34;软件架构&#34;&gt;&lt;a href=&#34;#软件架构&#34; class=&#34;headerlink&#34; title=&#34;软件架构&#34;&gt;&lt;/a&gt;软件架构&lt;/h2&gt;&lt;p&gt;软件架构目的就是方便在工作中更好地对组件进行研发、部署、运行和维护。其中的策略就是&lt;strong&gt;保留尽可能多的可选项&lt;/strong&gt;。让系统最大化程序员的生产力，同时最小化系统运营成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发：系统架构需要方便开发团队对它的开发，不同的团队结构应该采用不同的架构设计，比如团队的大小就会影响架构的选择&lt;/li&gt;
&lt;li&gt;部署：一键式部署&lt;/li&gt;
&lt;li&gt;运行：几乎任何运行问题都可以通过增加硬件来解决&lt;/li&gt;
&lt;li&gt;维护：减小新功能和系统缺陷占用的人力资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保持可选项，忽略那些无关紧要的实现细节。任何软件系统都可以拆解成&lt;strong&gt;策略&lt;/strong&gt;（业务的宏观逻辑和流程）和&lt;strong&gt;细节&lt;/strong&gt;（具体操作行为）。而&lt;strong&gt;策略才是系统的真正价值所在&lt;/strong&gt;。细节是指那些和策略交互的东西，包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&amp;#x2F;O设备&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;Web系统&lt;/li&gt;
&lt;li&gt;服务器&lt;/li&gt;
&lt;li&gt;框架&lt;/li&gt;
&lt;li&gt;交互协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计时，可以尽量拖延上面这些的设计，这样我们做出的决策才不会依赖各种很容易变化的信息。另一方面，也可以&lt;strong&gt;增加实现底层的可替换性&lt;/strong&gt;。举个具体例子：&lt;strong&gt;设备无关性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;独立性&#34;&gt;&lt;a href=&#34;#独立性&#34; class=&#34;headerlink&#34; title=&#34;独立性&#34;&gt;&lt;/a&gt;独立性&lt;/h3&gt;&lt;p&gt;一个良好的架构应支持下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统用例：设计良好的架构需要能够&lt;strong&gt;看起来&lt;/strong&gt;就可以反映系统的设计意图，比如一个购物车应用架构应该看起来就该是用来实现购物车的&lt;/li&gt;
&lt;li&gt;系统运行：可以解耦出多个独立服务，然后通过某种网络协议通信，这种架构即微服务&lt;/li&gt;
&lt;li&gt;系统维护&lt;/li&gt;
&lt;li&gt;系统开发&lt;/li&gt;
&lt;li&gt;系统部署：理想的独立部署应该能够做到&lt;strong&gt;热更新&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意留意表面的重复和实际的重复，如果两段代码变更速率和缘由不同，那么就不算是真正的重复。&lt;/p&gt;
&lt;h3 id=&#34;划分边界&#34;&gt;&lt;a href=&#34;#划分边界&#34; class=&#34;headerlink&#34; title=&#34;划分边界&#34;&gt;&lt;/a&gt;划分边界&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;设计良好的系统架构不应该依赖细节，而应该尽可能推迟细节性的决策。通过划清边界，可以推迟和延后细节性的决策，从而节省大量时间，避免问题。&lt;/li&gt;
&lt;li&gt;边界线应该画在不相干的事情中间，譬如GUI和业务逻辑&lt;/li&gt;
&lt;li&gt;针对核心业务逻辑的插件式架构可以提高可维护性和可扩展性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;边界剖析&#34;&gt;&lt;a href=&#34;#边界剖析&#34; class=&#34;headerlink&#34; title=&#34;边界剖析&#34;&gt;&lt;/a&gt;边界剖析&lt;/h3&gt;&lt;p&gt;简言之，应该尽可能从底层组件指向高层组件。&lt;/p&gt;
&lt;h3 id=&#34;策略和层次&#34;&gt;&lt;a href=&#34;#策略和层次&#34; class=&#34;headerlink&#34; title=&#34;策略和层次&#34;&gt;&lt;/a&gt;策略和层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变更原因、时间和层次不同的策略应该属于不同的组件&lt;/li&gt;
&lt;li&gt;按距离系统输入、输出距离的远近，可以确定策略的层次&lt;/li&gt;
&lt;li&gt;源码间的依赖关系，应该主要和组件所在的层次挂钩&lt;/li&gt;
&lt;li&gt;低层组件应该以插件的方式依赖高层组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;业务逻辑&#34;&gt;&lt;a href=&#34;#业务逻辑&#34; class=&#34;headerlink&#34; title=&#34;业务逻辑&#34;&gt;&lt;/a&gt;业务逻辑&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;业务逻辑是程序中真正用于或者体现赚钱&amp;#x2F;省钱的逻辑与过程&lt;/strong&gt;。其中关键逻辑和关键数据紧密组合成为&lt;strong&gt;业务实体&lt;/strong&gt;。业务实体应该只有高层逻辑，没有具体实现。而&lt;strong&gt;用例&lt;/strong&gt;是业务实体在不同侧面的具体体现。通过用例可以规范用户和业务实体的交互方式。&lt;/p&gt;
&lt;h3 id=&#34;“尖叫”的软件架构&#34;&gt;&lt;a href=&#34;#“尖叫”的软件架构&#34; class=&#34;headerlink&#34; title=&#34;“尖叫”的软件架构&#34;&gt;&lt;/a&gt;“尖叫”的软件架构&lt;/h3&gt;&lt;p&gt;“尖叫”即所见即所得。软件架构本身就足以能够体现其用途。一个良好的架构设计应该围绕用例展开，推迟和延后框架的选择，不要过度拘泥于框架。&lt;strong&gt;框架只是一个可选项&lt;/strong&gt;，是一个工具，而不是一种信念，更不是一种架构。&lt;/p&gt;
&lt;h3 id=&#34;整洁架构&#34;&gt;&lt;a href=&#34;#整洁架构&#34; class=&#34;headerlink&#34; title=&#34;整洁架构&#34;&gt;&lt;/a&gt;整洁架构&lt;/h3&gt;&lt;p&gt;一些常见的系统架构通常具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立于框架&lt;/li&gt;
&lt;li&gt;可被测试&lt;/li&gt;
&lt;li&gt;独立于UI&lt;/li&gt;
&lt;li&gt;独立于数据库&lt;/li&gt;
&lt;li&gt;独立于外部接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Main组件&#34;&gt;&lt;a href=&#34;#Main组件&#34; class=&#34;headerlink&#34; title=&#34;Main组件&#34;&gt;&lt;/a&gt;Main组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Main组件包含了系统中最细节化最底层的策略，它应该在做完脏活累活后，将程序的控制权交给最高抽象层的代码去执行&lt;/li&gt;
&lt;li&gt;针对不同系统可以配置不同的Main组件，即将Main组件视为应用程序的一个插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务：微观和宏观&#34;&gt;&lt;a href=&#34;#服务：微观和宏观&#34; class=&#34;headerlink&#34; title=&#34;服务：微观和宏观&#34;&gt;&lt;/a&gt;服务：微观和宏观&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统的架构边界事实上并不落在服务之间，而是&lt;strong&gt;穿透&lt;/strong&gt;所有服务，在服务内以组件形式存在&lt;/li&gt;
&lt;li&gt;服务可以提升系统的可扩展性和可开发性，不过服务却并不能代表整个系统的架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;整洁的嵌入式架构&#34;&gt;&lt;a href=&#34;#整洁的嵌入式架构&#34; class=&#34;headerlink&#34; title=&#34;整洁的嵌入式架构&#34;&gt;&lt;/a&gt;整洁的嵌入式架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;固件即对平台或硬件的强依赖代码，在固件和软件之间可以设置HAL（硬件抽象层），为它上层的软件提供服务，它可以帮助软件&lt;em&gt;脱离&lt;/em&gt;目标硬件平台来测试&lt;/li&gt;
&lt;li&gt;类似地，我们还可以引入OSAL（操作系统抽象层）来减少软件对操作系统的依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现细节&#34;&gt;&lt;a href=&#34;#实现细节&#34; class=&#34;headerlink&#34; title=&#34;实现细节&#34;&gt;&lt;/a&gt;实现细节&lt;/h2&gt;&lt;p&gt;那么什么算是实现细节呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt;，数据的组织结构和模型都是系统架构的一部分，但是从磁盘中存储&amp;#x2F;读取数据的机制或手段则没那么重要，就比如数据库或静态文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web&lt;/strong&gt;，Web只是UI，只是一种I&amp;#x2F;O设备&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用框架&lt;/strong&gt;，框架被创造的目的是解决作者遇到的问题，它要求我们去阅读文档，按照作者的要求整合到我们的应用中，可以使用但是不要被框架绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;案例：视频销售网站&#34;&gt;&lt;a href=&#34;#案例：视频销售网站&#34; class=&#34;headerlink&#34; title=&#34;案例：视频销售网站&#34;&gt;&lt;/a&gt;案例：视频销售网站&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统架构设计的第一步是识别系统中的各种角色和用例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;–END–&lt;/em&gt;&lt;/p&gt;
</content>
        <category term="设计" />
        <category term="架构" />
        <category term="组件" />
        <updated>2021-03-22T15:47:20.000Z</updated>
    </entry>
</feed>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"笔记\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2018/09/13/http-intro-note/",
            "url": "http://shenlvmeng.github.com/blog/2018/09/13/http-intro-note/",
            "title": "《图解HTTP》整理",
            "date_published": "2018-09-13T15:35:11.000Z",
            "content_html": "<blockquote>\n<p>读完了《图解HTTP》，就算是对计算机网络和HTTP部分内容做了个温习吧。同步做了整理，以便加强记忆和后面回顾。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>请求报文构成：</p>\n<ul>\n<li>方法</li>\n<li>URI（绝对或是相对）</li>\n<li>HTTP版本</li>\n<li>请求首部</li>\n<li>内容实体</li>\n</ul>\n<p>响应报文构成：</p>\n<ul>\n<li>HTTP版本号</li>\n<li>状态码</li>\n<li>状态码原语</li>\n<li>响应头部</li>\n<li>响应主体</li>\n</ul>\n<p>请求URI是服务器本身时，可以用<code>*</code>代替URI。</p>\n<p>可用的方法列表：</p>\n<ul>\n<li>GET 获取资源</li>\n<li>POST 传输信息</li>\n<li>PUT 传输文件，<strong>没有用户验证机制</strong>，很少用到</li>\n<li>DELETE 删除文件，同上，很少用到</li>\n<li>HEAD 获得响应头部，不返回主体</li>\n<li>OPTIONS 询问支持方法</li>\n<li>CONNECT 用来建立HTTPS连接的隧道</li>\n<li>TRACE 追踪路径上的所有服务器节点，很少用到</li>\n</ul>\n<p>其中后面三个是HTTP1.1才开始支持的。</p>\n<p><strong>持久化</strong></p>\n<p>在HTTP1.1后，HTTP建立的TCP连接默认是长连接（<code>keep-alive</code>），避免不必要的多次TCP握手和挥手。在此基础上，客户端可以同时向服务端发起多个资源请求。</p>\n<p><strong>状态化</strong></p>\n<p>HTTP本身是无状态的。通过cookie实现状态化，cookie通过服务端在响应头部的<code>set-cookie</code>字段下发，设置信息、使用范围、过期时间等内容。客户端在使用范围内的请求默认会携带上cookie信息。</p>\n<h2 id=\"HTTP报文结构\"><a href=\"#HTTP报文结构\" class=\"headerlink\" title=\"HTTP报文结构\"></a>HTTP报文结构</h2><ul>\n<li>请求首部和主体通过CR+LF分割开来</li>\n<li>报文编码<ul>\n<li>编码压缩<ul>\n<li>gzip （GNU zip）</li>\n<li>compress（UNIX compress）</li>\n<li>deflate（zlib）</li>\n<li>indentity（不压缩）</li>\n</ul>\n</li>\n<li>分块发送</li>\n<li>多部分发送（multipart）<ul>\n<li>multipart&#x2F;form-data 表单文件上传，用boundary字符<code>--</code>表示新的part的开始</li>\n<li>multipart&#x2F;byterange 配合206响应只包含了部分数据时使用</li>\n</ul>\n</li>\n<li>部分发送<ul>\n<li>Range指定字节范围</li>\n<li>206响应状态码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内容协商<ul>\n<li>双方就合适的语言、字符集、编码方式、过期时间进行协商</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><ul>\n<li>1xx 这一类型的状态码，代表请求已被接受，需要继续处理<ul>\n<li>100 Continue：客户端应当继续发送请求。</li>\n<li>101 Switching Protocals：将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。</li>\n</ul>\n</li>\n<li>2xx 成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<ul>\n<li>200 OK：请求已成功，在方法时HEAD时不返回响应主体</li>\n<li>204 No Content：服务器成功处理了请求，但不需要返回任何实体内容，<strong>用户浏览器应保留发送了该请求的页面</strong></li>\n<li>205 Reset Content：和204的唯一不同是返回此状态码的响应要求请求者重置文档视图</li>\n<li>206 Partial Content：服务器已经成功处理了部分GET请求。请求必须包含Range头信息来指示客户端希望得到的内容范围，返回使用<code>Content-Range</code>多用于下载工具</li>\n</ul>\n</li>\n<li>3xx 重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址在本次响应的Location域中指明。<ul>\n<li>300 Multiple Choices：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</li>\n<li>301 Moved Permanently：被请求的资源已永久移动到新位置，建议使用Location中的新地址</li>\n<li>302 Found：请求的资源现在临时从不同的URI响应请求</li>\n<li>303 See Other：和302的区别是，客户端<strong>应当采用GET的方式</strong>访问新的资源</li>\n<li>304 Not Modified：如果客户端发送了一个带条件（包括缓存相关的请求头部）的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变</li>\n<li>305 Use Proxy：被请求的资源必须通过指定的代理才能被访问</li>\n</ul>\n</li>\n<li>4xx 客户端错误：客户端发生了错误<ul>\n<li>400 Bad Request：由于包含语法错误，当前请求无法被服务器理解</li>\n<li>401 Unauthorized：当前请求需要用户验证，或用户未通过验证。</li>\n<li>403 Forbidden：服务器已经理解请求，但是拒绝执行它</li>\n<li>404 Not Found：资源未被在服务器上发现</li>\n<li>405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源，响应中必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表</li>\n<li>406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件</li>\n<li>413 Request Entity Too Large</li>\n<li>414 Request-URI Too Long</li>\n</ul>\n</li>\n<li>5xx 服务器错误：服务器在处理请求的过程中有错误发生<ul>\n<li>500 Internal Server Error：这个问题会在服务器的代码出错时出现</li>\n<li>501 Not Implemented：服务器不支持当前请求所需要的某个功能</li>\n<li>502 Bad GateWay：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</li>\n<li>503 Service Unavailable：临时的服务器维护或者过载。这个状况是临时的，并且将在一段时间以后恢复。</li>\n<li>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"协作机制\"><a href=\"#协作机制\" class=\"headerlink\" title=\"协作机制\"></a>协作机制</h2><ul>\n<li>代理（Proxy），单纯转发HTTP请求，会在响应头部的<code>Via</code>字段留下痕迹</li>\n<li>网关（Gateway），隔绝服务器和客户端，有安全、计费等逻辑</li>\n<li>隧道（tunnel），基于协议搭建，保证传输安全，对用户侧透明</li>\n<li>缓存（Cache），本地、服务端二级缓存，加快响应时间，有过期时间</li>\n</ul>\n<h2 id=\"报文头部\"><a href=\"#报文头部\" class=\"headerlink\" title=\"报文头部\"></a>报文头部</h2><ul>\n<li>首部用来进行连接的各种信息描述。每个首部的字段用字段名和值组成，两者用<code>:</code>隔开。</li>\n<li>首部分为端到端和逐跳两类，前者在报文转发的整个过程都保留，后者在转发后就会丢弃。典型的逐条首部有<code>Connection</code>, <code>Keep-Alive</code>, <code>Transfer-Encoding</code>, <code>Upgrade</code>等</li>\n</ul>\n<h3 id=\"通用首部\"><a href=\"#通用首部\" class=\"headerlink\" title=\"通用首部\"></a>通用首部</h3><h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>客户端和服务端协商缓存机制。配合下面一些首部字段使用：</p>\n<ul>\n<li><code>Etag</code></li>\n<li><code>Last-Modified</code></li>\n<li><code>Expires</code>（HTTP1.0）</li>\n<li><code>Pragma</code>（HTTP1.0）</li>\n<li><code>Age</code>（HTTP1.0）</li>\n<li><code>If-None-Match</code></li>\n<li><code>If-Not-Modified-Since</code></li>\n</ul>\n<p><code>Cache-Control</code>有下面一些可配置项。</p>\n<p>缓冲能力上，</p>\n<ul>\n<li>private，缓存只针对当前用户而言</li>\n<li>public，缓存对所有用户生效</li>\n<li>no-cache，始终对缓存进行过期验证</li>\n<li>no-store，不允许缓存</li>\n</ul>\n<p>过期时间上，</p>\n<ul>\n<li>min-fresh，返回指定时间范围内的非过期资源</li>\n<li>max-stale，返回指定时间范围内过期、非过期资源</li>\n<li>max-age，单位：秒，最大缓存时间</li>\n<li>s-max-age，同上，只用于CDN缓存</li>\n</ul>\n<p>二次验证上，</p>\n<ul>\n<li>only-if-cached，强制从缓存服务器中获取内容</li>\n<li>immutable，一旦缓存不可更改</li>\n<li>must-revalidate，即使本地已缓存，仍要求检查CDN缓存</li>\n<li>proxy-revalidate，缓存服务器必须检查源内容是否改变</li>\n</ul>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><p>管理连接，主要有两个用途。</p>\n<ul>\n<li>指定不希望转发给代理的字段</li>\n<li>管理持久连接。使用<code>Connection: Keep-Alive</code>建立连接（HTTP1.1默认行为），使用<code>Connection: Close</code>终止连接</li>\n</ul>\n<h4 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h4><p>报文创建时间。行如“Date: Tue, 03 Jul 2012 04:31:12 GMT”</p>\n<h4 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h4><p>历史遗留字段。<code>Pragma: no-cache</code>等同于<code>Cache-Control: no-cache</code>。</p>\n<p>除此外还有：</p>\n<ul>\n<li>Trailer，说明报文主体中记录的首部字段</li>\n<li>Transfer-Encoding，分段传输的主体编码</li>\n<li>Upgrade，切换协议，<strong>配合<code>Connection: Upgrade</code>使用</strong></li>\n<li>Via，标明沿途的整条路径</li>\n<li>Warning，缓存相关警告</li>\n</ul>\n<h3 id=\"请求首部\"><a href=\"#请求首部\" class=\"headerlink\" title=\"请求首部\"></a>请求首部</h3><ul>\n<li>Accept 接受文件的类型，类型间可以指定<code>q=x</code>表示权重值，x的取值在0到1之间。下同</li>\n<li>Accept-Charset 可以接受的文件字符集</li>\n<li>Accept-Encoding 可以接受的文件编码，有gzip，compress，deflate，indentity几种</li>\n<li>Accept-Language 可接受的语言</li>\n<li>Authorization 服务端需要的用户验证信息</li>\n<li>Age 从缓存实体产生到现在经历的时间</li>\n<li>Expect 期望的服务端返回状态码，服务端无法满足时返回417状态码，客户端等待服务端100响应时发送的请求都要带上该字段</li>\n<li>Host 服务器的主机名，通常是请求资源的URL</li>\n<li>If-Match 需要匹配的Etag，不满足时返回412，表示不满足条件</li>\n<li>If-Modified-Since 返回指定日期后的新内容，否则返回304</li>\n<li>If-Unmodified-Since 类似上</li>\n<li>If-Range 类似If-Match不过是范围匹配</li>\n<li>Max-Forwards 报文最多转发次数，通常配合TRACE方法使用</li>\n<li>Proxy-Authorization 代理服务端需要的用户验证信息</li>\n<li>Range 请求资源的部分内容，一般用在多线程下载（客户端发起）</li>\n<li>Referer 当前请求从哪个地址发起</li>\n<li>User-Agent 请求发起终端信息</li>\n</ul>\n<h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><ul>\n<li>Accept-Ranges，表示服务器是否支持Range请求，支持时值为bytes，否则是none</li>\n<li>Age，表示缓存到目前为止过了多久（HTTP1.0）</li>\n<li>Etag，资源的唯一标识，分为强Etag和弱Etag</li>\n<li>Location，用在3xx的请求中，表示客户端需要重定向到的新地址</li>\n<li>WWW-Authentication&#x2F;Proxy-Authentication，服务器、代理使用的认证类型</li>\n<li>Server，服务器信息</li>\n<li>Vary，与Vary指定首部字段同名的请求才会命中缓存</li>\n</ul>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><ul>\n<li>Allow 允许的访问方法</li>\n<li>Content-Encoding&#x2F;Content-Language&#x2F;Content-Length&#x2F; 内容的编码、语言、长度、类型</li>\n<li>Content-Location 内容的位置，通常在和访问URI时会用到</li>\n<li>Content-MD5 内容MD5编码，便于和客户端编码后进行对比，防止内容篡改</li>\n<li>Content-Range 用于部分请求</li>\n<li>Content-Type 文件类型，包括MIME type和字符集</li>\n<li>Expires&#x2F;Last-Modified 文件的过期时间和上次修改时间，用户判断缓存是否过期</li>\n</ul>\n<p>除此之外，还有和Cookie相关的两个头部，它们来自网景公司对于Cookie的设计。</p>\n<ul>\n<li>Set-Cookie，服务端下发设置Cookie信息。包含下列信息<ul>\n<li>expires，过期时间</li>\n<li>path，适用路径</li>\n<li>domain，适用域名</li>\n<li>secure，限制https才会携带Cookie</li>\n<li>HttpOnly，限制JS脚本访问Cookie</li>\n<li>下发的cookie内容</li>\n</ul>\n</li>\n<li>Cookie，客户端期望的cookie内容</li>\n</ul>\n<p>另外还有一些常用的首部字段：</p>\n<ul>\n<li>X-Frame-Options，规定页面在iframe中的呈现方式<ul>\n<li>DENY 禁止访问</li>\n<li>SAMEORIGIN 仅允许同源访问</li>\n</ul>\n</li>\n<li>X-XSS-Protection，为1时开启XSS防御</li>\n</ul>\n<p><strong>不建议使用”X-“开头的方式拓展非标准首部</strong>。 </p>\n<h2 id=\"HTTPS简介\"><a href=\"#HTTPS简介\" class=\"headerlink\" title=\"HTTPS简介\"></a>HTTPS简介</h2><p>HTTP缺点：</p>\n<ul>\n<li>使用明文 -&gt; 通信内容可以被窃听 –HTTPS–&gt; 加密通信内容</li>\n<li>不能验证身份 -&gt; DDoS攻击和伪装服务器、客户端身份 –HTTPS–&gt; 证书证明身份</li>\n<li>不能验证内容完整性 -&gt; 中间人攻击 –HTTPS–&gt; HTTPS保证完整性</li>\n</ul>\n<p>HTTPS特征：</p>\n<ul>\n<li>加密内容</li>\n<li>证书</li>\n<li>完整性保护</li>\n</ul>\n<p>HTTPS建立在SSL连接之上，SSL建立在TCP连接上。SSL使用共享秘钥和公开秘钥加密两种方式混合加密。在秘钥确保安全的情况下，使用共享秘钥对称加密，优化速度；否则使用公开秘钥确保安全性。</p>\n<ul>\n<li>共享秘钥，双方使用同一秘钥加密和解密，秘钥被监听后加密就失去了意义</li>\n<li>公开秘钥，使用公开秘钥加密，使用私有秘钥解密</li>\n</ul>\n<p>然而公开密钥本身并不能确保完整性，需要证书机构（CA）颁发证书认证，确保秘钥和端的有效以及合法性。服务端也可以使用OpenSSL为自己颁发自认证证书，但是一般会在浏览器上弹出警告。</p>\n<p>HTTPS建立连接的过程包括：</p>\n<ol>\n<li>协商决定秘钥组件</li>\n<li>服务端发送公开密钥、证书</li>\n<li>客户端检查证书合法性，以确认服务端身份，并拿到公钥</li>\n<li>客户端发送pre-master secret随机字符串</li>\n<li>服务端使用私钥加密pre-master secret hash值，返回加密的hash值（避免黑客尝试破解私钥）</li>\n<li>客户端使用公钥解密hash，对比自己之前生成的pre-master secret字符串hash，若一致，及证明服务端身份的合法性</li>\n<li>客户端生成一个对称加密算法和秘钥master-secret，使用公钥加密，发送给服务端</li>\n<li>双方使用master-secret进行通信</li>\n</ol>\n<p>通信的完整性可以通过将报文内容生成hash交由客户端验证来实现。</p>\n<p>SSL最初由网景开发，1.0和2.0版本被发现存在问题已被废弃。3.0后由IETF接手。目前可用的协议版本有SSL3.0和TLS1.0、TLS1.1、TLS1.2，其中最常用的是SSL3.0和TLS1.0。</p>\n<p><strong>证书</strong></p>\n<p>证书包含：</p>\n<ul>\n<li>发布机构（CA）</li>\n<li>有效期</li>\n<li>持有者（由CA担保证明持有者身份）</li>\n<li>公钥</li>\n<li>数字签名算法</li>\n<li>指纹算法</li>\n</ul>\n<p>为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会用自己的私钥加密后再和证书放到一起发布。使用者在打开证书时，根据加密算法，系统使用自带的公钥解密指纹和指纹算法，使用指纹算法计算证书的hash值和指纹对比，如果对的上就代表证书没问题。系统使用的公钥和证书一般由证书发布机构自己生成，内嵌在操作系统中。</p>\n<p>证书颁发机构（CA）通常会去做很多工作确保持有者的合法性，信任CA代表着信任CA颁发证书中的所有信息。所以一般系统只选择信誉较好的CA机构。公司内部使用或自生成的证书就只能被在指定范围内被信任。</p>\n<h2 id=\"身份验证\"><a href=\"#身份验证\" class=\"headerlink\" title=\"身份验证\"></a>身份验证</h2><ul>\n<li>BASIC 使用用户名密码验证，明文传输</li>\n<li>DIGEST 质询响应，防止密码被拦截，安全度和便利性都较差</li>\n<li>SSL 客户端证书 + HTTPS传输，成本高</li>\n<li>HTTP表单 + Cookie&#x2F;Session验证</li>\n</ul>\n<h2 id=\"功能追加协议\"><a href=\"#功能追加协议\" class=\"headerlink\" title=\"功能追加协议\"></a>功能追加协议</h2><p><strong>WebSocket</strong></p>\n<p>全双工，解决Ajax，长短轮询的局限。握手过程很简单：</p>\n<ul>\n<li>请求方添加<code>Upgrade</code>首部字段，声明升级到websocket。包含Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Verison等必要字段</li>\n<li>响应方回复101状态码，包含Sec-WebSocket-Accept（是根据Sec-WebSocket-Key生成的），Sec-WebSocket-Protocol</li>\n</ul>\n<p>连接建立后，双方使用WebSocket的方式进行通信</p>\n<p><strong>WebDAV</strong></p>\n<p>基于Web的文件属性管理。新增了一些方法和状态码，允许客户端远程修改服务器上的文件。</p>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><p><strong>RSS</strong></p>\n<p>RDF Site Summary，简易内容聚合。和Atom一样，使用XML的形式发布信息，通过特定的RSS阅读器阅读。</p>\n<h2 id=\"常见Web攻击方式\"><a href=\"#常见Web攻击方式\" class=\"headerlink\" title=\"常见Web攻击方式\"></a>常见Web攻击方式</h2><p>根本原因：HTTP本身没有必要的安全机制。</p>\n<h3 id=\"输出值转义相关攻击方式\"><a href=\"#输出值转义相关攻击方式\" class=\"headerlink\" title=\"输出值转义相关攻击方式\"></a>输出值转义相关攻击方式</h3><ul>\n<li>XSS，跨站脚本攻击，主要出现在<strong>动态拼接HTML</strong>的场景中，用户恶意注入的script代码段埋下陷阱，诱导用户误操作触发。盗取用户密码或Cookie信息</li>\n<li>SQL注入，通过URL注入的方式，制造恶意SQL语句，出现在<strong>动态拼接SQL语句</strong>的场景下。可以绕过认证、甚至破坏整个数据库</li>\n<li>OS命令注入，类似SQL注入，出现在<strong>动态拼接OS语句</strong>的场景下。</li>\n<li>HTTP首部攻击，出现在服务端响应头部使用了用户侧输入场景下，比如302响应中的Location头部可能存在的query部分。攻击者可以通过添加换行符，恶意添加新的首部字段，甚至篡改原有的响应主体</li>\n<li>邮箱首部注入攻击，类似HTTP首部攻击</li>\n</ul>\n<p>类似地还有目录遍历漏洞、远程文件引用漏洞。</p>\n<p>通过上面几种攻击方式，可以看到，<strong>永远不要信任用户侧输入</strong>，<strong>使用白名单机制，禁止动态拼接用户输入的语句</strong>。</p>\n<h3 id=\"设计缺陷相关攻击方式\"><a href=\"#设计缺陷相关攻击方式\" class=\"headerlink\" title=\"设计缺陷相关攻击方式\"></a>设计缺陷相关攻击方式</h3><ul>\n<li>强制浏览，在服务器公开目录下，浏览开发者本非自愿公开的文件。</li>\n<li>不正确的系统错误处理方式，数据库等内部系统抛出的错误，对用户毫无帮助，反倒能让攻击者看到服务背后的一些细节。包括，数据库错误、PHP等脚本错误、Web服务器的错误</li>\n<li>开放重定向，网站有诸如<code>?redirect=xxx</code>的path可以重定向时，一定要对redirect后的网址进行白名单控制，防止成为钓鱼攻击的跳板</li>\n</ul>\n<h3 id=\"session相关\"><a href=\"#session相关\" class=\"headerlink\" title=\"session相关\"></a>session相关</h3><ul>\n<li>XSS盗取cookie，伪装用户登录</li>\n<li>发送恶意链接，强制用户使用攻击者指定的session ID</li>\n<li>CSRF，跨站信息伪造，在带有用户信息的domain里留下恶意的网络请求，伪造用户发起请求，伪造请求可以通过<code>&lt;img src=&quot;xx&quot; /&gt;</code>, <code>&lt;video src=&quot;xxx&gt;&lt;/video&gt;</code>等多种形式</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>穷举法破解密码，暴力破解。使用图片验证码、手机验证码、机器检测等方式限制同IP的访问频率。<ul>\n<li>彩虹表。使用salt，增加破解难度</li>\n</ul>\n</li>\n<li>撞库。建议用户在不同域内使用不一样的密码</li>\n<li>点击劫持，使用透明元素覆盖在目标网页上。在18+网页中最常出现（😂）。</li>\n<li>DoS（Denial of Service）拒绝服务攻击，构造大量合法的网络请求，导致服务器超负荷。通常都是DDoS（Distributed Denial of Service）的形式。需要在IP层去过滤攻击的IP。</li>\n<li>后门程序</li>\n</ul>\n",
            "tags": [
                "笔记",
                "HTTP",
                "HTTPS",
                "状态码",
                "网络攻击",
                "介绍"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2018/09/02/dont-make-me-think-note/",
            "url": "http://shenlvmeng.github.com/blog/2018/09/02/dont-make-me-think-note/",
            "title": "《Don't make me think》 笔记",
            "date_published": "2018-09-02T15:46:37.000Z",
            "content_html": "<blockquote>\n<p>原版链接: <a href=\"https://book.douban.com/subject/25820714/\">https://book.douban.com/subject/25820714/</a></p>\n</blockquote>\n<h2 id=\"准则\"><a href=\"#准则\" class=\"headerlink\" title=\"准则\"></a>准则</h2><ul>\n<li>减少用户思考</li>\n<li>减少用户心理负担</li>\n</ul>\n<p>原因： 用户时间有限，界面必须易于理解</p>\n<h2 id=\"用户的使用方法\"><a href=\"#用户的使用方法\" class=\"headerlink\" title=\"用户的使用方法\"></a>用户的使用方法</h2><ul>\n<li>82原则，只扫描感兴趣的</li>\n<li>用户只寻求一个可行而非最优的答案</li>\n<li>用户并不关心产品如何运作，会按照某个可用的方式一直使用下去</li>\n</ul>\n<h2 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h2><ul>\n<li>利用习惯性思维，包括页面位置、使用方法、元素外观这些被培养起来的习惯。如无必要，勿增实体。</li>\n<li>层次分明，逻辑上的关联能从视觉上直接体现；能够划分区域</li>\n<li>明确标识可交互元素；提高信噪比，减少不必要视觉干扰</li>\n<li>标题更靠近关联的内容，突出关键词汇</li>\n<li>减少冗余文本，包括欢迎语、指示文字</li>\n</ul>\n<h2 id=\"Web导航\"><a href=\"#Web导航\" class=\"headerlink\" title=\"Web导航\"></a>Web导航</h2><p>重要性：</p>\n<ul>\n<li>用户在web中感受不到方位</li>\n<li>用户需要更快地达成目标</li>\n</ul>\n<p>习惯用法：</p>\n<ul>\n<li>导航部分（或是某些公用部分）固定出现在页面同样位置，会让用户能<strong>立即确认</strong>自己还处在这个网站里<ul>\n<li>在<strong>市场类应用</strong>里，包括站点ID、栏目、实用工具、搜索</li>\n</ul>\n</li>\n<li>站点ID需要有独特可区分的设计</li>\n<li>一个返回首页的导航链接</li>\n<li>简洁明了的搜索框<ul>\n<li>简单的按钮文案</li>\n<li>减少无用的提示文字</li>\n<li>明确可能的搜索选项（如果有的话）</li>\n</ul>\n</li>\n<li>每个页面需要有个名字（保留意见）<ul>\n<li>合适位置</li>\n<li>引人注目</li>\n<li>和链接保持尽量一致</li>\n</ul>\n</li>\n<li>明确告诉用户“我在哪儿”<ul>\n<li>面包屑</li>\n<li>tab</li>\n</ul>\n</li>\n<li>上述元素主要的原因：<strong>现实生活中，用户并不会按照设计师规划好的路径访问网页，可能会来自分享链接、搜索引擎，并不能保证从入口进入。要能让用户在任意一个页面都可以清楚明白它要完成某项任务的话，应该如何使用当前这个网页。</strong></li>\n</ul>\n<h2 id=\"吸引用户时需要注意的地方\"><a href=\"#吸引用户时需要注意的地方\" class=\"headerlink\" title=\"吸引用户时需要注意的地方\"></a>吸引用户时需要注意的地方</h2><p>主页要能传达整体印象。必须能显而易见地直截了当地明白：</p>\n<ul>\n<li>这是什么网站</li>\n<li>我能在里面做什么</li>\n<li>网站里有什么</li>\n<li>为什么选择这个网站</li>\n</ul>\n<p>在用户弄清楚这些问题的最初几秒甚至是最初几毫秒，是决定你能否留住他的关键（晕轮效应）。而且因为上面加粗字体的原因，你可能要在主页外的其他页面也保证这一点。</p>\n<p>一些手段：</p>\n<ul>\n<li>靠近站点ID的简洁的slogan</li>\n<li>一些推介语</li>\n<li>以明确主张为目标占用空间</li>\n<li>在描述使命时保证坦诚</li>\n<li>ab test和数据说话</li>\n</ul>\n<p>好口号和好的站点ID一样，是非常重要的。它需要至少有下面几点特征：</p>\n<ul>\n<li>清晰简洁、言之有物</li>\n<li>明确产品特色与优势，最好是只有你能适用，别的产品都用不了的那种</li>\n<li>最好能再个性、俏皮一点</li>\n</ul>\n<p>当然你们公司足够出名的话，上面这些就当不存在就行。</p>\n<p>接下来的任务就是，告诉用户该<strong>从哪里开始</strong>和避免滥用首页推介。</p>\n<h2 id=\"怎样减少信仰讨论\"><a href=\"#怎样减少信仰讨论\" class=\"headerlink\" title=\"怎样减少信仰讨论\"></a>怎样减少信仰讨论</h2><ul>\n<li>避免关于个人喜好的讨论（如：“我不喜欢下拉框”）</li>\n<li>针对场景，根据经验选择（如：“我认为这种场景下不适合下拉框”）</li>\n<li><strong>充分测试，数据说话反哺经验</strong></li>\n</ul>\n<h2 id=\"如何进行可用性测试\"><a href=\"#如何进行可用性测试\" class=\"headerlink\" title=\"如何进行可用性测试\"></a>如何进行可用性测试</h2><p><em>当下的互联网公司迭代速度之快，可能并没有时间做这方面的研究。</em></p>\n<p>区分开焦点测试（类似于种子用户，听取他们的使用感受和反馈）和可用性测试。</p>\n<ul>\n<li>焦点测试在早期阶段</li>\n<li>可用性测试持续进行</li>\n<li>周期性（比如一个月）进行可行性测试</li>\n<li>暴露严重问题，因为团队可能并没有资源解决所有问题</li>\n<li>应该有个主持人</li>\n</ul>\n<p>最有可能的测试流程：</p>\n<ul>\n<li>介绍部分</li>\n<li>简单的提问部分，了解测试者的背景</li>\n<li>简单的主页浏览，询问感受</li>\n<li>完成测试任务</li>\n<li>问题询问</li>\n</ul>\n<p>典型的问题:</p>\n<ul>\n<li>用户不清楚概念</li>\n<li>用户找不到想要的字眼</li>\n<li>内容太多了</li>\n</ul>\n<h2 id=\"移动时代带来的挑战\"><a href=\"#移动时代带来的挑战\" class=\"headerlink\" title=\"移动时代带来的挑战\"></a>移动时代带来的挑战</h2><ul>\n<li>狭小空间的约束<ul>\n<li>用户需要立即完成或经常重复的工作应该一样就能看到</li>\n<li>其他的事情应该轻点几下就能完成，而且有显而易见的路径到达</li>\n</ul>\n</li>\n<li><strong>兼容多平台的UI解决银弹是很难的</strong></li>\n<li>在UI上给用户足够的按钮，比如一个有着三维样式闪着光的按钮</li>\n<li>意识到没有光标了</li>\n<li>应用最好能“让人快乐”</li>\n<li>移动应用尤其需要<strong>可学习</strong>，然后是<strong>可记忆</strong></li>\n</ul>\n<h2 id=\"用户的好感度\"><a href=\"#用户的好感度\" class=\"headerlink\" title=\"用户的好感度\"></a>用户的好感度</h2><p>降低好感度的几种方式</p>\n<ul>\n<li>隐藏用户想要的信息</li>\n<li>对用户交互不宽容</li>\n<li>询问用户过多信息</li>\n<li>敷衍用户</li>\n<li>看上去不专业</li>\n</ul>\n<p>如何提升好感度</p>\n<ul>\n<li>知道用户想要什么</li>\n<li>简明易懂</li>\n<li>看上去花了心思</li>\n<li>知道用户的可能问题，并给予解释</li>\n<li>提高鲁棒性</li>\n</ul>\n<h2 id=\"如何说服你的老板推进可用性\"><a href=\"#如何说服你的老板推进可用性\" class=\"headerlink\" title=\"如何说服你的老板推进可用性\"></a>如何说服你的老板推进可用性</h2><p>略</p>\n",
            "tags": [
                "笔记",
                "UX",
                "UED",
                "准则"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/03/20/domevent-elementsize-mediatag/",
            "url": "http://shenlvmeng.github.com/blog/2017/03/20/domevent-elementsize-mediatag/",
            "title": "【笔记】JavaScript事件处理机制，元素大小判断与H5的媒体标签",
            "date_published": "2017-03-20T12:45:30.000Z",
            "content_html": "<p>前一阵舍友去面试，被问到JavaScript中的事件处理机制。暗自思忖，发现自己也没有深入的了解过。顺带连同常用的HTML元素大小和实际中用到的HTML5中的媒体元素简单整理在下面，方便之后回顾。</p>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>JavaScript和HTML的交互是通过<strong>事件</strong>实现的。可以通过监听器订阅文档或窗口中的事件，在事件发生时执行特定的代码。这种属于设计模式中的观察者模式。</p>\n<p>事件相关的API最早出现在IE4和NetScape Nivagator4（后面简称为网景）中。两种浏览器提供了相似却不同的API。在之后的DOM2级标准中对DOM事件进行了标准化。</p>\n<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3><p><strong>事件流</strong>描述的是页面中接受时间的顺序。在这点上IE和网景采用了完全相反的两种处理思路。IE采用的是<strong>事件冒泡流</strong>，网景采用的是<strong>事件捕获流</strong>。</p>\n<p>事件冒泡（event bubbling）指从事件开始的最具体的元素接收，再逐步向上传递到最外层的节点，直到<code>document</code>。如下图（来自红宝书）展示的过程，在下面的文档中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Event bubbling<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果div标签被点击，<code>click</code>事件会这样依次传递：<code>&lt;div&gt;</code> -&gt; <code>&lt;body&gt;</code> -&gt; <code>&lt;html&gt;</code> -&gt; <code>document</code>。（不同浏览器实现细节上会有不同）</p>\n<p><img src=\"/blog/blog/images/event-bubbling.jpg\"></p>\n<p>事件捕获（event capturing）则认为应该从父节点开始捕获事件直到事件目标。因此，同样的上面的例子，顺序将是：<code>document</code> -&gt; <code>&lt;html&gt;</code> -&gt; <code>&lt;body&gt;</code> -&gt;  <code>&lt;div&gt;</code>。</p>\n<p><img src=\"/blog/blog/images/event-capturing.jpg\"></p>\n<p>目前很少有人使用事件捕获这种方式作为事件流。</p>\n<h4 id=\"DOM-事件流\"><a href=\"#DOM-事件流\" class=\"headerlink\" title=\"DOM 事件流\"></a>DOM 事件流</h4><p>“DOM2级标准”中规定事件流包括三个阶段，<strong>事件捕获</strong>、<strong>处于目标</strong>、<strong>时间冒泡</strong>。在实际的DOM事件流中，实际目标不会接受到事件。因此如下图展示的那样，捕获阶段停止在父目标<code>&lt;body&gt;</code>上，之后事件发生在目标上，<strong>并作为事件冒泡的一部分</strong>。然后，冒泡阶段发生，事件传回到文档。</p>\n<p><img src=\"/blog/blog/images/DOM2-event-flow.jpg\"></p>\n<h3 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h3><p>事件处理程序指用户指定响应事件的某种动作。它们都以’on’开头。HTML元素本身都可以使用与之同名的HTML特性。</p>\n<h4 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h4><p>DOM0级事件处理程序就是将一个函数直接赋值给一个事件处理程序属性。使用这种方法指定的事件处理程序被认为是元素的一种方法，从而其作用域为元素本身，即<code>this</code>指向引用元素。可以通过直接为事件处理程序属性赋值为null删除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">id</span>); <span class=\"comment\">// &quot;button&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除</span></span><br><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所有浏览器都支持DOM0级事件处理程序。这么做的好处是可以保证浏览器兼容性，缺点是使得HTML和JavaScript紧密耦合，不利用后期维护。</p>\n<h4 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h4><p>伴随DOM2级标准提出，“DOM2级事件”提出了两种方法，用于绑定和解除事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>。它接受3个参数：<strong>事件名</strong>、<strong>事件处理程序对应的函数</strong>、<strong>表示捕获阶段的布尔值</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\">btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">id</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">id</span> + <span class=\"string\">&quot; again.&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用DOM2级方法绑定事件处理程序的一个优点是，<strong>可以添加多个程序到同一个标签上</strong>。使用DOM0级方法时则会覆盖上一次的事件处理程序。IE9及以上版本都支持DOM2级事件处理程序。</p>\n<p>由于IE事件处理程序在IE8之前，是通过类似的<code>attachEvent()</code>和<code>detachEvent()</code>方法。它的第一个参数是事件名（<strong>需要带上on</strong>），第二个参数是事件处理程序。通过这种方法绑定的处理程序都添加在冒泡阶段，且需要注意的是其中的<code>this</code>等于<code>window</code>对象。支持这种方式有IE和Opera。</p>\n<p>因此，一个跨浏览器兼容的事件绑定和解绑应该是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">EventUtil</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">addHandler</span>: <span class=\"keyword\">function</span>(<span class=\"params\">element, type, handler</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element.<span class=\"property\">addEventListener</span>) &#123;</span><br><span class=\"line\">            element.<span class=\"title function_\">addEventListener</span>(type, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element.<span class=\"property\">attachEvent</span>) &#123;</span><br><span class=\"line\">            element.<span class=\"title function_\">attachEvent</span>(<span class=\"string\">&quot;on&quot;</span> + type, handler);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            element[<span class=\"string\">&quot;on&quot;</span> + type] = handler;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">removeHandler</span>: <span class=\"keyword\">function</span>(<span class=\"params\">element, type, handler</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.<span class=\"property\">removeEventListener</span>) &#123;</span><br><span class=\"line\">            element.<span class=\"title function_\">removeEventListener</span>(type, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element.<span class=\"property\">detachEvent</span>) &#123;</span><br><span class=\"line\">            element.<span class=\"title function_\">detachEvent</span>(<span class=\"string\">&quot;on&quot;</span> + type, handler);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            element[<span class=\"string\">&quot;on&quot;</span> + type] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;</p>\n<h2 id=\"元素大小与位置\"><a href=\"#元素大小与位置\" class=\"headerlink\" title=\"元素大小与位置\"></a>元素大小与位置</h2><p>这些属性方法并不属于“DOM2级样式”，但是却经常得到使用。目前所有主流浏览器都支持这些属性。它们大多都是只读的。</p>\n<h3 id=\"偏移量\"><a href=\"#偏移量\" class=\"headerlink\" title=\"偏移量\"></a>偏移量</h3><p><strong>偏移量</strong>描述元素在屏幕中占用的可用空间，由其宽高决定，包括内边距、滚动条和边框（不包括外边距）。有下面4个属性：</p>\n<ul>\n<li><code>offsetHeight</code> 元素垂直方向上的占用空间</li>\n<li><code>offsetWidth</code> 元素水平方向上的占用空间</li>\n<li><code>offsetLeft</code> 元素左边框距<code>offsetParent</code>元素左内边框的像素距离</li>\n<li><code>offsetTop</code> 元素上边框距<code>offsetParent</code>元素上内边框的像素距离</li>\n</ul>\n<p>可以利用元素的<code>offsetLeft</code>或<code>offsetLeft</code>与其<code>offsetParent</code>对应属性相加直到根元素，获取到元素相对于页面的左偏移值或上偏移值。</p>\n<h3 id=\"客户区大小\"><a href=\"#客户区大小\" class=\"headerlink\" title=\"客户区大小\"></a>客户区大小</h3><p><strong>客户区大小</strong>指元素内容和内边距占据的空间大小，不包括滚动条。<code>clientWidth</code>是元素内容宽度加左右内边距的宽度，<code>clientHeight</code>是元素内容高度加上下内边距的高度。</p>\n<p>可以通过对<code>body</code>元素取值来获取当前浏览器视口的大小。</p>\n<h3 id=\"滚动大小\"><a href=\"#滚动大小\" class=\"headerlink\" title=\"滚动大小\"></a>滚动大小</h3><p><strong>滚动大小</strong>包含滚动内容的元素大小。它有下面4个相关属性：</p>\n<ul>\n<li><code>scrollHeight</code> 没有滚动条时，元素内容的高度</li>\n<li><code>scrollWidth</code> 没有滚动条时，元素内容的宽度</li>\n<li><code>scrollLeft</code> 被隐藏在内容区域左侧的像素数，可以设置从而改变元素滚动位置</li>\n<li><code>scrollTop</code> 被隐藏在内容区域上侧的像素数，可以设置从而改变元素滚动位置</li>\n</ul>\n<p><code>scrollHeight/scrollWidth</code>和<code>clientHeight/clientWidth</code>在不同浏览器下的表现行为并不相同，有的表示视口大小，有的表示元素内容区域大小。使用时可以<strong>取较大值</strong>。而另外两个属性<code>scrollLeft</code>和<code>scrollTop</code>则通常用在<code>document</code>中，获取和滚动相关的属性。</p>\n<h3 id=\"确定元素大小\"><a href=\"#确定元素大小\" class=\"headerlink\" title=\"确定元素大小\"></a>确定元素大小</h3><p>大多数主流浏览器为元素提供了<code>getBoundingClientRect()</code>方法，返回一个对象，包含<code>left</code>，<code>right</code>，<code>top</code>，<code>bottom</code>四个属性。给出了元素相对于视口的位置。</p>\n<p>对不支持这个方法的浏览器，可以通过偏移量的相关属性获取。</p>\n<p>&#x3D;&#x3D;&#x3D;</p>\n<h2 id=\"媒体元素\"><a href=\"#媒体元素\" class=\"headerlink\" title=\"媒体元素\"></a>媒体元素</h2><p>HTML5出现前，提供富媒体内容的网站多采用Flash的方式保证浏览器兼容性。HTML5新增了两个标签<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio\"><code>&lt;audio&gt;</code></a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a>。用于方便地嵌入音频和视频内容。同时，这两个标签也提供了实现常用功能的JavaScript API。允许为媒体创建自定义控件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;demo.mpg&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span>Video player is not available.<span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;song.mp3&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bar&quot;</span>&gt;</span>Audio player is not available.<span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中元素的<code>src</code>属性指定了加载的媒体文件，还可以通过<code>width</code>和<code>height</code>属性指定播放器大小。<code>controls</code>属性意味浏览器应该显示UI控件用于操作媒体。标签中的内容用于在不支持时显示后备内容。</p>\n<p>因为不同浏览器支持的媒体格式集并不完全相同，可以在标签下指定<strong>一或多个</strong><code>&lt;source&gt;</code>元素，通过<code>src</code>和<code>type</code>属性指定来源和格式，视频标签下<code>&lt;source&gt;</code>的<code>type</code>中甚至可以指定<code>codecs</code>表示解码器。目前现代浏览器（IE9+，对IE说的就是你）都支持这两个标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myVideo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;foo.mpg&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;foo.webm&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;video/webm; codecs=vp8, vorbis&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;song.ogg&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;song.mp3&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p><code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>提供了完善的JavaScript接口，下面是一些可能会用到的它们的属性。其中很多可以直接在标签元素上设置。</p>\n<ul>\n<li><code>autoplay</code> 取消或设置当前<code>autoplay</code>标识</li>\n<li><code>controls</code> 取消或设置当前<code>controls</code>标识，用于显示和隐藏浏览器内置控件</li>\n<li><code>currentTime</code> 获取已经播放的秒数</li>\n<li><code>duration</code> 获取媒体的总长度（秒数）</li>\n<li><code>ended</code> 获取媒体是否播放完成</li>\n<li><code>loop</code>  取消或设置媒体文件是否循环播放</li>\n<li><code>muted</code> 取消或设置媒体文件是否静音</li>\n<li><code>paused</code> 标识播放器是否暂停</li>\n<li><code>playbackRate</code> 取消或设置当前播放速度</li>\n<li><code>readyState</code> 标识媒体是否就绪，有0，1，2，3四种情况，表示不可用、可以播放当前帧、可以播放、加载完毕</li>\n<li><code>src</code> 媒体文件来源，可重写</li>\n<li><code>volume</code> 取消或设置当前音量，值为0.0到1.0</li>\n</ul>\n<h3 id=\"事件-1\"><a href=\"#事件-1\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>这两个媒体元素还有许多事件，有的是媒体播放的结果，有的是用户操作的结果。</p>\n<ul>\n<li><code>abort</code> 下载中断</li>\n<li><code>canplay</code> 对应着<code>readyState</code>为2</li>\n<li><code>canplaythrough</code> 对应着<code>readyState</code>为3</li>\n<li><code>ended</code> 媒体播放完毕</li>\n<li><code>error</code> 下载过程网络错误</li>\n<li><code>pause</code> 播放暂停</li>\n<li><code>play</code>  媒体收到播放指令</li>\n<li><code>playing</code> 媒体开始播放</li>\n<li><code>ratechange</code> 播放速度改变</li>\n<li><code>seeked</code> 移动到新位置</li>\n<li><code>seeking</code> 正在移动进度条</li>\n<li><code>volumnchange</code> <code>volumn</code>和<code>muted</code>属性值改变</li>\n<li><code>waiting</code> 播放因下载未完成暂停</li>\n</ul>\n<p>在如此丰富的属性和事件的帮助下，结合<code>play()</code>和<code>pause()</code>方法，我们可以很容易构建一个自定义的媒体播放器。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;player&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;player__content&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;video&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;movie.mov&quot;</span> <span class=\"attr\">poster</span>=<span class=\"string\">&quot;movie.jpg&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;400&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;200&quot;</span>&gt;</span></span><br><span class=\"line\">      Video is not supported.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;player__control&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Play!&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;video-play&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;curtime&quot;</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>/<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;duration&quot;</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> player = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;video&quot;</span>),</span><br><span class=\"line\">    btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;video-play&quot;</span>),</span><br><span class=\"line\">    curtime = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;curtime&quot;</span>),</span><br><span class=\"line\">    duration = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;duration&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新播放时间</span></span><br><span class=\"line\">duration.<span class=\"property\">innerHTML</span> = player.<span class=\"property\">duration</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为按钮添加处理事件</span></span><br><span class=\"line\"><span class=\"title class_\">EventUtil</span>.<span class=\"title function_\">addHandler</span>(btn, <span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (player.<span class=\"property\">paused</span>) &#123;</span><br><span class=\"line\">        player.<span class=\"title function_\">play</span>();</span><br><span class=\"line\">        btn.<span class=\"property\">value</span> = <span class=\"string\">&quot;Pause!&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        player.<span class=\"title function_\">pause</span>();</span><br><span class=\"line\">        btn.<span class=\"property\">value</span> = <span class=\"string\">&quot;Play!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定时更新时间</span></span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    curtime.<span class=\"property\">innerHTML</span> = player.<span class=\"property\">currentTime</span>;</span><br><span class=\"line\">&#125;, <span class=\"number\">250</span>);</span><br></pre></td></tr></table></figure>\n\n<p>最后，不是所有浏览器都支持这两个标签的所有解码器，因此有一个API来检测浏览器是否支持某种解码器。通过<code>canPlayType()</code>方法，该方法接收格式&#x2F;编解码器（如”<code>audio/wav</code>“）字符串，返回”probably”, “maybe”或是空字符串””。像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (audio.<span class=\"title function_\">canPlayType</span>(<span class=\"string\">&quot;audio/mpeg&quot;</span>))&#123;</span><br><span class=\"line\">    <span class=\"comment\">//进一步处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "HTML",
                "JavaScript",
                "DOM",
                "笔记"
            ]
        }
    ]
}
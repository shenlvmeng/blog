{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"代码\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2023/11/30/language-hidden-behind-computer/",
            "url": "http://shenlvmeng.github.com/blog/2023/11/30/language-hidden-behind-computer/",
            "title": "《Code》—— 从手电筒到计算机",
            "date_published": "2023-11-30T14:06:46.000Z",
            "content_html": "<blockquote>\r\n<p>大纲向</p>\r\n</blockquote>\r\n<p>《Code: The Hidden Language of Computer Hardware and\r\nSoftware》书名挺长，但是本好书。要是大学时期的老师按照书里的思路展开计算机专业部分的课程，我也不至于学了两年编程还是囫囵吞枣，只能邯郸学步。书里顺带还涉及了信号系统、数字电路等计算机外的部分内容，简直不能更适合当做信息工程或通信工程专业学生的课外读物。相比国内大学教材居高临下式的填鸭式讲法，我看到的几本国外教材（<a\r\nhref=\"https://shenlvmeng.github.io/blog/2018/05/01/sicp-note/\">计算机程序的构造和解释</a>、Gilbert\r\nStrang的<a\r\nhref=\"https://book.douban.com/subject/34820335/\">线性代数</a>）由浅入深、循循善诱的展开方式友好了许多。《Code》这本书虽然严格来说不算教材，只是计算机原理入门，但也相当适合和微机原理有缘分的人买来看看。浅显的文笔不会阻碍你深刻认识到计算机工作原理。</p>\r\n<p>全书1-10章对于计算机相关专业学生来说，很易理解，读起来很快。但从11章起到17章自动操作，内容突然有深度起来，读起来颇有思维体操的感觉。在18章了解芯片历史，短暂歇口气后，从19章到22章，你将完整了解到操作系统是怎么建立起来的。在此基础上，最后3章里介绍编程语言时，就一点也不突兀，很好理解了。</p>\r\n<h2 id=\"作者序\">作者序</h2>\r\n<ul>\r\n<li>内存和外存的区别体现了实际需求和可观性能的矛盾，简单说就是我们目前找不到同时具备两种存储所有优点（既快又持久）的存储媒介</li>\r\n</ul>\r\n<h2 id=\"至亲密友\">至亲密友</h2>\r\n<ul>\r\n<li>编码就是交流</li>\r\n<li>2个不同事物通过组合，可以表示所有信息</li>\r\n</ul>\r\n<h2 id=\"编码与组合\">编码与组合</h2>\r\n<ul>\r\n<li>摩尔斯电码</li>\r\n</ul>\r\n<h2 id=\"布莱叶盲文和二进制码\">布莱叶盲文和二进制码</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://zh.wikipedia.org/wiki/%E7%9B%B2%E6%96%87\">布莱叶盲文</a>用6个位置的凸点有无编码表示字符</li>\r\n</ul>\r\n<h2 id=\"手电筒的剖析\">手电筒的剖析</h2>\r\n<ul>\r\n<li>电压、电流、电阻、欧姆定律、功率</li>\r\n<li>开关的两种状态</li>\r\n</ul>\r\n<h2 id=\"绕过拐角的通信\">绕过拐角的通信</h2>\r\n<ul>\r\n<li>电路的串联、并联</li>\r\n<li>电路的尺寸极限</li>\r\n</ul>\r\n<h2 id=\"电报机和继电器\">电报机和继电器</h2>\r\n<ul>\r\n<li>利用电磁现象的电报机和继电器</li>\r\n</ul>\r\n<h2 id=\"数字和计数\">数字和计数</h2>\r\n<ul>\r\n<li>十进制的来源</li>\r\n<li>其他进制和二进制</li>\r\n</ul>\r\n<h2 id=\"二进制数\">二进制数</h2>\r\n<ul>\r\n<li>二进制是最简单的数字系统</li>\r\n<li>利用冗余可以消除信息里噪音的影响</li>\r\n<li>通用产品代码（条形码）的编码方式\r\n<ul>\r\n<li>奇偶校验</li>\r\n<li>模校验字符</li>\r\n<li>正反可读</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"逻辑与开关\">逻辑与开关</h2>\r\n<ul>\r\n<li>布尔代数的来源</li>\r\n<li>布尔代数的集合解释</li>\r\n<li>布尔代数的电路表示</li>\r\n</ul>\r\n<h2 id=\"门\">门</h2>\r\n<blockquote>\r\n<p>自此章起，终于开始进入数字电路到计算机的领域，<strong>逻辑门是其中最基础的单元</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li>串并联和与或门</li>\r\n<li>与或非门的继电器表示</li>\r\n<li>与非门和或非门的继电器表示</li>\r\n<li>德摩根律</li>\r\n</ul>\r\n<h2 id=\"二进制加法器\">二进制加法器</h2>\r\n<ul>\r\n<li>二进制表示下的加法\r\n<ul>\r\n<li>或门（结果输出）+ 与非门（进位输出）</li>\r\n</ul></li>\r\n<li>半加器和全加器（考虑了进位输入的半加器）</li>\r\n<li>8个全加器构成的<strong>8位加法器</strong></li>\r\n<li>行波进位</li>\r\n</ul>\r\n<h2 id=\"如何实现减法\">如何实现减法</h2>\r\n<ul>\r\n<li>补码和反码：用来将减法转化为加法</li>\r\n<li>有符号数和无符号数\r\n<ul>\r\n<li>有符号数首位1表示负数</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"反馈与触发器\">反馈与触发器</h2>\r\n<ul>\r\n<li>反馈是更复杂电路的基础</li>\r\n<li>振荡器：单纯取反后反馈到输入端的电路\r\n<ul>\r\n<li>周期和频率</li>\r\n</ul></li>\r\n<li>更复杂的反馈可以构成记忆电路状态的<strong>触发器</strong></li>\r\n<li>RS触发器，可以记忆置位和复位的值</li>\r\n<li>D型触发器，在保持位为1时，才会保存数据端输入</li>\r\n<li>D型触发器构成的8位<strong>锁存器</strong></li>\r\n<li>电平触发和边沿触发</li>\r\n<li>边沿触发的D型触发器</li>\r\n<li>分频器和8位行波计数器</li>\r\n</ul>\r\n<h2 id=\"字节和十六进制\">字节和十六进制</h2>\r\n<ul>\r\n<li>字节的来源\r\n<ul>\r\n<li>8位的长度刚好可以表示大多数书面语言的基本字符，对于象形文字，用2个字节也够了</li>\r\n</ul></li>\r\n<li>字节的十六进制表示</li>\r\n<li>十六进制和二进制的转换</li>\r\n</ul>\r\n<h2 id=\"存储器结构\">存储器结构</h2>\r\n<ul>\r\n<li>8-1选择器和3-8译码器</li>\r\n<li>8×1RAM：结合了选择器和译码器的8位锁存器\r\n<ul>\r\n<li>译码器和选择器的选择信号相同，这个信号也可以叫做<strong>地址</strong></li>\r\n<li>8×1RAM里各比特相互独立</li>\r\n</ul></li>\r\n<li>将2个8×1RAM用共享地址的方式连接到同一个地址/数据/写操作端上，可以得到8×2RAM</li>\r\n<li>将2个8×1RAM组合1个2-1选择器和一个1-2译码器，可以得到一个16×1RAM</li>\r\n<li>RAM的存储容量是2<sup>地址输入端个数</sup></li>\r\n<li>KB、MB、TB、PB、EB</li>\r\n<li>64K×8RAM需要2个字节表示的地址</li>\r\n<li>RAM需要恒定的电流来维持数据</li>\r\n</ul>\r\n<h2 id=\"自动操作\">自动操作</h2>\r\n<ul>\r\n<li>振荡器 + 16位计数器 + 64K×8RAM + 8位加法器构成的自动累加器</li>\r\n<li>代码和数据的区分\r\n<ul>\r\n<li>单独用一块64K×8RAM存储代码，代码指导机器如何操作</li>\r\n</ul></li>\r\n<li>操作码和操作数</li>\r\n<li>第3个字节：操作数的存储地址\r\n<ul>\r\n<li>避免了顺序存储的问题</li>\r\n</ul></li>\r\n<li>新的寻址方式：Jump指令\r\n<ul>\r\n<li>从指定地址开始寻址指令</li>\r\n</ul></li>\r\n<li>计算机区分于计算器的基础：条件跳转指令\r\n<ul>\r\n<li>零转移/进位转移/非零转移/无进位转移</li>\r\n</ul></li>\r\n<li>算术逻辑单元，ALU</li>\r\n<li>助记符表示下的机器码\r\n<ul>\r\n<li>MOV/LOD/STO/ADD/SUB/ADC/SBB/JMP/...</li>\r\n<li>汇编语言、手动汇编</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"从算盘到芯片\">从算盘到芯片</h2>\r\n<ul>\r\n<li>算盘</li>\r\n<li>对数表、对数尺</li>\r\n<li>机械计算器</li>\r\n<li>自动织布机与打孔的金属卡片</li>\r\n<li>巴贝奇的差分机和解析机</li>\r\n<li>赫尔曼·霍尔瑞斯的制表机\r\n<ul>\r\n<li>再次基础上，他成立了IBM</li>\r\n</ul></li>\r\n<li>从MARK I到13000个继电器的MARK II</li>\r\n<li>Grace Murray Hopper发现的第一个“bug”</li>\r\n<li>真空管的发明</li>\r\n<li>图灵的贡献\r\n<ul>\r\n<li>图灵机，可计算性</li>\r\n<li>图灵测试法</li>\r\n</ul></li>\r\n<li>ENIAC，此时仍在使用十进制数</li>\r\n<li>冯诺依曼和他的EDVAC\r\n<ul>\r\n<li>二进制数</li>\r\n<li>存储代码和数据的存储器</li>\r\n<li>程序计数器寻址</li>\r\n<li>允许条件跳转</li>\r\n</ul></li>\r\n<li>香农和信息论</li>\r\n<li>维纳和控制论</li>\r\n<li>UNIVAC</li>\r\n<li>晶体管的发明和半导体</li>\r\n<li>NPN晶体管</li>\r\n<li>集成电路（IC），又叫芯片\r\n<ul>\r\n<li>TTL（晶体管-晶体管逻辑，响应快功率高）和CMOS（互补金属氧化物半导体，响应慢功率低）</li>\r\n</ul></li>\r\n<li>摩尔定律</li>\r\n<li>Intel 4004，第一块计算机芯片，或者说微处理器</li>\r\n<li>Intel 4040，Intel 8008</li>\r\n</ul>\r\n<h2 id=\"两种典型的微处理器\">两种典型的微处理器</h2>\r\n<ul>\r\n<li>Intel 8008的改进：Intel 8080和Motorola 6800</li>\r\n<li>Intel 8080\r\n<ul>\r\n<li>振动器输入</li>\r\n<li>电源输出</li>\r\n<li>接地</li>\r\n<li>寻址信号</li>\r\n<li>控制信号</li>\r\n<li>数据信号</li>\r\n</ul></li>\r\n<li>汇编里的助记符只是方便我们使用，处理器只能读取字节</li>\r\n<li>8080中设置更方便处理器读取信息的寄存器</li>\r\n<li>直接寻址和间接寻址</li>\r\n<li>栈和程序计数器</li>\r\n<li>Call命令和子程序</li>\r\n<li>内存映像I/O和中断</li>\r\n<li>Motorola 6800</li>\r\n<li>little-endian（Intel方式）和big-endian（Motorola方式）\r\n<ul>\r\n<li>高低位字节存储方式在Intel和Motorola芯片里不同，Intel是低字节在前，Motorola则是高字节在前</li>\r\n<li>命名来源于《吉列佛游记》里关于吃鸡蛋前先敲碎哪个头的讨论</li>\r\n</ul></li>\r\n<li>8080被应用在第一台家用电脑Altair 8800上</li>\r\n<li>Apple II应用了6800的MOS技术改进版6502</li>\r\n<li>IBM在IBM PC(IBM\r\n5150)里使用了8088芯片，8088芯片的内部结构和8086类似，和8080的操作吗不兼容</li>\r\n<li>x86系列微处理器包括1982年发布的186和286芯片。之后又发布了32位的386和后续的486以及Intel\r\nPentium系列微处理器，尽管指令集不断扩展，但都支持8086起的所有处理器操作码</li>\r\n<li>Macintosh采用了Motorola的68000微处理器，并从1994年起使用RISC（精简指令集计算机）微处理器体系的PowerPC微处理器</li>\r\n<li>流水线技术（pipelining）和Cache（高速缓冲存储器）</li>\r\n</ul>\r\n<h2 id=\"ascii码和字符转换\">ASCII码和字符转换</h2>\r\n<ul>\r\n<li>Baudot码/Murray编码\r\n<ul>\r\n<li>转义</li>\r\n</ul></li>\r\n<li>ASCII码\r\n<ul>\r\n<li>7位编码</li>\r\n<li>控制字符</li>\r\n</ul></li>\r\n<li>BCD编码</li>\r\n<li>8位的ASCII码</li>\r\n<li>中日韩字符编码</li>\r\n<li>2字节的Unicode编码\r\n<ul>\r\n<li>支持象形文字</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"总线\">总线</h2>\r\n<ul>\r\n<li>总线信号\r\n<ul>\r\n<li>地址信号</li>\r\n<li>数据输入信号</li>\r\n<li>数据输出信号</li>\r\n<li>控制信号</li>\r\n</ul></li>\r\n<li>MCA总线/PCI总线</li>\r\n<li>SRAM、DRAM</li>\r\n<li>电子射线管（CRT）</li>\r\n<li>水平回归、垂直回归</li>\r\n<li>隔行扫描</li>\r\n<li>分辨率</li>\r\n<li>键盘实现</li>\r\n<li>磁带</li>\r\n<li>软盘和磁盘\r\n<ul>\r\n<li>磁道和扇区</li>\r\n<li>直接内存访问技术（DMA）</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"操作系统\">操作系统</h2>\r\n<ul>\r\n<li>PROM、EPROM</li>\r\n<li>文件系统</li>\r\n<li>CP/M</li>\r\n<li>引导系统</li>\r\n<li>API</li>\r\n<li>QDOS -&gt; MS-DOS\r\n<ul>\r\n<li>层次文件系统</li>\r\n</ul></li>\r\n<li>UNIX和UNIX思想\r\n<ul>\r\n<li>GNU</li>\r\n</ul></li>\r\n<li>多任务</li>\r\n<li>内存管理</li>\r\n</ul>\r\n<h2 id=\"定点数和浮点数\">定点数和浮点数</h2>\r\n<ul>\r\n<li>定点：小数点的位置总在数的某个特定位置</li>\r\n<li>浮点：基于科学计数法\r\n<ul>\r\n<li>4个字节的单精度</li>\r\n<li>8个字节的双精度</li>\r\n<li>IEEE标准浮点数</li>\r\n<li>精度问题</li>\r\n</ul></li>\r\n<li>数字协同处理器</li>\r\n</ul>\r\n<h2 id=\"高级语言和低级语言\">高级语言和低级语言</h2>\r\n<ul>\r\n<li>第一个编写汇编器的人需要手工对程序汇编。之后新的汇编器可以在已有的计算机上编写，利用已有的汇编器进行汇编，这种方式也叫<strong>交叉汇编</strong>。</li>\r\n<li>编译器（程序 -&gt; 机器码）</li>\r\n<li>FORTRAN，科学计算语言</li>\r\n<li>ALGOL，高级语言的鼻祖\r\n<ul>\r\n<li>for循环</li>\r\n<li>if语句</li>\r\n<li>块、变量声明</li>\r\n<li>数组</li>\r\n</ul></li>\r\n<li>计算机科学又像工程，又像艺术</li>\r\n<li>COBOL，第一个成功为商业系统使用的程序设计语言</li>\r\n<li>BASIC</li>\r\n<li>解释型语言，边读边执行</li>\r\n<li>Pascal、Turbo Pascal</li>\r\n<li>Ada</li>\r\n<li>C，BCPL（Basic CPL）的后继者</li>\r\n<li>LISP、APL</li>\r\n<li>面向对象程序设计语言</li>\r\n</ul>\r\n<h2 id=\"图形化革命\">图形化革命</h2>\r\n<ul>\r\n<li>用户界面</li>\r\n<li>SAGE\r\n<ul>\r\n<li>光笔</li>\r\n</ul></li>\r\n<li>鼠标</li>\r\n<li>Xerox，PARC，Alto工程</li>\r\n<li>图形界面和图形对象</li>\r\n<li>Macintosh和Mac系统</li>\r\n<li>Windows系统</li>\r\n<li>面向对象语言\r\n<ul>\r\n<li>SmallTalk语言</li>\r\n<li>C++</li>\r\n<li>Java</li>\r\n</ul></li>\r\n<li>集成开发环境（IDE）</li>\r\n<li>文本信息编码\r\n<ul>\r\n<li>RTF</li>\r\n<li>PostScript</li>\r\n</ul></li>\r\n<li>计算机图形\r\n<ul>\r\n<li>矢量 -&gt; CAD（计算机辅助设计）</li>\r\n<li>光栅 -&gt; 位图</li>\r\n</ul></li>\r\n<li>CCD（电荷耦合器）\r\n<ul>\r\n<li>光感度不同对应不同的像素值阵列（模拟信号 -&gt; 数字信号）</li>\r\n<li>数码相机、CD、DVD、VCD</li>\r\n</ul></li>\r\n<li>数据压缩\r\n<ul>\r\n<li>无损压缩\r\n<ul>\r\n<li>游程长度编码（RLE）</li>\r\n<li>GIF和LZW压缩</li>\r\n</ul></li>\r\n<li>有损压缩\r\n<ul>\r\n<li>JPEG</li>\r\n<li>OCR</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>脉冲编码调制技术（PCM）\r\n<ul>\r\n<li>ADC（模拟数字转换器）和DAC（数字模拟转换器）</li>\r\n<li>采样率和奈奎斯特采样定律</li>\r\n</ul></li>\r\n<li>语言识别</li>\r\n<li>MIDI合成器</li>\r\n<li>MPEG</li>\r\n<li>调制和解调</li>\r\n<li>Internet\r\n<ul>\r\n<li>WWW</li>\r\n<li>HTTP</li>\r\n<li>CGI</li>\r\n<li>JavaScript</li>\r\n</ul></li>\r\n</ul>\r\n<p><em>--END--</em></p>\r\n",
            "tags": [
                "代码",
                "计算机",
                "微机原理",
                "门",
                "操作系统",
                "数字电路"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/12/02/clean-code/",
            "url": "http://shenlvmeng.github.com/blog/2019/12/02/clean-code/",
            "title": "《代码整洁之道》——有一个好的代码品味",
            "date_published": "2019-12-02T15:08:32.000Z",
            "content_html": "<blockquote>\n<p>The only valid measurement of code quality: WTFs&#x2F;minute</p>\n</blockquote>\n<p>在成为一个程序员的初期，实现功能还需磕磕绊绊的阶段，我们大抵没有精力操心代码风格的问题；而在能够搞定环境和API使用的时间段，大部分人又会沉湎于使用一门语言让想象实现的成就感，而没有发现暗藏在迭代后的危机。往往迭代了一段时间后，才发现之前埋下的巨坑已经让自己无从下手。这时一部分人醒悟过来，意识到一个优良的代码风格对于项目推进的长远意义。这也是《Clean Code》这本书的宗旨。它较之《程序员修炼之道》更为具体，较之《重构》更为宏观。对于工作一段时间后的程序员来说，是一个很好的提醒和反思归纳的建议。让代码work的方式是千万种，而让代码可持续，可扩展，长久work的方式也许需要前辈指引些方法。</p>\n<h2 id=\"观念\"><a href=\"#观念\" class=\"headerlink\" title=\"观念\"></a>观念</h2><blockquote>\n<p>Later equals never —— Leblanc Law</p>\n</blockquote>\n<p>糟糕的代码会让人难以下手，拖慢进度，若无人着手改善，混乱会持续增加，进而降低团队生产力，降低人效，然后搞砸整个项目。为什么不一开始就打好基础，写出整洁代码呢？</p>\n<p>下面是一些大师对“整洁代码”的界定</p>\n<ul>\n<li>“代码逻辑直截了当，缺陷难以隐藏；减少依赖关系，从而便于维护；性能调优，省得引人做出没规矩的优化，干出蠢事；整洁的代码只干一件事” —— Bjarne Stroustrup</li>\n<li>“代码简单直接，如同优美的散文；从不隐藏设计者的意图，充满干净利落的抽象和直截了当的控制语句” —— Grady Booch</li>\n<li>“可由作者外的人阅读和扩展，应该有单元测试和验收测试；只使用有意义的命名；提供尽量正交的使用方法（一种而非多种做一件事的方法）；尽量少的API；尽量少的依赖关系，且要明确定义和清晰提供；代码应从字面意义上表达其含义” —— Dave Thomas</li>\n<li>“整洁的代码总是看起来像某位特别在意的人写的，几乎没有改进的余地，所有的改进都会回到原点” —— Michael Feather</li>\n<li>“能通过所有测试；没有重复代码，表达力强大；体现系统中的全部设计理念；包括尽量少的实体，如类、方法、函数。” —— Ron Jeffries</li>\n<li>“整洁代码让每个例程都深合己意；漂亮代码让语言看起来像是专门为解决那个问题而存在” —— Ward Cunningham</li>\n</ul>\n<p>编写代码的难度，取决于读周边代码的难度，要想干得快，就先让代码易读。</p>\n<blockquote>\n<p>让营地比你来时更干净 —— 童子军军规</p>\n</blockquote>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>好的命名，可以让人一眼就明白代码的逻辑。看下面两段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"type\">int</span>[]&gt; getThem() &#123;</span><br><span class=\"line\">  List&lt;<span class=\"type\">int</span>[]&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] x : theList)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x[<span class=\"number\">0</span>] == <span class=\"number\">4</span>)</span><br><span class=\"line\">      list1.add(x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Cell&gt; <span class=\"title function_\">getFlaggedCells</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  List&lt;Cell&gt; flaggedCells = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Cell&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Cell cell : gameBoard)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cell.isFlagged)</span><br><span class=\"line\">      flaggedCells.add(cell);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些准则：</p>\n<ul>\n<li>名副其实，一旦发现更好的，就替换掉旧的。<strong>如果名称还需要注释补充，那就不算名副其实</strong></li>\n<li>避免误导，提防使用不同之处较小的名称，比如<code>UsernameListEmptyFilter</code>和<code>UsernameListNullFilter</code>，不要混用1和l，以及0和O</li>\n<li>做有意义的区分，少废话，反例是<code>a1</code>和<code>a2</code>，<code>nameString</code>和<code>name</code></li>\n<li>使用<strong>能读出来</strong>的名称，方便程序员的沟通</li>\n<li>使用<strong>可搜索</strong>的名称，仅在块作用域或短函数内使用单字母名称</li>\n<li>不把类型信息放在名称中</li>\n<li>减少不必要的前缀和后缀</li>\n<li>类名应该是名词，方法名应该是动词或动词短语</li>\n<li>别玩梗</li>\n<li>标准化语素，为每一个抽象概念选择一个统一的词</li>\n<li>别用有多重含义的词汇，这会增加使用者顾虑和理解成本</li>\n<li>只在没有明确定义的场景下使用语境（类，前缀……）</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>下面是一些准则：</p>\n<ul>\n<li><strong>短小，更短小</strong></li>\n<li><strong>只做一件事，只做一件事，只做一件事</strong>，重要的事情说三遍<ul>\n<li>还有一种方式可以帮助判断函数是不是只做了一件事：<strong>函数语句是否在一个抽象层级上</strong></li>\n<li>只做一件事的函数无法被继续合理拆分成多段</li>\n</ul>\n</li>\n<li>让代码拥有从上到下的自然的阅读顺序，尽量避免跳来跳去的阅读顺序</li>\n<li>为函数使用<strong>描述性</strong>的名称</li>\n<li>函数<strong>最多3个入参</strong>，最理想是没有参数，其次是1个，再其次是2个，要避免3个参数<ul>\n<li><strong>布尔类型的参数会让你的函数难以理解</strong></li>\n<li>使用二元参数时，最好保证前后顺序不敏感</li>\n<li>对于复杂的入参，可以用对象封装起来</li>\n</ul>\n</li>\n<li>函数要么只做副作用（<em>做什么事</em>），要么没有副作用（<em>回答什么事</em>），而且能从名称中一目了然地看到</li>\n<li>用异常代替错误码，错误处理也是一件事</li>\n<li><strong>别重复自己（Don’t repeat yourself, DRY）</strong>。重复是软件中一切邪恶的根源，软件开发领域的所有创新都在不断尝试从源代码中消灭重复</li>\n</ul>\n<p>函数是语言的动词，类是名词。大师级的程序员把系统当做故事来讲，而不是程序来写。他们使用特定编程语言提供的工具构建一种<strong>更丰富和更具表达力的语言</strong>。好的函数必须干净利落的组合在一起，形成清晰明确的语言，帮你<strong>讲好故事</strong>。这个过程不是一蹴而就的，你可以现象什么就写什么，然后一点点打磨它。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><blockquote>\n<p>使用注释 &#x3D; 承认自己无法用代码表达清楚意图</p>\n</blockquote>\n<p>列举注释的准则前，必须摆正观念。<strong>注释是一种必须的恶，如果编程语言足够有表达力，或你长于用语言表达自己的意图，那么就不需要注释。注释的恰当用法是弥补我们用代码表达意图时遭遇的失败。</strong>注释存在的时间越久，具体所描述的事实就越远。原因很简单，程序员不可能坚持维护注释。</p>\n<p>的确，程序员应该让注释保持可维护而精准，但最好能直接写清楚代码，保证无须编写注释。<strong>真实只在一处：代码</strong>，只有代码能忠实告诉你它做的事。</p>\n<ul>\n<li><strong>注释无法挽救糟糕的代码</strong>，与其为糟糕代码补充大量注释，不如花时间写出整洁有表达力的代码</li>\n<li><strong>用代码代替注释</strong></li>\n<li>有些无法避免且合理存在的注释<ul>\n<li>法律信息</li>\n<li>对函数名的补充</li>\n<li>对稍微反常规意图的解释，避免误解</li>\n<li>糟糕的代码来自外部库或外部API</li>\n<li>敏感代码的警告</li>\n<li>TODO、FIXME</li>\n<li>Javadoc</li>\n</ul>\n</li>\n<li>下面则是一些很常见的糟糕注释，它们只是糟糕代码的借口<ul>\n<li>只有自己看得懂的注释</li>\n<li>对函数名的复述</li>\n<li>误导性注释</li>\n<li>日志型注释，如Milestone记录</li>\n<li>废话</li>\n<li>位置标记，如<code>====================</code></li>\n<li>代码署名</li>\n<li><em>大多数</em>注释掉的代码</li>\n<li>百科式的介绍</li>\n<li>私有代码的Javadoc</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>格式即代码风格，可以利用lint这样的自动化工具完成，需要在团队内保持一致。</p>\n<h3 id=\"垂直格式\"><a href=\"#垂直格式\" class=\"headerlink\" title=\"垂直格式\"></a>垂直格式</h3><p>在从上到下的组织上，</p>\n<ul>\n<li>可以向报纸一样，先大纲，再粗线条概述，再给出细节，越往下细节越多</li>\n<li>用<strong>空行</strong>分隔概念</li>\n<li>靠近的代码行暗示了代码间的紧密关系</li>\n<li>应避免迫使读者在源文件和类之间跳来跳去<ul>\n<li>变量声明应尽量靠近使用位置</li>\n<li>循环中的控制变量总在循环语句中声明</li>\n<li>类成员在类顶部声明</li>\n<li>如果某个函数调用了另一个，就应该把它们放一起</li>\n<li>概念相关的代码应该放在一起，如<code>getHour</code>和<code>getMinute</code></li>\n<li>如果可以，最好把被调用的函数放在执行调用的函数下面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"横向格式\"><a href=\"#横向格式\" class=\"headerlink\" title=\"横向格式\"></a>横向格式</h3><ul>\n<li>水平字符的上限，100或120</li>\n<li>使用<strong>空格</strong>分隔概念</li>\n<li><strong>不需要水平对齐</strong>，以为从左到右的阅读顺序优先于从上到下</li>\n<li>学会用<strong>缩进</strong>表现层级</li>\n</ul>\n<h2 id=\"对象和数据结构\"><a href=\"#对象和数据结构\" class=\"headerlink\" title=\"对象和数据结构\"></a>对象和数据结构</h2><ul>\n<li><strong>对象</strong>把数据隐藏于抽象的后面，暴露操作数据的函数，<strong>数据结构</strong>暴露数据，不提供有意义的函数。</li>\n<li>过程式代码难以添加新的数据结构，因为必须修改所有函数；面向对象代码难以添加新函数，因为必须修改所有类</li>\n<li>得墨忒尔律：类C的方法f只应该调用以下对象的方法：<strong>C、f创建的对象、作为参数传给f的对象、C的成员所持有的对象</strong></li>\n<li><strong>数据结构</strong>只简单地拥有公有变量，没有函数；而<strong>对象</strong>则只拥有私有变量和函数。一半是对象一半是数据结构的混淆会增加添加新函数和数据结构的难度</li>\n<li>DTO（Data Transfer Objects，数据传输对象）就是只有公有变量，没有函数的类，Active Record就是DTO的一种</li>\n</ul>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>错误处理很重要，但要是它搞乱了代码逻辑，那就是错误的用法。</p>\n<ul>\n<li>返回异常而不是错误码</li>\n<li>try-catch-finally语句块就像事务，可以帮你定义用户应该期待些什么</li>\n<li>在Java中，可控异常违反开闭原则带来的成本要高于收益</li>\n<li>打包第三方API，一方面降低了依赖的覆盖面，另一方面也有助于模拟第三方调用</li>\n<li>可以把抛出错误封装成特定的函数</li>\n<li>别返回和传递null值</li>\n</ul>\n<h2 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h2><p>边界即我们代码和第三方代码的连接处。</p>\n<ul>\n<li>通过编写测试来概览和理解第三方代码的形式叫做<strong>学习性测试（learning tests）</strong>。它可以帮助我们快速试错和反馈，从而对第三方API快速上手。</li>\n<li>在第三方代码尚未就绪时，<strong>编写我们想要的接口</strong>，可以使我们能保持代码在自己控制中，并在未来通过编写adapter的形式无痛迁移</li>\n<li>应尽量避免过多依赖第三方的特定信息，更多依靠你能控制的东西，好过依靠你控制不了的东西，免得日后受其控制</li>\n</ul>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><ul>\n<li>TDD（Test-Driven Development）三定律<ul>\n<li>在编写不能通过的单元测试前，不编写生产代码</li>\n<li>只编写刚好无法通过的单元测试，不能编译也算</li>\n<li>只编写刚好足已通过失败测试的生产代码</li>\n</ul>\n</li>\n<li><strong>测试代码和生产代码一样重要</strong>。正是单元测试让你的代码可扩展、可维护、可复用</li>\n<li>整洁的测试代码一样要求<strong>可读性</strong>。大多数测试代码可以总结为构造-操作-检验（Build-Operate-Check）模式。第一个环节构造测试数据，第二个环节操作数据，第三个环节验证是否得到期望的结果</li>\n<li>每个测试中的断言数量应该尽量少，且只测试一个概念</li>\n<li>FIRST原则<ul>\n<li>Fast，测试应该能够快速运行</li>\n<li>Independent，测试间应该相互独立</li>\n<li>Repeatable，测试应该在任何环境下可重复通过</li>\n<li>Self-Validating，测试应该有布尔值输出</li>\n<li>Timely，测试应及时编写</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><ul>\n<li>类应该由一组成员开始，从静态到普通，从共有到私有。且很少会有公有成员。</li>\n<li>类应该短小，<strong>类的名称应该能描述其权责</strong>。类名无法精确明明时，类大概就太长了。类名越含糊，类越有可能拥有过多权责。类名应该控制在25个字母内，且不应该包含连词。</li>\n<li>单一权责原则（Single Responsibility Principle，SRP）认为，类和模块应有且仅有<strong>一条加以修改的原因</strong>。这个原则可以帮助创造更好的抽象。它也是OO设计中最重要的概念之一。</li>\n<li>内聚：类应该只有少量实体变量，且所有方法都应该操作其中一些。当类的每个变量都被每个方法使用时，我们认为该类具有最大的内聚性。当发现类逐渐丧失内聚性时，尽早拆分它！让它变成多个短小的类。这个拆分的过程也是权责的拆分过程。</li>\n<li>通过基类和子类，可以在不修改类的同时，保持类对新功能的开放。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。可以通过抽象类和接口隔离细节修改带来的影响。</li>\n<li>降低类之间的连接耦合，可以采用依赖倒置原则（Dependency Inversion Principle，DIP），让类依赖于抽象（接口）而不是具体细节（自行构造类）</li>\n</ul>\n<h2 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h2><p><em>这一章的Java概念较多</em></p>\n<ul>\n<li>分开系统的构造和使用</li>\n<li><strong>依赖注入</strong>是控制反转的一种思路，它将第二权责从对象中拿出来，转移到专门的对象中去，从而遵循<strong>单一权责原则</strong></li>\n<li>我们应该专注于今天的用户故事，并且<strong>持续适当切分</strong>我们的关注面。书中举了Java AOP、AspectJ框架的例子</li>\n<li>实现时，使用<em>大致可工作的最简单方案</em>。只要软件构架有效切分了关注面，就比较好做根本性改动</li>\n</ul>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>Kent Beck关于测试的4个原则：</p>\n<ul>\n<li>运行所有测试，全面测试并持续通过所有测试的系统，就是可测试的系统。测试也能减少重构时可能破坏代码的顾虑。</li>\n<li>不可重复，使用模板生成或继承等高级概念</li>\n<li>表达程序员的意图。代码应当清晰表达作者的意图。使用好名称、保持类和函数的短小，以及之前章节提到的各种方法</li>\n<li>尽可能减少类和方法的数目，避免前两条规范的矫枉过正</li>\n</ul>\n<h2 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h2><p>并发是一种解耦策略，帮助我们分解开<strong>做什么（目的）</strong>和<strong>何时（时机）</strong>。</p>\n<ul>\n<li>并发<strong>有时</strong>能改善性能，会在编写额外代码上带来额外开销</li>\n<li>正确的并发是复杂的</li>\n<li>并发会带来系统结构的变化</li>\n</ul>\n<p>有些防御并发代码问题的原则：</p>\n<ul>\n<li>单一权责：分离并发代码和其他代码</li>\n<li>限制对可能共享的数据的访问</li>\n<li>线程应尽可能独立</li>\n</ul>\n<p>并发执行模式：</p>\n<ul>\n<li>生产者-消费者模式：数据通过队列传递，队列本身是一种限定资源</li>\n<li>读者-作者模式</li>\n<li>宴席哲学家问题</li>\n</ul>\n<p>还有一些需要注意的事情：</p>\n<ul>\n<li>警惕同步方法间的依赖</li>\n<li>尽可能减小sychronized区域</li>\n<li>尽早考虑程序关闭问题</li>\n<li>测试线程代码</li>\n</ul>\n<h2 id=\"3个实例\"><a href=\"#3个实例\" class=\"headerlink\" title=\"3个实例\"></a>3个实例</h2><p>书中以三个实例的重构过程向我们表现了一些将之前思路应用于优化代码的方式。</p>\n<h3 id=\"命令行参数解析：args\"><a href=\"#命令行参数解析：args\" class=\"headerlink\" title=\"命令行参数解析：args\"></a>命令行参数解析：args</h3><blockquote>\n<p>编程是一种技术甚于科学的东西，要编写整洁代码，必须先写肮脏代码，然后再<strong>清理它</strong></p>\n</blockquote>\n<p>在你的初稿，当代码糟糕透顶时甚至是前几稿中，很可能还是会存在烂摊子：成员多得吓人，奇怪命名的魔法字符串，一大堆的try-catch-finally代码。程序员们不都是蠢人，这堆糟糕透顶的代码其实是从最初看起来很合理但是<strong>扩展性差</strong>的代码一步步演化来的。</p>\n<p>需要使用一些总结和抽象，来简明地表达你的目的。另外，在重构前，“我”（其实是作者）要不厌其烦地强调TDD的必要性，它能保证你重构的每一步，系统都可以工作。在重构过程中，放进拿出是常见的事，小步幅、保持测试通过，你可能会不断移动各种东西。</p>\n<p>优秀的代码设计，大都关乎<strong>分隔</strong>——创建合适的空间防止不同种类的代码。对关注面的分隔让代码更易于理解和维护（减少理解所需要的大脑缓存）</p>\n<h3 id=\"JUnit\"><a href=\"#JUnit\" class=\"headerlink\" title=\"JUnit\"></a>JUnit</h3><ul>\n<li>不必要的编码前缀（<code>f_</code>）</li>\n<li>未封装的条件判断</li>\n<li>建议使用肯定式代替否定式判断</li>\n<li>奇怪的不直观的函数名</li>\n<li>易造成理解困难的变量名</li>\n<li>拆分违反SRP原则的函数</li>\n<li>避免隐式时序耦合的函数，用hardcode的形式显示表现时序耦合</li>\n</ul>\n<h3 id=\"SerialDate重构\"><a href=\"#SerialDate重构\" class=\"headerlink\" title=\"SerialDate重构\"></a>SerialDate重构</h3><p>再强调一遍，<strong>重构前要有一个完整的验证可行性的测试</strong>。然后开始重构：</p>\n<ul>\n<li>没有描述力的类名和术语名</li>\n<li>使用枚举代替常量类</li>\n<li>抽象类中不应知道实现细节</li>\n<li>基类不宜知道子类的情况</li>\n<li>多余的注释</li>\n<li>变量声明应该放在尽量靠近使用的地方</li>\n<li>如果有专业术语，就不要自己命名了</li>\n<li>不要写无用的模板代码</li>\n<li>如果函数对成员进行操作，它就不应该是静态的</li>\n<li>用<strong>解释临时变量</strong>的方式，让大段的代码更为简化和有表达力</li>\n<li>消除魔术数</li>\n</ul>\n<h2 id=\"味道和启发\"><a href=\"#味道和启发\" class=\"headerlink\" title=\"味道和启发\"></a>味道和启发</h2><p>作者在这里对《重构：既有代码设计的改善》里提到的味道做了自己的一些扩充，也可以作为对上面章节的回顾。</p>\n<p><em>“味道”，即那些看起来不大对劲的代码</em></p>\n<h3 id=\"注释-1\"><a href=\"#注释-1\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li>不恰当的信息，如修改记录</li>\n<li>过时的注释</li>\n<li>多余的废话</li>\n<li>错误的有误导性的注释</li>\n<li>注释掉的代码</li>\n</ul>\n<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>多步才能完成的构建</li>\n<li>多步才能完成的测试</li>\n</ul>\n<h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li>过多的入参</li>\n<li>布尔类型参数</li>\n<li>从未被调用的函数</li>\n<li>用于返回的参数</li>\n</ul>\n<h3 id=\"一般性问题\"><a href=\"#一般性问题\" class=\"headerlink\" title=\"一般性问题\"></a>一般性问题</h3><ul>\n<li>源文件中有多种语言</li>\n<li>明显违背字面意义的直觉</li>\n<li>不考虑边界情况</li>\n<li>忽视安全问题</li>\n<li><strong>重复</strong>，这也是最常见的问题。每次看到重复代码都代表遗漏了抽象。有一些常见的设计模式可以帮助你。</li>\n<li>代码的抽象层级有问题，或混杂。抽象类用来容纳高层级概念，子类用来容纳低层级概念。不同层级概念放在不同容器中。</li>\n<li>基类依赖于子类。通常来说，基类对子类应该一无所知</li>\n<li>信息过多，违背SRP</li>\n<li>从未使用的代码</li>\n<li>不恰当的垂直分隔</li>\n<li>语素前后不一致</li>\n<li>基于巧合、预设假设的耦合。异或是两个没有直接目的之间的模块的耦合。</li>\n<li><strong>特性依恋</strong>，类的方法只应对自身的成员和方法感兴趣，不应关注其他类的成员和方法</li>\n<li>使用boolean或枚举参数让一个函数表现多态。使用多个函数通常由于向单个函数传递代码来选择函数行为</li>\n<li>晦涩的意图，如魔术数、魔术字符串、过度简写的表达式</li>\n<li>位置错误的权责</li>\n<li>不恰当的静态方法，如完全不需要多态的函数</li>\n<li>使用自解释的变量名</li>\n<li>使用自解释的函数名</li>\n<li>理解算法</li>\n<li>把逻辑依赖（脑海中的限制&#x2F;已知条件）改为物理依赖</li>\n<li>使用if&#x2F;else、switch前想想有没有多态的实现方法</li>\n<li>遵循团队lint规则</li>\n<li>足够准确</li>\n<li>未封装的条件判断</li>\n<li>未封装的边界条件检测</li>\n<li>避免否定性条件</li>\n<li><strong>函数应该只做一件事</strong></li>\n<li><strong>函数应该只在一个抽象层级上</strong></li>\n<li>隐蔽的时序性耦合</li>\n<li>别随意，先好好思考再下手</li>\n<li>应该在较高层级放置可配置数据</li>\n<li>避免传递浏览，即遵守德墨忒尔律</li>\n</ul>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><ul>\n<li>使用通配符避免过长的导入清单</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">package</span>.*</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不要继承<em>常量</em>，使用静态导入</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> EmployeeConstants.*</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在可以的情况下，用枚举代替常量</li>\n</ul>\n<h3 id=\"名称\"><a href=\"#名称\" class=\"headerlink\" title=\"名称\"></a>名称</h3><ul>\n<li>使用描述性名称</li>\n<li>名称应该与抽象层级相符</li>\n<li>使用标准化语素</li>\n<li>使用无歧义的名称</li>\n<li>在较大作用范围使用较长名称，较小作用范围<em>可以</em>使用较短名称</li>\n<li>名称应该明确说明有副作用存在</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>要有足够的测试</li>\n<li>使用覆盖率工具</li>\n<li>别放过小测试</li>\n<li>被忽略的测试是对不确定事物的疑问</li>\n<li>测试边界条件</li>\n<li>测试失败的模式（pattern）会有启发性</li>\n<li>测试覆盖率的模式会有启发性</li>\n<li>测试应该快速</li>\n</ul>\n<h2 id=\"并发编程示例\"><a href=\"#并发编程示例\" class=\"headerlink\" title=\"并发编程示例\"></a>并发编程示例</h2><h3 id=\"客户端-x2F-服务端\"><a href=\"#客户端-x2F-服务端\" class=\"headerlink\" title=\"客户端&#x2F;服务端\"></a>客户端&#x2F;服务端</h3><ul>\n<li>如果吞吐量与I&#x2F;O有关，则并发编程可以提升运行效率</li>\n<li>保持并发系统整洁，把线程管理隔离到一个位置</li>\n</ul>\n<h3 id=\"可能的执行路径\"><a href=\"#可能的执行路径\" class=\"headerlink\" title=\"可能的执行路径\"></a>可能的执行路径</h3><p>深入到字节码和汇编语句的执行上，有些并非线程安全的操作中，不同的执行路径会带来不同结果。</p>\n<h3 id=\"了解类库\"><a href=\"#了解类库\" class=\"headerlink\" title=\"了解类库\"></a>了解类库</h3><ul>\n<li>Executor框架</li>\n<li>非锁定方案：AtomicBoolean，AtomicInteger和AtomicReference</li>\n<li>数据库连接、java.util中的容器、Servlet天生不是线程安全的</li>\n</ul>\n<h3 id=\"提升吞吐量\"><a href=\"#提升吞吐量\" class=\"headerlink\" title=\"提升吞吐量\"></a>提升吞吐量</h3><ul>\n<li>synchronized代码块最好能限制在小范围内</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁需要满足4个条件：</p>\n<ul>\n<li><strong>互斥</strong>，即资源数量有限，或无法在同一时间为多个线程公用</li>\n<li><strong>上锁及等待</strong>，从线程获取资源到完成工作前，不会释放这个资源</li>\n<li><strong>无抢先机制</strong>，线程无法从其他线程处夺取资源</li>\n<li><strong>循环等待</strong></li>\n</ul>\n<p>相反地，有4种避免死锁的方式：</p>\n<ul>\n<li><strong>不互斥</strong>，使用允许同时使用的资源，或增加资源数目</li>\n<li><strong>不上锁及等待</strong>，如果有等待情况就释放所有资源从新来过</li>\n<li><strong>满足抢先机制</strong></li>\n<li><strong>不做循环等待</strong></li>\n</ul>\n<h3 id=\"测试多线程代码\"><a href=\"#测试多线程代码\" class=\"headerlink\" title=\"测试多线程代码\"></a>测试多线程代码</h3><ul>\n<li>复现问题可能很难，可以借助工具（如ConTest）帮助</li>\n</ul>\n<p><em>–END–</em></p>\n",
            "tags": [
                "编程",
                "重构",
                "代码",
                "代码风格"
            ]
        }
    ]
}
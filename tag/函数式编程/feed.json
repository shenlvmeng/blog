{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"函数式编程\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "url": "http://shenlvmeng.github.com/blog/2017/06/20/functional-programming-brief/",
            "title": "函数式编程扫盲",
            "date_published": "2017-06-20T11:45:44.000Z",
            "content_html": "<p>名谓扫盲，实则是为自己扫盲。前些日子通过Elm的学习接触到了函数式编程的概念，发现语言风格和以C为代表的命令式编程大不相同，接触不同的编程思维还是很有助于自我提升的。在回顾的同时，这里走马观花地带过一些函数式编程的“热门词汇”。</p>\n<h2 id=\"历史故事\"><a href=\"#历史故事\" class=\"headerlink\" title=\"历史故事\"></a><a href=\"http://www.defmacro.org/ramblings/fp.html\">历史故事</a></h2><p>什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？这得从20世纪30年代开始讲起：</p>\n<blockquote>\n<p>新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫<a href=\"http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87\">阿隆佐·邱奇</a>(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有<a href=\"https://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5\">艾伦·图灵</a>、<a href=\"http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC\">约翰·冯·诺伊曼</a>、<a href=\"https://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94\">库尔特·哥德尔</a>。</p>\n</blockquote>\n<p>在与这些人的合作下，阿隆佐设计了一个名为<a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">lambda演算</a>的形式系统。在这种语言里面，函数的参数是函数，返回值也是函数。篇幅和本人能力限制，不对lambda演算做更多讲解。</p>\n<p>除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。</p>\n<p>到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！而后的诸多函数式编程语言（如Haskell，ML等）也多少收到Lisp的影响。</p>\n<h2 id=\"法则\"><a href=\"#法则\" class=\"headerlink\" title=\"法则\"></a><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">法则</a></h2><p>函数式编程的思想来源Lambda演算在最初设计时就是用来解决计算相关问题，它是一种相对于“命令式编程”完全不同的编程范式，后者告诉计算机怎么做，前者着眼在从数学角度描述问题。它的特点也很明显：</p>\n<ul>\n<li><strong>变量不可变</strong>，即默认带上<code>const</code>或是<code>final</code>（当然函数式编程里压根没有<code>const</code>和<code>final</code>的概念）。这么来看，叫它为“符号”似乎更合适</li>\n<li><strong>惰性求值</strong>，变量直到使用时才会真正计算它的值，因为这个特点，Haskell甚至允许无限列表的出现。同时，这也意味着语句的出现顺序和执行顺序并不相关。</li>\n<li><strong>高阶函数</strong>，函数可以作为入参或是返回值，这个也被很多不那么OOP的语言借鉴去了</li>\n<li><strong>无副作用</strong>，<strong>函数只负责映射数据</strong>，更像是个管道，绝不改变外部状态，同样的输入在任何时候会得到同样的输出（测试人员笑开了花）。这一点使得函数式编程语言天生支持并发执行。</li>\n<li><strong>一切皆函数</strong>，函数是第一公民</li>\n</ul>\n<p>λ演算用来描述一种形式系统，它的语法只有三条：</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>术语</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a</td>\n<td>变量</td>\n<td>一个代表参数或数字&#x2F;逻辑值的符号或字符串</td>\n</tr>\n<tr>\n<td>(λx.M)</td>\n<td>定义</td>\n<td>函数定义，<code>.</code>前面的标识符<code>x</code>为入参，M为表达式</td>\n</tr>\n<tr>\n<td>(M N)</td>\n<td>调用</td>\n<td>应用函数到一个入参</td>\n</tr>\n</tbody></table>\n<p>例如：<code>((λ x y. x + y) 1 2)</code>表示1和2相加。</p>\n<p>λ演算公理只有两个：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(λx.M[x]) → (λy.M[y])</td>\n<td>α变换</td>\n<td>改变入参名不影响结果</td>\n</tr>\n<tr>\n<td>((λx.M) E) → (M[x:&#x3D;E])</td>\n<td>β规约</td>\n<td>将入参传入λ意味着对它做演算</td>\n</tr>\n</tbody></table>\n<p>还以上面的相加为例，α变换就是<code>λ x y. x + y → λ a b. a + b</code>；β规约就是<code>(λ x y. x + y) a b → a + b</code>。是不是很好理解。</p>\n<p>通过这两个基本的公理，结合基本变量类型可以构造各种函数。如not函数，and函数，or函数，甚至if函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> and =</span><br><span class=\"line\"><span class=\"title\">true</span> value  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">false</span> value -&gt;  false</span><br><span class=\"line\"><span class=\"title\">value</span> true  -&gt;  value</span><br><span class=\"line\"><span class=\"title\">value</span> false -&gt;  false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">let</span> <span class=\"keyword\">if</span> =</span><br><span class=\"line\">λ cond tvalue fvalue. (cond and tvalue) or (not cond  and fvalue)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数意味着，我们可以把函数直接作为入参传入，或作为返回值返回。这早已不是函数式编程语言的专利，Python，JavaScript等也吸收了这个设计理念。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\">函数柯里化</a>即部分求值，就利用了高阶函数的特点提出的技术，它使得函数可以一个一个接受入参，返回相同的计算结果。类似于下面的感觉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pow</span>(<span class=\"params\">i, j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i^j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funtion <span class=\"title function_\">square</span>(<span class=\"params\">j</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">pow</span>(i, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>square</code>函数返回的函数需要指定<code>i</code>才可执行。柯里的名字来自于第一次提出这个技巧的逻辑学家<a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\">Haskell Curry</a>。</p>\n<p>另外，值得注意的是，在函数式编程下，高阶函数通过将函数作为参数惰性求值实现。那命令式编程下呢，答案是<a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">闭包</a>（lexical closure）。</p>\n<h2 id=\"递归？\"><a href=\"#递归？\" class=\"headerlink\" title=\"递归？\"></a>递归？</h2><p>函数式编程里没有状态变量（可以用其他方式实现），因此自然没有循环结构。实际上，函数式编程中的循环都是通过递归实现的。比如，斐波那契数列函数像下面这样：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> fact = λ n. <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"number\">1</span> (n * fact n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>这里<code>fact</code>函数引用了自身，虽然编译器可以识别这种写法，但是显然它并不符合严格的数学公理。</p>\n<p>重新审视这个变换，我们可以通过传入自身的方式来让它“数学化”。<code>let P = λ self n. if (n == 0) 1 (n * self(self n-1))</code>，然后在令<code>let fact n = P (P n)</code>。如此这般：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact 4</span><br><span class=\"line\">-&gt; P (P 4)</span><br><span class=\"line\">-&gt; if (4 == 0) (1) (4 * P(P 3))</span><br><span class=\"line\">-&gt; 4 * P(P 3)</span><br><span class=\"line\">-&gt; 4 * 3 * P(P 2)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * P(P 1)</span><br><span class=\"line\">-&gt; 4 * 3 * 2 * 1</span><br></pre></td></tr></table></figure>\n\n<p>可是，这个函数看上去并不自然，不像一个真正的递归函数，且λ演算的公理里并没有这样一条公理可以让你在定义函数的时候引用本身。还好，已经有人做了<a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">研究</a>，借助Y组合子的帮助，可以实现真正的递归函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">let</span> <span class=\"type\">Y</span> = λ <span class=\"type\">F</span>. <span class=\"type\">G</span>(<span class=\"type\">G</span>)</span><br><span class=\"line\"><span class=\"type\">G</span> = λ self. <span class=\"type\">F</span>(self(self))</span><br></pre></td></tr></table></figure>\n\n<p>这相当于我们在λ演算公理体系中添加了一条“可以在函数调用时引用自身”。这也是证明λ演算图灵等价的关键一步。这意味着它的计算能力和计算机是一致的，能通过λ演算描述的函数一定可以由计算机计算。</p>\n<h2 id=\"Haskell\"><a href=\"#Haskell\" class=\"headerlink\" title=\"Haskell\"></a>Haskell</h2><p><a href=\"https://www.zhihu.com/question/27355585\">Haskell</a>是一个纯函数式编程语言，它得名于上面提到过的Haskell Curry。Y组合子也是他发现的。</p>\n<p>Haskell中一切都是函数，甚至没有指令式编程中变量的概念，它的变量全部都是只允许一次赋值，不可改变。</p>\n<p>Haskell还没有一般意义上的控制流结构，如for循环，取而代之的是递归。同样，Haskell还有两个重要的特性，即无副作用和惰<br>性求值。偏数学的问题，用Haskell解决通常代码量都很小。下面是一个列表去重例子</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">cut</span> cond  []  = []</span><br><span class=\"line\"><span class=\"title\">cut</span> cond  (elem:rest) = <span class=\"keyword\">if</span>  cond elem <span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"title\">cut</span> cond  rest  <span class=\"keyword\">else</span>  elem:rest</span><br><span class=\"line\"><span class=\"title\">compress</span>  []  = []</span><br><span class=\"line\"><span class=\"title\">compress</span>  (elem:rest) = elem  : compress</span><br><span class=\"line\">(cut  (== elem) rest)</span><br></pre></td></tr></table></figure>\n<p>还有一个快排（不过借助了filter函数）的例子，也是短得不行</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> (elem:rest) = (qsort lesser) ++ [elem] ++ (qsort greater)</span><br><span class=\"line\">  <span class=\"keyword\">where</span></span><br><span class=\"line\">    lesser = filter (&lt; elem) rest</span><br><span class=\"line\">    greater = filter (&gt;= elem) rest</span><br></pre></td></tr></table></figure>\n<p>Haskell中还可以定义无穷列表，如[1..]表示所有正整数。这也是惰性求值特性带来的。<code>[1,3..] !! 42</code>将会返回85。</p>\n<h2 id=\"Monad\"><a href=\"#Monad\" class=\"headerlink\" title=\"Monad\"></a>Monad</h2><blockquote>\n<p>Monad其实就是自函子范畴上的一个幺半群而已</p>\n</blockquote>\n<p>这节将展示一个图文并茂的说明但并不致力于解释清楚monad到底是个什么（因为我自己也不明白）。这篇对比<a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">functor，applicatives，monad</a>的文章写得很透彻易懂，尽管这可能并不能描述一个100%的monad。要更深刻了解monad还是需要学习范畴论的内容。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.byvoid.com/upload/fl/images/FP/FP.pdf\">函数式编程.pdf</a><br><a href=\"http://www.defmacro.org/ramblings/fp.html\">Functional Programming For The Rest of Us</a><br><a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors, Applicatives, And Monads In Pictures</a></p>\n",
            "tags": [
                "函数式编程",
                "闭包",
                "Haskell",
                "monad"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/",
            "url": "http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/",
            "title": "Elm——函数式前端框架介绍",
            "date_published": "2017-06-19T09:36:01.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Elm提出于2012年，最初出现在Evan Czaplicki的毕业论文中（掩面）。目标是提出一个面向web的函数式编程语言。它拥有诸多特性</p>\n<ul>\n<li>强类型语言</li>\n<li>一次编译，no runtime error</li>\n<li>状态不可修改</li>\n<li>函数是一级公民等</li>\n</ul>\n<p>Elm是门新语言，它是一个类似React（但绝对和它不一样）的前端框架。在Web App的设计它甚至启发了Flux设计的提出。在如今前端框架吸收函数式编程以及强类型语言优点的形势下，学习Elm可能会开启对Web前端开发的重新认识。</p>\n<p>再看完下面的介绍后，建议阅读两篇对Elm的评价，相信更有助于对这门年轻语言特点的理解：</p>\n<ul>\n<li><a href=\"https://medium.com/@ericdreichert/my-thoughts-on-elm-lang-b609d69cfa4d\">My thoughts on Elm Lang</a></li>\n<li><a href=\"https://hackernoon.com/some-thoughts-on-elm-development-39a0f8a9002a\">Some thoughts on Elm Development</a></li>\n</ul>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>Elm是通过将代码编译成JavaScript工作的。一个最简单的Elm App大概像下面这样：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Html <span class=\"keyword\">exposing</span> (<span class=\"type\">Html</span>, button, div, text)</span><br><span class=\"line\"><span class=\"keyword\">import</span> Html.Events <span class=\"keyword\">exposing</span> (onClick)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> =</span><br><span class=\"line\">  <span class=\"type\">Html</span>.beginnerProgram &#123; model = <span class=\"number\">0</span>, view = view, update = update &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Msg</span> = <span class=\"type\">Increment</span> | <span class=\"type\">Decrement</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Increment</span> -&gt;</span><br><span class=\"line\">      model + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Decrement</span> -&gt;</span><br><span class=\"line\">      model - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">view</span> model =</span><br><span class=\"line\">  div []</span><br><span class=\"line\">    [ button [ onClick <span class=\"type\">Decrement</span> ] [ text <span class=\"string\">&quot;-&quot;</span> ]</span><br><span class=\"line\">    , div [] [ text (toString model) ]</span><br><span class=\"line\">    , button [ onClick <span class=\"type\">Increment</span> ] [ text <span class=\"string\">&quot;+&quot;</span> ]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n\n<p>那么这样一个Elm文件是怎么应用在页面中呢？</p>\n<p>在<a href=\"http://elm-lang.org/\">Elm</a>安装完成后，会有4个Elm相关的包：</p>\n<ul>\n<li>elm-repl 命令行操作，在cli中感受Elm的语法特点</li>\n<li>elm-reactor 快速脚手架搭建</li>\n<li>elm-make 编译工具</li>\n<li>elm-package 包管理工具</li>\n</ul>\n<p>麻雀虽小，五脏俱全。</p>\n<h2 id=\"语法特点\"><a href=\"#语法特点\" class=\"headerlink\" title=\"语法特点\"></a>语法特点</h2><p>Elm在<a href=\"http://elm-lang.org/docs/syntax\">语法</a>上不同于C风格的所有语言，和Haskell更为靠近。</p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>用<code>--</code>开启单行注释，结合<code>&#123;&#125;</code>进行多行注释</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- a single line comment</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&#123;- a multiline comment</span></span><br><span class=\"line\"><span class=\"comment\">   <span class=\"comment\">&#123;- can be nested -&#125;</span></span></span><br><span class=\"line\"><span class=\"comment\">-&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>Elm是强类型语言，有Bool，Int，Float，Char，String 5种基本类型。有意思的是，<strong>Elm没有Null</strong>。这也是特别<a href=\"https://guide.elm-lang.org/error_handling/\">设计</a>的。</p>\n<div class=\"tip\">注意：Elm中Char类型用单引号`'`包裹，而String类型用双引号`\"`包裹。\n</div>\n\n<p>除了基本类型，Elm中还有List，Array，Tuple，Dict，Record几种泛型。其中List，Record设计类似JavaScript中的Array和Object。</p>\n<div class=\"tip\">在Elm中`Array`和`List`是两种不同的类型，前者通过链表实现，后者通过Relaxed Radix Tree实现。前者在增删节点上高效，后者在随机查询时高效。</div>\n\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">1</span> :: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">1</span> :: <span class=\"number\">2</span> :: <span class=\"number\">3</span> :: <span class=\"number\">4</span> :: []</span><br><span class=\"line\"><span class=\"title\">point</span> =                         <span class=\"comment\">-- create a record</span></span><br><span class=\"line\">  &#123; x = <span class=\"number\">3</span>, y = <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">point</span>.x                         <span class=\"comment\">-- access field</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">List</span>.map .x [point,&#123;x=<span class=\"number\">0</span>,y=<span class=\"number\">0</span>&#125;]   <span class=\"comment\">-- field access function</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; point | x = <span class=\"number\">6</span> &#125;               <span class=\"comment\">-- update a field</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; point |                       <span class=\"comment\">-- update many fields</span></span><br><span class=\"line\">    x = point.x + <span class=\"number\">1</span>,</span><br><span class=\"line\">    y = point.y + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>*(值得注意的是，上面的<code>::</code>和<code>.x</code>实际上都是函数)*。</p>\n<h4 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h4><p>类型是Elm中重要的一环，每个变量都需要有类型，编译时需要进行检查。因此显式地声明变量类型很重要。</p>\n<p>当我们需要通过基本类型构造复杂类型时，可以通过<code>type alias</code>的形式为record创建新的类型。在新类型创建的同时，会同步生成一个record构造函数。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- Before：麻烦的函数写法</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> : &#123; name : <span class=\"type\">String</span>, bio : <span class=\"type\">String</span>, pic : <span class=\"type\">String</span> &#125; -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> user =</span><br><span class=\"line\">  <span class=\"type\">String</span>.length user.bio &gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">-- After：简便的写法</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">User</span> =</span><br><span class=\"line\">  &#123; name : <span class=\"type\">String</span></span><br><span class=\"line\">  , bio : <span class=\"type\">String</span></span><br><span class=\"line\">  , pic : <span class=\"type\">String</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"title\">hasBio</span> : <span class=\"type\">User</span> -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\"><span class=\"title\">hasBio</span> user =</span><br><span class=\"line\">  <span class=\"type\">String</span>.length user.bio &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Union类型\"><a href=\"#Union类型\" class=\"headerlink\" title=\"Union类型\"></a>Union类型</h4><p>之所以单独拿出来说，是因为Union Type的设计几乎是Elm的精髓。首先，它类似于枚举（enum）的概念，通过<code>type enum = A | B | C</code>的形式定义一个类型。这是简单的Union Type的使用。</p>\n<p>Union Type还有Tagged Union的用法。即下面这样。这意味着<strong>User可以是不带信息的Anonymous或带有String信息的Named</strong>。<code>Anonymous</code>和<code>Named</code>是User的两个构造函数。其中Named接受一个String类型入参构造User类型。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">User</span> = <span class=\"type\">Anonymous</span> | <span class=\"type\">Named</span> <span class=\"type\">String</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">注意：不同Union Type间的Tag构造函数不能同名，即不能出现下面的情况。同时Tag后的额外消息是泛型`a`时，需要在type名后也加上，便于type check</div>\n\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">User</span> = <span class=\"type\">Named</span> | <span class=\"type\">Named</span> <span class=\"type\">String</span> <span class=\"comment\">-- Wrong!</span></span><br></pre></td></tr></table></figure>\n\n<p>结合上面的特点，可以很容易地将相似数据结构或设计抽象为单一模板，如<a href=\"https://guide.elm-lang.org/types/union_types.html\">举例</a>中的将时间轴、日志等统一抽象为widget。思路：<strong>逐个击破，合而为一</strong></p>\n<p>由于Union Type可以递归定义，通过Union Type甚至可以构建链表和<a href=\"http://elm-lang.org/examples/binary-tree\">二叉树</a>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">List</span> a = <span class=\"type\">Empty</span> | <span class=\"type\">Node</span> a (<span class=\"type\">List</span> a)</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Tree</span> a = <span class=\"type\">Empty</span> | <span class=\"type\">Node</span> a (<span class=\"type\">Tree</span> a) (<span class=\"type\">Tree</span> a)</span><br></pre></td></tr></table></figure>\n\n<p>此外，Elm中的错误处理<a href=\"https://guide.elm-lang.org/error_handling/maybe.html\">Maybe</a>和<a href=\"https://guide.elm-lang.org/error_handling/result.html\">Result</a>也是基于Union Type实现的。</p>\n<p>因为Union Type的不同子类型可以有自己独特的构造函数，且支持解构赋值，因此非常适合用作实现状态管理的事件。Web App中的update函数接受的Html Msg类型实际上也是Union Type实现的。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>除了不能手动更改状态的变量（因此<strong>递归完全替代了循环结构</strong>），函数是Elm中最常见的存在。命令式编程中，函数用作告诉电脑该怎么做。函数式编程中，函数用作描述一种映射关系，告诉电脑要什么。Elm中函数像下面这样声明：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">square</span> n =</span><br><span class=\"line\">  n^<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">hypotenuse</span> : <span class=\"type\">Float</span> -&gt; <span class=\"type\">Float</span> -&gt; <span class=\"type\">Float</span></span><br><span class=\"line\"><span class=\"title\">hypotenuse</span> a b =</span><br><span class=\"line\">  sqrt (square a + square b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">distance</span> (a,b) (x,y) =</span><br><span class=\"line\">  hypotenuse (a-x) (b-y)</span><br></pre></td></tr></table></figure>\n\n<p>入参在上，返回值在下。入参间通过空格隔开，由于Elm支持函数柯里化，所以在函数的类型声明中，也是通过<code>-&gt;</code>隔开每个入参以及返回值的。由于函数变成了纯粹的“通道”，函数体中声明临时变量的语法通过<code>let ... in</code>的形式实现。</p>\n<p>Elm中也有匿名函数，像下面这样，由反斜线<code>\\</code>开头：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">square</span> =</span><br><span class=\"line\">  \\n -&gt; n^<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">squares</span> =</span><br><span class=\"line\">  <span class=\"type\">List</span>.map (\\n -&gt; n^<span class=\"number\">2</span>) (<span class=\"type\">List</span>.range <span class=\"number\">1</span> <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p>函数间通过<code>|&gt;</code>和<code>&lt;|</code>连接减少括号的使用。例如下面这样</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">viewNames1</span> names =</span><br><span class=\"line\">  <span class=\"type\">String</span>.join <span class=\"string\">&quot;, &quot;</span> (<span class=\"type\">List</span>.sort names)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">viewNames2</span> names =</span><br><span class=\"line\">  names</span><br><span class=\"line\">    |&gt; <span class=\"type\">List</span>.sort</span><br><span class=\"line\">    |&gt; <span class=\"type\">String</span>.join <span class=\"string\">&quot;, &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- (arg |&gt; func) is the same as (func arg)</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，可以通过<code>&gt;&gt;</code>和<code>&lt;&lt;</code>构造复合函数。<code>``</code>用来将第<code>n</code>个函数入参前置，使得居于更符合语法习惯，如<code>buyMilk `then` drinkMilk</code>中<code>buyMilk</code>参数被提前。<code>n</code>可以通过<code>infixr</code>设置。</p>\n<p>其中可能较难理解的是<strong>递归完全替代了循环结构</strong>，Elm类似其他函数式语言，没有<code>for</code>和<code>while</code>。它用描述问题的方式，通过递归解决普通的循环问题，下面举两个例子：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">reverse</span> : <span class=\"type\">List</span> a -&gt; <span class=\"type\">List</span> a</span><br><span class=\"line\"><span class=\"title\">reverse</span> list =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> list <span class=\"keyword\">of</span></span><br><span class=\"line\">    [] -&gt; []</span><br><span class=\"line\">    (x::xs) -&gt; reverse xs ++ [x]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">quicksort</span> : <span class=\"type\">List</span> comparable -&gt; <span class=\"type\">List</span> comparable</span><br><span class=\"line\"><span class=\"title\">quicksort</span> list = </span><br><span class=\"line\">  <span class=\"keyword\">case</span> list <span class=\"keyword\">of</span></span><br><span class=\"line\">    [] -&gt; []</span><br><span class=\"line\">    (x::xs) -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> </span><br><span class=\"line\">        smallerSorted = quicksort (<span class=\"type\">List</span>.filter ((&gt;) x) xs)</span><br><span class=\"line\">        biggerSorted = quicksort (<span class=\"type\">List</span>.filter ((&lt;=) x) xs)</span><br><span class=\"line\">      <span class=\"keyword\">in</span>  </span><br><span class=\"line\">        smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure>\n\n<p>可以找到规律：</p>\n<blockquote>\n<p>Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest.</p>\n</blockquote>\n<p>更具体的解释可以看参考链接3。</p>\n<h3 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h3><p>Elm中没有<code>for</code>和<code>while</code>循环（都通过递归实现了）。但是存在<code>if</code>和<code>case</code>语句。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">if</span> powerLevel &gt; <span class=\"number\">9000</span> <span class=\"keyword\">then</span> <span class=\"string\">&quot;OVER 9000!!!&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;meh&quot;</span></span><br><span class=\"line\"><span class=\"title\">case</span> maybe <span class=\"keyword\">of</span></span><br><span class=\"line\">  <span class=\"type\">Just</span> xs -&gt; xs</span><br><span class=\"line\">  <span class=\"type\">Nothing</span> -&gt; []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">case</span> xs <span class=\"keyword\">of</span></span><br><span class=\"line\">  hd::tl -&gt; <span class=\"type\">Just</span> (hd,tl)</span><br><span class=\"line\">  []     -&gt; <span class=\"type\">Nothing</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">case</span> n <span class=\"keyword\">of</span></span><br><span class=\"line\">  <span class=\"number\">0</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"number\">1</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">  _ -&gt; fib (n<span class=\"number\">-1</span>) + fib (n<span class=\"number\">-2</span>) <span class=\"comment\">-- _表示不接受入参</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><ul>\n<li><code>++</code>连接字符串，<code>+</code>表示相加</li>\n<li>Elm不会进行强制类型转换</li>\n<li>缩进会影响语句解析</li>\n<li>list中所有元素类型必须一致</li>\n<li>tuples设计类似python</li>\n<li>records类型不允许访问不存在的属性</li>\n<li><code>//</code>用来进行C风格的除法</li>\n<li>Elm中!用于连接Model和Cmd，用<code>/=</code>表示<code>!=</code>，同<code>not</code>表示<code>!</code></li>\n</ul>\n<p>Elm的语言设定大不同于C风格，所以，多写去熟悉它的语法风格吧。</p>\n<h2 id=\"Elm架构\"><a href=\"#Elm架构\" class=\"headerlink\" title=\"Elm架构\"></a>Elm架构</h2><p>Elm构建Web App的架构为MVU（不考虑Cmd和Subscription的话），这和目前大部分MVVM框架一样，致力于减少UI维护，减少不必要的状态修改来更好地定位错误。有意思的是，Elm也<a href=\"http://elm-lang.org/blog/blazing-fast-html\">采用了Virtual DOM的设计</a>。</p>\n<ul>\n<li>Model，类似Web App的state，通常为<code>records</code>类型</li>\n<li>Update，更新state的唯一方式（类似于action或commit），通常类型为<code>Msg -&gt; Model -&gt; (Model, Cmd Msg)</code></li>\n<li>View，根据state渲染HTML的方式，通常类型为<code>Model -&gt; Html Msg</code></li>\n</ul>\n<p>Update部分，通常像下面这样，接受Union Type的Msg，并通过<code>case ... of</code>接受到附在Msg上的payload。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; <span class=\"type\">Model</span></span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Change</span> newContent -&gt;</span><br><span class=\"line\">      &#123; model | content = newContent &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View部分，所有常用的标签名和属性名都被封装为函数，接受属性列表和子元素列表两个入参，像下面这样。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">view</span> : <span class=\"type\">Model</span> -&gt; <span class=\"type\">Html</span> <span class=\"type\">Msg</span></span><br><span class=\"line\"><span class=\"title\">view</span> model =</span><br><span class=\"line\">  div []</span><br><span class=\"line\">    [ input [ placeholder <span class=\"string\">&quot;Text to reverse&quot;</span>, onInput <span class=\"type\">Change</span> ] []</span><br><span class=\"line\">    , div [] [ text (<span class=\"type\">String</span>.reverse model.content) ]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n\n<p>将M、V、U三部分结合在一起就可以构造简单的web应用了。当有异步任务等复杂情况出现时，需要通过Cmd和Subscription实现。</p>\n<h3 id=\"Effects\"><a href=\"#Effects\" class=\"headerlink\" title=\"Effects\"></a>Effects</h3><p><img src=\"https://guide.elm-lang.org/architecture/effects/beginnerProgram.svg\" alt=\"Elm Architecture\"></p>\n<p>说这两位之前，我们要回顾下之前的工作流。仔细观察就能发现，我们所做的事只是描述了接受Html Msg后如何生产新的Model并根据新的Model生产新的Html Msg交给Elm Runtime，之后的脏活累活都交给Elm干了。根据Elm的描述，除了vDOM外，它还使用了下面两个手段提升效率：</p>\n<ul>\n<li><strong>Skip Work</strong>，通过<code>lazy</code>（类似React的<code>shouldComponentUpdate</code>）限制更新频率</li>\n<li><strong>Align Work</strong>，通过<code>Html.keyed</code>（类似React的<code>key</code>）减少无意义的diffing。</li>\n</ul>\n<p>回到正题，Cmd和Subscription也是对Msg所做的外层包装而已。除了能向Elm Runtime pipe Html Msg外，当然也可以发送命令或订阅事件</p>\n<p><img src=\"https://guide.elm-lang.org/architecture/effects/program.svg\"></p>\n<p>。Html, Cmd, Sub三者实际上没太大区别，都是我们将生成的数据交给Elm Runtime，剩下的做甩手掌柜。它可以帮助我们：</p>\n<ul>\n<li>更好的debug</li>\n<li>确保Elm函数的线性时不变</li>\n<li>优化HTTP连接，缓存effects</li>\n</ul>\n<p>下面是一个Sub的例子：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SUBSCRIPTIONS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">subscriptions</span> : <span class=\"type\">Model</span> -&gt; <span class=\"type\">Sub</span> <span class=\"type\">Msg</span></span><br><span class=\"line\"><span class=\"title\">subscriptions</span> model =</span><br><span class=\"line\">  <span class=\"type\">Time</span>.every second <span class=\"type\">Tick</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; (<span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span>)</span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Tick</span> newTime -&gt;</span><br><span class=\"line\">      (newTime, <span class=\"type\">Cmd</span>.none)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>之前提到过Elm致力于“编辑时无bug&#x3D;&gt;Runtime无bug”。除了强类型和无状态（实际上是Immutable的状态）外，还有Maybe和Result的辅助。</p>\n<blockquote>\n<p>Elm treats errors as data.</p>\n</blockquote>\n<p>参考<a href=\"https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/\">null的糟糕设计</a>，Elm通过</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Maybe</span> a = <span class=\"type\">Nothing</span> | <span class=\"type\">Just</span> a</span><br></pre></td></tr></table></figure>\n<p>定义了Maybe类型。结合<code>case of</code>的特殊情况处理，通过<strong>option types</strong>的方法<strong>替代Null</strong>。<a href=\"http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Maybe\">core&#x2F;Maybe</a>模块还有<code>withDefault</code>，<code>andThen</code>等其他方法。</p>\n<p>类似于Maybe，Result用Union Type的形式定义了不可靠操作的返回值。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Result</span> error value = <span class=\"type\">Err</span> error | <span class=\"type\">Ok</span> value</span><br></pre></td></tr></table></figure>\n<p>通过Err和Ok两种类型，隐含了其他语言中的<code>try catch</code>操作，<strong>避免exception</strong>的出现。Elm库函数是实现了Result类型的，如<code>Http.get</code>。Result预定义在<a href=\"http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Result\">core&#x2F;Result</a>中</p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>另外，Elm中有Task用来处理异步操作中的失败情况。类似于JS中的Promise。使用思路是先通过succeed方法和fail方法定义Task再使用。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">Task</span> err ok =</span><br><span class=\"line\">  <span class=\"type\">Task</span> err ok</span><br><span class=\"line\"><span class=\"title\">succeed</span> : a -&gt; <span class=\"type\">Task</span> x a</span><br><span class=\"line\"><span class=\"title\">fail</span> : x -&gt; <span class=\"type\">Task</span> x a</span><br></pre></td></tr></table></figure>\n\n<p>在Elm由0.17升级到0.18时，有两种方式执行一个Task。<code>Task.perform</code>和<code>Task.attempt</code>。前者针对<strong>从不返回错误</strong>的task，后者针对<strong>可能出错</strong>的task。更重要的是，在<code>Task.attempt</code>中结合了熟悉的Result模型。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">perform</span> : (a -&gt; msg) -&gt; <span class=\"type\">Task</span> <span class=\"type\">Never</span> a -&gt; <span class=\"type\">Cmd</span> msg</span><br><span class=\"line\"><span class=\"title\">attempt</span> : (<span class=\"type\">Result</span> x a -&gt; msg) -&gt; <span class=\"type\">Task</span> x a -&gt; <span class=\"type\">Cmd</span> msg</span><br><span class=\"line\"><span class=\"comment\">-- example</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">Msg</span> = <span class=\"type\">Click</span> | <span class=\"type\">NewTime</span> <span class=\"type\">Time</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">update</span> : <span class=\"type\">Msg</span> -&gt; <span class=\"type\">Model</span> -&gt; ( <span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span> )</span><br><span class=\"line\"><span class=\"title\">update</span> msg model =</span><br><span class=\"line\">  <span class=\"keyword\">case</span> msg <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">Click</span> -&gt;</span><br><span class=\"line\">      ( model, <span class=\"type\">Task</span>.perform <span class=\"type\">NewTime</span> <span class=\"type\">Time</span>.now )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NewTime</span> time -&gt;</span><br><span class=\"line\">      ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"互操作性\"><a href=\"#互操作性\" class=\"headerlink\" title=\"互操作性\"></a>互操作性</h2><p>Elm的互操作性体现在和JSON以及JavaScript上。</p>\n<h3 id=\"与JSON\"><a href=\"#与JSON\" class=\"headerlink\" title=\"与JSON\"></a>与JSON</h3><p>通过Json.Decode和Json.Encode完成相关工作。解析部分由<code>decodeString</code>完成。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">decodeString</span> : <span class=\"type\">Decoder</span> a -&gt; <span class=\"type\">String</span> -&gt; <span class=\"type\">Result</span> <span class=\"type\">String</span> a</span><br></pre></td></tr></table></figure>\n<p>由第一个参数指定decoder类型，如 <code>decodeString int &quot;42&quot;</code>就指定了一个整数的解析器。在多数情况下，JSON字符串并没这么简单。这时，需要先利用基本的int、string、list、dict解析器结合map2、map3等构造相应的Decoder，再交给decodeString处理。<strong>函数返回<code>Result</code>类型</strong>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Json.Decode <span class=\"keyword\">exposing</span> (..)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">alias</span> <span class=\"type\">Point</span> = &#123; x : <span class=\"type\">Int</span>, y : <span class=\"type\">Int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> = map2 <span class=\"type\">Point</span> (field <span class=\"string\">&quot;x&quot;</span> int) (field <span class=\"string\">&quot;y&quot;</span> int)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">decodeString</span> pointDecoder <span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;&#123; &quot;</span>x<span class=\"string\">&quot;: 3, &quot;</span>y<span class=\"string\">&quot;: 4 &#125;&quot;</span><span class=\"string\">&quot;&quot;</span> <span class=\"comment\">-- Ok &#123; x = 3, y = 4 &#125; : Result String Point</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很麻烦。不像JavaScript里一个<code>JSON.parse()</code>完事，确实Elm解析JSON的笨拙为人诟病，官方的<a href=\"http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest\">pipeline</a>包通过<code>|&gt;</code>组合Decoder，让语法稍微好了一点。最新的0.18版本下有<a href=\"http://package.elm-lang.org/packages/elm-community/json-extra/2.6.0/Json-Decode-Extra\">json-extra</a>提供更方便的decoder选择。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Json.Decode.Pipeline <span class=\"keyword\">exposing</span> (decode, required)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> : <span class=\"type\">Decoder</span> <span class=\"type\">Point</span></span><br><span class=\"line\"><span class=\"title\">pointDecoder</span> =</span><br><span class=\"line\">  decode <span class=\"type\">Point</span></span><br><span class=\"line\">    |&gt; required <span class=\"string\">&quot;x&quot;</span> int</span><br><span class=\"line\">    |&gt; required <span class=\"string\">&quot;y&quot;</span> int</span><br></pre></td></tr></table></figure>\n\n<p>可这距离<code>JSON.parse</code>还是不够啊。于是有人写了个根据Records类型<a href=\"https://github.com/eeue56/json-to-elm\">生成decoder的工具</a>，或者<a href=\"http://noredink.github.io/json-to-elm/\">在线生成</a>。</p>\n<p>相比之下，<a href=\"http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode\">encode</a>过程就简单多了。</p>\n<h3 id=\"与JavaScript\"><a href=\"#与JavaScript\" class=\"headerlink\" title=\"与JavaScript\"></a>与JavaScript</h3><p>有两种方式，port或flag。</p>\n<p>前者类似于在Elm应用上凿洞，用类似订阅发布的模式工作。需要在文件开头的module声明前，额外加上<code>port</code>关键词，同时需要暴露的接口前也需要<code>port</code>关键词。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">port</span> <span class=\"keyword\">module</span> Spelling <span class=\"keyword\">exposing</span> (..)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- port for sending strings out to JavaScript</span></span><br><span class=\"line\"><span class=\"keyword\">port</span> check : String -&gt; Cmd msg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- port for listening for suggestions from JavaScript</span></span><br><span class=\"line\"><span class=\"keyword\">port</span> suggestions : (<span class=\"type\">List</span> <span class=\"type\">String</span> -&gt; msg) -&gt; Sub msg</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title class_\">Elm</span>.<span class=\"property\">Spelling</span>.<span class=\"title function_\">fullscreen</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"property\">ports</span>.<span class=\"property\">check</span>.<span class=\"title function_\">subscribe</span>(<span class=\"keyword\">function</span>(<span class=\"params\">word</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> suggestions = <span class=\"title function_\">spellCheck</span>(word);</span><br><span class=\"line\">  app.<span class=\"property\">ports</span>.<span class=\"property\">suggestions</span>.<span class=\"title function_\">send</span>(suggestions);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spellCheck</span>(<span class=\"params\">word</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// have a real implementation!</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后者暴露program的init给外部JavaScript。在声明Elm program时，使用<code>programWithFlags</code>而非<code>program</code>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">init</span> : <span class=\"type\">Flags</span> -&gt; ( <span class=\"type\">Model</span>, <span class=\"type\">Cmd</span> <span class=\"type\">Msg</span> )</span><br><span class=\"line\"><span class=\"title\">init</span> flags =</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> =</span><br><span class=\"line\">  programWithFlags &#123; init = init, ... &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title class_\">Elm</span>.<span class=\"property\">MyApp</span>.<span class=\"title function_\">fullscreen</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&#x27;Tom&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">token</span>: <span class=\"string\">&#x27;12345&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Elm的思路是不向后兼容，避免过去问题的引入。只通过port和flags的方式，借由Elm runtime和外部JS沟通，避免自身的runtime exception，把问题只留在JavaScript部分。</p>\n<h2 id=\"工程实践\"><a href=\"#工程实践\" class=\"headerlink\" title=\"工程实践\"></a>工程实践</h2><p>使用Elm编写简单的应用时，可能一个.elm文件完成后，就可以直接<code>elm-make index.elm --output index.js</code>就OK了。当工程较大时（目前还没怎么看到生产环境用Elm的），必然需要拆分组件。</p>\n<p>Elm在设计上，拆分的比MVVM框架更细。它拆分到了函数的级别，由于它pure function的特点，不受状态的束缚，重用函数比MVVM框架顾虑少太多了。如，重用view函数就相当于React和Vue中的函数式组件。重用update函数，可以实现MVVM中“组件A改变组件B，组件B改变组件C，组件C改变组件A”的史诗级难题。</p>\n<p>封装和应用是通过<code>module ... exposing ...</code>和<code>import ... exposing ...</code>的语法完成的。Elm会去elm-package.json中的<code>source-directories</code>以及<code>dependencies</code>中声明的路径和包下寻找<code>import</code>对应的东西。剩下的，只要控制好复用程度，在习惯Elm语法后，就可以轻松且高逼格地编写Web应用了。</p>\n<p>Elm编写好，且通过<code>elm-make</code>成功编译后，会得到一个<code>.js</code>文件，在需要的HTML文件中引入，会得到一个<code>Elm</code>全局对象，存储了所有的program。<strong>每个program都有<code>embed</code>方法和<code>fullscreen</code>方法绑定在HTML文件中</strong>。之后，大功告成！</p>\n<p>参考作者所写的<a href=\"https://github.com/evancz/elm-todomvc\">TODOMVC</a>是个不错的开始。</p>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p><strong>Q：Where are my components? And how do they communicate?</strong><br>A：参见<a href=\"https://guide.elm-lang.org/reuse/\">Scaling The Elm Architecture</a></p>\n<p><strong>Q：What’s the “Elm style”?</strong><br>A：回头看看<a href=\"#%E5%89%8D%E8%A8%80\">前言</a>一节最后放的两个Elm开发感受，Elm中，View和Updates两部分均可以拆解成多个&#x2F;组helper functions。最后在一个门面文件中汇总。Elm将state、updates、view放在一个文件，对开发更友好。Elm的优势在于函数式编程特点的帮助（无副作用&#x2F;纯函数&#x2F;强类型&#x2F;出色的错误处理机制）和对人机交互模式的优异抽象。它的问题在</p>\n<ul>\n<li>不完善的文档</li>\n<li>蹩脚的互操作（interop）设计（port和flag）</li>\n<li>学习曲线陡峭</li>\n<li>缺乏成熟的成套解决方案</li>\n<li>坑爹的JSON支持</li>\n</ul>\n<p><strong>Q：Who will save my front-end routing?</strong><br>A：有的，借助<a href=\"https://github.com/elm-lang/navigation\">Elm Navigation package</a>就可以做到，具体如何和状态变化绑定起来参见<a href=\"https://www.elm-tutorial.org/en/07-routing/01-intro.html\">tutorial的routing部分</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://guide.elm-lang.org/\">An Introduction to Elm</a></li>\n<li><a href=\"http://elm-lang.org/docs/syntax\">syntax</a></li>\n<li><a href=\"https://learnyouanelm.github.io/pages/05-recursion.html\">Recursion | Elm</a></li>\n<li><a href=\"https://infi.nl/nieuws/why-i-became-an-elm-evangelist/\">Why I became an Elm evangelist</a></li>\n<li><a href=\"https://github.com/isRuslan/awesome-elm\">awesome-elm</a></li>\n</ul>\n",
            "tags": [
                "Elm",
                "框架",
                "函数式编程"
            ]
        }
    ]
}
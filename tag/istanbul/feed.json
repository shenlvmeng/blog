{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"istanbul\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2020/04/17/fe-coverage-improve/",
            "url": "http://shenlvmeng.github.com/blog/2020/04/17/fe-coverage-improve/",
            "title": "前端代码覆盖率实时统计改进方案",
            "date_published": "2020-04-16T16:08:03.000Z",
            "content_html": "<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><a href=\"https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/\">旧的覆盖率方案</a>实现了覆盖率采集的可行性探索。但是旧方案中也存在着侵入较多，适用场景有局限性，istanbul版本老旧，sourcemap支持不足等问题需要优化。有关覆盖率采集、维护、呈现、上报需要一个更通用和更具可拓展性的方案。</p>\n<p>因此，在对整个覆盖率要解决的问题和目标进行抽象后，可以得到以下的实现方案。</p>\n<h2 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h2><p><img src=\"https://s1.ax1x.com/2020/04/16/JEZ1J0.png\" alt=\"整体结构\"></p>\n<p>新的覆盖率方案可以分为3层：</p>\n<ul>\n<li><strong>采集层</strong>，这一层主要解决对代码进行<strong>插桩</strong>（instrument）的过程，只有插桩过的代码才能在执行的过程中不断积累覆盖率数据，从而通过端到端测试得到代码的覆盖率情况</li>\n<li><strong>数据层</strong>，采集到的覆盖率数据有上报的需求，浏览器端数据只有上报到服务端才能查看和操作，如果接入第三方平台，就更需要有专门数据<strong>处理和上报</strong>，这一层正是完成这部分工作</li>\n<li><strong>视图层</strong>，方案要自带<strong>视图化</strong>能力，给开发者更直观的反馈，同时要有<strong>可交互性</strong>，满足开发者的日常需求。这一层要能比较方便地绑定到流行的服务端环境中，减少侵入成本</li>\n</ul>\n<p>整体实现上，基于新版本<a href=\"https://github.com/gotwarlost/istanbul\">istanbuljs</a>。下面分层介绍各层实现中需要进行的工作。</p>\n<h2 id=\"采集层\"><a href=\"#采集层\" class=\"headerlink\" title=\"采集层\"></a>采集层</h2><p>代码插桩实现中，拆分为下面几点：</p>\n<h3 id=\"babel-preset\"><a href=\"#babel-preset\" class=\"headerlink\" title=\"babel preset\"></a>babel preset</h3><p>对于使用babel转码的工程来说，<a href=\"https://github.com/istanbuljs/babel-plugin-istanbul\">babel-plugin-istanbul</a>直接提供了一个可以插桩代码的插件。这里要做的只是区分线上和其他环境，以及预定义preset，减少用户babel配置成本。</p>\n<p>babel preset的书写可以参考<a href=\"https://babeljs.io/docs/en/presets#creating-a-preset\">babel preset</a>一节，我们只需将原先<code>.babelrc</code>或<code>babel.config.js</code>中的配置项用<code>require</code>包裹即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">env</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">development</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                    [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;babel-plugin-istanbul&#x27;</span>)]</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">boe</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                    [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;babel-plugin-istanbul&#x27;</span>)]</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>相对应的，接入方需要额外在<code>scm_build.sh</code>脚本中额外传入boe环境变量来区分boe和线上环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$BUILD_TYPE</span> = <span class=\"string\">&quot;offline&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    BABEL_ENV=boe yarn build</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    yarn build</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，默认情况下，istanbul只会对后缀为<code>[&#39;.js&#39;, &#39;.cjs&#39;, &#39;.mjs&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.jsx&#39;]</code>的文件进行处理，为了处理<code>.vue</code>文件，需要显式给<code>babel-plugin-istanbul</code>文件传入<code>extension</code>字段。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">env</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">development</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                    [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;babel-plugin-istanbul&#x27;</span>), &#123; <span class=\"attr\">extension</span>: [<span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.cjs&#x27;</span>, <span class=\"string\">&#x27;.mjs&#x27;</span>, <span class=\"string\">&#x27;.ts&#x27;</span>, <span class=\"string\">&#x27;.tsx&#x27;</span>, <span class=\"string\">&#x27;.jsx&#x27;</span>, <span class=\"string\">&#x27;.vue&#x27;</span>] &#125;]</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">boe</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                    [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;babel-plugin-istanbul&#x27;</span>), &#123; <span class=\"attr\">extension</span>: [<span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.cjs&#x27;</span>, <span class=\"string\">&#x27;.mjs&#x27;</span>, <span class=\"string\">&#x27;.ts&#x27;</span>, <span class=\"string\">&#x27;.tsx&#x27;</span>, <span class=\"string\">&#x27;.jsx&#x27;</span>, <span class=\"string\">&#x27;.vue&#x27;</span>] &#125;]</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hookRequire动态插桩\"><a href=\"#hookRequire动态插桩\" class=\"headerlink\" title=\"hookRequire动态插桩\"></a><code>hookRequire</code>动态插桩</h3><p>有些场景下并不使用babel进行转码，这里以最典型的TypeScript为例，<code>.ts</code>文件可以用<code>tsc</code>编译。<code>tsc</code>编译后的js代码只有插桩后，才可能采集到的覆盖率数据，因此接入方需要在所有业务代码的import之前调用hook，保证所有的服务端js代码在被执行前都完成了插桩。</p>\n<p>实现上，新版本istanbuljs整个是个monorepo，原来istanbul各模块的功能拆分到了packages的各子项目中。其中和hook相关的位于<strong>istanbul-lib-hook</strong>。这个库虽然并没有API和文档。但还好，和老版本的hook.js区别不大。使用暴露出来的<strong>hookRequire</strong>方法即可，使用方式也与之前无异。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> istanbul <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; hook &#125; = istanbul;</span><br><span class=\"line\"></span><br><span class=\"line\">instrumenter = <span class=\"keyword\">new</span> <span class=\"title class_\">Instrumenter</span>(options);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformer = instrumenter.<span class=\"property\">instrumentSync</span>.<span class=\"title function_\">bind</span>(instrumenter);</span><br><span class=\"line\">hook.<span class=\"title function_\">hookRequire</span>(matcher, transformer, &#123;</span><br><span class=\"line\">    <span class=\"attr\">postLoadHook</span>: <span class=\"function\">(<span class=\"params\">file: <span class=\"built_in\">any</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hookRequire &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-hook&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createInstrumenter &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-instrument&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">instrumenter = <span class=\"title function_\">createInstrumenter</span>(options);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformer = instrumenter.<span class=\"property\">instrumentSync</span>.<span class=\"title function_\">bind</span>(instrumenter);</span><br><span class=\"line\"><span class=\"title function_\">hookRequire</span>(matcher, transformer, &#123;</span><br><span class=\"line\">    <span class=\"attr\">postLoadHook</span>: <span class=\"function\">(<span class=\"params\">file: <span class=\"built_in\">any</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>hookRequire</code>方法接受3个参数：</p>\n<ul>\n<li><code>matcher</code>，来自用户输入，用来判断当前文件是否要被hook</li>\n<li><code>transformer</code>，最关键的代码转换函数，读入代码，返回转换后的代码，插桩的转换由<strong>istanbul-lib-instrument</strong>提供（原先的instrumenter.js），理论上也能支持其他的转换函数。这里使用<code>instrumentSync</code>这个同步转换。</li>\n<li><code>options</code>，支持verbose和postLoadHook两个选项<ul>\n<li><code>verbose</code>，boolean，是否打印详细日志</li>\n<li><code>postLoadHook</code>，function，成功回调，函数会传入完整的文件名</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sourcemap处理\"><a href=\"#sourcemap处理\" class=\"headerlink\" title=\"sourcemap处理\"></a>sourcemap处理</h3><p>由于istanbuljs插桩的是编译后的js代码，需要借助sourcemap才能找到源文件的覆盖情况。编译后文件的覆盖情况对开发者没有借鉴意义。使用<code>hookRequire</code>动态插桩时，还是需要自己处理sourcemap。</p>\n<p>老版本istanbul对sourcemap并不支持，需要借助<a href=\"https://github.com/SitePen/remap-istanbul\">remap-istanbul</a>才能实现。新版本的istanbuljs有一个独立的包<strong>istanbul-lib-source-maps</strong>支持这方面的功能。遗憾的是，再次没有文档介绍如何使用。</p>\n<p>通过查看测试样例和阅读源码可以发现，istanbul-lib-instrument中的<code>instrumentSync</code>支持第三个<code>sourcemap</code>参数，如果传入，则会在采集文件的覆盖率数据中附加该文件的sourcemap信息到<code>inputSourceMap</code>字段。而istanbul-lib-source-maps这个包可以对覆盖率数据中带有<code>inputSourceMap</code>字段的数据进行反映射，得到源文件覆盖情况。最终达到我们的目的。</p>\n<p>源文件的sourcemap信息需要自己采集，这里借鉴的nyc中使用的方案：<a href=\"https://github.com/thlorenz/convert-source-map\">convert-source-map</a>。这个npm包可以读取文件末尾的sourcemap字符串并转换为sourcemap对象。所以整体上，实现sourcemap处理的流程如下：</p>\n<ol>\n<li>在hookRequire的transformer中拿到代码字符串</li>\n<li>通过convert-source-map的<code>fromSource</code>方法拿到sourcemap对象</li>\n<li>在调用istanbul-lib-instrument的<code>instrumentSync</code>方法时，传入该对象<ol>\n<li>instrumenter内部的visitor.js调用source-coverage.js的<code>inputSourceMap</code>方法将文件的sourcemap传入</li>\n<li>source-coverage.js将sourcemap存入覆盖率数据中</li>\n</ol>\n</li>\n<li>使用istanbul-lib-source-maps中的<code>transformCoverage</code>方法转换覆盖率数据即可得到原始的覆盖率</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createInstrumenter &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-instrument&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> convert <span class=\"keyword\">from</span> <span class=\"string\">&#x27;convert-source-map&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">instrumenter = <span class=\"title function_\">createInstrumenter</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Step 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">transformer</span>: <span class=\"title class_\">Transformer</span> = <span class=\"function\">(<span class=\"params\">code, options</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Step 2</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> sourceMap = convert.<span class=\"title function_\">fromSource</span>(code);</span><br><span class=\"line\">    <span class=\"comment\">// Step 3</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> transformed = instrumenter.<span class=\"title function_\">instrumentSync</span>(</span><br><span class=\"line\">        code,</span><br><span class=\"line\">        options.<span class=\"property\">filename</span>,</span><br><span class=\"line\">        sourceMap ? sourceMap.<span class=\"title function_\">toObject</span>() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformed;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">hook</span>(matcher, transformer, &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据层\"><a href=\"#数据层\" class=\"headerlink\" title=\"数据层\"></a>数据层</h2><p>在覆盖率数据维护上，主要有下面几点工作：</p>\n<h3 id=\"sourcemap处理-1\"><a href=\"#sourcemap处理-1\" class=\"headerlink\" title=\"sourcemap处理\"></a>sourcemap处理</h3><p>在代码插桩附带上sourcemap信息后，可以参考istanbul-lib-source-maps的测试用例，用<code>transformCoverage</code>方法转换得到原始的覆盖率，即上一个同名小节中的第4步。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getOriginalCoverage</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 采集到的覆盖率</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> currCoverage = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getCoverage</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> coverageMap = <span class=\"title function_\">createCoverageMap</span>(currCoverage);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mapStore = <span class=\"title function_\">createSourceMapStore</span>(&#123;&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// Step 4</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> transformed = <span class=\"keyword\">await</span> mapStore.<span class=\"title function_\">transformCoverage</span>(coverageMap);</span><br><span class=\"line\">    <span class=\"comment\">// 对应到源文件的覆盖率</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformed.<span class=\"property\">data</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现时，还需要注意对一些sourcemap结构体中的<code>sourceRoot</code>进行特殊处理，避免反映射后得到嵌套的错误路径。</p>\n<h3 id=\"覆盖率数据维护\"><a href=\"#覆盖率数据维护\" class=\"headerlink\" title=\"覆盖率数据维护\"></a>覆盖率数据维护</h3><p>在一个测试覆盖率的周期下，需要merge每次产生的新的覆盖率。同时，要能通过原始的覆盖率数据生成摘要，方便UI展示。</p>\n<p>istanbul-lib-coverage的<code>CoverageMap</code>类型自带的<code>merge</code>方法，可以merge新的覆盖率数据到源<code>CoverageMap</code>中。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mergeClientCoverage</span>(<span class=\"params\">clientCoverage: CoverageMap</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!clientCoverage) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> currCoverage = <span class=\"title function_\">getCoverageObject</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> coverageMap = <span class=\"title function_\">createCoverageMap</span>(currCoverage)</span><br><span class=\"line\">    coverageMap.<span class=\"title function_\">merge</span>(clientCoverage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基准覆盖数据维护\"><a href=\"#基准覆盖数据维护\" class=\"headerlink\" title=\"基准覆盖数据维护\"></a>基准覆盖数据维护</h3><p>有些js代码在未访问到业务代码时就会被执行到，比如<code>import</code>和<code>export</code>语句。这些覆盖率如果被清空，就再也无法通过端到端测试找回来，所以需要对于这部分覆盖数据专门维护，这里称作<strong>基准覆盖数据</strong>。</p>\n<p>实现上，在hook完成后，取得hook文件的覆盖率数据，即可得到。这里需要异步执行，保证能够取到。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">hook</span>(matcher, transformer, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"attr\">postLoadHook</span>: <span class=\"function\">(<span class=\"params\">filename: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"title function_\">matcher</span>(filename) &amp;&amp; <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title class_\">Coverage</span>.<span class=\"title function_\">saveBaselineCoverage</span>(filename));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>每次reset操作，实现上并非简单的清空数据，而是将覆盖率数据置为基准覆盖数据。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// express</span></span><br><span class=\"line\">app.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/reset&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Coverage</span>.<span class=\"title function_\">restoreBaselineCoverage</span>();</span><br><span class=\"line\">    res.<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">code</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据上报\"><a href=\"#数据上报\" class=\"headerlink\" title=\"数据上报\"></a>数据上报</h3><p>数据上报只需实现定期上报，在上报时通过使用方预先定义好的中间件，便于使用方做预处理的工作。同时，提供一个关闭方法，可以在适当时机停止上报，形如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CoverageCollector</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"title function_\">use</span>(<span class=\"params\">middleware: Middleware</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">middlewares</span>.<span class=\"title function_\">push</span>(middleware);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"title function_\">init</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">intervalFlag</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">intervalFlag</span> = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">send</span>(), <span class=\"variable language_\">this</span>.<span class=\"property\">interval</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"title function_\">close</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">intervalFlag</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearInterval</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">intervalFlag</span>);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">intervalFlag</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">async</span> <span class=\"title function_\">send</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> coverageData = <span class=\"variable language_\">this</span>.<span class=\"property\">middlewares</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">data, middle</span>) =&gt;</span> <span class=\"title function_\">middle</span>(data), coverage);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> axios.<span class=\"title function_\">post</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">url</span>, coverageData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Send coverage data failed: &#x27;</span>, err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"视图层\"><a href=\"#视图层\" class=\"headerlink\" title=\"视图层\"></a>视图层</h2><p>视图化和可操作性上，有下面几点工作：</p>\n<h3 id=\"路由提供\"><a href=\"#路由提供\" class=\"headerlink\" title=\"路由提供\"></a>路由提供</h3><p>中间件对于开发者的受益，体现在能够通过浏览器访问得到视图化和可操作性的覆盖率数据。在功能上，中间件提供5个路由：</p>\n<ul>\n<li><code>/</code>，GET，提供整个项目的覆盖率摘要页面</li>\n<li><code>/show</code>，GET，访问文件或文件夹时，提供文件覆盖率详情或文件夹覆盖率摘要</li>\n<li><code>/reset</code>，POST，重置当前项目的覆盖率，开始一次新的采集周期</li>\n<li><code>/object</code>，GET，返回覆盖率的原始数据的JSON格式</li>\n<li><code>/client</code>，POST，用来接收来自浏览器端的覆盖率数据，merge到整体的覆盖率数据中</li>\n</ul>\n<p>实现上，直接提供预定义好的app或express应用，npm包暴露一个attachHandler API，使用方直接挂载即可拥有上述功能。类似下面所示。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;/coverage&#x27;</span>, attachHandler.<span class=\"title function_\">koa</span>()));</span><br></pre></td></tr></table></figure>\n\n<p>由于绑定一定发生在服务端环境，可以的话，需要顺便区分线上和其他环境。</p>\n<h3 id=\"报告html页面生成\"><a href=\"#报告html页面生成\" class=\"headerlink\" title=\"报告html页面生成\"></a>报告html页面生成</h3><p>开发者应该能在每个测试周期内（即请求<code>/reset</code>前），通过访问特定路由得到渲染好的html页面。istanbuljs通过istanbul-lib-report和istanbul-reports两个包相互配合实现导出report的功能。其中：</p>\n<ul>\n<li>istanbul-lib-report：重点负责构建文件层级结构和生成摘要数据，定义遍历每个节点时行为的几个抽象类</li>\n<li>istanbul-reports：重点实现各种各样导出格式下内容的生成（只考虑了生成静态文件），通过实现istanbul-lib-report中ReportBase基类，完成遍历中内容的生成</li>\n</ul>\n<p>下面是README.md给出的示例</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> libReport = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;istanbul-lib-report&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> reports = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;istanbul-reports&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// coverageMap, for instance, obtained from istanbul-lib-coverage</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> coverageMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> configWatermarks = &#123;</span><br><span class=\"line\">    <span class=\"attr\">statements</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">functions</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">branches</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">lines</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create a context for report generation</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> context = libReport.<span class=\"title function_\">createContext</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">dir</span>: <span class=\"string\">&#x27;report/output/dir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// The summarizer to default to (may be overridden by some reports)</span></span><br><span class=\"line\">    <span class=\"comment\">// values can be nested/flat/pkg. Defaults to &#x27;pkg&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">defaultSummarizer</span>: <span class=\"string\">&#x27;nested&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">watermarks</span>: configWatermarks,</span><br><span class=\"line\">    coverageMap,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an instance of the relevant report class, passing the</span></span><br><span class=\"line\"><span class=\"comment\">// report name e.g. json/html/html-spa/text</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> report = reports.<span class=\"title function_\">create</span>(<span class=\"string\">&#x27;json&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">skipEmpty</span>: configSkipEmpty,</span><br><span class=\"line\">    <span class=\"attr\">skipFull</span>: configSkipFull</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call execute to synchronously create and write the report to disk</span></span><br><span class=\"line\">report.<span class=\"title function_\">execute</span>(context)</span><br></pre></td></tr></table></figure>\n\n<p>在istanbul-reports&#x2F;lib&#x2F;html中主要定义了html相关内容的生成，但是其中对于fs模块的使用，限制了该npm包在server侧的应用。经过<a href=\"https://github.com/istanbuljs/istanbuljs/issues/530\">询问作者</a>得到，istanbuljs并没有想法支持动态生成html响应。另外，istanbul-lib-report和istanbul-reports关联较多，新开发一个report类型用于生成html响应成本较大。</p>\n<p>综上，使用旧的方案，即旧版本istanbul生成html响应比较合适。</p>\n<h2 id=\"新方案\"><a href=\"#新方案\" class=\"headerlink\" title=\"新方案\"></a>新方案</h2><p>上述工作完成后，最终可以实现一个新的覆盖率方案，基本解决了上面提到的侵入较多，适用场景有局限性，istanbul版本老旧，sourcemap支持不足等问题。</p>\n<h2 id=\"已知问题\"><a href=\"#已知问题\" class=\"headerlink\" title=\"已知问题\"></a>已知问题</h2><p>上面的改进方案解决了方案接入上的困难，和实现上的一些纰漏，满足了开发者自测时的需求。但同时也有以下不足：</p>\n<ul>\n<li>对于更复杂的数据呈现和与业务流程的整合，即<a href=\"https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/\">旧方案</a>已知问题的第4点：“不能以分支、版本、仓库等空间维度或以历史信息、趋势等时间维度查看覆盖率报告，也没有diff内容覆盖率功能”，还需要更多努力。</li>\n<li>对于一些特殊场景，如没有使用babel转码的纯前端，不使用express或koa框架的服务端等无法支持</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/thlorenz/convert-source-map\">convert-source-map</a></li>\n<li><a href=\"https://github.com/istanbuljs/istanbuljs\">istanbuljs</a></li>\n<li><a href=\"https://github.com/istanbuljs/nyc\">nyc</a></li>\n</ul>\n",
            "tags": [
                "覆盖率",
                "端到端测试",
                "istanbul",
                "istanbuljs"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/",
            "url": "http://shenlvmeng.github.com/blog/2020/04/16/istanbuljs/",
            "title": "JS代码覆盖率工具instanbuljs及其思路介绍",
            "date_published": "2020-04-16T15:51:13.000Z",
            "content_html": "<p><img src=\"https://s1.ax1x.com/2020/04/16/JEZ3WV.png\" alt=\"istanbul介绍\"></p>\n<p><a href=\"https://istanbul.js.org/\">intanbuljs</a>是JS语言中最流行的覆盖率采集工具。其前身是个人发起的<a href=\"https://github.com/gotwarlost/istanbul\">istanbul</a>项目。日常使用中，经常将相关的CLI工具<a href=\"https://github.com/istanbuljs/nyc\">nyc</a>配合着<a href=\"https://istanbul.js.org/docs/tutorials/\">流行的前端测试框架</a>一起使用，达到在单元&#x2F;集成&#x2F;e2e测试的同时，输出测试覆盖率数据的效果。</p>\n<p>当然，你也可以通过<a href=\"https://github.com/istanbuljs/babel-plugin-istanbul\">babel-plugin-istanbul</a>配合测试框架<a href=\"https://istanbul.js.org/docs/tutorials/\">使用</a>。</p>\n<h2 id=\"和istanbul的对比\"><a href=\"#和istanbul的对比\" class=\"headerlink\" title=\"和istanbul的对比\"></a>和istanbul的对比</h2><p>对于此前对前端测试覆盖率稍有了解了的人来说，可能更熟悉的是旧版的istanbul。istanbuljs在功能上和istanbul没有太大的区别，但在项目组织和实现细节上有着些许不同。</p>\n<ul>\n<li><a href=\"https://github.com/istanbuljs/istanbuljs\">istanbuljs</a>使用monorepo组织整个项目，将相对独立的插桩、hook、覆盖率、sourcemap、报告等拆分成多个包独立实现和发版</li>\n<li>使用babel实现源代码的AST解析和插桩（instrument）代码的生成</li>\n<li>内置支持sourcemap</li>\n<li>报告生成上取消了对express的依赖，只在本地产出报告</li>\n</ul>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于希望借助istanbuljs实现代码覆盖率相关功能的（nyc也基于istanbuljs实现），了解其各个包工作原理将会有所帮助。下面就按功能范畴介绍各个包的实现原理。</p>\n<h3 id=\"代码插桩和hook\"><a href=\"#代码插桩和hook\" class=\"headerlink\" title=\"代码插桩和hook\"></a>代码<a href=\"https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)\">插桩</a>和hook</h3><p>覆盖率产出建立在<strong>代码插桩</strong>的基础上。根据插桩时机，分为<strong>编译时插桩</strong>和<strong>运行时插桩</strong>。</p>\n<ul>\n<li><strong>编译时插桩</strong>，即在代码转译过程中插入覆盖率采集代码，产出代码本身即拥有采集能力，譬如babel-plugin-istanbul</li>\n<li><strong>运行时插桩</strong>，即产出代码本身不具有采集能力，在运行时通过hook的方式在使用的代码中插入覆盖率采集代码，譬如<code>hookRequire</code></li>\n</ul>\n<p>不同于使用babel的编译时插桩，运行时插桩需要额外的hook一步。插桩和hook分别由<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-instrument\">istanbul-lib-instrument</a>和<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-hook\">istanbul-lib-hook</a>实现。</p>\n<h4 id=\"istanbul-lib-instrument\"><a href=\"#istanbul-lib-instrument\" class=\"headerlink\" title=\"istanbul-lib-instrument\"></a>istanbul-lib-instrument</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createInstrumenter &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-instrument&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> instrumenter = <span class=\"title function_\">createInstrumenter</span>(&#123;</span><br><span class=\"line\">    coverageVariable,</span><br><span class=\"line\">    <span class=\"attr\">debug</span>: options &amp;&amp; options.<span class=\"property\">debug</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> transformed = instrumenter.<span class=\"title function_\">instrumentSync</span>(</span><br><span class=\"line\">    code,</span><br><span class=\"line\">    options.<span class=\"property\">filename</span>,</span><br><span class=\"line\">    sourceMap ? sourceMap.<span class=\"title function_\">toObject</span>() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>istanbul-lib-instrument利用babel实现了代码插桩。仓库暴露了3个API：</p>\n<h5 id=\"createInstrumenter\"><a href=\"#createInstrumenter\" class=\"headerlink\" title=\"createInstrumenter\"></a><code>createInstrumenter</code></h5><p>最主要的API。以入参作为配置项创建一个<code>Instrumenter</code>实例，配置项如下：</p>\n<ul>\n<li><code>coverageVariable</code> 覆盖率全局变量名，可选，默认<code>__coverage__</code></li>\n<li><code>preserveComments</code> 是否保留注释，可选，默认<code>false</code></li>\n<li><code>esModules</code> 是否插桩ES6代码，可选，默认<code>false</code></li>\n<li><code>produceSourceMap</code> 是否为插桩前后代码生成sourcemap，可选，默认<code>false</code></li>\n<li><code>debug</code> 是否打印详细信息，可选，默认<code>false</code></li>\n<li>… 更多配置参见<a href=\"https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-instrument/api.md#parameters-4\">文档介绍</a></li>\n</ul>\n<p>通常使用时，配置项均使用默认值即可。<code>Instrumenter</code>实例有下面几个重要的方法</p>\n<p><strong><code>instrumentSync</code></strong></p>\n<p>同步插桩代码，支持ES6和ES5，插桩ES6代码时，需要配置项中的<code>esModules</code>为<code>true</code>。解析代码出错时会抛出错误。方法返回插桩后的代码字符串，入参如下：</p>\n<ul>\n<li><code>code</code> 代码字符串</li>\n<li><code>filename</code> 文件名（包含路径）</li>\n<li><code>inputSourceMap</code> 用来将当前代码的覆盖率反映射到源文件中的覆盖率，需要是sourcemap格式。</li>\n</ul>\n<p>在指定了<code>inputSourceMap</code>后，当前文件采集覆盖率时，会附带上传入的这个sourcemap，从而可以结合istanbul-lib-sourcemaps使用。</p>\n<p><strong><code>instrument</code></strong></p>\n<p>callback风格的插桩，此时抛出错误将通过回调的入参传入，而非直接抛出。插桩的代码也会在回调中传入而非直接返回。需要注意的是，回调的执行和语句的执行在同一个process tick中，而不是异步的。</p>\n<p>函数入参即<code>instrumentSync</code>的第三个位置插入函数类型的<code>callback</code>入参。</p>\n<p>剩余的两个方法：</p>\n<ul>\n<li><code>lastFileCoverage</code>，返回最近一次的文件覆盖率对象</li>\n<li><code>lastSourceMap</code>，返回最近一次的文件的sourcemap</li>\n</ul>\n<h5 id=\"programVisitor\"><a href=\"#programVisitor\" class=\"headerlink\" title=\"programVisitor\"></a><code>programVisitor</code></h5><p><code>programVisitor</code>是一个将babel用于插桩的适配器函数，该函数会返回一个具有<code>enter</code>以及<code>exit</code>方法的对象，这两个方法必须应用在<code>Program</code>的enter和exit属性上，实现插桩效果。istanbuljs内部也是通过<code>programVisitor</code>实现的功能。<code>programVisitor</code>内部并不依赖babel的状态，因此也可以用在babel以外的环境。</p>\n<p>该函数支持以下入参：</p>\n<ul>\n<li><code>types</code>，babel-types实例，语法节点类型</li>\n<li><code>sourceFilePath</code>，文件路径，可选，默认为<code>unknown.js</code></li>\n<li><code>opts</code>，插桩配置项，可以参见<a href=\"https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-instrument/api.md#parameters-4\">文档介绍</a></li>\n</ul>\n<p>在函数内部集中了插桩的细节实现，即对于特定类型语法树节点插入对应逻辑。</p>\n<h5 id=\"readInitialCoverage\"><a href=\"#readInitialCoverage\" class=\"headerlink\" title=\"readInitialCoverage\"></a><code>readInitialCoverage</code></h5><p>配合<code>Instrumenter</code>的<code>lastFileCoverage</code>方法使用，读取文件的初始覆盖率。</p>\n<p>上面这些API中，最常用和最核心的即<code>instrumentSync</code>方法。在实现上，方法分为下面几步：</p>\n<ol>\n<li>根据<code>Instrumenter</code>的配置项确定babel的配置项，同时，引入<code>programVisitor</code>作为babel的plugin，指定遍历节点的操作</li>\n<li>使用<code>@babel/core</code>的<code>transformSync</code>API，得到生成的代码</li>\n<li>更新<code>fileCoverage</code>和<code>sourcemap</code></li>\n<li>返回代码</li>\n</ol>\n<h4 id=\"istanbul-lib-hook\"><a href=\"#istanbul-lib-hook\" class=\"headerlink\" title=\"istanbul-lib-hook\"></a>istanbul-lib-hook</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; hookRequire &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-hook&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">hookRequire</span>(matcher, transformer, &#123;</span><br><span class=\"line\">    <span class=\"attr\">verbose</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">postLoadHook</span>: <span class=\"function\">(<span class=\"params\">filename: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>istanbul-lib-hook提供了下面一些API，用来hook JS中对代码的引用，其中后三个API都有对应的unhook API：</p>\n<ul>\n<li><code>hookRequire</code>，hook了<code>require</code>引入的代码</li>\n<li><code>hookCreateScript</code>，hook了<code>vm.createScript</code>引入的代码</li>\n<li><code>hookRunInThisContext</code>，hook了<code>vm.runInThisContext</code>引入的代码</li>\n<li><code>hookRunInContext</code>，hook了<code>vm.runInContext</code>引入的代码、</li>\n</ul>\n<p>在其中最常用的是<code>hookRequire</code>，入参如下：</p>\n<ul>\n<li><code>matcher</code>，函数类型，接收文件的完整路径，返回bool类型，用来判断是否对文件插桩</li>\n<li><code>transformer</code>，函数类型，接收代码和文件路径，返回插桩后的代码，可以通过对上面提到的<code>Instrumenter</code>的<code>instrumentSync</code>封装得到</li>\n<li><code>options</code>，配置项<ul>\n<li><code>verbose</code>，是否打印详细信息</li>\n<li><code>postLoadHook</code>，文件hook之后的回调</li>\n</ul>\n</li>\n</ul>\n<p><code>hookRequire</code>借助Nodejs的Module加载机制实现，hook了后缀为<code>.js</code>文件的编译过程，在每次<code>require</code>的时候触发。详细的原理可以参见<a href=\"https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/\">这里</a>。唯一的不同是，在istanbuljs中，这一实现被封装在<a href=\"https://github.com/istanbuljs/append-transform\">append-transform</a>包中实现，来兼容异常情况。实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> appendTransform = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;append-transform&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hookRequire</span>(<span class=\"params\">matcher, transformer, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"title function_\">transformFn</span>(matcher, transformer, options.<span class=\"property\">verbose</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> extensions = options.<span class=\"property\">extensions</span> || [<span class=\"string\">&#x27;.js&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    extensions.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">ext</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">appendTransform</span>(<span class=\"function\">(<span class=\"params\">code, filename</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> ret = <span class=\"title function_\">fn</span>(code, filename);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postLoadHook) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">postLoadHook</span>(filename);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret.<span class=\"property\">code</span>;</span><br><span class=\"line\">        &#125;, ext);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据维护\"><a href=\"#数据维护\" class=\"headerlink\" title=\"数据维护\"></a>数据维护</h3><p>在代码插桩的基础上，产出的覆盖率数据会积累在全局变量上。在数据可视化和统计结果展示前，还需要将数据封装成更贴近实际场景的形态，便于进行合并、输出、摘要等操作。</p>\n<p>这部分工作在<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-coverage\">istanbul-lib-coverage</a>中完成。</p>\n<h4 id=\"覆盖率数据结构\"><a href=\"#覆盖率数据结构\" class=\"headerlink\" title=\"覆盖率数据结构\"></a>覆盖率数据结构</h4><p>下面是采集到的原始数据的结构定义，这也是istanbul-lib-coverage的基础。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CoverageMapData</span> &#123;</span><br><span class=\"line\">    [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">FileCoverageData</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">FileCoverageData</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">statementMap</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Range</span> &#125;;</span><br><span class=\"line\">    <span class=\"attr\">fnMap</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">FunctionMapping</span> &#125;;</span><br><span class=\"line\">    <span class=\"attr\">branchMap</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">BranchMapping</span> &#125;;</span><br><span class=\"line\">    <span class=\"attr\">s</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">    <span class=\"attr\">f</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: &#123; [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>[] &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Location</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">line</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">column</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Range</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">start</span>: <span class=\"title class_\">Location</span>;</span><br><span class=\"line\">    <span class=\"attr\">end</span>: <span class=\"title class_\">Location</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BranchMapping</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">loc</span>: <span class=\"title class_\">Range</span>;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">locations</span>: <span class=\"title class_\">Range</span>[];</span><br><span class=\"line\">    <span class=\"attr\">line</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">FunctionMapping</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">decl</span>: <span class=\"title class_\">Range</span>;</span><br><span class=\"line\">    <span class=\"attr\">loc</span>: <span class=\"title class_\">Range</span>;</span><br><span class=\"line\">    <span class=\"attr\">line</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"istanbul-lib-coverage\"><a href=\"#istanbul-lib-coverage\" class=\"headerlink\" title=\"istanbul-lib-coverage\"></a>istanbul-lib-coverage</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> libCoverage <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-coverage&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = libCoverage.<span class=\"title function_\">createCoverageMap</span>(globalCoverageVar);</span><br><span class=\"line\"><span class=\"keyword\">const</span> summary = libCoverage.<span class=\"title function_\">createCoverageSummary</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">map.<span class=\"title function_\">merge</span>(otherCoverageMap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取摘要</span></span><br><span class=\"line\">map.<span class=\"title function_\">files</span>().<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">f</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fc = map.<span class=\"title function_\">fileCoverageFor</span>(f);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = fc.<span class=\"title function_\">toSummary</span>();</span><br><span class=\"line\">    summary.<span class=\"title function_\">merge</span>(s);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Global summary&#x27;</span>, summary);</span><br></pre></td></tr></table></figure>\n\n<p>包暴露了3个API, 用来创建封装好的覆盖率数据。</p>\n<h5 id=\"createCoverageMap\"><a href=\"#createCoverageMap\" class=\"headerlink\" title=\"createCoverageMap\"></a><code>createCoverageMap</code></h5><p>传入原始数据（<code>CoverageMapData</code>类型）或<code>CoverageMap</code>类型，返回一个<code>CoverageMap</code>类型对象，在覆盖率数据基础上，提供了方法，包含：</p>\n<ul>\n<li><code>merge</code>，合并另一个<code>CoverageMap</code>对象或数据</li>\n<li><code>filter</code>，传入filter函数，删除部分覆盖率数据</li>\n<li><code>toJSON</code>，返回原始数据</li>\n<li><code>files</code>，返回文件列表</li>\n<li><code>fileCoverageFor</code>，返回特定文件的覆盖率</li>\n<li><code>addFileCoverage</code>，增加特定文件的覆盖率</li>\n<li><code>getCoverageSummary</code>，生成覆盖率摘要数据</li>\n</ul>\n<p>摘要数据数据结构如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CoverageSummaryData</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">lines</span>: <span class=\"title class_\">Totals</span>;</span><br><span class=\"line\">    <span class=\"attr\">statements</span>: <span class=\"title class_\">Totals</span>;</span><br><span class=\"line\">    <span class=\"attr\">branches</span>: <span class=\"title class_\">Totals</span>;</span><br><span class=\"line\">    <span class=\"attr\">functions</span>: <span class=\"title class_\">Totals</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Totals</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">total</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">covered</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">skipped</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">pct</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"createFileCoverage\"><a href=\"#createFileCoverage\" class=\"headerlink\" title=\"createFileCoverage\"></a><code>createFileCoverage</code></h5><p>类似<code>createCoverageMap</code>，通过传入原始数据或对象的方式，创建<code>FileCoverage</code>对象。对象有如下方法：</p>\n<ul>\n<li><code>getLineCoverage</code>，返回每一行的执行次数</li>\n<li><code>getUncoveredLines</code>，返回未覆盖的行序号列表</li>\n<li><code>getBranchCoverageByLine</code>，获取每个分支按行计算的覆盖率比例</li>\n<li><code>toJSON</code>，返回原始数据</li>\n<li><code>merge</code>，合并另一个<code>FileCoverage</code>或原始数据</li>\n<li><code>computeSimpleTotals</code>，根据输入的属性，计算覆盖率摘要</li>\n<li><code>computeBranchTotals</code>，根据分支计算覆盖率摘要</li>\n<li><code>resetHits</code>，重置所有已执行的数据</li>\n<li><code>toSummary</code>，生成摘要数据</li>\n</ul>\n<h5 id=\"createCoverageSummary\"><a href=\"#createCoverageSummary\" class=\"headerlink\" title=\"createCoverageSummary\"></a><code>createCoverageSummary</code></h5><p>根据输入数据，创建摘要。方法较简单：</p>\n<ul>\n<li><code>merge</code>，合并一个摘要数据</li>\n<li><code>toJSON</code>，返回原始摘要数据</li>\n<li><code>isEmpty</code>，是否为空</li>\n</ul>\n<p>整体来看istanbul-lib-coverage所做的工作，即按照约定好的格式，将数据组织起来，为可视化输出做了基础。</p>\n<h4 id=\"istanbul-lib-source-maps\"><a href=\"#istanbul-lib-source-maps\" class=\"headerlink\" title=\"istanbul-lib-source-maps\"></a>istanbul-lib-source-maps</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createSourceMapStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-source-maps&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> libCoverage <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-coverage&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStore = <span class=\"title function_\">createSourceMapStore</span>(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> coverageMap = libCoverage.<span class=\"title function_\">createCoverageMap</span>(coverageData);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformed = <span class=\"keyword\">await</span> mapStore.<span class=\"title function_\">transformCoverage</span>(coverageMap);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformedCoverage = transformed.<span class=\"property\">data</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(transformedCoverage);</span><br></pre></td></tr></table></figure>\n\n<p>绝大多数情况下，istanbuljs采集到的都是转译后目标文件的代码覆盖率，这个数据对于开发者来讲意义不大，需要将这里采集到的行列数据反映射到源文件的位置上。内置<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-source-maps\">istanbul-lib-source-maps</a>包用来处理这种情况的。</p>\n<p>istanbul-lib-source-maps只负责转换代码位置和目录，并不能负责收集代码或文件的sourcemap信息，这一步交给使用者自己实现。就像我们在<code>instrumentSync</code>一节提到的，通过第三个入参<code>inputSourceMap</code>可以产出满足istanbul-lib-source-maps需要的覆盖率数据，从而借助istanbul-lib-source-maps获取到源文件的覆盖率。</p>\n<p>这个包本身只暴露<code>createSourceMapStore</code>这一个API，通过传入配置的方式，初始化一个sourcemap的store。配置项如下：</p>\n<ul>\n<li><code>verbose</code>，是否打印详细信息</li>\n<li><code>baseDir</code>，sourcemap文件的基础目录</li>\n<li><code>SourceStore</code>，一个<code>SourceStore</code>对象</li>\n<li><code>sourceStoreOpts</code>，初始化<code>SourceStore</code>对象的参数列表</li>\n</ul>\n<p>初始化好的<code>MapStore</code>对象有如下方法：</p>\n<ul>\n<li><code>registerURL</code>，通过dataURL注册一个sourcemap到store中</li>\n<li><code>registerMap</code>，通过sourcemap对象注册一个sourcemap到store中</li>\n<li><code>getSourceMapSync</code>，从当前store中获取指定文件的sourcemap</li>\n<li><code>addInputSourceMapsSync</code>，为当前覆盖率数据同步添加store中的sourcemap数据</li>\n<li><code>sourceFinder</code>，寻找指定文件的源文件路径</li>\n<li><code>transformCoverage</code>，利用当前store中的sourcemap信息，将覆盖率对应到源文件上。<strong>覆盖率信息中有<code>inputSourceMap</code>字段时，优先使用<code>inputSourceMap</code>字段里的sourcemap信息</strong></li>\n<li><code>dispose</code>，清除store数据</li>\n</ul>\n<p>包中的其余文件也都基于<code>MapStore</code>实现诸如路径转换，数据转换等工具方法。更多细节，可以参见<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-source-maps\">源文件</a>。</p>\n<p>使用时，有两种方式：</p>\n<ul>\n<li>先导入没有sourcemap的覆盖率信息，再逐个注册sourcemap到store中，最后执行<code>transformCoverage</code></li>\n<li>直接导入有<code>inputSourceMap</code>信息的覆盖率数据，执行<code>transformCoverage</code></li>\n</ul>\n<p>可以根据实际场景选择使用方式。例如，nyc中就使用的第2种方式，利用<a href=\"https://github.com/thlorenz/convert-source-map\">convert-source-map</a>采集到文件内的sourcemap信息，在代码插桩时传入。</p>\n<h3 id=\"可视化与报告\"><a href=\"#可视化与报告\" class=\"headerlink\" title=\"可视化与报告\"></a>可视化与报告</h3><p>覆盖率工具的最终目的是向使用者呈现可读的数据样式，通常是以UI或文件的形式。因此，要将上一章中维护好的数据按使用者需求输出。可视化和报告由<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-report\">istanbul-lib-report</a>以及<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports\">istanbul-reports</a>实现。</p>\n<p>其中，前者定义了产出报告的抽象行为，后者实现了各种具体的报告形态。两个包结合在一起使用的方式如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> libReport <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-lib-report&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reports <span class=\"keyword\">from</span> <span class=\"string\">&#x27;istanbul-reports&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> coverageMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> configWatermarks = &#123;</span><br><span class=\"line\">    <span class=\"attr\">statements</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">functions</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">branches</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>],</span><br><span class=\"line\">    <span class=\"attr\">lines</span>: [<span class=\"number\">50</span>, <span class=\"number\">80</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> context = libReport.<span class=\"title function_\">createContext</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">dir</span>: <span class=\"string\">&#x27;report/output/dir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 摘要的生成方式</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以是nested/flat/pkg 默认为&#x27;pkg&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">defaultSummarizer</span>: <span class=\"string\">&#x27;nested&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">watermarks</span>: configWatermarks,</span><br><span class=\"line\">    coverageMap,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> report = reports.<span class=\"title function_\">create</span>(<span class=\"string\">&#x27;json&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">skipEmpty</span>: configSkipEmpty,</span><br><span class=\"line\">    <span class=\"attr\">skipFull</span>: configSkipFull</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 同步操作</span></span><br><span class=\"line\">report.<span class=\"title function_\">execute</span>(context);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"istanbul-lib-report\"><a href=\"#istanbul-lib-report\" class=\"headerlink\" title=\"istanbul-lib-report\"></a>istanbul-lib-report</h4><p>维护好的覆盖率数据会和具体的文件节点绑定，形成树状数据结构。遍历每个树节点就是产出报告的基本步骤，只不过不同报告格式，遍历节点的操作也不同。istanbul-lib-report中定义了基本的树状结构和遍历规则。</p>\n<p>包暴露了3个API，</p>\n<ul>\n<li><code>createContext</code>，创建一个包含产出报告配置信息context对象</li>\n<li><code>getDefaultWatermarks</code>，返回默认的评级指标，默认是0到50到80，分别对应差中好</li>\n<li><code>ReportBase</code>，所有报告必须继承的基类</li>\n</ul>\n<p>其中context和ReportBase是配合实现生成报告的。先来看简单的ReportBase，<code>ReportBase</code>类中简单地描述了管理摘要树的方法和定义了通用的<code>execute</code>方法来生成报告。具体会在istanbul-reports中提到。</p>\n<p>再来看Context类。Context入参配置项包含：</p>\n<ul>\n<li><code>dir</code>，产出报告的目标目录</li>\n<li><code>watermarks</code>，评级指标，默认使用0-50-80-100</li>\n<li><code>sourceFinder</code>，通过文件路径返回代码的函数，默认为文件读取操作</li>\n<li><code>coverageMap</code>，覆盖率数据</li>\n<li><code>defaultSummarizer</code>，摘要树生成的风格，有<code>flat</code>,<code>pkg</code>,<code>nested</code>3种选择<ul>\n<li><code>flat</code>，所有文件全部打平到1层里，挂载到最近的公共祖先上</li>\n<li><code>pkg</code>，所有文件向上追溯1层文件夹，挂载到最近的公共祖先上</li>\n<li><code>nested</code>，所有文件向上追溯，直到追溯到最近的公共祖先上</li>\n</ul>\n</li>\n</ul>\n<p>构建好的<code>Context</code>有一个<code>writer</code>属性挂载在<code>this</code>和<code>this.data</code>上，它决定了报告的产出形式，目前这个包提供了两种产出形式：<strong>文件</strong>和<strong>字符串</strong>，后者只用在产出XML数据时。其余报告基本都通过文件的形式产出，这也是istanbuljs和istanbul的一大不同。在istanbul中，html可以借助express依赖以HTML响应的形式返回。</p>\n<p>文件的输出类定义在<code>file-writer.js</code>中，其中的<code>FileWriter</code>定义了基本的<code>copyFile</code>，<code>writerForDir</code>，<code>writeFile</code>操作用来递归的复制和写入文件。另外在<code>writeFile</code>中，根据目标是否是file，选择使用<code>ConsoleWriter</code>或者<code>FileContentWriter</code>。这两者继承自基本的<code>ContentWriter</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ContentWriter</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">colorize</span>(<span class=\"params\">str <span class=\"comment\">/*, clazz*/</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">println</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">write</span>(<span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span>\\n`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">close</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileContentWriter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ContentWriter</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">fd</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">fd</span> = fd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">write</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">writeSync</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">fd</span>, str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">close</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">closeSync</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">fd</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsoleWriter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ContentWriter</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">write</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capture) &#123;</span><br><span class=\"line\">            output += str;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            process.<span class=\"property\">stdout</span>.<span class=\"title function_\">write</span>(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">colorize</span>(<span class=\"params\">str, clazz</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> colors = &#123;</span><br><span class=\"line\">            <span class=\"attr\">low</span>: <span class=\"string\">&#x27;31;1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">medium</span>: <span class=\"string\">&#x27;33;1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">high</span>: <span class=\"string\">&#x27;32;1&#x27;</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supportsColor.<span class=\"property\">stdout</span> &amp;&amp; colors[clazz]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">`\\u001b[<span class=\"subst\">$&#123;colors[clazz]&#125;</span>m<span class=\"subst\">$&#123;str&#125;</span>\\u001b[0m`</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字符串的输出类只有<code>XMLWriter</code>，位于<code>xml-writer.js</code>中，在其中定义了xml的开闭标签和缩进操作。</p>\n<p>这个Context还有一些方法提供给reports使用：</p>\n<ul>\n<li><code>getWriter</code>&#x2F;<code>getXMLWriter</code>，返回输出数据的writer</li>\n<li><code>getSource</code>，通过<code>sourceFinder</code>寻找源码</li>\n<li><code>classForPercent</code>，将评价转化为HTML类名</li>\n<li><code>getVisitor</code>，获取一个遍历的vistor对象</li>\n<li><code>getTree</code>，根据摘要风格返回一个用于遍历的树，</li>\n</ul>\n<p>下面具体介绍vistor和tree的概念</p>\n<h5 id=\"Visitor和BaseTree\"><a href=\"#Visitor和BaseTree\" class=\"headerlink\" title=\"Visitor和BaseTree\"></a><code>Visitor</code>和<code>BaseTree</code></h5><p><code>Visitor</code>类和<code>BaseNode</code>类定义了遍历和节点的基本操作，其中Visitor使用代理人模式，在构造时传入一个回调函数对象，当<code>visitor</code>对象触发特定事件时，会将当前节点和状态交给回调函数，实现遍历效果。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Visitor</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">delegate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">delegate</span> = delegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">&#x27;Start&#x27;</span>, <span class=\"string\">&#x27;End&#x27;</span>, <span class=\"string\">&#x27;Summary&#x27;</span>, <span class=\"string\">&#x27;SummaryEnd&#x27;</span>, <span class=\"string\">&#x27;Detail&#x27;</span>]</span><br><span class=\"line\">    .<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> <span class=\"string\">`on<span class=\"subst\">$&#123;k&#125;</span>`</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"title class_\">Visitor</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, fn, &#123;</span><br><span class=\"line\">            <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"title function_\">value</span>(<span class=\"params\">node, state</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">this</span>.<span class=\"property\">delegate</span>[fn] === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">this</span>.<span class=\"property\">delegate</span>[fn](node, state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>相对应的<code>BaseNode</code>类定义了用于遍历的<code>visit</code>方法</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseNode</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 递归遍历</span></span><br><span class=\"line\">    <span class=\"title function_\">visit</span>(<span class=\"params\">visitor, state</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件夹没有详情，只有摘要</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">isSummary</span>()) &#123;</span><br><span class=\"line\">            visitor.<span class=\"title function_\">onSummary</span>(<span class=\"variable language_\">this</span>, state);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            visitor.<span class=\"title function_\">onDetail</span>(<span class=\"variable language_\">this</span>, state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">getChildren</span>().<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> &#123;</span><br><span class=\"line\">            child.<span class=\"title function_\">visit</span>(visitor, state);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">isSummary</span>()) &#123;</span><br><span class=\"line\">            visitor.<span class=\"title function_\">onSummaryEnd</span>(<span class=\"variable language_\">this</span>, state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后在<code>BaseTree</code>中从Root开始遍历即可：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseTree</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">root</span> = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">root</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">visit</span>(<span class=\"params\">visitor, state</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(visitor <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Visitor</span>)) &#123;</span><br><span class=\"line\">            visitor = <span class=\"keyword\">new</span> <span class=\"title class_\">Visitor</span>(visitor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visitor.<span class=\"title function_\">onStart</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">getRoot</span>(), state);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRoot</span>().<span class=\"title function_\">visit</span>(visitor, state);</span><br><span class=\"line\">        visitor.<span class=\"title function_\">onEnd</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">getRoot</span>(), state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同的摘要风格形成的树状结构不同，它们都是<code>ReportTree</code>类型，而<code>ReportTree</code>正是继承自<code>BaseTree</code>。<code>ReportTree</code>由继承自<code>BaseNode</code>的<code>ReportNode</code>构建。在<code>ReportNode</code>上定义了和覆盖率或文件操作相关的一些方法，如<code>getFileCoverage</code>，<code>getCoverageSummary</code>等。</p>\n<p>一个context内的visitor和tree可以通过<code>getVisitor</code>和<code>getTree</code>得到</p>\n<h4 id=\"istanbul-reports\"><a href=\"#istanbul-reports\" class=\"headerlink\" title=\"istanbul-reports\"></a>istanbul-reports</h4><p>istanbul-reports包中定义了种类繁多的导出格式，在入口文件通过指定的配置项选择使用，如上面样例中的<code>const report = reports.create(&#39;json&#39;, &#123;/* ... */&#125;)</code>即使用<code>json/lib/index.js</code>下导出的<code>JsonReport</code>类。istanbul-reports所有格式都基于istanbul-lib-report中基类的定义。这里以简单的json格式为例。</p>\n<p>其中定义了对于<code>onStart</code>，<code>onDetail</code>，<code>onEnd</code>的定义和上面<code>BaseNode</code>中介绍的回调函数相对应，在遍历<code>ReportTree</code>的各个阶段被触发，通过context的writer去输出。而writer从<code>ReportBase</code>中可以发现是通过context确定的，在context中默认是filewriter。而遍历是如何执行的呢？</p>\n<p>回头看下ReportBase的实现。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _summarizer = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;ReportBase.#summarizer&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ReportBase</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">opts = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>[_summarizer] = opts.<span class=\"property\">summarizer</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">execute</span>(<span class=\"params\">context</span>) &#123;</span><br><span class=\"line\">        context.<span class=\"title function_\">getTree</span>(<span class=\"variable language_\">this</span>[_summarizer]).<span class=\"title function_\">visit</span>(<span class=\"variable language_\">this</span>, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>execute</code>中传入context，即可把带有覆盖率信息的树形数据结构交给report代表的visitor遍历，逐个节点地打印出覆盖率报告。</p>\n<p>其余类型的报告也是类似的原理。</p>\n<h2 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h2><ul>\n<li><a href=\"https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/\">前端代码覆盖率实时统计方案探索</a></li>\n<li><a href=\"https://shenlvmeng.github.io/blog/2020/04/17/fe-coverage-improve/\">前端代码覆盖率实时统计改进方案</a></li>\n</ul>\n",
            "tags": [
                "覆盖率",
                "istanbul",
                "istanbuljs"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2020/04/16/fe-coverage-scheme/",
            "url": "http://shenlvmeng.github.com/blog/2020/04/16/fe-coverage-scheme/",
            "title": "前端代码覆盖率实时统计方案探索",
            "date_published": "2020-04-16T15:46:17.000Z",
            "content_html": "<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>随着业务增长，代码逐渐复杂，前端有些时候不能通过自测保证代码质量，而测试同学从用户角度进行端到端的case测试，也有可能存在测试case不够全面或重复覆盖的情况。而测试覆盖质量只能通过测试case评审来保证，没有量化的、直观的客观数据。</p>\n<p>然而前端场景和后端不同，UI测试因为业务形态原因，变更会更频繁，编写和维护单测成本比较高。因此目前且短期内前端工程还是以传统的用户角度的端到端测试为主。另外，在SSR项目中，前端开发也会书写API层，这部分代码也需要测试覆盖到。目前前端生态还没有一个能同时覆盖UI层和API层的覆盖率统计框架，需要借助已有的工具实现这点。</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>提升开发自测质量和提测质量，避免case覆盖不全的问题，同时有直观的统计指标衡量。</p>\n<h3 id=\"预期效果\"><a href=\"#预期效果\" class=\"headerlink\" title=\"预期效果\"></a>预期效果</h3><p>分3个阶段：</p>\n<p>第一阶段：<strong>基本可用版本</strong>，能够采集UI层和API层的代码覆盖率，覆盖率采集过程对前端开发透明，无需开发业务以外的开发成本。能够打开浏览器页面直观查看各个代码覆盖率。</p>\n<p>第二阶段：<strong>丰富统计数据</strong>，在第一阶段基础上，能够<em>记录</em>不同分支甚至不同版本历史的覆盖率，能够借助gitlab只查看<em>增量文件</em>的覆盖率。</p>\n<p>第三阶段：<strong>打通QA平台</strong>，在第二阶段基础上，接入QA已有平台或自建平台，在第三方页面查看数据；形成一套覆盖率采集方案。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>本地、特性分支上使用</p>\n<h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><p>覆盖率采集建立在<a href=\"https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)\">代码插桩</a>基础上。前端生态里比较成熟的工具是<a href=\"https://github.com/gotwarlost/istanbul\">istanbuljs</a>，该库的0.x.x版本位于<a href=\"https://github.com/gotwarlost/istanbul\">istanbul</a>库。关于该库的科普介绍，可以阅读ruanyifeng的<a href=\"https://www.ruanyifeng.com/blog/2015/06/istanbul.html\">科普文</a>。</p>\n<p>istanbul提供两种插桩方式：<strong>编译时</strong>和<strong>运行时</strong>。</p>\n<ul>\n<li>编译时<ul>\n<li>nyc命令行的<a href=\"https://github.com/istanbuljs/nyc/blob/master/docs/instrument.md\">instrument子命令</a>可以完成手动插桩</li>\n<li><a href=\"https://github.com/istanbuljs/babel-plugin-istanbul\">babel-plugin-istanbul</a>可以在使用babel的前端工程里，在<strong>编译阶段</strong>植入插桩代码。TypeScript项目可以使用<a href=\"https://www.npmjs.com/package/@istanbuljs/nyc-config-typescript\">@istanbuljs&#x2F;nyc-config-typescript</a>插件</li>\n</ul>\n</li>\n<li>运行时，需要借助<a href=\"https://github.com/gotwarlost/istanbul-middleware\">istanbul-middleware</a>中间件的帮助<ul>\n<li><code>im.hookLoader</code>，适用于服务端文件的动态插桩，方法利用istanbul-lib-hook中的<code>hookRequire</code>方法，hook被require引入的<strong>js文件</strong>，返回插桩后的js文件。因此需要在业务代码require前引入</li>\n<li><code>im.createClientHandler</code>，用于客户端<strong>js文件</strong>的动态插桩，它会把指定根路径下的js文件请求拦截，返回插桩后的代码。</li>\n</ul>\n</li>\n</ul>\n<p>在后台项目中，服务端代码使用<code>.ts</code>书写，本地使用<code>ts-node</code>启动，boe和线上使用<code>tsc</code>编译后的js文件启动。前端代码使用<code>.ts</code>书写，本地使用webpack + babel预编译成js。结合这个场景看，在node侧使用<code>hookLoader</code>，在UI测使用babel-plugin-istanbul插件更合适。</p>\n<p>总体来讲，工作分两步：<strong>代码插桩</strong>和<strong>可视化</strong>。</p>\n<h3 id=\"代码插桩\"><a href=\"#代码插桩\" class=\"headerlink\" title=\"代码插桩\"></a>代码插桩</h3><p>规划里一切功能的基础和本质都来自代码插桩。</p>\n<h4 id=\"client端\"><a href=\"#client端\" class=\"headerlink\" title=\"client端\"></a>client端</h4><p>client端可以直接使用目前仍良好维护的<a href=\"https://github.com/istanbuljs/babel-plugin-istanbul\">babel-plugin-istanbul</a>插件。在<code>.babelrc</code>中引入相关配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;env&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;plugins&quot;</span>: [<span class=\"string\">&quot;istanbul&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仅在test环境下开启该插件。可以用<a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a>这样的工具设置<code>NODE_ENV=test</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;cross-env NODE_ENV=test npm run start&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>插件还有<code>include</code>，<code>exclude</code>，<code>useInlineSourceMaps</code>这样的配置项。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;env&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">        [<span class=\"string\">&quot;istanbul&quot;</span>, &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;useInlineSourceMaps&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;exclude&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;**/*.spec.js&quot;</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>插桩后的业务代码如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cov_ac7rkuoyv = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> path = <span class=\"string\">&quot;/Users/test/shenlvmeng/nyc-demo/src/App.js&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"string\">&quot;7dec600464f484deef063d183319f809a7c25687&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"variable language_\">global</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>(<span class=\"string\">&quot;return this&quot;</span>)();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> gcv = <span class=\"string\">&quot;__coverage__&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> coverageData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&quot;/Users/shenlvmeng/nyc-demo/src/App.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">statementMap</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;0&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">start</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">line</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">          <span class=\"attr\">column</span>: <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">end</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">line</span>: <span class=\"number\">14</span>,</span><br><span class=\"line\">          <span class=\"attr\">column</span>: <span class=\"number\">9</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">fnMap</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;0&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">&quot;App&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">decl</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">start</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">line</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">            <span class=\"attr\">column</span>: <span class=\"number\">9</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"attr\">end</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">line</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">            <span class=\"attr\">column</span>: <span class=\"number\">12</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">loc</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">start</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">line</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">            <span class=\"attr\">column</span>: <span class=\"number\">15</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"attr\">end</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">line</span>: <span class=\"number\">33</span>,</span><br><span class=\"line\">            <span class=\"attr\">column</span>: <span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">line</span>: <span class=\"number\">7</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">branchMap</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">s</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;0&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;0&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">_coverageSchema</span>: <span class=\"string\">&quot;43e27e138ebf9cfc5966b082cf9a028302ed4184&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">hash</span>: <span class=\"string\">&quot;7dec600464f484deef063d183319f809a7c25687&quot;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> coverage = <span class=\"variable language_\">global</span>[gcv] || (<span class=\"variable language_\">global</span>[gcv] = &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (coverage[path] &amp;&amp; coverage[path].<span class=\"property\">hash</span> === hash) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> coverage[path];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> coverage[path] = coverageData;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _jsxFileName = <span class=\"string\">&quot;/Users/test/shenlvmeng/nyc-demo/src/App.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  cov_ac7rkuoyv.<span class=\"property\">f</span>[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">  cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>(react__WEBPACK_IMPORTED_MODULE_0__[<span class=\"string\">&quot;useEffect&quot;</span>])(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    cov_ac7rkuoyv.<span class=\"property\">f</span>[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">    cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">1</span>]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    (<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      cov_ac7rkuoyv.<span class=\"property\">f</span>[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">      cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">__coverage__</span>);</span><br><span class=\"line\">      cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">3</span>]++;</span><br><span class=\"line\">      axios__WEBPACK_IMPORTED_MODULE_1___default.<span class=\"property\">a</span>.<span class=\"property\">defaults</span>.<span class=\"property\">headers</span>.<span class=\"property\">post</span>[<span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">      cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">4</span>]++;</span><br><span class=\"line\">      axios__WEBPACK_IMPORTED_MODULE_1___default.<span class=\"property\">a</span>.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;http://localhost:4000/coverage/client&#x27;</span>, <span class=\"variable language_\">window</span>.<span class=\"property\">__coverage__</span>);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  cov_ac7rkuoyv.<span class=\"property\">s</span>[<span class=\"number\">5</span>]++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;div&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">&quot;App&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">16</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;, react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;header&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">&quot;App-header&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">17</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;, react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;img&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">src</span>: _logo_svg__WEBPACK_IMPORTED_MODULE_2___default.<span class=\"property\">a</span>,</span><br><span class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">&quot;App-logo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">alt</span>: <span class=\"string\">&quot;logo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">18</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;), react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;p&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">19</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;, <span class=\"string\">&quot;Edit &quot;</span>, react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;code&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">20</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;, <span class=\"string\">&quot;src/App.js&quot;</span>), <span class=\"string\">&quot; and save to reload.&quot;</span>), react__WEBPACK_IMPORTED_MODULE_0___default.<span class=\"property\">a</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">&quot;App-link&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">href</span>: <span class=\"string\">&quot;https://reactjs.org&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">target</span>: <span class=\"string\">&quot;_blank&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">rel</span>: <span class=\"string\">&quot;noopener noreferrer&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">fileName</span>: _jsxFileName,</span><br><span class=\"line\">      <span class=\"attr\">lineNumber</span>: <span class=\"number\">22</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;, <span class=\"string\">&quot;Learn React&quot;</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到针对每个文件，插桩后的代码新建了一个函数，用于更新这个文件的覆盖率信息。在业务代码执行时，会不断更新对应的计数器。前端代码run起来后，可以通过<code>window.__coverage</code>直接得到当前项目的覆盖率情况。</p>\n<p><strong>覆盖率计算原理</strong></p>\n<p>拿到代码字符串后，使用AST解析库解析出语法树，在对应树节点插入覆盖率语句，之后将语法树转成插桩后的代码。这个过程在0.x.x版本的实现可以参加<a href=\"http://gotwarlost.github.io/istanbul/public/apidocs/files/lib_instrumenter.js.html#l467\">这里</a>。</p>\n<p>0.x.x版本的instanbul使用<a href=\"https://github.com/jquery/esprima\">esprima</a>和<a href=\"https://github.com/estools/escodegen\">escodegen</a>。在最新的istanbuljs的<a href=\"https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-lib-instrument\">istanbul-lib-instrument</a>中使用babel相关的包完成解析、生成等功能，但插桩思路不变。</p>\n<h4 id=\"node端\"><a href=\"#node端\" class=\"headerlink\" title=\"node端\"></a>node端</h4><p>node端使用istanbul-middleware中间件的<code>hookLoader</code>完成动态插桩。该中间件为<a href=\"https://github.com/gotwarlost/istanbul\">instanbul</a>作者所写，所依赖的istanbul版本是目前已经不再维护的0.x.x版本，同时中间件也是基于express所写，年代较老。中间件的设计和我们的场景有些距离，因此需要在其基础上进行改造。</p>\n<p>在预期场景下，我们主要使用<code>im.hookLoader</code>和<code>im.createHandler</code>两个方法。</p>\n<h5 id=\"im-hookLoader\"><a href=\"#im-hookLoader\" class=\"headerlink\" title=\"im.hookLoader\"></a><code>im.hookLoader</code></h5><p><code>im.hookLoader</code>只是在instanbul hook的基础上做的简单封装。看<a href=\"http://gotwarlost.github.io/istanbul/public/apidocs/files/lib_hook.js.html#l77\">文档</a>可以发现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hookRequire</span>(<span class=\"params\">matcher, transformer, options</span>) &#123;</span><br><span class=\"line\">    options = options || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"title function_\">transformFn</span>(matcher, transformer, options.<span class=\"property\">verbose</span>),</span><br><span class=\"line\">        postLoadHook = options.<span class=\"property\">postLoadHook</span> &amp;&amp;</span><br><span class=\"line\">            <span class=\"keyword\">typeof</span> options.<span class=\"property\">postLoadHook</span> === <span class=\"string\">&#x27;function&#x27;</span> ? options.<span class=\"property\">postLoadHook</span> : <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"title class_\">Module</span>.<span class=\"property\">_extensions</span>[<span class=\"string\">&#x27;.js&#x27;</span>] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">module</span>, filename</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret = <span class=\"title function_\">fn</span>(fs.<span class=\"title function_\">readFileSync</span>(filename, <span class=\"string\">&#x27;utf8&#x27;</span>), filename);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret.<span class=\"property\">changed</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">module</span>.<span class=\"title function_\">_compile</span>(ret.<span class=\"property\">code</span>, filename);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">originalLoader</span>(<span class=\"variable language_\">module</span>, filename);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (postLoadHook) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">postLoadHook</span>(filename);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>hook require是利用CommonJS的模块加载规范实现的。这里介绍下模块加载流程相关的背景。</p>\n<h5 id=\"模块加载流程\"><a href=\"#模块加载流程\" class=\"headerlink\" title=\"模块加载流程\"></a>模块加载流程</h5><p>require和module来自nodejs的<a href=\"https://nodejs.org/api/modules.html#modules_module\">Modules</a>模块。无需显式引入（原因下面会提）即可使用里面的<code>module</code>, <code>require</code>, <code>exports</code>的关键字。在require一个包时，分为了<strong>解析、加载、封装、求值、缓存</strong>几步。</p>\n<ol start=\"0\">\n<li>解析一步交给<code>module.require(modulename)</code>方法实现，该方法调用静态方法<code>Module._load</code>加载模块。</li>\n<li>加载时首先调用<code>Module._resolveFilename</code>解析路径，解析过程大致分为粗筛和精确定位</li>\n<li>粗筛，原生模块则直接返回模块名，否则从当前目录逐步向上寻找node_modules目录下的模块文件夹</li>\n<li>精确定位，首先在上面的目录下寻找有无没有拓展名的同名文件，再寻找以<code>js</code>、<code>json</code>、<code>node</code>拓展名结尾的文件；再寻找同名目录下<code>package.json</code>中<code>main</code>字段指定的路径，最后寻找同名目录下的index.js</li>\n<li>得到路径后，先试图从<code>Module._cache</code>中寻找有无模块缓存，若没有，则新建模块对象并缓存，之后调用<code>module.load()</code>方法加载该模块</li>\n<li>node默认只能load以<code>js</code>, <code>json</code>, <code>node</code>结尾的文件，除此之外均视为<code>.js</code>文件</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Module</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">load</span> = <span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">filename</span> = filename;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">paths</span> = <span class=\"title class_\">Module</span>.<span class=\"title function_\">_nodeModulePaths</span>(path.<span class=\"title function_\">dirname</span>(filename));</span><br><span class=\"line\">    <span class=\"keyword\">var</span> extension = path.<span class=\"title function_\">extname</span>(filename) || <span class=\"string\">&#x27;.js&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title class_\">Module</span>.<span class=\"property\">_extensions</span>[extension]) extension = <span class=\"string\">&#x27;.js&#x27;</span>;</span><br><span class=\"line\">    <span class=\"title class_\">Module</span>.<span class=\"property\">_extensions</span>[extension](<span class=\"variable language_\">this</span>, filename);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">loaded</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><code>Module._extensions</code>键值对默认只包含对上述三种文件的处理。其中json和node文件较简单</li>\n</ol>\n<ul>\n<li>json，读取文件 &#x3D;&gt; <code>JSON.parse</code> &#x3D;&gt; 注入到<code>module.exports</code>上</li>\n<li>node，调用<code>process.dlopen</code>加载</li>\n<li>js，调用<code>module._compile()</code>处理文件内容</li>\n</ul>\n<ol start=\"5\">\n<li><code>module._compile</code>执行js文件编译，编译前调用<code>Module.wrap</code>方法将模块封装在函数内，这也是<code>module</code>，<code>require</code>，<code>exports</code>，<code>__filename</code>，<code>__dirname</code>可以直接在模块内使用，且模块间的<code>module</code>，<code>require</code>，<code>exports</code>不相互干扰的原因。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Module</span>.<span class=\"property\">wrap</span> = <span class=\"keyword\">function</span>(<span class=\"params\">script</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Module</span>.<span class=\"property\">wrapper</span>[<span class=\"number\">0</span>] + script + <span class=\"title class_\">Module</span>.<span class=\"property\">wrapper</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Module</span>.<span class=\"property\">wrapper</span> = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;(function (exports, require, module, __filename, __dirname) &#123; &#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;\\n&#125;);&#x27;</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>wrap后，调用<code>vm.runInThisContext</code>将字符串转为可执行的js函数。最后一句执行封装的函数，注入当前module的相关信息到模块中</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Module</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">_compile</span> = <span class=\"keyword\">function</span>(<span class=\"params\">content, filename</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> wrapper = <span class=\"title class_\">Module</span>.<span class=\"title function_\">wrap</span>(content);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> compiledWrapper = vm.<span class=\"title function_\">runInThisContext</span>(wrapper, &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: filename,</span><br><span class=\"line\">    <span class=\"attr\">lineOffset</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">displayErrors</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  result = compiledWrapper.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">exports</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">exports</span>, <span class=\"built_in\">require</span>, <span class=\"variable language_\">this</span>, filename, dirname);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，可以在REPL中输入<code>require.extensions</code>看到nodejs支持的3种文件拓展。而hookRequire所做的就是hook了加载<code>.js</code>的步骤，在交由<code>module._compile</code>处理前，前进行了插桩处理。</p>\n<blockquote>\n<p>注：<code>ts-node</code>能够import<code>.ts</code>文件也是因为在<code>module._extendsion</code>中添加了<code>.ts</code>的处理方法</p>\n</blockquote>\n<p>综上，在本地测试时，由于通过<code>ts-node</code>启动，<code>im.hookLoader</code>只会hook<code>.js</code>文件（0.x.x版本），会导致没有服务端代码覆盖率，上线前tsc后，就可以顺利注入，从<code>global.__coverage__</code>中拿到覆盖率数据。</p>\n<h4 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h4><p>服务端覆盖率数据采集借助上述的<code>im.hookLoader</code>就已完成。前端页面的代码覆盖率需要自行周期性上报。<code>im.createHandler</code>提供的API可以接收前端覆盖率，该方法创建的路由回调会调用<code>utils.mergeFileCoverage</code>最终将增量覆盖率数据累加在<code>global.__coverage__</code>中。</p>\n<h3 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h3><p>可视化需要借助istanbul（0.x版本）本身提供的相关API，又或者直接更方便地使用<code>im.createHandler</code>。其方便封装了一些istanbul的API，实现的简单的可视化功能，更多介绍可以直接参考istanbul-middleware使用文档。</p>\n<h4 id=\"im-createHandler\"><a href=\"#im-createHandler\" class=\"headerlink\" title=\"im.createHandler\"></a><code>im.createHandler</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createHandler</span>(<span class=\"params\">opts</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//send static file for /asset/asset-name</span></span><br><span class=\"line\">    app.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/asset&#x27;</span>, express.<span class=\"title function_\">static</span>(<span class=\"variable constant_\">ASSETS_DIR</span>));</span><br><span class=\"line\">    app.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/asset&#x27;</span>, express.<span class=\"title function_\">static</span>(path.<span class=\"title function_\">join</span>(<span class=\"variable constant_\">ASSETS_DIR</span>, <span class=\"string\">&#x27;vendor&#x27;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    app.<span class=\"title function_\">use</span>(bodyParser.<span class=\"title function_\">urlencoded</span>(urlOptions));</span><br><span class=\"line\">    app.<span class=\"title function_\">use</span>(bodyParser.<span class=\"title function_\">json</span>(jsonOptions));</span><br><span class=\"line\"></span><br><span class=\"line\">    app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        core.<span class=\"title function_\">render</span>(<span class=\"literal\">null</span>, res, origUrl);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的使用上看，<code>im.createHandler</code>的使用是和express绑定的，并不适配koa的风格，要想使用在非express服务端场景里，或者增加额外功能，就需要重构这个方法。不过，由于一些API的使用从0.x.x版本迁移到新的monorepo的版本并不平滑，且新版本API暂无文档。所以尽管instanbul已经不再更新，对istanbul-middleware中间件的重构还只能保持对旧版本istanbul的依赖。</p>\n<h4 id=\"重构设计\"><a href=\"#重构设计\" class=\"headerlink\" title=\"重构设计\"></a>重构设计</h4><p>为了兼容koa环境，从istanbul-middleware库fork新版本istanbul-koa-middleware，使用ts重写。去掉无用的代码，重点需要改造的就是<code>createKoaHandler</code>方法。</p>\n<p>为减少istanbul-koa-middleware使用方的依赖，考虑使用类似istanbul-middleware的形式，在<code>createKoaHandler</code>内部定义koa应用，使用方只需引入koa-mount和istanbul-koa-middleware即可在任意路由上挂载覆盖率可视化相关子路由。</p>\n<p>除此之外：</p>\n<ul>\n<li>使用koa-static替代<code>express.static</code></li>\n<li>使用koa-mount替代<code>app.use(&#39;/some/path&#39;, someMiddleware)</code></li>\n<li>使用koa-router替代<code>app.get</code>和<code>app.post</code></li>\n<li>定义<code>WebFramework</code>接口，掩盖对回调中<code>res</code>使用方式的不同</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">WebFramework</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">setHeader</span>: <span class=\"function\">(<span class=\"params\">key: <span class=\"built_in\">string</span>, value: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: <span class=\"function\">(<span class=\"params\">code: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    <span class=\"attr\">write</span>: <span class=\"function\">(<span class=\"params\">content: <span class=\"built_in\">any</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    <span class=\"attr\">end</span>: <span class=\"function\">(<span class=\"params\">content?: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">genWebFrameworkCtxFromKoaCtx</span>(<span class=\"params\">ctx: Koa.ParameterizedContext</span>): <span class=\"title class_\">WebFramework</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">setHeader</span>(<span class=\"params\">key, value</span>) &#123;</span><br><span class=\"line\">            ctx.<span class=\"title function_\">set</span>(key, value);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_\">status</span>(<span class=\"params\">code</span>) &#123;</span><br><span class=\"line\">            ctx.<span class=\"property\">status</span> = code;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_\">write</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">            ctx.<span class=\"property\">res</span>.<span class=\"title function_\">write</span>(content);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_\">end</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">            ctx.<span class=\"property\">res</span>.<span class=\"title function_\">end</span>(content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，重构后的istanbul-koa-middleware就可以帮我们实现最简单的覆盖数据可视化了。后续的新增功能，也都建立在对<code>createHandler</code>函数的改造上。</p>\n<h3 id=\"已知问题\"><a href=\"#已知问题\" class=\"headerlink\" title=\"已知问题\"></a>已知问题</h3><p>在上面工作完成后，第一阶段目标基本已经实现。</p>\n<p><img src=\"https://s1.ax1x.com/2020/04/16/JEZliq.png\" alt=\"效果图1\"><br><img src=\"https://s1.ax1x.com/2020/04/16/JEZ8zT.png\" alt=\"效果图2\"></p>\n<p>但是，还有很多可以优化的地方，这也是后续阶段需要解决的问题：</p>\n<ul>\n<li>服务端代码如果没有正确设置source-map，覆盖率展示的文件是tsc之后的js文件，可读性差</li>\n<li>需要区分环境，在特定环境下才对代码文件插桩</li>\n<li>本地环境下可以访问到原始的ts文件，上传测试环境后，由于不会打包上传源文件，覆盖率报告将看不了原始ts文件的覆盖详情</li>\n<li>覆盖率报告功能太简单，不能以分支、版本、仓库等空间维度或以历史信息、趋势等时间维度查看<br>，也没有diff内容覆盖率功能</li>\n<li>出现了一些意义不大的文件，需要剔除</li>\n</ul>\n<h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><ul>\n<li><a href=\"https://tech.youzan.com/front-coverage/\">前端精准测试探索：覆盖率实时统计工具</a></li>\n<li><a href=\"https://tech.kujiale.com/qian-duan-fu-gai-lu/\">基于Istanbul 优雅地搭建前端JS覆盖率平台</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8/\">Requiring modules in Node.js: Everything you need to know</a></li>\n<li><a href=\"https://juejin.im/post/5d84456851882556f33d5fb0\">node模块加载机制 - 掘金</a></li>\n</ul>\n",
            "tags": [
                "前端",
                "端到端测试",
                "istanbul",
                "代码覆盖率",
                "istanbul-middleware",
                "代码插桩",
                "require钩子",
                "babel-plugin-istanbul"
            ]
        }
    ]
}
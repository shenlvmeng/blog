{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"读书笔记\" tag",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2021/11/24/leadership-pipeline/",
            "url": "http://shenlvmeng.github.com/blog/2021/11/24/leadership-pipeline/",
            "title": "《领导梯队》—— 领导力模型构建",
            "date_published": "2021-11-24T15:07:36.000Z",
            "content_html": "<p>对于很多从一线成长到管理岗位的员工来讲，管理工作和管理能力的阶段多少要靠自己领悟。可能从日常工作、文档培训中形成了管理工作懵懂认识，不成熟的归纳认知很可能会让你卡在某个阶段无法提升，又找不到办法。《领导梯队》这本书从基层开始分析管理路线上每一个阶段的做事思路，或许不能适应在所有场景下，但最起码能给人一种启示——什么才叫管理，以及想走管理路线的话，可以做些什么。当然，做事过犹不及，作为技术人员，理清管理思路后，别忘了你的本职工作。至少在前几个阶段，对你的技术能力是有要求的。</p>\n<h2 id=\"序和导论\"><a href=\"#序和导论\" class=\"headerlink\" title=\"序和导论\"></a>序和导论</h2><p>在讨论领导梯队和领导力模型之前，我们要认清下面一些现状：</p>\n<ul>\n<li>在快速发展的行业里（如互联网），是缺乏领导人才的</li>\n<li>一味地引入，忽视内部培养，无法建立完善而持久的领导梯队</li>\n</ul>\n<p>因此，公司需要一个领导力发展模型，模型从个人贡献者到CEO可以分为6个阶段：</p>\n<ul>\n<li>个人贡献者到一线经理</li>\n<li>一线经理到部门总监</li>\n<li>部门总监到事业部副总经理</li>\n<li>事业部副总经理到事业部总经理</li>\n<li>事业部总经理到集团高管</li>\n<li>集团高管到CEO</li>\n</ul>\n<p>角色负责的范围逐渐扩大，在<strong>工作技能</strong>、<strong>时间管理</strong>、<strong>工作理念</strong>三方面的要求也各有侧重。</p>\n<p>最后，书中提到的领导力模型和阶段并非适用于所有场景，需要根据实际情况灵活调整。毕竟人是复杂的，管理也是。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>这里具体介绍了领导力发展的6个阶段：</p>\n<ul>\n<li>从管理自我到管理他人<ul>\n<li>从专业化、职业化思路转变到<strong>通过他人完成任务</strong>作为自己取得成功的关键</li>\n</ul>\n</li>\n<li>从管理他人到管理经理人员<ul>\n<li>负责选拔人才成为一线经理</li>\n<li>帮助一线经理清除“依靠自己获得成功”的错误观念</li>\n</ul>\n</li>\n<li>从管理经理人员到管理职能部门<ul>\n<li>战略眼光</li>\n<li>跨层级沟通</li>\n<li>和其他部门合作，基于工作需要帮自己部门争取资源</li>\n</ul>\n</li>\n<li>从管理职能部门到事业部总经理<ul>\n<li>清楚管理工作和市场结果的关系</li>\n<li>从盈利和长远发展出发</li>\n<li>兼顾长远和近期目标</li>\n<li>更多时间用来分析反思</li>\n</ul>\n</li>\n<li>从事业部总经理到集团高管<ul>\n<li>资金调拨和人才配置</li>\n<li>培养事业部经理</li>\n<li>评估业务投资组合策略</li>\n</ul>\n</li>\n<li>从集团高管到CEO<ul>\n<li>从管理技能转变到经营理念</li>\n<li>远大抱负、权衡取舍、外部视角</li>\n</ul>\n</li>\n</ul>\n<p>在小公司里，可能不会有这么多领导力的层级。</p>\n<h2 id=\"管理自我到管理他人\"><a href=\"#管理自我到管理他人\" class=\"headerlink\" title=\"管理自我到管理他人\"></a>管理自我到管理他人</h2><blockquote>\n<p>关键词：团队努力、计划、沟通</p>\n</blockquote>\n<p>随着个人贡献者能力的提升，一部分人会被提拔到职业生涯里第一个领导岗位上。在这个岗位上获得成功需要心态上的一大转变，即<strong>工作成功不再通过自己亲自做获得，而是通过下述和团队的努力获得</strong>。在这个位置，经理身上需要承担一些管理动作，包括：</p>\n<ul>\n<li>制定计划</li>\n<li>工作涉及</li>\n<li>人员选拔</li>\n<li>授权</li>\n<li>绩效监督、评估</li>\n<li>辅导和反馈收集</li>\n<li>沟通和氛围营造</li>\n<li>获取资源</li>\n<li>奖励和激励</li>\n</ul>\n<p>在时间管理上，需要划分出更多时间做：</p>\n<ul>\n<li>执行计划</li>\n<li>和下属沟通</li>\n<li>和兄弟部门、客户、供应商等沟通</li>\n</ul>\n<p>这一阶段可以采用下面一些手段帮助经理对齐领导力模型：</p>\n<ul>\n<li>准备：提前对齐岗位期望</li>\n<li>监督：通过旁听、360评估、和同行比较等方法</li>\n<li>干预：oneone沟通，引导</li>\n</ul>\n<p>一线经理是未来领导者的摇篮，在选拔这类人才时，可以考察此人帮助别人成功的意愿以及是否可以从帮助别人获得满足。</p>\n<h2 id=\"管理他人到管理经理\"><a href=\"#管理他人到管理经理\" class=\"headerlink\" title=\"管理他人到管理经理\"></a>管理他人到管理经理</h2><blockquote>\n<p>关键词：授权、选培一线经理、部门协作</p>\n</blockquote>\n<p>这个过程通常代表着从一线经理到部门总监。工作上也主要围绕着一线经理展开，主要职责是整合工作、分配资源和培训管理者。要敢于<strong>授权</strong>，同时建设授权后的问责系统，另外开始培养战略和文化的问题。作为一个部门总监，至少需要以下几个技能：</p>\n<ul>\n<li>选拔和培养有能力的一线经理<ul>\n<li>建设性批评、就事论事</li>\n</ul>\n</li>\n<li>让一线经理对管理工作负责<ul>\n<li>对齐期望，减少越俎代庖</li>\n<li>调整不合适的一线经理</li>\n</ul>\n</li>\n<li>在部门配置资源<ul>\n<li>根据部门情况调配资源（薪水、项目等）</li>\n</ul>\n</li>\n<li>协调下属部门和其他部门的管辖<ul>\n<li>信息共享，鼓励团结协作</li>\n<li>context、not control</li>\n</ul>\n</li>\n</ul>\n<p>其中第一项能力最为重要，要善于授权，培养<strong>大局观</strong>。寻找对管理工作有真正热情的人。在交流时，把一线经理当成一个团队而非一线员工。部门总监是第一个完全依靠管理技能而非从事专业技术工作的管理层级，要能够传递高层战略到基层员工，也要能将基层员工的执行能力反馈给战略制定者。</p>\n<h2 id=\"管理经理到管理职能部门\"><a href=\"#管理经理到管理职能部门\" class=\"headerlink\" title=\"管理经理到管理职能部门\"></a>管理经理到管理职能部门</h2><blockquote>\n<p>关键词：信息收集、全局观、战略思维、成熟度</p>\n</blockquote>\n<p>职能主管这个层级会有多种信息来源，需要能够熟练地收集和理解信息，沟通上从交谈转为倾听，要能积极倾听开放思想。另外，职能主管需要认识到，他不再是职能部门的一员，而是该部门的领导者。他需要拥有<strong>战略性思维</strong>，可以胸怀<strong>全局</strong>把握整体，而不是依赖以往领域的经验做事：</p>\n<ul>\n<li>长期思维（3-5年）</li>\n<li>关注业界最新发展动态<ul>\n<li>技术方面</li>\n<li>经营方面</li>\n</ul>\n</li>\n<li>全面了解商业模式和战略目标<ul>\n<li>业务目标</li>\n<li>市场定位</li>\n<li>战略变动</li>\n<li>如何盈利</li>\n<li>团队优势</li>\n<li>所在部门可以做出的贡献</li>\n<li>其他部门的贡献</li>\n</ul>\n</li>\n<li>将职能部门的所有方面纳入战略考虑，这也要求了解之前不甚熟悉的其他职能领域</li>\n</ul>\n<p>一个称职的事业部副总应该是<strong>成熟</strong>的。这体现在：</p>\n<ul>\n<li>谦逊好学、坦诚清晰</li>\n<li>善于授权、相信他人</li>\n<li>乐于沟通，善于表达</li>\n<li>和兄弟职能部门保持合作而不是竞争，因为个人成功和进步只有在企业成功时才有可能实现</li>\n</ul>\n<p>与之相反，可能会出现下面这些bad case：</p>\n<ul>\n<li>无法从项目运作导向转变到战略导向</li>\n<li>不重视不熟悉或是不感兴趣的工作</li>\n<li>表现不成熟</li>\n</ul>\n<h2 id=\"管理职能部门到事业部总经理\"><a href=\"#管理职能部门到事业部总经理\" class=\"headerlink\" title=\"管理职能部门到事业部总经理\"></a>管理职能部门到事业部总经理</h2><blockquote>\n<p>关键词：时间管理、工作透明、部门权衡、视野开阔</p>\n</blockquote>\n<p>相对职能主管，事业部总经理工作的曝光度要高得多，他有很强的掌控权，也对成本和收入直接负责。副总经理需要制定业务战略和整合各部门工作。对比职能主管的部门策略思维，事业部总经理的<strong>业务战略</strong>思维要求他拥有更广泛的视野，综合无数外部因素，考虑本行业甚至全球事务。</p>\n<ul>\n<li>如何实现业务增长</li>\n<li>如何提高盈利水平</li>\n<li>如何增强竞争优势</li>\n</ul>\n<p>这个思维模式的转变是有难度的，也是必须完成的。</p>\n<p>事业部总经理需要处理错综复杂的各种问题，兼顾短期和长期目标。为了了解业务的方方面面，保证视野开阔，他还需要时间学习很多新知识。<strong>时间管理</strong>成为一个难题。事业部总经理不能单单依靠个人能力获得成功，他需要把部门经理整合成高效团队，重视和平衡所有部门，并把具体工作授权给它们。事业部总经理的关注对比副总经理更为强烈，在项目、计划和人员管理上也有很大权限，这也让他的一举一动十分透明。做每一个决定前都要认真考虑。</p>\n<p>自我提升上，可以借助<strong>协同三角形</strong>模型：</p>\n<ul>\n<li>战略方向<ul>\n<li>竞争优势：产品、市场、客户</li>\n</ul>\n</li>\n<li>人员能力<ul>\n<li>经验</li>\n<li>技能</li>\n<li>思维模式</li>\n<li>视角</li>\n</ul>\n</li>\n<li>组织能力<ul>\n<li>组织结构</li>\n<li>工作设计</li>\n<li>工作流程</li>\n<li>权力配置</li>\n<li>人员配置</li>\n<li>组织文化</li>\n</ul>\n</li>\n</ul>\n<p>可以通过考虑一些问题来实现上面的思考方式：</p>\n<ul>\n<li>我们有合适的产品么</li>\n<li>我们的竞争优势能报纸么</li>\n<li>我们的客户细分市场何合适么</li>\n<li>员工是否有创新意识</li>\n<li>我们是否有客户导向的思维模式</li>\n<li>我们的产品研发部门是否有足够授权</li>\n<li>我们的各部门是否可以有效组织</li>\n</ul>\n<h2 id=\"事业部总经理到集团高管\"><a href=\"#事业部总经理到集团高管\" class=\"headerlink\" title=\"事业部总经理到集团高管\"></a>事业部总经理到集团高管</h2><blockquote>\n<p>关键词：集团战略、新机会、选培事业部总经理</p>\n</blockquote>\n<p>晋升到集团高管后，脱离了具体某项业务。要学会<strong>从集团的角度</strong>出发制定战略，辅导培训事业部总经理。具体体现在</p>\n<ul>\n<li>和事业部领导班子保持交流，选拔和培养总经理</li>\n<li>评估各事业部的战略规划，批准它们的业务规划而不是亲自管理</li>\n<li>超越财务结果评价事业部总经理</li>\n<li>监督各业务部门奉行公司的价值观和各项政策</li>\n<li>在必要的时候使用兼并收购的方式补充业务</li>\n</ul>\n<p>集团高管还要能抽出时间发现行业里的潜在机会和新商机。</p>\n<p>一个合格的集团高管需要有下面的标准：</p>\n<ul>\n<li>业绩优异</li>\n<li>出色的战略能力</li>\n<li>有效的人才培养</li>\n<li>对客户满意充满激情</li>\n<li>敏锐的商业头脑</li>\n<li>愿意共享资源</li>\n<li>践行公司价值观</li>\n<li>关心公司成功</li>\n</ul>\n<h2 id=\"从集团高管到首席执行官\"><a href=\"#从集团高管到首席执行官\" class=\"headerlink\" title=\"从集团高管到首席执行官\"></a>从集团高管到首席执行官</h2><blockquote>\n<p>关键词：可持续发展、执行力、组织能力培养、长期思想</p>\n</blockquote>\n<p>首席执行官受到各方的密切关注，不容出错。在领导力模型里面临下面一些挑战：</p>\n<ul>\n<li>平衡长短期利益，实现可持续发展</li>\n<li>设定公司发展的方向，承担风险，深思熟虑<ul>\n<li>公司方向、行业变化、商业模式、竞争格局</li>\n</ul>\n</li>\n<li>培养组织能力，保证人才供给</li>\n<li>确保战略执行到位，对如何盈利有与生俱来的直觉<ul>\n<li>我的表现如何</li>\n<li>我了解公司的情况么</li>\n<li>有向上反馈渠道么</li>\n<li>董事会履行自己授权么</li>\n<li>我的团队高效有活力么</li>\n</ul>\n</li>\n<li>处理好全球化和外部关系</li>\n</ul>\n<p>培养首席执行官没有捷径，一个首席执行官需要经历领导力模型的大多数阶段，他的理想路径包括：</p>\n<ul>\n<li>在核心业务部门的多个职位工作过</li>\n<li>有海外任职经历</li>\n<li>领导业务部门实现突破性增长</li>\n<li>领导新兴业务和振兴衰落业务</li>\n<li>主管过公司的人力资源</li>\n</ul>\n<p>首席执行官的工作目标通常都需要<strong>较长的时间</strong>才能逐步达成，工作理念上也要有所转变。</p>\n<h2 id=\"诊断问题\"><a href=\"#诊断问题\" class=\"headerlink\" title=\"诊断问题\"></a>诊断问题</h2><p>在上面介绍完了整个领导力模型后，这里可以比照着整个模型，定期做整个组织的审视，很容易发现人员错误配置在某一层级的情况。通常因为在快速晋升的过程中，遗漏或仓促跳过了一些发展阶段，做事思路还没有转变。这会引起：</p>\n<ul>\n<li>虽然短期业务看着不错，对长期可持续发展却没有帮助</li>\n<li>越俎代庖和工作效率下降</li>\n<li>对员工职业发展不利</li>\n</ul>\n<p>在评估时，可以通过和个体以及个体的上下级沟通，判断在领导技能、时间管理、工作理念几方面是否和层级相匹配。</p>\n<h2 id=\"改善业绩评估\"><a href=\"#改善业绩评估\" class=\"headerlink\" title=\"改善业绩评估\"></a>改善业绩评估</h2><p>在日常的绩效评估中，可以加入领导模型的能力评估。避免出现职责断裂或者重叠的情况。可以用圆圈标识一个员工的7项绩效内容期望。当达到<strong>全面绩效</strong>时，可以考虑将他人名到一个新的领导岗位。每提升到一个新的领导层级，从会出现绩效缺口。在培训工作持续进行时后，培训对象会逐渐取得全面绩效。这个时候对其进行超常规能力的测试，如果结果表明候选人已做好准备，就可以继续升职。这个测试可以通过让同一层级的领导者组成团队，完成一项高度挑战性任务来实施。</p>\n<h2 id=\"继任计划\"><a href=\"#继任计划\" class=\"headerlink\" title=\"继任计划\"></a>继任计划</h2><p>继任计划是指在各级领导梯队中培养高绩效人员，确保充足的人才储备。整体思路是关注<strong>绩效</strong>和<strong>潜能</strong>，适配公司的实际情况，定期审视领导梯队继任计划。</p>\n<p>潜能上分3档：</p>\n<ul>\n<li><strong>转型潜能</strong>：3-5年甚至更短时间可以从事下一层工作</li>\n<li><strong>成长潜能</strong>：不久可以从事同一层级的更重要工作</li>\n<li><strong>熟练潜能</strong>：可以更好完成当前层级的相同工作</li>\n</ul>\n<p>从潜能和绩效两个维度，可以划分出9类员工。针对不同方格内的员工，着重培养领导力和提升绩效。</p>\n<p>好的继任计划要求适用在所有业务和职能、贴合公司实际、可以公开讨论。</p>\n<h2 id=\"梯队的潜在缺陷\"><a href=\"#梯队的潜在缺陷\" class=\"headerlink\" title=\"梯队的潜在缺陷\"></a>梯队的潜在缺陷</h2><p>领导梯队也有遇到问题的时候，通常可能来自下面这些情况：</p>\n<ul>\n<li>选错人才<ul>\n<li>在上一个层级做出成绩，不代表他的领导技能、时间管理、工作理念都已达到下一层级的要求</li>\n</ul>\n</li>\n<li>让表现不佳者在岗位停留太久<ul>\n<li>判断一名管理者是否还依赖上一级的领导技能、时间管理、工作理念</li>\n<li>观察管理者直接下属的职业发展和业绩</li>\n</ul>\n</li>\n<li>不善于倾听反馈<ul>\n<li>开阔心胸</li>\n<li>选择性听取</li>\n</ul>\n</li>\n<li>不善于定义工作<ul>\n<li>明确责任边界</li>\n<li>对齐责任边界</li>\n</ul>\n</li>\n</ul>\n<p>一个组织能需要有一个领导力框架，它能给绩效评估标准，提供更多的讨论问题的角度。通常一个团队内缺乏坦诚也是缺陷即将出现的危险信号。</p>\n<h2 id=\"职能主管发展路线\"><a href=\"#职能主管发展路线\" class=\"headerlink\" title=\"职能主管发展路线\"></a>职能主管发展路线</h2><p>除了上面提到的领导力模型之外，还有职能方向的支线，即从集团职能主管到企业职能主管。集团职能主管和事业部总经理很像，但又不太一样：</p>\n<ul>\n<li>事业部总经理将智能战略纳入到整体业务计划中，但职能直观则将每一个事业部的职能战略纳入到集团整体的职能战略中</li>\n<li>两者都要有商业思维，职能主管也要从“我们能这么做么”转变到“我们这样做能赚钱么”</li>\n<li>职能主管通常同时向集团职能主管和事业部总经理负责，这需要他能灵活处理各种人群和利益关系，并且知道怎么妥协</li>\n<li>集团职能主管主要为集团高管提供咨询意见而不是产品和其他内容</li>\n</ul>\n<p>作为集团职能主管，要避免出现下面的情况：</p>\n<ul>\n<li>给所有人承诺，却从不兑现<ul>\n<li>集团职能主管要能够分解复杂关系，划清责任边界，获知业务优先级、自己优先级，最后做出果断的决定</li>\n</ul>\n</li>\n<li>过度干涉职能部门经历的工作</li>\n<li>整天围着集团高管转</li>\n</ul>\n<p>企业职能主管一般指CFO、CTO、COO、总法律顾问这些。他们的目的是将自己的职能和公司联系在一起，因此他们必须设定职能发展方向、学会服务整个公司而不仅是自己的职能、了解公司外部环境。要能满足下面一些要求：</p>\n<ul>\n<li>商业竞争中如何发挥职能的支持获得竞争优势</li>\n<li>了解所在职能在业界的发展状况</li>\n<li>向集团高管提供所在职能领域或一般性领域的发展机会</li>\n</ul>\n<p>下面是一些对于企业职能主管的发展建议：</p>\n<ul>\n<li>尽早获取专家对职能部门的建议</li>\n<li>和CEO和各层级关键领导对齐你的目标和计划</li>\n<li>定期和各层级部门交流</li>\n<li>学会管理时间</li>\n</ul>\n<h2 id=\"教练辅导\"><a href=\"#教练辅导\" class=\"headerlink\" title=\"教练辅导\"></a>教练辅导</h2><p>教练辅导即用一种富有激励的方式，将上面的领导力模型指引给员工或是管理者。可以通过一些问题确定此人的领导能力、时间管理和工作理念：</p>\n<ul>\n<li>谈谈你的职业发展<ul>\n<li>经历的每一个职务</li>\n<li>工作具体内容</li>\n<li>工作成就</li>\n<li>重大挑战</li>\n</ul>\n</li>\n<li>现在职位的工作<ul>\n<li>面临的问题、挑战</li>\n<li>取得的成就</li>\n</ul>\n</li>\n<li>工作日程</li>\n<li>主要依靠的技能</li>\n<li>工作信念是什么</li>\n<li>职业抱负是什么</li>\n</ul>\n<p>有些时候，自己进行教练辅导会比聘用不专业的教练要更好。</p>\n<h2 id=\"领导力模型惠及全员\"><a href=\"#领导力模型惠及全员\" class=\"headerlink\" title=\"领导力模型惠及全员\"></a>领导力模型惠及全员</h2><p>略</p>\n<p><em>–END–</em></p>\n",
            "tags": [
                "读书笔记",
                "管理学",
                "领导力",
                "梯队"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/03/12/wisdom-of-life-pessimistic-life/",
            "url": "http://shenlvmeng.github.com/blog/2019/03/12/wisdom-of-life-pessimistic-life/",
            "title": "《人生的智慧》 ——幸福与人生",
            "date_published": "2019-03-11T16:14:51.000Z",
            "content_html": "<blockquote>\n<p>“在读完叔本华的书第一页以后，就知道得很清楚，我要把他写的所有东西都读完为止；他说的每一个字词我都要听” —— 尼采</p>\n</blockquote>\n<p>尽管是出自腰封上的促销的话，尼采的推介语比“当代名家们”写的“此书甚好读世之绝有”格调就要高很多了。《人生的智慧》一书取自于叔本华晚年最后一部巨著《附录和补遗》的一部分，包含了他对《作为意欲和表象的世界》其中哲学观点的补充，以及回首一生的一些更广泛的思考。对比哲学形而上学的深奥探讨，这本书讨论的事情与世俗生活甚是接近，叔本华在书中放弃了居高临下的审视态度，用他擅长的冷峻客观的笔法努力将讨论变得清晰简明。</p>\n<blockquote>\n<p>“看到我最后的小孩的诞生，我是多么的高兴。随着这一部著作的完成，我在这个世界上的使命也就终于完成了。我的却感到了如释重负，这一重负在24年来，一直沉重地压在我的双肩。 —— 叔本华”</p>\n</blockquote>\n<p>《人生的智慧》书中延续了叔本华形而上学和悲观主义哲学。叔本华认为：</p>\n<ul>\n<li>意志可以脱离客观实在而存在，甚至能超越人的理性</li>\n<li>同时他将极端悲观主义与之联系，认为人意志的存在是一切痛苦的根源</li>\n<li>世界为意志表象，而人生只是表象的一种状态；从而生活在表象的世界中，一切都是虚幻泡影，现实的生活没有任何意义</li>\n</ul>\n<p>在这本书中字里行间都渗透着他上面的认识，幸运的是，书写的角度足够世俗，逐一探讨关于人性、人格、地位、荣耀、名声等长久困惑人们的问题，认为<strong>有智慧的人应该以超然而明智的态度对待世务</strong>。通篇在论述道理时，并不像苦口婆心的教导或谆谆教诲的指引。你能感受到他只是静静地表达自己的思想，不把它强加给你；但当你合上书后，那些思想结晶却已让你心悦诚服地接受。</p>\n<p>全书分为下面几节展开。</p>\n<h2 id=\"基本的划分\"><a href=\"#基本的划分\" class=\"headerlink\" title=\"基本的划分\"></a>基本的划分</h2><p>除开外在的财与名外，内在的健壮充实、精神世界的高追求和高禀赋更有助于找到幸福。</p>\n<ul>\n<li>人的命运决定于<strong>人的自身</strong>，<strong>人拥有的身外之物</strong>，<strong>人向其他人展示的样子</strong>；这也是后面论述的划分</li>\n<li>人的内心快乐异或痛苦首先都是人的感觉、意愿、思想的结果，人身外的所有事物都只是间接地发挥作用</li>\n<li>一个人精神能力的界限决定性地限定了他领略高级快乐的能力</li>\n<li>人的自身是具有<strong>绝对价值</strong>且<strong>他人无法得到的</strong>，这和后两点完全不同。<strong>人的自身对人的幸福而言比人所拥有的财富重要得多。</strong></li>\n<li>我们不应该把这一说法错误地理解为：我们应该忽略赚取那些必须和适合的东西，但真正的财富，亦即过分的丰裕盈余，对我们幸福帮助不大</li>\n<li>人拥有的财产、物品和人的名誉、声望是互为影响、促进的关系</li>\n</ul>\n<h2 id=\"人的自身\"><a href=\"#人的自身\" class=\"headerlink\" title=\"人的自身\"></a>人的自身</h2><blockquote>\n<p>无论身在何处，我们只能在我们自身寻找或者获得幸福 ——《旅行者》</p>\n</blockquote>\n<p>每个人都必须成为和做最好的自己，一个人越能做到这一点，在身上就越能够找到乐趣和幸福的源泉。精神需求（即陶冶自己）有助于摆脱无聊、摆脱庸俗，追求真正的幸福。</p>\n<ul>\n<li>对人的幸福起着首要和关键作用的是主体的好处，即健康的身体和心灵。</li>\n<li>让我们幸福或者不幸福的事情不是那些客观、真实的事物本身，而是我们对这些事物的理解和把握</li>\n<li><strong>人类幸福的两个死敌就是痛苦和无聊。还有我们成功远离其中一个的时候，也就在同等程度接近了另一个</strong>。外在原因是生活的艰辛和匮乏造成了痛苦，而相反丰裕和安定就会产生无聊；内在原因是<strong>一个人对痛苦的感受能力与对无聊的感受能力成反比</strong>。精神迟钝就不易感到痛苦的忧伤，后果就是内在空虚，外在体现一刻不停地关注外在世界的各种事情；精神敏锐的人思想活跃，奔涌不息，很少感到无聊，但相反更易提高了对精神痛苦的敏感性。</li>\n<li>正是由于内在空虚，人们才追求社交、娱乐和五花八门的奢侈</li>\n<li><strong>一个人自身拥有越丰富，对身外之物的需求就越少，别人对他来说就越不重要</strong></li>\n</ul>\n<blockquote>\n<p>愚蠢的人饱受无聊之苦 —— 塞内加<br>愚人的生活比死亡还要糟糕 —— 耶稣·西拉克</p>\n</blockquote>\n<ul>\n<li>思想狭隘的人更容易受到无聊侵袭，他们会为意欲找到一些琐碎、微小和暂时的动因，以图刺激意欲并以此刺激智力活动起来。因为没有动因时意欲就休息了，智力也就放假了。对于这种人，<strong>闲暇</strong>只会造就无用的家伙。</li>\n<li>为了争取外在之物而失去了内在的东西，比如为了荣耀、地位、排场、头衔、名声牺牲自己全部或大部分的宁静、闲暇和独立——这是极度愚蠢的行为</li>\n<li>人的快乐分三种：<strong>机体新陈代谢能力带来的快乐</strong>，如吃喝；<strong>发挥肌肉力量带来的快乐</strong>，如狩猎；<strong>施展感觉能力方面的快乐</strong>，如思考观察。感受能力约卓越，我们享受的精神快乐就越大。</li>\n<li>精神生活是“天才”的唯一目标，生活知识他们实现自己目标的一种手段。这类人即使有最良好的性格脾气，也不会对朋友、家庭、集体表现出其他人都有的休戚与共。因为他们自给自足，只有拥有自身内在，失去了其他一切也能得到安慰。</li>\n<li><strong>一个内在丰富的人需要闲暇去培养和发展自己的精神才能，享受自己的内在财富。</strong>闲暇即自我。</li>\n<li>闲暇是反命运的。因为人的天然使命就是花费时间去获得自己和家人赖以生存的东西，而不是自由发挥自己的智力。因此需要闲暇是一个人的幸运。因为这体现了他不同常人的禀赋。</li>\n</ul>\n<h2 id=\"人所拥有的财产\"><a href=\"#人所拥有的财产\" class=\"headerlink\" title=\"人所拥有的财产\"></a>人所拥有的财产</h2><p>财富应该是手段而不是目的。</p>\n<ul>\n<li>一个人拥有财产的方面是否得到满足由他期待得到的财产和他已经拥有的财产之间的关系所决定</li>\n<li>我们感到不满足的根源，在于我们不断推高我们的期望。</li>\n<li>我们应把现有的财富视为抵御众多可能发生的不行和灾祸的城墙</li>\n<li>（赚钱）这苦役本是凡夫俗子的天然命运。只有得到命运如此垂青和眷顾的人，才可能是真正自由的人，是“自己的主人”。</li>\n</ul>\n<h2 id=\"人所展现的表象\"><a href=\"#人所展现的表象\" class=\"headerlink\" title=\"人所展现的表象\"></a>人所展现的表象</h2><p>正视、珍视自我认知，不要狂热地活在他人的看法里。珍惜自己的个性，尤其是较好的一面。</p>\n<ul>\n<li>他人的看法就其本身而言，对我们的幸福并非至关重要。（我们会受到他人看法的影响）从我们的角度出发，应该抑制这一人性的弱点，尽量降低我们对待别人意见的敏感程度。</li>\n<li>每个人首要并确实是活在自己的皮囊里，而不是活在他人的见解中。据此，<strong>正确评估自己本身的价值和看待他人对自己的看法，对我们的幸福大有裨益</strong>。把别人的意见和看法看得太过重要是人们普遍犯下的错误</li>\n<li>虚荣使人健谈，骄傲使人沉默</li>\n<li>如果我们善意地忽略自己的优点，他人就会真心、坦率地把我们认定为就是这个样子</li>\n<li>个性远远优于民族性</li>\n</ul>\n<blockquote>\n<p>你必须强迫自己接受应有的骄傲 —— 贺拉斯</p>\n</blockquote>\n<p><em>（注：即对自己应有的心安理得）</em></p>\n<h3 id=\"地位\"><a href=\"#地位\" class=\"headerlink\" title=\"地位\"></a>地位</h3><p>地位对于增进幸福的目的而言，没有什么意义。然而大众缺乏判断力，记忆力也不强，这也是地位意义不大的原因。</p>\n<h3 id=\"名誉\"><a href=\"#名誉\" class=\"headerlink\" title=\"名誉\"></a>名誉</h3><p><strong>名誉在客观上是他人对我们的价值的看法，主观上则是我们对于他人看法的顾忌</strong>。每一个人为了维持名誉，需要完成在他所占据的独特位置上，人们要求他和期望他做好的事情。而他通常也会重视别人的这些看法，即“名誉感”或“羞耻感”。</p>\n<h4 id=\"公民名誉\"><a href=\"#公民名誉\" class=\"headerlink\" title=\"公民名誉\"></a>公民名誉</h4><ul>\n<li>之所以有名誉，归根到底是因为人们确信一个人的性格是不会改变的</li>\n<li>公民名誉即道德</li>\n<li>名誉只是标明这个人不是一个例外，声望却标明这个人是一个例外。因此，声望是要争取的，而名誉只需保有就行了。</li>\n<li>名誉的价值是间接的</li>\n</ul>\n<h4 id=\"公职名誉\"><a href=\"#公职名誉\" class=\"headerlink\" title=\"公职名誉\"></a>公职名誉</h4><ul>\n<li>公职名誉要求担任公职的人，除了保有公民名誉，还要对其职位保持尊敬</li>\n<li>自愿为国家服务的人亦都享有公职荣誉</li>\n</ul>\n<h4 id=\"性别名誉\"><a href=\"#性别名誉\" class=\"headerlink\" title=\"性别名誉\"></a>性别名誉</h4><p><em>（注：这一部分论述的是传统社会中的性别名誉）</em></p>\n<ul>\n<li>女性名誉远比男性名誉重要，因为女性与异性之间的关系在女性生活中是头等大事</li>\n<li>女性从男性哪里要求和期待一切东西，而男性从女性哪里首要和直接地只要求得到一样东西——女性本身。可以说，女性名誉的价值只是一种习俗的常规意义上的价值</li>\n</ul>\n<h4 id=\"骑士名誉\"><a href=\"#骑士名誉\" class=\"headerlink\" title=\"骑士名誉\"></a>骑士名誉</h4><p>这类名誉在西方历史中较为典型。</p>\n<ul>\n<li>骑士名誉跟一个人自身价值或道德本性没有关系，只和他人对我们的看法和行为有关。只要因为他人的污言秽语或行动冒犯丧失了骑士名誉，我们能做的只有诉诸身体和暴力，通过决斗的方式恢复名誉。</li>\n<li>骑士名誉是自大和愚蠢的象征。看似匪夷所思，实际也在我们生活中时常出现。一个真正珍视自己价值的人，面对空穴来风的侮辱、诋毁会淡然处之，但如果做不到这一点，那精明和修养会帮他掩藏起怒气</li>\n<li>我们应该避免对一些身体冲撞做过度解读，这会带来真正的祸害</li>\n</ul>\n<h4 id=\"民族荣誉\"><a href=\"#民族荣誉\" class=\"headerlink\" title=\"民族荣誉\"></a>民族荣誉</h4><p>民族荣誉上，武力是唯一的裁决者。相比可信任来说，令人生畏是民族荣誉和国家荣誉更需要的。</p>\n<h3 id=\"名声\"><a href=\"#名声\" class=\"headerlink\" title=\"名声\"></a>名声</h3><blockquote>\n<p>石头扔进泥淖，是不会弄出涟漪的 —— 谚语</p>\n</blockquote>\n<ul>\n<li>名誉包含人们在同等处境下必须具备的素质；而名声涉及的素质是我们不可能要求人们一定具备的。这可以是行为业绩或思想作品。行为业绩一方面有赖机遇，另一方面总是跟随动因，所以往往不能持久。而思想作品通常开始声音微弱，而后历久弥新逐渐响亮起来。</li>\n<li>名声维持的越久，到来得就越迟。人类精神思想最高级的产物一般都不会受大众欢迎，根本原因就是每一个人只能真正理解和欣赏自己同类</li>\n<li>名誉是作为信用预先支付的，而名声只能是顶住嫉妒，经过争取得来的。要创作优秀的作品，避免低劣的作品，创作者就必须地址和鄙视大众和其代言人的批判。从而<strong>名声总是逃离追逐它的人，却会尾随对它毫不在意的人</strong>。</li>\n<li><strong>有价值和让人幸福的不是名声，而是借以获得名声的东西</strong>，或更准确的说，让人得到幸福的是产生这些优点和贡献的思想与能力。</li>\n<li>大众的头脑是可怜、凄凉的舞台，这里不可能有真正的幸福。既然人们一般都缺乏独立判断，尤其缺乏欣赏高级别和高难度成就的能力，所以，人们总是听从他人的权威</li>\n</ul>\n<h2 id=\"建议和格言\"><a href=\"#建议和格言\" class=\"headerlink\" title=\"建议和格言\"></a>建议和格言</h2><p>聊了上面一些原则性的话题，下面谈一些建议。</p>\n<h3 id=\"泛论\"><a href=\"#泛论\" class=\"headerlink\" title=\"泛论\"></a>泛论</h3><blockquote>\n<p>理性的人寻求的不是快乐，而只是没有痛苦</p>\n</blockquote>\n<p><em>（注：叔本华的悲观主义认知）</em></p>\n<ul>\n<li>缺少痛苦的程度是衡量一个人生活幸福的标准。而没有痛苦的状态是真正的最大的幸福。</li>\n<li>正是奋力争取幸福快乐、荣耀排场带来了巨大的不幸</li>\n</ul>\n<blockquote>\n<p>我们所说的社交、聚会、沙龙，是悲惨的一出戏，一台糟糕的话剧，乏味、无趣，依靠机械、服饰和包装暂时地撑持。 ——《格言和随想》</p>\n</blockquote>\n<ul>\n<li>一般来说，人们常做的一大蠢事就是过分地为生活未雨绸缪</li>\n</ul>\n<h3 id=\"对待自己\"><a href=\"#对待自己\" class=\"headerlink\" title=\"对待自己\"></a>对待自己</h3><p>对自己负责，自给自足。冷静、理性地使用自己的思想能力。</p>\n<ul>\n<li>对自己生命计划有一个大概的了解，能够比任何一切都更有效地增强自己的勇气</li>\n<li><strong>人生智慧的重要一点是在关注现在和计划将来两者之间达成恰到好处的平衡</strong>。我们的存在唯独就在这一时间。</li>\n<li>只有人挣脱了所有各种可能的期望和要求<em>（注：这当然不现实）</em>，返回赤裸和冰冷的存在本身，人才领会精神上的安宁，而精神上的安宁却是幸福的构成基础</li>\n<li>思想活动要和实际活动相结合<em>（注：学而不思则罔，思而不学则殆）</em></li>\n<li>要<strong>勤于反省</strong>，不要随波逐流</li>\n<li><strong>谁要是不热爱独处，他也就不热爱自由</strong>。社交聚会要求人们做出牺牲，而一个人越具备独特的个性，他就越难做出这样的牺牲。社交聚会一旦人多势众，平庸就会占据上风。有深度的交谈和充满思想的想法，只能属于有思想丰富的人所组成的聚会。而在泛泛的社交聚会上，人们对有思想见识的谈话绝对深恶痛绝，所以在这种社交场合要取悦他人。</li>\n</ul>\n<blockquote>\n<p>一个完全依靠自己，一切称得上属于他的东西都存在于他的自身的人是不可能不幸福的 —— 西塞罗</p>\n</blockquote>\n<ul>\n<li><strong>只有那些依靠自己，总的来说能够成为自己的人才是处境最妙的</strong>。促使人们热衷与人交往的原因，就是人们无法忍受孤独或无法在孤独中忍受自己。而人们单调的个性使他们无法忍受自己，人的群居生活可被视为人与人相互间的精神取暖。</li>\n<li>一个人的高贵本性首先反映在这个人无法从他人的交往中得到乐趣<em>（注：持保留意见）</em>。虽然生活在众人之中，但他不可以成为众人的一份子，而是要与众人更多地保持某种纯粹客观的联系<em>（注：从某种角度讲，就是缺乏人情味。我认为在叔本华所推介的精神高尚境界以及世俗感情间找到一个平衡点才是最适宜的）</em>。</li>\n<li>嫉妒对人来说是自然的，但嫉妒既是一种罪恶又是一种不行。<em>（注：叔本人也没有给出有效地克服这种感情的办法）</em></li>\n<li>不要老是紧张兮兮不断回头重新考虑已经付诸实行的事情和担忧可能遭遇到的危险，应该给思考贴上封条，确信已经考虑到了一切，并以此得到安慰</li>\n<li>遭遇不幸时，要能积极主动地面对生活，把握住自己的情绪，改变能改变的</li>\n<li><strong>任何关乎我们痛苦和快乐的事情都应该以理性和判断力去观察和考虑</strong>，对其不掺杂个人情绪的思考。与此同时，<strong>千万不要让想象力介入思考</strong>，因为想象力无法对事情做出判断，智慧毫无益处地扰乱我们的情绪。</li>\n<li>在夜晚，我们的理解力和判断力就变得疲倦和呆滞，已无法深入事情的本质。因此<strong>夜晚并不适宜思考严肃的，尤其令人不悦的事情</strong>。早上适合人们从事工作和创造，不管是精神上还是体力上的。因为早晨是一天的青年期，一切都是明亮、新鲜和轻松的。</li>\n<li>只在恰当的时间里操心、享受、忍耐一样事情，其他的则完全不要想<em>（注：想清楚自己为何烦忧，逐个击破，不要带着包袱前进）</em></li>\n</ul>\n<blockquote>\n<p>生命在于运动 —— 亚里士多德</p>\n</blockquote>\n<ul>\n<li>我们的生存从本质上就是不停歇、不安的。<strong>去操劳、去克服困难是人的一种需要。持久的享受和完全的满足所带来的停滞和静态，会让人无法忍受</strong>。克服障碍是人的本能，没有机会时，人们也会依照自己的个性去制造这样的机会</li>\n<li>肌肉会疲劳，精神操劳得厉害也会变衰弱。我们不应强制性地、持续不停顿和在不适宜的时间用脑，<strong>我们一定要给予大脑必需的、充足的睡眠，借此修养、恢复</strong>。睡眠是我们提前借取的一小段死亡，以此获得和更新被白天所耗尽了的生命。</li>\n</ul>\n<h3 id=\"看待他人\"><a href=\"#看待他人\" class=\"headerlink\" title=\"看待他人\"></a>看待他人</h3><p>他人是固执的，不要抱太高的期望。要谨慎机灵，避免受伤。</p>\n<ul>\n<li>为了在人群中生存，我们必须容许和承认别人以既定的个性存在。<strong>我们关心的只是如何以一个人的本性和特质所允许的方式利用这个人，既不应该希望改变也不可以干脆谴责这个人的本性</strong></li>\n<li>人与人在精神、气质上的同声相应或大相径庭，会轻易和很快在人们的交谈中显现出来。同类的两个人很容易就谈论的一切达成某种程度的和谐一致。</li>\n<li>记忆中人会被理念化，这个美化工作需要很长时间才能完成。要想得到这个好处，方法之一就是尽量不要与人见面</li>\n<li>和别人说话时，会自然地把自己降到他人的水平。因此<strong>和庸俗的人交谈时，自己不同时变得庸俗简直就是不可能的事情</strong>。</li>\n</ul>\n<blockquote>\n<p>很难在高度尊敬一个人的同时，有非常喜爱他 —— 拉罗什富科<br>取悦我们所必需的思想深度刚好就是我们自己的思想深度 —— 《论精神》 第2篇，第10章</p>\n</blockquote>\n<ul>\n<li><strong>我们只能选择得到别人的尊敬，或是他们的喜爱。</strong>别人对我们的喜爱总是出于私心，且并不总是值得我们自豪的。别人对我们的尊敬，情况相反，因为这是我们强行从别人哪里、违背他们意愿获得的。别人通常都把这尊敬掩藏起来。尊敬和我们的价值紧密相关，而喜爱则不是，因为<strong>喜爱是主观的，尊敬是客观的</strong></li>\n<li>大部分人都是如此主观，根本上除了他们自己外不会对别的感兴趣，结果就是别人说什么话马上就能让他们联想到自己。在这些人身上，意欲远远压倒了认识力，他们微弱的智力完全服务于意欲们甚至片刻也摆脱不了意欲的控制。<strong>占星术是一个极好的证明，由于人这种可鄙的主体性，所以把一切都与自己搭上关联。占星术把天体的运行和寒酸的自己拉上关系，也把它与尘世间的俗事、丑行联系在一起。这种情况古已有之</strong>。</li>\n<li><strong>对任何人都不可太过迁就和热情</strong>。如果我们太过友好、礼貌和殷勤，我们反而有可能失去这些朋友。与人交往的优势全在于任何方面都不需要对方，<strong>并且让他们看到这一点</strong>。</li>\n</ul>\n<blockquote>\n<p>不尊崇别人的人会受到别人的尊崇 —— 意大利谚语</p>\n</blockquote>\n<ul>\n<li>谁要是以为这世上魔鬼就是头上长角或者傻瓜就是身挂铃铛，他就会永远成为他们的猎物和玩物。与他人交往时，人们只是露出其中的一面。无论如何，对刚认识不久的人，都应注意不要评估太高。否则十有八九我们都会失望甚至蒙受损失。<strong>一个人会在细节小事上疏于防备，从而表露出自己的性格</strong>。</li>\n</ul>\n<blockquote>\n<p>没有哪条狗是坏到不会摇尾巴的 —— 意大利谚语</p>\n</blockquote>\n<ul>\n<li>要具备某种不发自我们与生俱来的本性，而只是出自理想思考，完全从外在获得的性格，是件很困难的事。人的天性从来没有完全停止过对此的抗争。<strong>造作是我们对自己的某种自我谴责和贬低</strong>。我们不能无条件放任自流，完全表现自己的样子。<strong>对否定属性的隐瞒是合理的，但是对肯定属性的冒充是不对的</strong>。</li>\n<li>以他人为镜，从中能清楚看到自己的缺点</li>\n<li>人与人最重要的关系和由此产生的联系不是理念上的<em>（注：即兴致相投）</em>，而是以某种物质利益为基础。这点认识上的转变通常在年长时才会认识到。因为<strong>在这个贫穷和匮乏的世界，应付匮乏和需求的手段无论在何处都是最重要的，因此也是压倒一切的。</strong></li>\n<li>在这个世界上流行的不是真正的尊重和真正的友谊，只是做得尽量逼真和自然地显示尊重和友谊的表面功夫。朋友间分隔太远或长时间不见会有损友情，<strong>甚至我们最亲爱的朋友随着岁月的流逝会逐渐变成抽象的概念，我们对他们的关切也越来越变得纯粹只是理性上的</strong>。</li>\n</ul>\n<blockquote>\n<p>从我们最好的朋友所遭遇的不幸，我们总能找到某样并不会使我们不悦的东西 —— 拉罗什富科</p>\n</blockquote>\n<ul>\n<li>一个人表现出聪明和思想只能激起人们对他的憎恨和方案，并且这种感情还因为憎恨者和反感者没有正当理由说出来而变得更加强烈。<strong>显示自己的聪明智慧其实就是间接地指责别人愚蠢和无能</strong>。每个人都会本能地靠近给他带来优越感的物体。</li>\n</ul>\n<blockquote>\n<p>要取悦别人的话，唯一的方式就是把自己裹以最傻呆的动物的外皮 —— 格拉西安</p>\n</blockquote>\n<ul>\n<li><strong>保持礼貌就是大家心照不宣订下这样一条协议：我们都将互相忽略和避免对方在道德上和智力上的可怜本质。</strong>有礼貌是精明的做法，不礼貌的言行是愚蠢的。<em>（注：礼貌是人的一种保护措施，用光彩的外表掩饰贫乏难看，有棱有角的内在动物本性；在公众面前失去礼貌，就有如脱光衣服示众）</em></li>\n<li>人的性格是不会改变的。<strong>一辈子也难改变一个人，能改变一个人的只有他自己</strong></li>\n<li>所有激烈的情绪都来自意欲，而认识力在本质上是冷静的</li>\n</ul>\n<blockquote>\n<p>你的敌人不可以知道的东西，都不能告诉你的朋友 —— 阿拉伯谚语<br>如果保持沉默，那我的秘密就是我的囚徒；如果失口说出这个秘密，那我就变成了这秘密的囚徒 —— 阿拉伯谚语<br>沉默之树结出安宁之果 —— 阿拉伯谚语</p>\n</blockquote>\n<ul>\n<li>选择沉默是精明所致，采用说话则是虚荣心使然。我们经常都有做出这两者的机会，但通常为求得瞬间的快意而选择说话，不惜舍弃沉默所带给我们的长久好处</li>\n<li>对不少人我们可以态度礼貌、声调友好地说出真正无礼的话语，而又避免直接的危险。<em>（注：因为这表示我们并没有诉诸自己的感情，没有情绪化）</em></li>\n</ul>\n<h3 id=\"看待命运\"><a href=\"#看待命运\" class=\"headerlink\" title=\"看待命运\"></a>看待命运</h3><p>要对可能面临的苦难有所认识和准备。</p>\n<ul>\n<li>通常，外在的时间和我们的根本目的犹如两股向着不同方向牵引的力，这两股力形成的对角线就成了我们的生活轨迹。</li>\n<li>一个精明的人不会被事物恒久不变的表象欺骗，甚至能预见事物即将发生的变化方向</li>\n<li>时间索取的利息比任何一个高利贷都夸张</li>\n<li>总的来说，一个人在遭遇各种不幸横祸的时候，如果能够保持镇定自若，那就显示出他知道人生有可能遭遇的灾难是巨大和不可胜数的。</li>\n<li>我们对每天人际交往中遇到的琐细烦忧，不可以放在心上，放在脑子里，而应视这些东西为前进路上的小狮子，随脚踢开，千万不要认真回想和琢磨这些事情。</li>\n<li>一定程度的敬畏对于我们在这一世界的生存是必须的</li>\n</ul>\n<h2 id=\"人生的各个阶段\"><a href=\"#人生的各个阶段\" class=\"headerlink\" title=\"人生的各个阶段\"></a>人生的各个阶段</h2><h3 id=\"童年期\"><a href=\"#童年期\" class=\"headerlink\" title=\"童年期\"></a>童年期</h3><p>懵懂，上帝视角观察生活，不被意欲牵扰。</p>\n<ul>\n<li>童年期我们更多处于认知而不是意欲的状态，因此也充满了幸福。这个时候，生活以其全部以呈现在我们眼前，一切都是那样的新颖、鲜活。在童年期和青年早期对事物的经验和认识构成了以后所有认识和经验的固定原型和类别。</li>\n<li>教育也忙于向我们灌输概念。不过这些概念并不会给我们真正本质的东西。这些东西就在我们对这个世界所作的直观把握中</li>\n<li><strong>所有事物的客体存在，亦即其纯粹在表象中的存在，总是令人愉快的，而这些事物的主体存在，亦即作为意欲存在时，却都沉浸在痛苦和悲哀中</strong>。</li>\n<li>在稍后的日子，我们有了对现实生活的渴望，急切期盼做事和受苦，这把我们拉进了喧嚷、骚动的人生。我们逐渐了解事物的另一面，即意欲的一面。</li>\n</ul>\n<h3 id=\"青年期\"><a href=\"#青年期\" class=\"headerlink\" title=\"青年期\"></a>青年期</h3><ul>\n<li>在青年期困扰我们造成我们不幸福的原因是，我们对幸福的<strong>刻意追求</strong>。无论处在何种环境，我们通常都会感到不满，那是因为我们把现在才首次了解到的、无处不在的人生的空虚和可怜归咎于我们的环境</li>\n<li>如果人的前半生特征是苦苦追求幸福而又无法满足，那人的后半生特征则变成了害怕遭遇不幸</li>\n<li>一个成熟的人从自己生活经验中获得的，首先是不再先入为主和想当然</li>\n<li><strong>在年轻的时候，我们误以为生活中的重要人物和重要意义的时间会大张旗鼓地露面和轰轰烈烈地发生。到了老年后，对生活的回顾却显示这些人物和事件都是悄无声息、不为人注意地从后门进入我们的生活</strong></li>\n</ul>\n<h3 id=\"中老年\"><a href=\"#中老年\" class=\"headerlink\" title=\"中老年\"></a>中老年</h3><ul>\n<li>到了人生后半部分的人，看到了刺绣的背面，背面不那么美丽，但给人以教益，因为它让人看到刺绣品的总体针线</li>\n<li>我们在青年时代感到喜悦和朝气，部分原因是我们正在走着上坡的路，并没有看见死亡。从年轻的角度看，生活就是漫长无尽的将来；从老年的角度看，那不过是一段极其短暂的过去</li>\n<li>蓦然回首走过的一生，我们为什么觉得如此短暂呢？因为我们对这生活回忆不多，所以就觉得生活短暂了。这回忆漏掉了所有没多大意义和许多不愉快的事，剩下来的因此很少。很多开始有意义的事情，经过经常和无数次的重复后，慢慢成了没有意义。因为我们更能回忆我们的早年，而不是之后的时光。我们生活的时间越长，值得事后回想和重要有意义的事情就越少，唯有回想，才能让这些事留在记忆中。</li>\n<li>有时我们的回忆可以把某一幕尘封已久的往事栩栩如生地重现在眼前，仿佛发生在昨天，但我们无法回想起现在和当初发生这一幕往事间所流逝的漫长时间。这段时间无法像一副图画一目了然，并且这之间发生的事情也大都忘记了；对这些事情只保留抽象中的大概认识，纯粹某一概念而已。所以那过去很久的某一往事显得那样的接近，宛如发生在昨天，而其余的时间则消失无踪。</li>\n<li>青年人根据自己度过的为数不多的年岁估算将来，这些过去了的日子总是充满回忆，并因此显得漫长，因为<strong>新奇感</strong>使所有一切都显得有意义。</li>\n<li><strong>有时候，我们以为自己是在怀念某一处遥远的地方，但其实，我们只是怀念着我们在年轻、朝气蓬勃的时候。</strong></li>\n<li>人只有在年轻时期才是充满意识地生活，到了老年只带着一半的意识活着。人们做他们不得不做的事，之后却不知道自己是否做了那些事情</li>\n<li>童年期，新奇感把一切事物都纳入我们的意识，因此每一天都是漫长的。<strong>我们在外出旅行的时候也遭遇同样的情形，所以，在旅行中度过的一个月似乎比在家的四个月还要长</strong>。</li>\n<li><strong>一年的感觉长短与这一年除以我们年龄所得的商成反比</strong>；其次我们感受无聊的成都与我们的年龄成反比。在后半辈子，无聊也大都连带消失了。并且另一方面，我们的情欲及其痛苦也沉寂了。</li>\n<li>青年期占优势的是直观，在老年期占优势的是思想</li>\n<li>我们精神力最旺盛的时期，毫无疑问是青年期，最迟能延至35岁左右。从这个年纪开始，精神力就开始衰弱。</li>\n<li>在青年期，我们的知识总是支离破碎、残缺不全的。只有到了老年，我们才能对生活获得某一完整的、恰如其分的表象认识。人们在青年时代有更多的设想，但在老年阶段，有的更多是判断力、洞察力和对事物的根本认识</li>\n<li>我们经常低估我们在年轻时做出的成绩，也轻视那时候的判断力</li>\n<li>最奇怪的是，只有在生命临近完结之时，一个人才会真正认清和明白，甚至他自己、他就自己的木目标和方向，尤其在他与这个世界和他人的关系方面</li>\n<li><strong>每种快感的产生都只是一种需求的缓解</strong></li>\n<li>不管怎么说，青年期是躁动不安的时期，老年期是安宁的时期。青年人收到缤纷世界及其丰富形态的诱惑，他的想象力马上就夸大了这一世界所能给予的东西。在老年，人们得以更正确、更清晰地认清所有一切的客观面目。</li>\n<li>青年期和老年期的根本区别在青年期的前景就是生活，而老年期的前景却是死亡。</li>\n</ul>\n<h2 id=\"附：叔本华的生平轶事\"><a href=\"#附：叔本华的生平轶事\" class=\"headerlink\" title=\"附：叔本华的生平轶事\"></a>附：叔本华的生平轶事</h2><ul>\n<li>“在孩子们从生活原型中了解到生活之前，不应该从生活的复制品中认识生活的任何方面。因此，不要匆匆忙忙只是把书本放在孩子们的手中。……让他们永远直接从现实世界里提取概念”</li>\n<li>生来就注定要成就一番伟大事业的人，从青年时代起就会在内心秘密感到这一事实</li>\n<li>“设立国家的必要性就在于人们已经承认：人与人之间并没有什么公正可言”。</li>\n</ul>\n<p><em>–END–</em></p>\n",
            "tags": [
                "读书笔记",
                "哲学",
                "幸福",
                "人生",
                "叔本华"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/02/13/1587-a-year-of-no-significance/",
            "url": "http://shenlvmeng.github.com/blog/2019/02/13/1587-a-year-of-no-significance/",
            "title": "关于《万历十五年》的一些思考",
            "date_published": "2019-02-13T15:18:30.000Z",
            "content_html": "<blockquote>\n<p>作为读书后的感受记录，照例先做概要，再谈感受。</p>\n</blockquote>\n<p>我是在大学阶段知道《万历十五年》这本书的，当时作为《形势与政策》课的读书笔记建议书目之一。可见尽管写的四百多年前的事，对于当今还是有参考意义。如作者所说，全书介于学术著作和商业书籍之间，用有趣的具有复古气息的口气，从点到面地讲述了万历年间的诸多史事和几个典型人物，由浅入深、抽丝剥茧地探讨了传统社会存在的僵化问题，并给出现代社会以经验和教训。读毕感叹黄仁宇先生功底之深厚，著学之审慎。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>归根到底，还是过于依托世俗道德约束百官和平民，缺少法律的规矩约束，使得整个社会制度很容易跟不上经济发展和科学进步，而最终走向窠臼被淘汰。</li>\n<li>明朝的皇帝即使贵为天子，也不过是制度所需要的产物，他作为“天命”的象征，有天赋的最终仲裁和决定权，需要调和百官之间的关系；但同时也是传统道德的完美象征和百官楷模，需要严格依从传统和道德行事。</li>\n<li>文官们熟读孔孟之书，研究历史兴亡之道，从伦理道德出发解释日常事务，在面对违反伦常的虚伪矫情时，如果不力加诤谏而听之任之，必然会影响本朝安危</li>\n<li>宦官是皇帝和文官之间的协调者，一个优秀的皇帝会成为文官和太监间的平衡者，相互掣肘</li>\n</ul>\n<h2 id=\"申时行\"><a href=\"#申时行\" class=\"headerlink\" title=\"申时行\"></a>申时行</h2><ul>\n<li>在这种制度下，道德至高无上，它不仅可以指导行政，还可以代替行政</li>\n<li>一项政策能否付诸实施，实施后或成或败，全看它与所有文官的共同习惯是否相安无事。</li>\n<li>文官作为政策的实施者，朝廷最大的任务就是促进文官之间的互相信赖与和谐，鼓舞士气，发挥精神上的力量。</li>\n<li>理想和现实是脱节的，人们口头上的理想即为“阳”，人们不可告人的私欲即为“阴”，调节阴阳是一件麻烦事。因此，<strong>与其暴露各人的阴，毋宁提倡他们的阳</strong>。</li>\n<li>身为首辅最大的贡献，则在于是各种人才都能在政府中发挥长处，对他们起感化和领导的作用。</li>\n<li>申时行尽管意识到阴阳难以调节，问题症结所在，却没有能力改变制度。他决心做和事佬来调和阴阳，生平不愿宣扬别人的缺点，对于提拔自己的人，更不会妄加批判。</li>\n</ul>\n<h2 id=\"万历\"><a href=\"#万历\" class=\"headerlink\" title=\"万历\"></a>万历</h2><ul>\n<li>本朝的司法制度极为简单，缺乏判决争端的依据。以立储为例，假如帝国真正实行法治，继承皇位一事由一个独立性的法庭作出判决，那么皇帝委托律师根据文法和不成文法来做辩护，立幼而不立长是有胜诉可能的。但是<strong>本朝不是以法律治理臣民，而是以“四书”中的伦理作为主宰</strong>。</li>\n<li>文官已成一种强大的力量，强迫宝座上的皇帝在处理政务时摈弃他个人的意志，历任首辅又都以群臣的代言人自居。万历却无能为力，因为在制度中，皇帝作为仲裁者而非实施者，没有制定法律的力量，不能改造制度避免冲突发生。因此消极怠工的报复，目的并非恢复皇帝的权威而只是单纯发泄</li>\n<li>体制上有欠缺，文官们就需要精神力量来弥补组织上的不足。一方面，这些熟读经史的人以仁义道德相标榜，以治国平天下为己任；另一方面，体制上有存在如此多罅隙，给这些人强烈的引诱</li>\n<li><strong>长期的道德沦丧，即标志社会形态何其组织制度的脱节</strong></li>\n</ul>\n<h2 id=\"海瑞\"><a href=\"#海瑞\" class=\"headerlink\" title=\"海瑞\"></a>海瑞</h2><ul>\n<li><strong>海瑞的一生体现了一个有教养的读书人服务公众牺牲自我的精神，但这种精神的实际作用却至为微薄。</strong></li>\n<li>抽象的道德代替了法律，上至官僚下至村民，其判断是非的标准是“善恶”而非合法或非法。</li>\n<li>以熟读诗书的文人治理农民，他们不可能改进这个司法制度</li>\n<li>财政制度弊病在于缺乏弹性，不能适应环境而调整。政府不用技术和经济的力量来扶植民众，而单纯依靠政治上的压力和道德上的宣传，结果只能是事与愿违</li>\n<li>海瑞不相信为人处世应该有阴阳的分别，因此被称为奇特、怪僻而执拗。</li>\n</ul>\n<h2 id=\"戚继光\"><a href=\"#戚继光\" class=\"headerlink\" title=\"戚继光\"></a>戚继光</h2><ul>\n<li>明朝文官地位高于武官。大多数文官以中庸之道为处事的原则，标榜稳健和平，这和武官克敌制胜征战沙场的常态相矛盾。</li>\n<li>戚继光功成名遂，固然是本身的卓越才能使然，但是得到谭纶的支持也是必不可少的因素。</li>\n<li>戚继光是个复杂的人物，不能把她强行安放在用传统道德构成的标准框架里。他的天才，在于他发现面对落后的军事制度，帝国不允许也没有能力做全面的改革，能做的只有妥协；而他的成功也在于他善于在技术上调和各种矛盾，<strong>在组织制度上没办法，就在私人关系上寻找出路</strong>。</li>\n<li>戚继光的长处在于他没有把人事上的才能当成投机取巧和升官发财的本钱，而只是作为建立新军和保卫国家的手段</li>\n</ul>\n<h2 id=\"李贽\"><a href=\"#李贽\" class=\"headerlink\" title=\"李贽\"></a>李贽</h2><ul>\n<li>大凡高度的概括，总带有想象的成分</li>\n<li>李贽视舍小节而顾大局的作法为正当，其前提是以公共利益为依托，在伦理上的解释则是公众道德不同于私人道德，目的纯正不妨手段不纯</li>\n<li>李贽是提倡实践的理论家，但并不表示自己有意于实践；他攻击虚伪的伦理道德，也拒绝以传统的历史观为自己的历史观，但更广泛的范围里仍然是儒家的信徒。</li>\n<li>张居正意识到必须要在组织上作部分的调整和改革，但是在理论上找不到更好的学说，就只能以自己的一身挺立于合法合合理之间。</li>\n<li>混合阴阳，在长时间里造成了法律和道德的脱节</li>\n</ul>\n<p>当一个人口众多的国家，个人行动全凭儒家简单粗浅而又无法固定的原则所限制，法律又毫无创造性，则社会发展的程度必然受到限制。<strong>即使宗旨善良，也不能补助技术之不及</strong>。</p>\n<p><em>–END–</em></p>\n",
            "tags": [
                "制度",
                "道德",
                "文官",
                "万历",
                "明朝",
                "读书笔记"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2018/11/22/selfish-gene/",
            "url": "http://shenlvmeng.github.com/blog/2018/11/22/selfish-gene/",
            "title": "《自私的基因》——生命的必然性和偶然性",
            "date_published": "2018-11-22T15:36:28.000Z",
            "content_html": "<p>《自私的基因》是道金斯在上世纪70年代写的一本关于生物学的经典著作。书中从“自私的”复制因子基因的角度出发，推导出生物学、社会学各个方面的规律猜想，乃至最后上升到对生命、人类产生的必然性和偶然性的大胆设想。全书从第5章起，开始引人入胜，内容渐入佳境，让人手不释卷。其中对于代际、两性出现、共生群居等方面的探讨，令我有三观再塑之感。尽管前几章对复制因子基因的“自私性”和生存机器铺垫甚多，有点拖沓，整体还是很值得一读的。另外，把《自私的基因》和《人类简史》连在一起思考，甚至有更奇妙更透彻的感觉。</p>\n<h2 id=\"对“自私的基因”一词的解释\"><a href=\"#对“自私的基因”一词的解释\" class=\"headerlink\" title=\"对“自私的基因”一词的解释\"></a>对“自私的基因”一词的解释</h2><p><strong>生物的进化的最基本单位是基因而不是生物个体</strong>。因为基因有复制性，可以控制个体性状。生物的生存繁衍等一切行为的本质是基因带来的。成功基因的标志是可以在复制中不断战胜其余复制因子，<strong>这个过程是“盲目的”。基因是不会做选择的，做选择的是自然环境</strong>。经过自然选择留下来的成功基因，自然是生存能力最强，留下复制最多的，看上去也是最“自私的”。自私一词是有些感性，但是它是对成功基因最恰当的形容了。你可以把它和<strong>“不被淘汰”</strong>等同。</p>\n<h2 id=\"复制因子\"><a href=\"#复制因子\" class=\"headerlink\" title=\"复制因子\"></a>复制因子</h2><p>基因作为自然界诞生的产物，更通用的说法可以叫<strong>复制因子</strong>。在复制因子出现之前，自然界一片混沌，各种大分子在“分子汤”内自由游荡，随意组合，我们很难把它们叫做“个体”。直到有一天（说得不大严谨）出现了第一个复制因子。它们不见得是分子汤里最大的，但是它有可贵的性质——能复制自身。这个偶然性虽然非常之小，但是<strong>一旦出现就会不可逆的扩张开来</strong>。以至于复制因子一旦出现就会占据整个分子汤的主要地位，它会必然地在海洋里疯狂复制自己的拷贝。</p>\n<p>很有可能基因只不过是一种复制因子，在基因出现前甚至出现之初，可能甚至很可能有类似基因的其他复制因子。复制因子之间必定会有胜利和失败者，因为分子汤资源是有限的，不足以维持无限量的复制。现在看来，最终基因胜利了。在基因的竞争和演化中，逐渐出现了蛋白质的保护膜，更多的基因渐渐聚合起来，蛋白质分工逐渐明确，生存机器由此产生。<strong>人不过也是一种生存机器罢了</strong>，“操纵”这个机器的是背后的基因。</p>\n<p>另外，复制过程当然不会是完美无缺的，因此产生的多样性，让生存机器间也出现了越来越大的形态差异。</p>\n<h2 id=\"基因与染色体\"><a href=\"#基因与染色体\" class=\"headerlink\" title=\"基因与染色体\"></a>基因与染色体</h2><p>我们生物都是同一种复制因子——DNA的生存机器，基因在染色体中，它通过蛋白酶监督着蛋白质的生成，并通过蛋白质控制生物性状。基因对生物的控制是<strong>“单向”的</strong>，也即后天所学是无法改变基因并遗传给后代的。个体的存活时间可能很有限，但是基因不断复制和交叉会一代代传递下去。</p>\n<p>基因的复制最好是完美无缺的，自然选择对失误的复制惩罚往往很严重，如染色体丢失、倒位很容易导致个体的死亡。但是也有些复制失误不会造成那么大问题，只是在个体的一生逐渐积累，这也就是衰老。成功基因的标志除了“自私”，即能传递自身，还要保证和其他基因的通力合作下，能让生存机器的死亡至少推迟在生殖以后。有种观点认为性“促进了在单个个体内积累以往出现在不同个体内的有利突变”。</p>\n<p>所谓<strong>进化就是指基因库中某些基因变多了，而另外的变少了的过程</strong>。</p>\n<h2 id=\"基因机器\"><a href=\"#基因机器\" class=\"headerlink\" title=\"基因机器\"></a>基因机器</h2><p>基因通过合成蛋白质，进而由神经控制和激素控制控制生物个体。控制下个体的每一次行为都是一次选择，在自然选择后留下的都是适于当前环境的。动物的行为无论是利己的还是利他的，都在基因控制之下，基因是主要的策略制定者，大脑则是执行者，并接管了很多决策职能。</p>\n<p>一个生存机器对另外生存机器的行为或神经系统施加影响时，前者就是在和后者联络（communication）。这也让基因的影响力能辐射到另外的个体，产生相互的影响。即下章会提到的行为。</p>\n<h2 id=\"博弈论下的动物行为\"><a href=\"#博弈论下的动物行为\" class=\"headerlink\" title=\"博弈论下的动物行为\"></a>博弈论下的动物行为</h2><p>动物间的搏斗是<strong>克制且按规则</strong>进行的，因为不分青红皂白地杀死对手并无明显的好处，在一个庞大复杂的竞争系统中，除掉一个对手不见得就是好事，但是把特定对手杀死或者至少搏斗一番是个好主意。在行为双方都可以做选择时，博弈论的理论告诉我们，在大量样本的情况下，会有进化上的稳定策略（ESS）。而偏离ESS的行为将会受到自然选择的惩罚。</p>\n<p><em>（关于鹰和鸽子策略的探讨篇幅过长，建议网上查看，便于理解ESS）</em></p>\n<p>进化中的稳定策略无处不在，且不止一种策略会留在最后的稳态中（稳定的多态性）。在行为双方能力不对称（这是常态）且行为双方有记忆时，开始个体的胜利或失败可能是完全偶然的，但是随着搏斗的进行，个体间会自动归类成等级，避免激烈的搏斗，从而产生了阶级。按照博弈论思路下的推导，一个种群内可能会从一个ESS跳到另一个ESS，伴随着环境不断进步。</p>\n<p>不过，面对和自己有着很多共同基因的近亲，这种讨论就失效了。基因 + 自然选择必然会留下特地照顾自身复制的基因。这方面讨论见下一章。</p>\n<h2 id=\"亲代行为与计划生育\"><a href=\"#亲代行为与计划生育\" class=\"headerlink\" title=\"亲代行为与计划生育\"></a>亲代行为与计划生育</h2><p>经过自然选择的基因必然具有一个特质：最大程度的复制自身。基因有没有一些比较合情理的“识别”自身复制的方法呢？有，其中一个就是<strong>个体的近亲</strong>。这显然是亲代对子代利他性行为普遍存在的原因。父母之爱是亲代之爱的一种特殊情况。亲代间基因的相似度显然是不同的，血缘关系越近，基因相似度越高，对应的 利他性行为也会越显著。很明显兄弟姐妹之爱不如父母之爱来得那么普遍（只从天生层面讲）。</p>\n<p>然而父母对子代的关心不会一直持续。因为父母对一个个体的关怀可以分为两个阶段：<strong>生育幼儿</strong>，<strong>养育幼儿</strong>。从基因“自私”的一面来讲，亲代理应最大限度生育后代。但是事实却不是这样，一大原因是野生动物生存困难，几乎永远不可能因衰老死亡，疾病、饥饿、捕食者种种隐私很容易导致野生个体死亡。而且可以观察到，野生生物通常会控制自己生育后代的数目，即“计划生育”，这是因为，计划生育在资源和生存条件恶劣的情况下，反而能最大限度增加子代的存活数。节制的剩余数目反而是当前环境的最优解。过度生育的个体会被自然选择惩罚。</p>\n<h2 id=\"代际的竞争\"><a href=\"#代际的竞争\" class=\"headerlink\" title=\"代际的竞争\"></a>代际的竞争</h2><p>亲代对子代的投资往往是不均等的，同时对某个子代的投入，必然是以牺牲对其他子代投入为代价的。子代为了保证自己的存活，往往会竭尽所能甚至是欺骗。同时，亲代在自身随着衰老养育能力下降后，通常会有生殖能力逐渐消失的现象（尤其是雌性），因为此时对子女的投入不如对孙子孙女的投入平均回报大。雄性往往是逐渐衰退的，原因可能是，父亲对子女的投资额比不上母亲。幼儿的哺乳期不宜过长，到尚未出生的弟弟妹妹因为他继续吃奶蒙受的损失超过从他那里得来好处的数倍时，他就不应再吃下去了。广义的断奶由此出现。</p>\n<p>然而，子代为了自己利益的最大化，和亲代的目标必然有分歧，最终的结局是两方理想条件的某种妥协。我们不要指望子代个体本性里有利他主义的成分，<strong>道德准则和基因里的本性是两回事</strong>。</p>\n<p>这里要再强调一下，从基因到个体的“自私”表现，都是经过自然选择的必然结果，不自私的基因和个体都在激烈的竞争中被淘汰了。</p>\n<h2 id=\"两性\"><a href=\"#两性\" class=\"headerlink\" title=\"两性\"></a>两性</h2><p>生物大多有性别之分，尤其是有性生殖个体。在生殖上，可以说每个配偶的本性都应该会设法利用对方，迫使自己少投资，对方多投资。那两性是如何出现的呢？我们知道两种生殖细胞，一种细胞（卵细胞）较大，数量少，营养物质充足，不灵活；另外一种（精子）较小，数量巨大，身材瘦小，灵活。明显卵细胞一方投资较多，看起来是精子那一方占了便宜，为什么会这样呢？假设最开始两种生殖配子是差不多的性质，<strong>一旦这种配子间的分歧产生，性质偏向卵细胞的一方在诞生个体上就会更有优势，而偏向精子的一方在寻找对象上（量大，灵活）也会更有优势，而性质介于两者之间的生殖配子就会收到自然选择的惩罚</strong>。从而这种差异就像脱缰的野马，一发不可收拾，到两者的形态到达再继续变化就要被惩罚的稳态，即现在这个模样。</p>\n<p>而精子代表的一方就成为了雄性，卵子一方成为了雌性。从上面的理论可以自然推测出，朝着尽量多诞生复制的目标下，雄性个体数目较之雌性个体会越来越少（因为雄性个体可以很轻易产生大量精子，对应到大范围的雌性）。但是现状很显然不是这样，男女比例是很接近的。原因是，生育一个儿子的基因较之生育女儿极有可能会复制自己出现在成为大量后代中。 在基因朝着多生育儿子的趋势前进时，自然地就平衡了之前男少女多的情况。<strong>生育相同数目的儿女的策略是进化上的稳定策略</strong>。</p>\n<p>对生育个体而言，他或她在其中投资的越少，所能生育的子女就越多。但是雌性<strong>由于卵细胞的存在</strong>，个体往往从自己体内诞生，个体一旦死亡，自己比做父亲的要蒙受更大损失。顺便补充有趣的一点，在鱼类中情况是反过来的，有一种可能是，鱼类的交配过程是共同排出生殖细胞到水中完成交配，而不是在雌性个体内。这时情况就变了，谁先排出生殖细胞就更易把责任推给另一方（值得商榷），卵细胞相对较大，在水中不易散逸，精子则很容易散逸。所以雄鱼通常得等在雌性后面排出生殖细胞，而被迫承担养育责任。</p>\n<p>说回来，在交配完成后，双方都要冒着被对方抛弃的危险（雌性可以遗弃还未诞生的个体，所以雄性也有风险）。在这种博弈情况下，有一些常见策略，如“家庭幸福”和“大丈夫”。前者指在交配前，双方仔细观察对方忠诚和眷恋家庭生活的可能迹象，“订婚期”长对雄性个体也有利，因为他有上当受骗，抚养其他雄性个体所生子女的风险。在雄性有忠诚、薄情两种决策，雌性有忸怩、放荡两种决策下，较多忠诚和较多忸怩以及较少薄情和较少放荡会达到一种稳态。大丈夫策略下，则是根据雄性个体素质进行选择，保证子代更加健壮，从而更容易拥有交配权。素质判断的过程随着雄性偶尔的欺骗出现，会向着<strong>雄性某些表征愈发明显和雌性观察力愈发敏锐发展</strong>。表征明显得有时甚至略显夸张，这一方面也是种“炫耀”，炫耀自己拥有一些<strong>累赘</strong>也依然能活的很好。</p>\n<p>雌性因为卵子的自愿地位，不必像雄性个体那样，仅仅具有性吸引力就能保证自己的卵子有受精机会，所以在交配问题上更加挑剔（比如雌驴会避免和雄马交配，生育出没有生育能力的骡子），雄性则相反，需要具有更加吸引人（尤其是雌性）的种种性状。同时，凡是存在乱伦禁忌的地方，可以认为雌性会比雄性更严守此这种禁忌。</p>\n<h2 id=\"共生和合作\"><a href=\"#共生和合作\" class=\"headerlink\" title=\"共生和合作\"></a>共生和合作</h2><p>生存机器间除了搏斗、亲代、有性参与的相互作用，还有共生和合作的存在。比如鸟群和鱼群的存在。有些群体个体会警告其余个体危险的存在等等。这些看似利他性行为实际都可以从有利自己生存的角度考虑。</p>\n<p>蚂蚁、蜜蜂、裸鼹鼠等物种的<strong>职虫不育性</strong>是个很有趣的现象。它们的个体间营社会性生活。这其实是把生育和抚育策略结合在一起进化的结果。这个现象和雌虫的生殖特性密切相关。雌虫生育的个体都是<strong>单倍体</strong>，兄弟姐妹间基因的相似度甚至高于自己生育的后代的相似度。相比自己繁殖养育，不如“耕耘”有生殖力的母体，趋势母体提高繁殖力，复制自己的基因。同时，往往这种生物生存的环境资源有限，外出繁育ROI较低。</p>\n<p>在共生现象中，双方都有骗子和傻瓜两种策略，但在斤斤计较策略存在的情况下，骗子策略会被渐渐战胜。有观点认为，人类细胞不过是共生微生物的结果，而我们本身也是不同基因共生的群体结果。</p>\n<h2 id=\"推广到文化\"><a href=\"#推广到文化\" class=\"headerlink\" title=\"推广到文化\"></a>推广到文化</h2><p>正如《人类简史》里面所说，涉及到道德、规范、法律、文化的领域，就进入了人类的想象空间。复制因子的规律能否推广到“文化因子”（meme）中是个不错的尝试。不过meme本身是可以人为操纵，而不是“盲目的”。和基因不同，数学模型和概念在此很难有用武之地，试图对人类意识的探讨更易让类比有刻意引申之嫌。</p>\n<h2 id=\"好人好报\"><a href=\"#好人好报\" class=\"headerlink\" title=\"好人好报\"></a>好人好报</h2><p>在个体合作时，基于合作和背叛两种基本元素，可以产生很多合作策略。当合作明确只能做一次时，双方会面临<strong>“囚徒困境”</strong>，即个体的最优解不是整体的最优解。但是，<strong>合作明确会持续进行，且看不到终点时</strong>（看不到终点很重要，因为有终点存在，整个信任就会从最后一次合作的倒推开始崩塌），这个“零和问题”变成了“<strong>非零和问题</strong>”。这种情况下，拥有<strong>宽容</strong>，<strong>善良</strong>，<strong>不嫉妒</strong>特质的合作策略会在各种策略中获胜，并最终达到稳态。</p>\n<p><em>描述过程见书第十二章，写的很有意思</em></p>\n<p>总结来说，<strong>未知的</strong>，<strong>长期的</strong>，<strong>非零和</strong>进化博弈下，好人会取得最终的胜利，并占据大多数。</p>\n<h2 id=\"生命的必然和偶然\"><a href=\"#生命的必然和偶然\" class=\"headerlink\" title=\"生命的必然和偶然\"></a>生命的必然和偶然</h2><p>最后一章里，我们总结一下前面所有的结论，并试图给出更透彻、更明白的一些结论。首先，个体生物即载体以努力传播自己基因为任务，同时对基因有利对整个生命体也有利。基因所能影响的只有蛋白质合成，再操纵细胞乃至整个生存机器，并最终“从自身身体中逃逸出”，操作整个外部世界，如海狸的河坝。这里我们考虑一下“寄生”和“共生”的区别。通过一些例子来看，最终的区别是<strong>寄生个体将基因传递给后代的方式是否和宿主基因一样</strong>。享有共同命运的寄生生物基因，最终会享有共同利益，停止寄生行为。比如绿色水螅和水藻的基因，以及甲虫和细菌的基因，寄生基因只能通过宿主的生殖细胞拥有未来。</p>\n<p>推广一下，<strong>我们自己的基因通力合作，不是因为它们共享同一个身体，而是它们共享同一条出路——精子和卵子</strong>。如果能找到一条另外的出路，一些基因自然就会表现得不再合作。比如，人体内流感病毒的基因通过飞沫传递，狂犬病病毒之于狗也是这样。基因对于个体的控制比你想象得要厉害，给一个男人看女人身体的图片，便可以唤起其性冲动，甚至勃起，而这个过程中，他并没有被欺骗，认为图片是个真实的女人。虽然他知道是打印机打出的图片，他的神经系统依然有和面对真实女性一样的反应。我们的身体不过是“寄生”基因的集合体。自然选择偏向控制他人的基因，动物行为倾向于最大化此基因的生存。</p>\n<p>总结下，<strong>共生的基因共享离开当前基因载体的共同渠道</strong>，个体如果想成为有效的基因载体，必须保证<strong>对所有其中的基因提供等概率的、通往未来的共同通道</strong>。最后回答三个问题。</p>\n<p><strong>为什么基因汇聚在一起，形成细胞？</strong>，单个基因操纵的化学反应通常不足以合成所需的最终产物，一种蛋白酶需要在其他基因存在的情况下才能生长繁荣。</p>\n<p><strong>为什么细胞会汇聚在一起，形成多细胞？</strong>，一方面是体型的优势，另一方面是便于分工，让每一个部件处理特定任务时更有效率。</p>\n<p>最后一个，也是最有意思的问题。<strong>为什么生命体循环总有瓶颈般的受精卵阶段？</strong>，不论大象、蚂蚁都是这样。原因是，从部分个体开始的繁殖只能获得很少一部分改变，彻底的改变，只能从“设计图纸”开始，<strong>保证每一个个体都拥有干净的起点</strong>。瓶颈保证了生命循环继承的是图纸而不是成品。另外，这种瓶颈的存在，<strong>让生命循环定型，更有规律的重复</strong>。<strong>基因这种精确的行为规划是胚胎得意进化形成复杂组织和器官的先决条件</strong>，鹰的眼睛，燕子的翅膀，这些精确和复杂的器官不可能在没有时间规划下出现。最后，也是最关键一点，<strong>瓶颈的存在自然地带来的基因间的共同利益</strong>，因为所有的基因都需要通过瓶颈传给下一代，别无选择。</p>\n<p>总结一下，生命循环成为“瓶颈状”，有生命的材料会渐渐聚在一起，形成独立而统一的生命体。生命材料越多，就有更多的载体细胞凝结努力，作用于特殊种类的细胞，使他们可以承载其共同的基因，通过瓶颈走向下一代。所有生命的基本单位和最初动力都是复制因子，没有任何复制过程是完美的，一些编译失去复制能力而灰飞烟灭。互惠的复制因子间可以帮助对方更好的生存，这些复制因子聚合一处形成了细胞，与而后形成的多细胞生命，由“瓶颈”生命循环进化而成的载体繁荣发展，逐渐变成愈加独立的载体。</p>\n",
            "tags": [
                "读书笔记",
                "人类",
                "生存",
                "基因"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/12/15/you-dont-know-js-part2/",
            "url": "http://shenlvmeng.github.com/blog/2017/12/15/you-dont-know-js-part2/",
            "title": "《You don't know JS》 下（类型文法&异步&ES6与未来）",
            "date_published": "2017-12-15T12:59:38.000Z",
            "content_html": "<blockquote>\n<p>原作：<a href=\"https://github.com/getify/You-Dont-Know-JS\">You-Dont-Know-JS</a><br>本文的99.9%的内容都来自《You dont know JS》的<a href=\"https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN\">电子中文版</a></p>\n<p>传送门：<a href=\"https://shenlvmeng.github.io/blog/2017/12/13/you-dont-know-js-part1/\">《You don’t know JS》 上（入门&amp;作用域&amp;对象）</a></p>\n</blockquote>\n<h2 id=\"类型和文法\"><a href=\"#类型和文法\" class=\"headerlink\" title=\"类型和文法\"></a>类型和文法</h2><h3 id=\"内建类型\"><a href=\"#内建类型\" class=\"headerlink\" title=\"内建类型\"></a>内建类型</h3><ul>\n<li>7种类型</li>\n<li>值才有类型，变量没有</li>\n<li><code>undefined</code> ≠ is not defined（undeclared）。<code>undefined</code>表示定义却没有赋值的变量类型。然而<code>typeof</code>一个未声明的变量也会返回<code>undefined</code>，这是<code>typeof</code>的安全机制，它给了我们更多空间检查变量是否可用。</li>\n</ul>\n<h3 id=\"值\"><a href=\"#值\" class=\"headerlink\" title=\"值\"></a>值</h3><p>由于JS里String的只读性，所有String的相关方法都是返回一个新字符串。</p>\n<p>使用二进制浮点数的最出名（臭名昭著）的副作用是（记住，这是对 所有 使用 IEEE 754 的语言都成立的 —— 不是许多人认为&#x2F;假装 仅 在 JavaScript 中存在的问题）：<code>0.1 + 0.2 === 0.3 // false</code>。不过可以用<code>Number.EPSILON</code>做最小误差得到足够精确的近似结果。ES6下已经可以用<code>Number.isInteger()</code>和<code>Number.isSafeInteger()</code>检查数字是不是整数&#x2F;安全整数。</p>\n<h4 id=\"特殊值\"><a href=\"#特殊值\" class=\"headerlink\" title=\"特殊值\"></a>特殊值</h4><p><code>undefined</code>和<code>null</code>是JS里比较特殊的两类值，它们既是类型又是唯一的值。更加不幸的是，在非strict模式下，<code>undefined</code>还可以作为标识符，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>另外，在特别需要<code>undefined</code>时，<code>void</code>操作符会变得很有用。</p>\n<p>Infinity &#x2F; Infinity &#x3D;&#x3D; undefined。</p>\n<p>针对一些特殊的等价情况（NaN和-0），ES6使用<code>Object.is()</code>判断其相等性。</p>\n<h4 id=\"值与引用\"><a href=\"#值与引用\" class=\"headerlink\" title=\"值与引用\"></a>值与引用</h4><p>在JS中没有指针，只有引用，同时页没有语法上的提示可以控制值和引用的赋值&#x2F;传递。取而代之的是，值的类型用来唯一控制值是通过值拷贝，还是引用拷贝来赋予（复合值）。引用指向的是值本身而不是变量，不能使用一个引用来改变另一个引用所指向的值。</p>\n<p>底层的基本标量值是不可变的（String和Boolean也一样）。比如一个Number对象持有一个基本标量值2，那么这个Number对象就永远不能再持有另一个值；你只能用一个不同的值创建一个全新的Number对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">    x = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">    x; <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>( a ); <span class=\"comment\">// 或等价的 `Object(a)`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>( b );</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( b ); <span class=\"comment\">// 2, 不是 3</span></span><br></pre></td></tr></table></figure>\n\n<p>在其中<code>x = x + 1</code>这一步，包装值内的x被取出+1后，赋值给x，将其从一个引用变成一个基本标量值3。</p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>对于最简单的值，JSON字符串化行为基本上和<code>toString()</code>转换是相同的，在对String字符串化时，结果也会包含<code>&quot;&quot;</code>，如<code>JSON.stringify(&quot;11&quot;) // &quot;&quot;11&quot;&quot;</code>。另外，对于JSON不安全值（即不能移植到消费JSON的语言中），有下面的处理：</p>\n<ul>\n<li>忽略<code>undefined</code>，<code>function</code>，<code>symbol</code></li>\n<li>在<code>Array</code>中遇到这种类型的值，会被替换为null（避免修改位置信息）</li>\n<li>在<code>Object</code>的属性中遇到时，属性会被简单的忽略掉</li>\n<li>带有循环引用时，<code>JSON.stringify()</code>会报错</li>\n</ul>\n<p>另外，对于有<code>toJSON()</code>方法的对象，JSON字符串化会优先使用该方法。<code>JSON.stringify()</code>的第二个参数可以指定Array或Function说明可以编辑的对象属性。第三个参数是填充符，填充在各级开头，用来友好展示结果，最多取入参的前10个字符。</p>\n<p>在对象上使用<code>toNumber</code>和<code>toString</code>方法，首先会找到其原始类型（<code>toPrimitives()</code>），即使用其<code>valueOf()</code>或<code>toString()</code>方法（也会在<code>[[prototype]]</code>上寻找）。</p>\n<h4 id=\"gt-Number\"><a href=\"#gt-Number\" class=\"headerlink\" title=\"-&gt; Number\"></a>-&gt; Number</h4><p>可以用<code>Date.now()</code>代替<code>+new Date()</code>获取更好的语义。</p>\n<p><code>~</code>除了可以用来检查<code>-1</code>这个特殊的值，还可以通过<code>~~</code>对小数取整，因为执行位操作时会先将数字转为Int32类型。</p>\n<p><strong><code>parseInt</code>以及<code>parseFloat</code>和<code>+</code>或<code>Number()</code>强制类型转换存在区别。</strong>它们的作用是，从字符串中解析出一个<code>number</code>出来。两者是不能相互替换的。后者是不能<em>容忍</em>非数字字符的。另外，**请在字符串上使用<code>parseInt</code>和<code>parseFloat</code>**，这也是它们的设计目的。对非字符串类型使用它们可能得到意外的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">1</span>/<span class=\"number\">0</span>, <span class=\"number\">19</span> ); <span class=\"comment\">// 18，惊不惊喜，意不意外</span></span><br></pre></td></tr></table></figure>\n\n<p>原因是，parseInt会把第一个参数<code>toString</code>（这不能责怪它，因为它本来就是设计对String使用的）。类似的例子还能举出很多：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.000008</span> );       <span class=\"comment\">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.0000008</span> );      <span class=\"comment\">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"literal\">false</span>, <span class=\"number\">16</span> );      <span class=\"comment\">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"built_in\">parseInt</span>, <span class=\"number\">16</span> );   <span class=\"comment\">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;0x10&quot;</span> );         <span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;103&quot;</span>, <span class=\"number\">2</span> );       <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>parseInt</code>会通过前缀试图猜测数字进制，默认是10进制。以<code>0x</code>开头表示16进制，以<code>0b</code>开头表示2进制，以<code>0o</code>开头表示8进制。</p>\n<h4 id=\"gt-Boolean\"><a href=\"#gt-Boolean\" class=\"headerlink\" title=\"-&gt; Boolean\"></a>-&gt; Boolean</h4><p>使用<code>!!</code>强制转换类型。</p>\n<p><code>&amp;&amp;</code>与<code>||</code>在JS中的逻辑和C++以及Java中的不大一样，它并不一定返回boolean类型的值，而是根据比较的两个数判断返回哪一个。其中<code>&amp;&amp;</code>可以用来进行短路操作。</p>\n<p>另外，对于Symbol来说，只能通过<code>String()</code>的形式转为String类型，却不能转为Boolean类型。</p>\n<h4 id=\"等价\"><a href=\"#等价\" class=\"headerlink\" title=\"等价\"></a>等价</h4><p>等价分为<code>==</code>和<code>===</code>。</p>\n<p>在<code>String</code>和<code>Number</code>进行比较时，会对<code>String</code>使用强制类型转换（类似<code>+</code>和<code>Number()</code>）；</p>\n<p>在和<code>Boolean</code>比较时，<strong>会首先把Boolean类型转为Number类型，再进行比较</strong>。这会产生下面这样比较迷惑的情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;42&quot;</span> == <span class=\"literal\">true</span>  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"string\">&quot;42&quot;</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>Object</code>和非<code>Object</code>比较时，会先对<code>Object</code>进行<code>toPrimtives</code>，即先使用<code>valueOf()</code>看能否转成基本类型，再使用<code>toString()</code>。</p>\n<p>下面有一些疯狂的例子，但却可以由上面的规则解释：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;0&quot;</span> == <span class=\"literal\">false</span>    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == []     <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == []         <span class=\"comment\">// true</span></span><br><span class=\"line\">[] == ![];      <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">2</span> == [<span class=\"number\">2</span>];       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == []        <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [<span class=\"literal\">null</span>];   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">&quot;\\n&quot;</span>       <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的坑可以看到，等号的两边总有<code>[]</code>或<code>&quot;&quot;</code>或<code>false</code>或<code>0</code>。建议在这些情况使用<code>===</code>。</p>\n<p>下面是由Alex Dorey(@dorey on GitHub)制作的一个方便的表格，将各种比较进行了可视化：</p>\n<p><img src=\"https://github.com/getify/You-Dont-Know-JS/raw/1ed-zh-CN/types%20%26%20grammar/fig1.png\"></p>\n<h4 id=\"大小关系比较\"><a href=\"#大小关系比较\" class=\"headerlink\" title=\"大小关系比较\"></a>大小关系比较</h4><p>首先对值进行<code>toPrimitives</code>转换，如果有一个不是String，则使用<code>Number</code>类型比较。见下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// toNumber</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [ <span class=\"number\">42</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [ <span class=\"string\">&quot;43&quot;</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">a &lt; b;  <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// toString</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">b</span>: <span class=\"number\">42</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123; <span class=\"attr\">b</span>: <span class=\"number\">43</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a &lt; b;  <span class=\"comment\">// false</span></span><br><span class=\"line\">a == b; <span class=\"comment\">// false</span></span><br><span class=\"line\">a &gt; b;  <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">a &lt;= b; <span class=\"comment\">// true</span></span><br><span class=\"line\">a &gt;= b; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的例子里，a和b在比较时，都会转成”[object Object]”。而等价比较上会比较引用是否相同。因此都返回false，而JS中的<code>&lt;=</code>和<code>&gt;=</code>操作会去对应计算<code>&gt;</code>和<code>&lt;</code>的结果再取反，从而会得到两个<code>true</code>。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><h4 id=\"语句和表达式\"><a href=\"#语句和表达式\" class=\"headerlink\" title=\"语句和表达式\"></a>语句和表达式</h4><p>JS中的表达式都有一个隐式的返回值，但是它只会打印在控制台中，并不会真实返回。块语句的返回值是块中最后一个语句的返回值。ES7中可能会引入do语句显式地使用这个返回值。</p>\n<p>JS中的<code>++</code>和C风格类似，表示自增，有前后之分。但是<code>++a++</code>这种用法是不合法的。</p>\n<p>赋值表达式的返回是赋予的值，这在链式赋值时很好用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b, c;</span><br><span class=\"line\">a = b = c = <span class=\"number\">42</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里，<code>c = 42</code>被求值得出42（带有将42赋值给c的副作用），然后<code>b = 42</code>被求值得出42（带有将42赋值给b的副作用），而最后<code>a = 42</code>被求值（带有将42赋值给a的副作用）。</p>\n<p>另一种用法是直接将之放在<code>&amp;&amp;</code>和<code>||</code>的前后，检查赋值语句的真值。</p>\n<h4 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h4><p><code>&#123;&#125;</code>包裹的内容作为表达式结果可以直接赋值给变量，但是直接声明时会被当做代码块，但是可能仍然是合法的，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"title function_\">bar</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为，JS中允许使用语句标签，便于<code>break</code>和<code>continue</code>跳转（JS中没有<code>goto</code>）。而JSON中带有<code>&quot;&quot;</code>的键则不会被这么解释，因为语句标签不允许出现引号。</p>\n<p>我们现在来解决下面的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\">&#123;&#125; + []; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么交换顺序会对<code>+</code>的规则有影响？在第一个式子里一切都是正常的，<code>[]</code>转换成<code>&quot;&quot;</code>，<code>&#123;&#125;</code>转换成<code>[object Object]</code>；在第二个式子里，<code>&#123;&#125;</code>被理解成一个空代码块儿，<code>[]</code>被强制转换为0。</p>\n<h4 id=\"操作符优先级\"><a href=\"#操作符优先级\" class=\"headerlink\" title=\"操作符优先级\"></a>操作符优先级</h4><ul>\n<li><code>&amp;&amp;</code>优先于<code>||</code>。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">这里</a>有完整的表格。</li>\n<li><code>&amp;&amp;</code>和<code>||</code>有短接的特点，即当第一个表达式为true或false时直接返回结果。</li>\n<li>赋值表达式和三元表达式<code>? : </code>一样是从右向左结合的</li>\n</ul>\n<h4 id=\"ASI（自动分号）\"><a href=\"#ASI（自动分号）\" class=\"headerlink\" title=\"ASI（自动分号）\"></a>ASI（自动分号）</h4><p>尽量避免ASI，只在确认没有歧义的地方依赖ASI。</p>\n<h4 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h4><ul>\n<li>JS有早期错误一说，即运行前编译期间的错误</li>\n<li><code>let</code>会造成块域内的TDZ（Temporal Dead Zone，时间死区），<code>typeof</code>在此时会报错，而不会返回<code>undefined</code>。TDZ是指变量还没到能使用它的时候，还需要初始化。下面还有一个例子：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"> a = <span class=\"number\">42</span>, b = a + b + <span class=\"number\">5</span> </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>ES6提供了剩余参数来代替原有的<code>arguments</code>对象，这更加安全。</li>\n</ul>\n<p><strong><code>finally</code>子句</strong></p>\n<p><code>try catch</code>在和<code>finally</code>一起使用时，<code>finally</code>的语句一定会被执行，而且一定会在<code>try</code>语句执行完后立即执行，即使<code>try</code>中有<code>return</code>或者<code>throw</code>、<code>continue</code>等控制语句。可以在<code>finally</code>中修改<code>try</code>中的结果，但是最后不要这么做，因为会影响程序可读性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&quot;Hello&quot;</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&quot;never runs&quot;</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"title function_\">foo</span>() );</span><br><span class=\"line\"><span class=\"comment\">// Hello</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught Exception: 42</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"宿主环境\"><a href=\"#宿主环境\" class=\"headerlink\" title=\"宿主环境\"></a>宿主环境</h4><p>由于浏览器的遗留行为，使用id属性创建DOM元素会创建同名的全局变量。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> foo == <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">    foo = <span class=\"number\">42</span>;       <span class=\"comment\">// 永远不会运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( foo ); <span class=\"comment\">// HTML元素</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>永远不要修改内建类型。</li>\n<li>JS的函数和变量声明提升只在同一<code>&lt;script&gt;</code>标签内</li>\n</ul>\n<h4 id=\"保留字\"><a href=\"#保留字\" class=\"headerlink\" title=\"保留字\"></a>保留字</h4><blockquote>\n<p>Let this long package float, Goto private class if short. While protected with debugger case, Continue volatile interface. Instanceof super synchronized throw, Extends final export throws.</p>\n<p>Try import double enum?</p>\n<p>False, boolean, abstract function, Implements typeof transient break! Void static, default do, Switch int native new. Else, delete null public var In return for const, true, char …Finally catch byte.</p>\n</blockquote>\n<p>来自StackOverflow用户“art4theSould”创造性的一首<a href=\"http://stackoverflow.com/questions/26255/reserved-keywords-in-javascript/12114140#12114140\">小诗</a>。</p>\n<p>另外，在ES6+中，可以使用保留字作为对象字面量中的属性名或键。</p>\n<h2 id=\"异步与性能\"><a href=\"#异步与性能\" class=\"headerlink\" title=\"异步与性能\"></a>异步与性能</h2><p>JS引擎对时间没有天生的感觉，只是一个任意JS代码段的按需执行环境。是周围的宿主环境在不停地安排“事件”（JS代码的执行）。举例来说，当你的JS程序发起一个从服务器取得数据的Ajax请求时，你在一个函数（通常称为回调）中建立好“应答”代码，然后JS引擎就会告诉宿主环境，“嘿，我就要暂时停止执行了，但不管你什么时候完成了这个网络请求，而且你还得到一些数据的话，请<em>回来调</em>这个函数。”</p>\n<p>然后浏览器就会为网络的应答设置一个监听器，当它有东西要交给你的时候，它会通过将回调函数插入<strong>事件轮询</strong>来安排它的执行。</p>\n<p>关于事件轮询队列，<a href=\"https://shenlvmeng.github.io/blog/2017/02/27/event-loop/\">之前</a>也有过一些介绍。</p>\n<h3 id=\"异步概览\"><a href=\"#异步概览\" class=\"headerlink\" title=\"异步概览\"></a>异步概览</h3><p>异步≠并行。异步本质上还是串行的。工作依然有先后之分，没有线程、线程池的概念。从而，在JS中的函数都是原子的，即不会与别的函数的代码<strong>相互穿插</strong>（除非使用<code>Generator</code>）。</p>\n<h4 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h4><p>并发是当两个或多个“进程”（或任务）在同一时间段内同时执行，而不管构成它们的每个操作是不是同时进行的。在JS中，单线程事件轮询是并发的一种表达。</p>\n<p><strong>不互动</strong></p>\n<p>当程序中运行多个“进程”（或任务），如果它们之间没有逻辑联系，那么不互动是完全可以接受的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">results</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"property\">foo</span> = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\">results</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"property\">bar</span> = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\"><span class=\"title function_\">ajax</span>( <span class=\"string\">&quot;http://some.url.1&quot;</span>, foo );</span><br><span class=\"line\"><span class=\"title function_\">ajax</span>( <span class=\"string\">&quot;http://some.url.2&quot;</span>, bar );</span><br></pre></td></tr></table></figure>\n\n<p><strong>互动</strong></p>\n<p>相反，如果它们之间有依赖关系，或者前后次序而产生互动时，<code>let it alone</code>就会出事。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">response</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>( data );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\"><span class=\"title function_\">ajax</span>( <span class=\"string\">&quot;http://some.url.1&quot;</span>, response );</span><br><span class=\"line\"><span class=\"title function_\">ajax</span>( <span class=\"string\">&quot;http://some.url.2&quot;</span>, response );</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"协调\"><a href=\"#协调\" class=\"headerlink\" title=\"协调\"></a>协调</h4><p>跳过使用全局变量等丑陋的协作手段，有一种方法，将长时间处理的任务打断成多个小段的请求外加setTimeout，以便将任务穿插完成。</p>\n<h4 id=\"Jobs\"><a href=\"#Jobs\" class=\"headerlink\" title=\"Jobs\"></a>Jobs</h4><p>ES6在事件轮询队列之上引入了一层新概念，称为“工作队列（Job queue）”。它和轮询队列的关系类似于Macrotask和Microtask。</p>\n<h3 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h3><h4 id=\"顺序的大脑\"><a href=\"#顺序的大脑\" class=\"headerlink\" title=\"顺序的大脑\"></a>顺序的大脑</h4><p>回调不符合正常思维逻辑顺序 &amp; 回调地狱。</p>\n<h4 id=\"信任问题\"><a href=\"#信任问题\" class=\"headerlink\" title=\"信任问题\"></a>信任问题</h4><p><em>（本人并不完全赞同）</em>回调遭受着<em>控制反转</em>的蹂躏，它们隐含地将控制权交给第三方（通常第三方工具不受你控制！）来调用你程序的延续。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise的<code>then</code>和<code>catch</code>。</p>\n<h4 id=\"可靠的Promise\"><a href=\"#可靠的Promise\" class=\"headerlink\" title=\"可靠的Promise\"></a>可靠的Promise</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>( <span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>( <span class=\"string\">&quot;B&quot;</span> );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>( <span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>( p3 );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>( <span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>( <span class=\"string\">&quot;A&quot;</span> );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>( <span class=\"keyword\">function</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( v );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">p2.<span class=\"title function_\">then</span>( <span class=\"keyword\">function</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( v );</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A B  &lt;-- 不是你可能期望的 B A</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为p1由p3解析的结果所解析，这个过程是异步地。</p>\n<p>作者认为Promise在很大程度上，解决了下面的问题：</p>\n<ul>\n<li>调的太早&#x2F;太晚（本人并不赞同）</li>\n<li>根本不调回调（勉强成立），Promise通知状态改变是由编程者自己代码控制的，用<code>resolve</code>或<code>reject</code>（用户只能借助外部环境API发起异步操作，resolve一样要么放在传统的回调，要么转交给第三方完成）。</li>\n<li>调太少或太多次（成立），一个Promise一旦resolve或者reject，状态就不再发生变化</li>\n<li>没能传入任何参数&#x2F;环境（勉强成立），原因与第二条相同</li>\n<li>吞掉所有错误和异常（勉强成立），Promise中在catch字句里捕获异常。</li>\n</ul>\n<p><code>Promise.resolve(p)</code>会把thenable的入参<code>p</code>转换为合法的Promise。这里猜测下这个<code>resolve(p)</code>的实现（个人猜想）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"property\">resolve</span> = <span class=\"function\"><span class=\"params\">thenable</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// if `thenable` is a promise, just return it</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// if `thenable` is plain, just resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> thenable.<span class=\"property\">then</span> != <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">resolve</span>(thenable);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        thenable.<span class=\"title function_\">then</span>(resolve, reject);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个thenable的例子</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">then</span>(<span class=\"params\">cb, err</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Math</span>.<span class=\"property\">random</span> &lt; <span class=\"number\">0.5</span> ? <span class=\"title function_\">cb</span>(<span class=\"number\">42</span>) : <span class=\"title function_\">err</span>(<span class=\"string\">&quot;oops! Something bad happens.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h4><p>看看RxJS的<a href=\"http://reactivex.io/rxjs/manual/overview.html\">Introduction</a>。就可以很轻松地理解Promise的流程和链式过程了。</p>\n<h4 id=\"Promise模式\"><a href=\"#Promise模式\" class=\"headerlink\" title=\"Promise模式\"></a>Promise模式</h4><p><code>Promise.all()</code>和<code>Promise.race()</code>。除了这两个官方钦定的方法外，其他的Promise库还实现了像是<code>any()</code>，<code>none()</code>，<code>first()</code>，<code>last()</code>这样的方法，看看RxJS的<a href=\"http://reactivex.io/rxjs/manual/overview.html#categories-of-operators\">operators</a>会有更多选择。</p>\n<h4 id=\"Promise的限制\"><a href=\"#Promise的限制\" class=\"headerlink\" title=\"Promise的限制\"></a>Promise的限制</h4><ul>\n<li>顺序的错误处理</li>\n<li>只能传单一的值（其实就是状态改变不可逆）</li>\n<li>单次解析（同上），文章也在<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch3.md#%E6%83%B0%E6%80%A7\">惰性</a>的上方提到了观察者模式的RxJS，的确在设计时间概念的领域，RxJS要厉害多了</li>\n<li>惰性（生产生产Promise函数的工厂函数）</li>\n<li>不可反悔（即不能中途撤销）</li>\n<li>性能</li>\n</ul>\n<h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>使用同步风格书写异步代码的基础在Generator。关于这部分的更详细介绍见本人之前参考阮一峰大神写的<a href=\"https://shenlvmeng.github.io/blog/2017/03/29/javascript-async-programming-2/\">博文</a></p>\n<h4 id=\"打破运行至完成\"><a href=\"#打破运行至完成\" class=\"headerlink\" title=\"打破运行至完成\"></a>打破运行至完成</h4><p>generator（生成器）是一个可以和别的代码穿插执行的非原子的特殊函数。使用<code>new</code>构造generator得到的只是一个迭代器，迭代器在执行到<code>yield</code>时会让出执行权。真正执行这个迭代器需要用调用或者执行器的方式。</p>\n<p>yield和next是generator可以和外部甚至是其他generator双向通信。但是generator只是声明了自己将要以什么样的形式去执行。还需要一个下面这样的帮助函数去推动它执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step</span>(<span class=\"params\">gen</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> it = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不论`yield`出什么，只管在下一次时直接把它塞回去！</span></span><br><span class=\"line\">        last = it.<span class=\"title function_\">next</span>( last ).<span class=\"property\">value</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><ul>\n<li>可以把generator像状态机一样使用。</li>\n<li><code>for of</code>需要迭代器的实现</li>\n<li>可以在generator上使用<code>for of</code></li>\n<li>使用<code>return</code>而非<code>next</code>可以终止生成器执行</li>\n</ul>\n<h4 id=\"在异步流程中使用generator\"><a href=\"#在异步流程中使用generator\" class=\"headerlink\" title=\"在异步流程中使用generator\"></a>在异步流程中使用generator</h4><p>generator的yield暂停特性不仅意味着我们可以从异步的函数调用那里得到<em>看起来</em>同步的return值。</p>\n<h4 id=\"带有promise的generator\"><a href=\"#带有promise的generator\" class=\"headerlink\" title=\"带有promise的generator\"></a>带有promise的generator</h4><p>在ES6的世界中最棒的就是将generator（看似同步的异步代码）与Promise（可靠性和可组合性）组合起来。</p>\n<p>co与koa。</p>\n<p><strong>ES7中的await和async</strong></p>\n<p>像下面这样，没有<code>run</code>函数，没有生成器函数的<code>*</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">request</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;http://some.url.1/?x=&quot;</span> + x + <span class=\"string\">&quot;&amp;y=&quot;</span> + y</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> text = <span class=\"keyword\">await</span> <span class=\"title function_\">foo</span>( <span class=\"number\">11</span>, <span class=\"number\">31</span> );</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( text );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>( err );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"yield委托\"><a href=\"#yield委托\" class=\"headerlink\" title=\"yield委托\"></a>yield委托</h4><p>使用<code>yield * foo</code>可以把其他的生成器函数整合进当前生成器中。除了生成器外，还可以委托一个非generator的iterator。错误可以委托，promise可以委托，委托还可以递归。</p>\n<p>结合yield可以很方便地协调多个generator</p>\n<h4 id=\"thunk\"><a href=\"#thunk\" class=\"headerlink\" title=\"thunk\"></a>thunk</h4><p>同步的thunk即包装了所有预设形参的函数执行的函数。异步thunk指需要指定callback的包装所有其他预设形参异步函数的函数。像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同步thunk</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fooThunk</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">foo</span>( <span class=\"number\">3</span>, <span class=\"number\">4</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步thunk</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,cb</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"title function_\">cb</span>( x + y );</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fooThunk</span>(<span class=\"params\">cb</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">foo</span>( <span class=\"number\">3</span>, <span class=\"number\">4</span>, cb );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦来说会有一个工具thunkify帮你完成制造函数thunk的工作（放心，总会有人这么做的）。它的用法是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fooThunkory = <span class=\"title function_\">thunkify</span>( foo );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fooThunk1 = <span class=\"title function_\">fooThunkory</span>( <span class=\"number\">3</span>, <span class=\"number\">4</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> fooThunk2 = <span class=\"title function_\">fooThunkory</span>( <span class=\"number\">5</span>, <span class=\"number\">6</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">fooThunk1</span>( <span class=\"keyword\">function</span>(<span class=\"params\">sum</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( sum );     <span class=\"comment\">// 7</span></span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">fooThunk2</span>( <span class=\"keyword\">function</span>(<span class=\"params\">sum</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( sum );     <span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure>\n\n<p>包装函数生产一个thunkory，之后指定除cb以外的其他参数得到thunk函数。</p>\n<p>thunk和Promise本质上其实是等价的。只不过是回调所在的为之不一样罢了。所以使用Promise.wrap包装得到的promise还是thunkify包装得到的thunk函数其实都可以yield出来。因为，它们都能通过指定回调来让generator进一步推动下去。</p>\n<p>当然了无论是在可组合性还是错误处理上，Promise都有更胜一筹。所以，thunk通常作为替代性的前ES6方案。</p>\n<h4 id=\"前ES6的Generator\"><a href=\"#前ES6的Generator\" class=\"headerlink\" title=\"前ES6的Generator\"></a>前ES6的Generator</h4><p>当然了Generator也是可以通过其他方式<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch4.md#%E5%89%8Des6%E6%97%B6%E4%BB%A3%E7%9A%84generator\">实现</a>的。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><h4 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h4><p>近HTML5时代被加入web平台的特性，称为“Web Worker”。这是一个浏览器（也就是宿主环境）特性，而且几乎和JS语言本身没有任何关系。<a href=\"https://shenlvmeng.github.io/blog/2017/09/04/pwa-and-hybrid-brief/\">这里</a>简单说了下它和Service Worker的区别。</p>\n<h4 id=\"asm-js\"><a href=\"#asm-js\" class=\"headerlink\" title=\"asm.js\"></a>asm.js</h4><p>“<a href=\"http://asmjs.org/\">asm.js</a>”是可以被高度优化的JavaScript语言子集的标志。通过小心地回避那些特定的很难优化的（垃圾回收，强制转换，等等）机制和模式，asm.js风格的代码可以被JS引擎识别，而且用主动地底层优化进行特殊的处理。</p>\n<h3 id=\"基准分析（BenchMark）和调优\"><a href=\"#基准分析（BenchMark）和调优\" class=\"headerlink\" title=\"基准分析（BenchMark）和调优\"></a>基准分析（BenchMark）和调优</h3><ul>\n<li><a href=\"http://benchmarkjs.com/\">Benchmark.js</a>用统计学的方式避免时间戳测量语句性能时的不准确</li>\n<li><a href=\"http://jsperf.com/\">jsPerf.com</a>基于Benchmark.js的代码性能测试平台</li>\n</ul>\n<h4 id=\"编写好的测试\"><a href=\"#编写好的测试\" class=\"headerlink\" title=\"编写好的测试\"></a>编写好的测试</h4><ul>\n<li>注意上下文的影响</li>\n<li>“过早的优化是万恶之源”</li>\n<li>尾部调用优化</li>\n</ul>\n<h2 id=\"ES6与未来\"><a href=\"#ES6与未来\" class=\"headerlink\" title=\"ES6与未来\"></a>ES6与未来</h2><h3 id=\"ES？现在与未来\"><a href=\"#ES？现在与未来\" class=\"headerlink\" title=\"ES？现在与未来\"></a>ES？现在与未来</h3><ul>\n<li>polyfill与转译</li>\n</ul>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>尽管ES6算是JS最新的官方特性，下面说的大部分特性已经被很经常地使用了。</p>\n<ul>\n<li>块作用域（之前的部分已经提到过了）</li>\n<li>扩散、剩余，<code>...</code>操作符，用在函数入参，数组和对象中</li>\n<li>函数默认参数值（是不是很神奇），默认参数值可以是合理的表达式甚至是函数调用</li>\n<li>解构赋值，也可以有默认参数值</li>\n<li>对象字面量拓展，简约声明&#x2F;简约方法&#x2F;getter，setter&#x2F;计算型属性名&#x2F;<code>__proto__</code>&#x2F;<code>super</code></li>\n<li><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/es6%20%26%20beyond/ch2.md#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F\">模板字面量</a></li>\n<li>箭头函数，词法<code>this</code></li>\n<li><code>for of</code>和iterator</li>\n<li>正则表达式拓展<ul>\n<li>Unicode标识</li>\n<li>粘性标志</li>\n</ul>\n</li>\n<li>数字，八进制</li>\n<li>Unicode<ul>\n<li>合理的string长度，<code>String.prototype.normalize()</code></li>\n<li><code>charCodeAt</code> &#x3D;&gt; <code>codePointAt</code></li>\n<li><code>fromCharCode</code> &#x3D;&gt; <code>fromCodePoint</code></li>\n<li>Unicode标识符名称</li>\n</ul>\n</li>\n<li>Symbol，新的基本类型，它是一个新的包装器对象，可以认为每个<code>EVT_LOGIN</code>持有一个不能被其他任何值所（有意或无意地）重复的值。<ul>\n<li><code>Symbol.for()</code>先查询是否有一个同名的Symbol，如果有就返回，没有就创建一个</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"组织\"><a href=\"#组织\" class=\"headerlink\" title=\"组织\"></a>组织</h3><h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p>迭代器<code>Iterator</code>接口有一个必选接口<code>next()</code>，和两个可选接口<code>return()</code>和<code>throw()</code>，它的result被规定为包括属性<code>value</code>和<code>done</code>，下面是一个数组的迭代：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = arr[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]();</span><br><span class=\"line\"></span><br><span class=\"line\">it.<span class=\"title function_\">next</span>();      <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">it.<span class=\"title function_\">next</span>();      <span class=\"comment\">// &#123; value: 2, done: false &#125;</span></span><br><span class=\"line\">it.<span class=\"title function_\">next</span>();      <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">it.<span class=\"title function_\">next</span>();      <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>但通常使用<code>for of</code>就足够了。我们可以依照这个接口，定义一个自己的迭代器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Fib</span> = &#123;</span><br><span class=\"line\">    [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> n1 = <span class=\"number\">1</span>, n2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使迭代器成为一个可迭代对象</span></span><br><span class=\"line\">            [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>; &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"title function_\">next</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> current = n2;</span><br><span class=\"line\">                n2 = n1;</span><br><span class=\"line\">                n1 = n1 + current;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: current, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>(v) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Fibonacci sequence abandoned.&quot;</span></span><br><span class=\"line\">                );</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: v, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Generator-1\"><a href=\"#Generator-1\" class=\"headerlink\" title=\"Generator\"></a>Generator</h4><p>这个上一章已经提到了。它可以用来：</p>\n<ul>\n<li>生产一系列值，即状态机</li>\n<li>串行执行的任务队列，化<em>异步</em>为<em>同步</em></li>\n</ul>\n<h4 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h4><p><code>import</code>和<code>export</code></p>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><ul>\n<li>ES6引入了元属性的概念，用<code>new.target</code>表示。在任意的构造器中，<code>new.target</code>总是指向<code>new</code>实际直接调用的构造器。</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p><strong>ArrayBuffer</strong></p>\n<p>它表示一组比特位，但是这些比特的实际意义是由结构化数组控制的，由它表示这些比特上的“视图”究竟是8位有符号整数还是字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBuffer</span>( <span class=\"number\">32</span> );</span><br><span class=\"line\">buf.<span class=\"property\">byteLength</span>;                     <span class=\"comment\">// 32字节</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint16Array</span>( buf );</span><br><span class=\"line\">arr.<span class=\"property\">length</span>;                         <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p>一个单独的缓冲可以连接多个视图</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBuffer</span>( <span class=\"number\">2</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> view8 = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>( buf );</span><br><span class=\"line\"><span class=\"keyword\">var</span> view16 = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint16Array</span>( buf );</span><br><span class=\"line\"></span><br><span class=\"line\">view16[<span class=\"number\">0</span>] = <span class=\"number\">3085</span>;</span><br><span class=\"line\">view8[<span class=\"number\">0</span>];                       <span class=\"comment\">// 13</span></span><br><span class=\"line\">view8[<span class=\"number\">1</span>];                       <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<p>在ES6中可以使用下面的类型化数组构造器：</p>\n<ul>\n<li>Int8Array（8位有符号整数），Uint8Array（8位无符号整数）</li>\n<li>Uint8ClampedArray（8位无符号整数，每个值都被卡在0 - 255范围内）</li>\n<li>Int16Array（16位有符号整数），Uint16Array（16位无符号整数）</li>\n<li>Int32Array（32位有符号整数），Uint32Array（32位无符号整数）</li>\n<li>Float32Array（32位浮点数，IEEE-754）</li>\n<li>Float64Array（64位浮点数，IEEE-754）</li>\n</ul>\n<p><strong>Maps</strong></p>\n<p>摆脱对象只能使用字符串做键值的限制。有<code>get</code>、<code>set</code>、<code>delete</code>、<code>has</code>、<code>clear</code>等方法。类似地还有WeakMap，不过它只能使用对象做键。</p>\n<p><strong>Sets</strong></p>\n<p>一个集合。类似Map，不过<code>set</code>换成了<code>add</code>，且没有<code>get</code>。Set和Map都有自己的迭代器。也可以通过<code>keys</code>，<code>values</code>，<code>entries</code>来访问里面的内容。</p>\n<h3 id=\"新增API-amp-元编程\"><a href=\"#新增API-amp-元编程\" class=\"headerlink\" title=\"新增API &amp; 元编程\"></a>新增API &amp; 元编程</h3><p>略，参考<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/es6%20%26%20beyond/ch6.md\">原文</a></p>\n<h3 id=\"ES6以后\"><a href=\"#ES6以后\" class=\"headerlink\" title=\"ES6以后\"></a>ES6以后</h3><ul>\n<li>asnyc function</li>\n<li><code>Object.observe</code></li>\n<li>指数运算符<code>**</code></li>\n<li><code>Array#includes</code>替代<code>~Array.indexOf(value)</code></li>\n<li>SIMD（多个数据），用于多个元素的并行数学操作，参考下面<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v1 = <span class=\"variable constant_\">SIMD</span>.<span class=\"title function_\">float32x4</span>( <span class=\"number\">3.14159</span>, <span class=\"number\">21.0</span>, <span class=\"number\">32.3</span>, <span class=\"number\">55.55</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = <span class=\"variable constant_\">SIMD</span>.<span class=\"title function_\">float32x4</span>( <span class=\"number\">2.1</span>, <span class=\"number\">3.2</span>, <span class=\"number\">4.3</span>, <span class=\"number\">5.4</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">SIMD</span>.<span class=\"property\">float32x4</span>.<span class=\"title function_\">mul</span>( v1, v2 );</span><br><span class=\"line\"><span class=\"comment\">// [ 6.597339, 67.2, 138.89, 299.97 ]</span></span><br></pre></td></tr></table></figure></li>\n<li>WASM（Web Assembly）</li>\n</ul>\n<p><em>-END-</em></p>\n",
            "tags": [
                "读书笔记",
                "JavaScript"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/",
            "url": "http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/",
            "title": "《You don't know JS》 上（入门&作用域&对象）",
            "date_published": "2017-12-13T12:54:12.000Z",
            "content_html": "<blockquote>\n<p>原作：<a href=\"https://github.com/getify/You-Dont-Know-JS\">You-Dont-Know-JS</a><br>本文的99.9%的内容都来自《You dont know JS》的<a href=\"https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN\">电子中文版</a></p>\n<p>传送门：<a href=\"https://shenlvmeng.github.io/blog/2017/12/15/you-dont-know-js-part2/\">《You don’t know JS》 下（类型文法&amp;异步&amp;ES6与未来）</a></p>\n</blockquote>\n<h2 id=\"入门与进阶\"><a href=\"#入门与进阶\" class=\"headerlink\" title=\"入门与进阶\"></a>入门与进阶</h2><h3 id=\"值和类型\"><a href=\"#值和类型\" class=\"headerlink\" title=\"值和类型\"></a>值和类型</h3><p>JavaScript只有带类型的值，没有带类型的变量。大家都知道JS的基本类型共6类：</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>object</li>\n</ul>\n<p>但是在ES6之后，需要新增一类<code>symbol</code>。另外，对null使用<code>typeof</code>将得到“object”的结果。</p>\n<p>JavaScript中对“falsy”的定义包括：</p>\n<ul>\n<li>“”</li>\n<li>0, -0, NaN</li>\n<li>null, undefined</li>\n<li>false</li>\n</ul>\n<p>除此之外的值都是truthy。</p>\n<p>关于JavaScript中的<code>==</code>和<code>===</code>，作者的看法是在必要的时候<code>==</code>会很好地改善程序。然而<code>==</code>的<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\">判断规则</a>比较复杂，可以总结出一些情况便于我们选择是否使用<code>==</code>：</p>\n<ul>\n<li>如果一个比较的两个值之一可能是<code>true</code>或<code>false</code>，避免&#x3D;&#x3D;而使用&#x3D;&#x3D;&#x3D;。</li>\n<li>如果一个比较的两个值之一可能是<code>0</code>&#x2F;<code>&quot;&quot;</code>&#x2F;<code>[]</code>，避免&#x3D;&#x3D;而使用&#x3D;&#x3D;&#x3D;。</li>\n<li>其他情况下，放心使用<code>==</code>。不仅安全，在许多情况下它可以简化你的代码并改善可读性。</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>一个变量标识符必须以a-z，A-Z，$，或<code>_</code>开头。它可以包含任意这些字符外加数字0-9，但不能使用保留字。</p>\n<p>变量作用域提升（var定义）和嵌套就不多说了。</p>\n<h3 id=\"Strict模式\"><a href=\"#Strict模式\" class=\"headerlink\" title=\"Strict模式\"></a>Strict模式</h3><p>让代码更严谨，同样可以选择用在全局或是函数中。</p>\n<h3 id=\"函数作为值\"><a href=\"#函数作为值\" class=\"headerlink\" title=\"函数作为值\"></a>函数作为值</h3><p><strong>IIFE</strong>（立即执行函数）和<strong>闭包</strong>是JS中值得玩味的特性。除了使用<code>()</code>包裹，还可以用<code>void</code>打头开始一个IIFE。</p>\n<p>闭包经常用来包装模块。</p>\n<h3 id=\"this指代和prototype\"><a href=\"#this指代和prototype\" class=\"headerlink\" title=\"this指代和prototype\"></a>this指代和prototype</h3><p>略</p>\n<h3 id=\"新的特性\"><a href=\"#新的特性\" class=\"headerlink\" title=\"新的特性\"></a>新的特性</h3><p>填充（polyfill）和转译（transpile）</p>\n<h2 id=\"作用域与闭包\"><a href=\"#作用域与闭包\" class=\"headerlink\" title=\"作用域与闭包\"></a>作用域与闭包</h2><h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域与LHS，RHS。在非Strict模式下，如果到全局作用域还找不到变量，会在作用域内创建一个新的同名变量。在Strict模式下，不允许这种行为（意外地创建全局变量），此时会抛出ReferenceError，即找不到变量。如果找到了值，但是并不能对它做一些事情，就会抛出TypeError。</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><p>JavaScript使用词法作用域，即变量和作用域在编写代码阶段已经确定。JS引擎也可以在这个阶段针对作用域和变量对代码进行优化，但是<code>eval()</code>和<code>with()</code>会在代码中动态改变作用域，从而使得引擎无法进行优化，使代码运行得更慢。在strict模式下，<code>eval()</code>的不安全用法（修改作用域）以及<code>with()</code>都是不允许使用的。</p>\n<p>词法作用域是编写时的，而动态作用域（和this）是运行时的。词法作用域关心的是函数<strong>在何处被声明</strong>，但是动态作用域关心的是函数<strong>从何处被调用</strong>。</p>\n<p><code>this</code>在JS中始终是运行时的，即根据运行时的调用情况有不同的值。在<strong>箭头函数</strong>中则是词法this的，即声明时决定。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>封装、匿名函数、IIFE。</p>\n<p>for循环、if、while、switch等流程控制语句的<code>&#123;&#125;</code>，都是<em>假的</em>块作用域，其中的内容都依附于外部的函数作用域。with（不建议使用），try catch，let，const可以形成新的块作用域。</p>\n<p>在ES6到ES5的转译时，具有块作用域的代码，会采用<code>try catch</code>来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(a) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><ul>\n<li>在代码被执行前，所有的声明，变量和函数，都会首先被处理。处理的只有“声明”，而没有“赋值”。</li>\n<li>函数提升优先于变量的提升</li>\n<li>后续的提升会覆盖此前的同名提升</li>\n</ul>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><blockquote>\n<p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。</p>\n</blockquote>\n<p>循环加闭包会出现面试中的经典问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码为啥不好用？</p>\n<p>从之前关于作用域的讨论来看，每次setTimeout只是完成了函数声明，并丢进队列里而已。当定时器函数在其词法作用域外执行时，因为闭包的特点会保留有父级的作用域。而这5个函数都定义在同一个父级函数作用域内，对变量i的引用自然是同一个了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">j</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( j );</span><br><span class=\"line\">        &#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">    &#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有IIFE的加持，父级作用域现在变成了每个IIFE而非for循环所在的作用域。即每个变量i来自不同的独立作用域，自然就可以得到理想的效果了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不就是想要个块作用域嘛，使用<code>let</code>关键字后变量将不是只为循环声明一次，而是为每次迭代声明一次。每次都能得到一个新的块作用域，自然得到和IIFE一样的效果。</p>\n<h2 id=\"this与对象\"><a href=\"#this与对象\" class=\"headerlink\" title=\"this与对象\"></a><code>this</code>与对象</h2><h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a><code>this</code>是什么</h3><p>也许JS已经入门的前端程序员们早就对this在不同环境下的不同值烂熟在心。但可能没有想过这种情况的本质：上一部分提到的<strong>JS中的this是运行时的</strong>，和作用域完全不一样。</p>\n<p>对比一下按照传统OOP理解下的JS代码，从不同的角度看，能进一步得到对this的认识：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">bar</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">num</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&quot;foo: &quot;</span> + num );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 追踪 `foo` 被调用了多少次</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">count</span>++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"property\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">foo</span>( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `foo` 被调用了多少次？</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( foo.<span class=\"property\">count</span> ); <span class=\"comment\">// 0 -- 这他妈怎么回事……？</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然看上去很愚蠢，但是从词法作用域的角度去理解，是不是能更清楚看到JS中<code>this</code>的特殊之处。</p>\n<h3 id=\"this豁然开朗\"><a href=\"#this豁然开朗\" class=\"headerlink\" title=\"this豁然开朗\"></a><code>this</code>豁然开朗</h3><p>根据上面的描述，<code>this</code>是根据调用点确定含义的。下面的4个规则，在准备JS面试的时候肯定都见过：</p>\n<ul>\n<li>默认绑定，独立函数调用。可以认为这种this规则是在没有其他规则适用时的默认规则。此时<code>this</code>指向全局对象，在strict mode下，<code>this</code>指向undefined。</li>\n<li>隐含绑定，调用点有一个环境对象，即作为函数方法，但是下面的情况下会回退到默认绑定，因为调用点实际位于独立函数内<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.<span class=\"property\">foo</span>; <span class=\"comment\">// 函数引用！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;oops, global&quot;</span>; <span class=\"comment\">// `a`也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">bar</span>(); <span class=\"comment\">// &quot;oops, global&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">========</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doFoo</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">fn</span>(); <span class=\"comment\">// &lt;-- 调用点!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;oops, global&quot;</span>; <span class=\"comment\">// `a`也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doFoo</span>( obj.<span class=\"property\">foo</span> ); <span class=\"comment\">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li>显式绑定，<code>call</code>与<code>apply</code>可以显式attach context到函数上，使用<code>bind</code>可以避免前面那种<code>this</code>丢失的情况。</li>\n<li>new绑定，函数作为构造函数调用时，<code>this</code>指向即将返回的新对象。</li>\n</ul>\n<p>从优先级上看，new &gt; 硬绑定 &gt; 隐含绑定 &gt; 默认绑定。其中“new &gt; 硬绑定”有趣的一点是，使用<code>bind</code>在第一个后的参数实际上会作为函数的默认入参（类似于函数柯里化），如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">p1,p2</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">val</span> = p1 + p2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里使用 `null` 是因为在这种场景下我们不关心 `this` 的硬绑定</span></span><br><span class=\"line\"><span class=\"comment\">// 而且反正它将会被 `new` 调用覆盖掉！</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.<span class=\"title function_\">bind</span>( <span class=\"literal\">null</span>, <span class=\"string\">&quot;p1&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"keyword\">new</span> <span class=\"title function_\">bar</span>( <span class=\"string\">&quot;p2&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">baz.<span class=\"property\">val</span>; <span class=\"comment\">// p1p2</span></span><br></pre></td></tr></table></figure>\n\n<p>除了上面的规则，还有一些特例：</p>\n<p>传递<code>null</code>或<code>undefined</code>给<code>call</code>，<code>apply</code>或<code>bind</code>时，那么这些值会被忽略掉，取而代之的是<strong>默认绑定</strong>规则将适用于这个调用。单纯使用apply数组化输入参数（现在已经可以用<code>[...foo]</code>了）和bind柯里化函数时常用到。</p>\n<p>不过，这么做还是有风险，建议用<code>Object.create(null)</code>创建的对象替代<code>null</code>，既能表示无意义的值，又能避免<strong>默认绑定</strong>的行为。</p>\n<p>作者给出了软绑定的工具方法，提高了硬绑定的灵活性，又避免了<strong>默认绑定</strong>的问题。逻辑是在绑定时检查<code>this</code>是否是全局对象，如果是才使用输入的<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">softBind</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">softBind</span> = <span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">            curried = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>( <span class=\"variable language_\">arguments</span>, <span class=\"number\">1</span> ),</span><br><span class=\"line\">            bound = <span class=\"keyword\">function</span> <span class=\"title function_\">bound</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fn.<span class=\"title function_\">apply</span>(</span><br><span class=\"line\">                    (!<span class=\"variable language_\">this</span> ||</span><br><span class=\"line\">                        (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class=\"line\">                            <span class=\"variable language_\">this</span> === <span class=\"variable language_\">window</span>) ||</span><br><span class=\"line\">                        (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">global</span> !== <span class=\"string\">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class=\"line\">                            <span class=\"variable language_\">this</span> === <span class=\"variable language_\">global</span>)</span><br><span class=\"line\">                    ) ? obj : <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">                    curried.<span class=\"property\">concat</span>.<span class=\"title function_\">apply</span>( curried, <span class=\"variable language_\">arguments</span> )</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        bound.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( fn.<span class=\"property\"><span class=\"keyword\">prototype</span></span> );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>另外，前面提到的箭头函数具有词法<code>this</code>，等同在调用前声明<code>self = this</code>，再把<code>self</code>传入的效果。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>内建对象中，只有<code>Date()</code>是必须要使用<code>new</code>创建的。</p>\n<p>对象的属性有两种访问方法：<code>.</code>操作符或<code>[ ]</code>操作符。不同的是<code>.</code>操作符后只能使用标识符兼容的属性名，<code>[...]</code>操作符后可以使用任何合理的UTF-8的字符串。另外，对象的属性名总是字符串，如果使用了其他类型值，会进行强制转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject[<span class=\"literal\">true</span>] = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\">myObject[<span class=\"number\">3</span>] = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">myObject[myObject] = <span class=\"string\">&quot;baz&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject[<span class=\"string\">&quot;true&quot;</span>];               <span class=\"comment\">// &quot;foo&quot;</span></span><br><span class=\"line\">myObject[<span class=\"string\">&quot;3&quot;</span>];                  <span class=\"comment\">// &quot;bar&quot;</span></span><br><span class=\"line\">myObject[<span class=\"string\">&quot;[object Object]&quot;</span>];    <span class=\"comment\">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计算型属性名\"><a href=\"#计算型属性名\" class=\"headerlink\" title=\"计算型属性名\"></a>计算型属性名</h4><p>ES6中新增了<em>计算型属性名</em>，允许使用表达式作为一个键名称，表达式用<code>[ ]</code>括起来。像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prefix = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    [prefix + <span class=\"string\">&quot;bar&quot;</span>]: <span class=\"string\">&quot;hello&quot;</span>,</span><br><span class=\"line\">    [prefix + <span class=\"string\">&quot;baz&quot;</span>]: <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject[<span class=\"string\">&quot;foobar&quot;</span>]; <span class=\"comment\">// hello</span></span><br><span class=\"line\">myObject[<span class=\"string\">&quot;foobaz&quot;</span>]; <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure>\n\n<p>深、浅复制与对象属性描述符（description），<code>writable</code>和<code>configurable</code>，<code>getOwnPropertyDescriptor()</code>与<code>defineProperty()</code>。在JS中，<code>delete</code>仅用于直接从目标对象移除该对象的（可以被移除的）属性，与释放内存并无直接关系。</p>\n<h4 id=\"Immutability\"><a href=\"#Immutability\" class=\"headerlink\" title=\"Immutability\"></a>Immutability</h4><p><strong>注意：所有这些方法创建的都是浅不可变性。也就是，它们仅影响对象和它的直属属性的性质。如果对象拥有对其他对象（数组、对象、函数等）的引用，那个对象的内容不会受影响，任然保持可变</strong>。</p>\n<p>属性描述符里的<code>writable</code>和<code>configuratable</code>限制了对属性和属性值的修改。<code>preventExtensions()</code>方法可以防止对象被添加新属性。</p>\n<ul>\n<li><code>seal()</code> &#x3D; <code>configuratable: false</code> + <code>preventExtensions()</code></li>\n<li><code>freeze()</code> &#x3D; <code>seal()</code> + <code>writable: false</code></li>\n</ul>\n<h4 id=\"getter与setter\"><a href=\"#getter与setter\" class=\"headerlink\" title=\"getter与setter\"></a>getter与setter</h4><p>除了使用<code>defineProperty</code>外，可以直接用字面量的形式，通过<code>get prop1()</code>或<code>set prop1(val)</code>的形式设置getter和setter。</p>\n<p><code>for in</code>和<code>for of</code>。</p>\n<h3 id=\"混合（淆）“类”的对象\"><a href=\"#混合（淆）“类”的对象\" class=\"headerlink\" title=\"混合（淆）“类”的对象\"></a>混合（淆）“类”的对象</h3><blockquote>\n<p>有些语言（比如Java）不给你选择，所以这根本没什么 选择性 —— 一切都是类。其他语言如C&#x2F;C++或PHP同时给你过程式和面向类的语法，在使用哪种风格合适或混合风格上，留给开发者更多选择。</p>\n</blockquote>\n<p><strong>类意味着拷贝。</strong></p>\n<p>当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。多态也是拷贝行为的结果。</p>\n<p>但是：</p>\n<ul>\n<li>第一，JavaScript并<strong>不会</strong>自动地 （像类那样）在对象间创建拷贝；</li>\n<li>第二，显式mixin只能复制函数或对象的<strong>引用</strong>，而不是自身。</li>\n</ul>\n<blockquote>\n<p>正如我们在第四章讲解的，在 JavaScript 中，对于对象来说没有抽象模式&#x2F;蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p>\n<p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p>\n<p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p>\n<p>总之，JavaScript中面向对象的部分和大多数OOP语言不完全一样。这使得在JS中模拟类编程将既累又会埋下很多坑。</p>\n</blockquote>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>使用<code>[[get]]</code>查询属性时，也会在<code>[[prototype]]</code>链上寻找，因此修改对象属性的时候，应该注意<strong>属性遮蔽</strong>（即在<code>[[prototype]]</code>中找到）的情况。它会增加代码的复杂度和可读性，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.<span class=\"title function_\">hasOwnProperty</span>( <span class=\"string\">&quot;a&quot;</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>( <span class=\"string\">&quot;a&quot;</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">a</span>++; <span class=\"comment\">// 噢，隐式遮蔽！</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>( <span class=\"string\">&quot;a&quot;</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>for in</code>循环中，同样注意用<code>hasOwnProperty()</code>排除<code>[[prototype]]</code>上的属性。</p>\n<p>所有用<code>constructor</code>构建的对象都有所指向的prototype，而在prototype中的<code>.constructor</code>又会指回<code>constructor</code>。但是这个关系是可以被覆盖的。</p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><p>作者认为，JS中的对象是通过链接组织起来的。说是原型继承，实际上就是在两个原型间建立了<code>[[prototype]]</code>的关系。这个关系的建立方法很多，各有优劣。最简单的还是用ES5提供的<code>Object.create()</code>方法，对<code>__proto__</code>和<code>constructor</code>等视而不见。它的polyfill像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Object</span>.<span class=\"property\">create</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"property\">create</span> = <span class=\"keyword\">function</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\">        F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>Object.create()</code>第一个后面的参数可以用来声明对象属性描述符，不过用得不多。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>虽然这些JavaScript机制看起来和传统面向类语言的“初始化类”和“类继承”类似，而在JavaScript中的关键区别是，没有拷贝发生。取而代之的是对象最终通过<code>[[Prototype]]</code>链链接在一起。</p>\n<p>相反，“委托”是一个更确切的术语，因为这些关系不是拷贝而是委托链接。</p>\n</blockquote>\n<p>从这个角度去看<code>new Foo()</code>过程中发生的事，除了返回一个新的对象外，<code>Foo()</code>还会将这个对象和<code>Foo.prototype</code>链接起来（通过指定<code>[[prototype]]</code>），<code>Foo.prototype</code>和别的对象并没有本质区别。</p>\n<h3 id=\"行为委托\"><a href=\"#行为委托\" class=\"headerlink\" title=\"行为委托\"></a>行为委托</h3><p>在上面一章提到，<code>[[prototype]]</code>是存在于对象内部的引用另一个对象的内部连接。当一个属性&#x2F;方法引用在一个对象上发生，而这样的属性&#x2F;方法又不存在时，这个链接就会被使用。在这种情况下，<code>[[Prototype]]</code>链接告诉引擎去那个被链接的对象上寻找该属性&#x2F;方法。接下来，如果那个对象也不能满足查询，就沿着它的<code>[[Prototype]]</code>查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。</p>\n<p>其重要的实质<strong>全部在于被连接到其他对象的对象</strong>。</p>\n<p>下面是一段OLOO（链接到其他对象的对象）风格的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Task</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">setID</span>: <span class=\"keyword\">function</span>(<span class=\"params\">ID</span>) &#123; <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = <span class=\"variable constant_\">ID</span>; &#125;,</span><br><span class=\"line\">    <span class=\"attr\">outputID</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使 `XYZ` 委托到 `Task`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"variable constant_\">XYZ</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Task</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">XYZ</span>.<span class=\"property\">prepareTask</span> = <span class=\"keyword\">function</span>(<span class=\"params\">ID,Label</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setID</span>( <span class=\"variable constant_\">ID</span> );</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">label</span> = <span class=\"title class_\">Label</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">XYZ</span>.<span class=\"property\">outputTaskDetails</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">outputID</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">label</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>它的特点在于：</p>\n<ul>\n<li>状态保留在委托者上</li>\n<li>避免<code>[[prototype]]</code>链上的重复命名</li>\n<li>行为委托用在内部实现，避免暴露在API的设计上</li>\n</ul>\n<p><strong>思维的转变</strong></p>\n<p>放弃传统OO思路在JS中的蹩脚实现（像下面这样），抓住<code>[[prototype]]</code>链接对象以及“原型链”的特殊性，可以让思路更加自然且符合JS的特点（像下面的下面那样）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\">who</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">me</span> = who;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">identify</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">me</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Bar</span>(<span class=\"params\">who</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Foo</span>.<span class=\"title function_\">call</span>( <span class=\"variable language_\">this</span>, who );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">speak</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>( <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">identify</span>() + <span class=\"string\">&quot;.&quot;</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Bar</span>( <span class=\"string\">&quot;b1&quot;</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Bar</span>( <span class=\"string\">&quot;b2&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">b1.<span class=\"title function_\">speak</span>();</span><br><span class=\"line\">b2.<span class=\"title function_\">speak</span>();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">init</span>: <span class=\"keyword\">function</span>(<span class=\"params\">who</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">me</span> = who;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">identify</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">me</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Bar</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Foo</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\">speak</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>( <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">identify</span>() + <span class=\"string\">&quot;.&quot;</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Bar</span> );</span><br><span class=\"line\">b1.<span class=\"title function_\">init</span>( <span class=\"string\">&quot;b1&quot;</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Bar</span> );</span><br><span class=\"line\">b2.<span class=\"title function_\">init</span>( <span class=\"string\">&quot;b2&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">b1.<span class=\"title function_\">speak</span>();</span><br><span class=\"line\">b2.<span class=\"title function_\">speak</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在这种委托的思路下，不存在严格的父子关系，甚至不存在继承和类的说法。全程通过<code>Object.create()</code>建立起对象和对象的联系，连<code>new</code>也是不建议使用的。</p>\n<p>但是这种思路也有个明显的问题，“子类”没法定义“父类”的同名方法，因为整个程序建立在<code>[[prototype]]</code>联系的基础上，重复命名将会隔断连接。</p>\n<p>作者并不推荐匿名函数的使用，认为：1，追踪调试栈困难；2，难以自引用；3，代码变得不好理解。这点上我是保留意见的。</p>\n<h3 id=\"类型自省\"><a href=\"#类型自省\" class=\"headerlink\" title=\"类型自省\"></a>类型自省</h3><p>类型自省即<code>instanceof</code>，而这个操作符是依赖于<code>[[prototype]]</code>中的constructor属性的，这个属性除了不可枚举外，相较其他属性并没有特别之处。重写或者<code>[[prototype]]</code>的改变就可以改变它。因此，<code>instanceof</code>在很多情况下可能并不会那么可靠。</p>\n<p>使用鸭子类型的类型自省就更加不可靠了。</p>\n<p>在作者提出的OLOO范式中，采取<code>isPrototypeOf()</code>和<code>Object.getPrototypeOf()</code>进行类型自省。</p>\n<h3 id=\"新的class关键字\"><a href=\"#新的class关键字\" class=\"headerlink\" title=\"新的class关键字\"></a>新的<code>class</code>关键字</h3><p>为了便于“类”思维编程者，<code>class</code>可以说是一大福音。</p>\n<ul>\n<li>不再有<code>.prototype</code>的困扰</li>\n<li><code>extends</code>一键式继承</li>\n<li><code>super</code>对多态的支持</li>\n<li>语法上使用更加贴近OOP语言</li>\n</ul>\n<p>但实际上，这里的<code>class</code>只是语法糖，它还是没实现从类（“蓝图”）到实例（“建筑”）以及从父类到子类的复制，还建立在<code>[[prototype]]</code>的基础上。<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/apA.md\">原文</a>给出了很多例子说明这点。</p>\n<blockquote>\n<p>在传统面向类的语言中，你从不会在晚些时候调整类的定义，所以类设计模式不提供这样的能力。但是JS的一个最强大的部分就是它是动态的，而且任何对象的定义都是（除非你将它设定为不可变）不固定的可变的东西。</p>\n</blockquote>\n<blockquote>\n<p>换句话说，class 好像在告诉你：“动态太坏了，所以这可能不是一个好主意。这里有看似静态语法，把你的东西静态编码。”</p>\n<p>关于 JavaScript 的评论是多么悲伤啊：动态太难了，让我们假装成（但实际上不是！）静态吧。</p>\n</blockquote>\n",
            "tags": [
                "读书笔记",
                "JavaScript"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/11/04/sapiens-a-brief-history-of-humankind/",
            "url": "http://shenlvmeng.github.com/blog/2017/11/04/sapiens-a-brief-history-of-humankind/",
            "title": "《人类简史》读书笔记",
            "date_published": "2017-11-04T06:23:39.000Z",
            "content_html": "<p>《人类简史》是几年前的畅销书，早有耳闻。它不是对智人几万年来的历史事件像讲故事似的一个个娓娓道来，反而从生物学、社会学、宗教、经济、人文等各个方面提出了相当有深度的观点和见解，包括认知革命、农业革命、帝国与金钱、科技革命等方面的理解让我大开眼界。虽然了解了人类在这些方面的种种真相，对日常生活似乎也不会有什么改善，这并不妨碍它成为一本好书。总而言之，《人类简史》值得一读。</p>\n<h3 id=\"认知革命\"><a href=\"#认知革命\" class=\"headerlink\" title=\"认知革命\"></a>认知革命</h3><p>智人不过是地球生物发展长河中的一种物种而已，与它类似的还有尼安德特人、丹尼索瓦人、梭罗人等其他人种。然而随着智人向地球的各个大陆蔓延时，这些人种却渐渐消失在历史长河中。在这个过程中，智人似乎发生了认知革命，在智人之前，许多动物都有自己的语言，作者认为不同的是，首先智人的语言能够传达更多的信息，从而执行复杂的计划；其次<strong>只有智人可以谈论并不真正存在的事物，同时相信一些不大可能的事情</strong>。“虚构”这件事的重点在于人类可以拥有想象，同时可以<strong>一起想象</strong>，编制出共同的虚构故事。这种“想象的现实”也是人类后面建立秩序的基础。</p>\n<p>早期的智人（农业革命前）主要靠狩猎和采集生存，营群体游牧生存。不论从工作时间、生存本领还是幸福程度甚至都比现代人高。他们的营养充分、能够免受饥饿或营养不良的影响、由于不依赖单一作物，受自然灾害影响较小，也很少受传染病影响。在度过艰难的童年时光后，多半能活到不错的岁数。在这个阶段，智人的信仰为<strong>泛神论</strong>，即一切皆有灵，几乎任何一个地点，任何一个动物，任何一个植物都有自己的声明和情感。</p>\n<p>随着智人向各个大陆迁移、在从大陆向太平洋岛屿迁移，这股毁天灭地的人类洪水带来了大批的动植物灭绝，尤其是大型陆地动物。</p>\n<h3 id=\"农业革命\"><a href=\"#农业革命\" class=\"headerlink\" title=\"农业革命\"></a>农业革命</h3><p>作者认为，农业革命是史上最大的谎言，看上去是人类驯服的小麦和水稻，实际上却是小麦和水稻驯服了人类。农业革命包括农业作物的驯服（植物），包括小麦、水稻、玉米、马铃薯、豆类等，也包括动物的驯服，如牛、狗、羊、鸡等。主要发生在中东、中国、中美洲，原因很简单：<strong>大多数的动植物无法驯化，这些好驯化的动植物只生长在特定的地方</strong>。</p>\n<p>人类以小麦等为主食完全是巧合，人们发现在作物丰盛的情况下，终于不用再四处迁移，从而转而通过种植这些农业作物为生，永久聚落开始形成，生活方式的变化使得人类需要考虑自然灾害等的影响，需要预留多余的粮食，同时还要从早到晚照料这些作物免受其他物种侵袭。<strong>这似乎是一个陷阱</strong>，智人的身体构造其实并不是为了成天弯腰除草和挑水准备的，身体劳累的同时，传染病和暴力行为也威胁到人类的生存。人类以为自己再辛苦点，生活就会更好，等到群落规模达到上百上千人的时候才发现已经无法回头到以狩猎和采集为生的生活，因为此时只有这些农作物能养活这么多人。可受苦的不只是人类，农业革命中的动物也在饱受着痛苦，只因人类需要它们来过上更好的生活。</p>\n<p>随着农民生产出来的食物越来越多，加上运输技术的成熟，住在一起的人越来越多，渐渐形成村落和城镇，这个速度快到人类根本没有进化出让这么多人协同工作的本能。幸运的是，智人是个可以讲“谎话”和相信“谎话”的物种。于是一系列“虚构的故事”帮助人类建立稳定的秩序。同时为了保证秩序不会崩塌，还需要暴力的维持。除了暴力还需要一些真正的信徒。为了做到这一点，</p>\n<ul>\n<li><strong>第一，对外的说法绝对要坚持它们千真万确、绝非虚构，并永远强调下去</strong></li>\n<li><strong>第二，在教育上也要彻底贯彻同一套原则，要在一切事物中融入这套由想象建构出的秩序</strong></li>\n</ul>\n<p>最后，想象构建的秩序深深与真实的世界结合，想象构建的秩序塑造了我们的欲望，想象出的秩序存在于人与人的思想连接。作为人类，我们已经不可能摆脱想象建构出的秩序，因为为了让所有人都摆脱，我们需要想象出更强大的东西，从而只是换了种想象而已。即使最后真正摆脱了这种秩序，所谓犬儒主义者，将不可能建立起稳定的帝国。</p>\n<h3 id=\"记忆过载\"><a href=\"#记忆过载\" class=\"headerlink\" title=\"记忆过载\"></a>记忆过载</h3><p>随着人口规模越来越大，“虚构的故事”越来越多，秩序也越来越复杂。下面几个原因催生出新的表达方式：</p>\n<ol>\n<li>人类并不像蜜蜂，将秩序深植在基因之中，随着人死亡，秩序并不会遗传下去</li>\n<li>大脑容量有限，储存不了这么多信息</li>\n<li>人类大脑的演化并不是为了储存抽象信息设计的，只习惯于存储动植物、地形等具体信息</li>\n</ol>\n<p>于是，数字和文字逐渐形成，让“虚构的故事”能够更久地传承下去，文字也从记录这些秩序逐渐发展到完备的可以表达日常的生活。在管理机构里，专门有人记忆这些秩序，便于随时取出使用。文字对人类的重要影响是，<strong>逐渐改变了人类思维和看待这个世界的方式，从过去的自由连接、整体思考到分割思考、官僚主义</strong>。而数字符号更是如今程序语言的基石。</p>\n<p>历史从无正义，这些“想象的故事”并不公平，总把人分成一些其实并不存在的分类，上层人享有各种权力和特权，下等人有的只有歧视和压迫，阶级由此产生。有趣的是，大多数人都会认为只有自己社会的阶级才是自然的，而其他社会的阶级分法实在虚伪。不幸的是，复杂的人类社会似乎确实需要这种由想象建构出来的阶级制度和歧视，而这种歧视往往会造成恶性循环（被歧视-&gt;没有发展机会-&gt;缺乏教育、贫穷-&gt;被歧视），成为底层人士被歧视的所谓客观道理。</p>\n<p>关于性别歧视和偏见，许多人认知的所谓“自然”和“不自然”并不是生物学的概念，而是人为（如基督教神学）想象出的规则，指的是“符合创造自然的神的旨意”。各种规定男人就该如何、女人就该怎样的法律、规范、权利和义务，反映的多半只是人类的想象，而不是生物天生的现实。</p>\n<h3 id=\"人类的融合统一\"><a href=\"#人类的融合统一\" class=\"headerlink\" title=\"人类的融合统一\"></a>人类的融合统一</h3><p>农业革命后，人类社会规模变得更大，维系社会秩序的想象故事也更为精致。人类从出生到死亡被各种虚构的故事和规则围绕，人们往往遵照着这种人造而非天生的直觉，这种直觉就叫做“文化”。原本整个世界是可以大致划分成多个相互隔离并具有一定规模的世界的。随着亚非世界的发展，不断吞噬了其他世界。如今，几乎所有人类都认同同一套地缘政治体系，即地球被划分出不同的国家；使用同一套经济制度，采用同一套法律制度和科学体系。有三种秩序促成了现在的大统一：金钱、帝国、宗教。</p>\n<p>农业革命后，随着城镇和王国的出现，人类的分工越来越细，从前一个部落内就可以完成的需求，如今可能需要找完全的陌生人。以物易物的交易有诸多的问题，某些社会采用集中的以物易物系统，但是大多数社会通过发明“钱”的概念解决。这里的<strong>“钱”完全是一个概念，存在于人们共同想象中的概念</strong>。金钱不仅能够交换物品，还能用来积累财富，相比农作物等，金钱要好储存多了，同时也更便于携带。金钱在转换、存储、运输上的优势，造就了现如今如此复杂的商业系统。可以说，“金钱是人类有史以来最成功的互信系统”。</p>\n<p>帝国是一种政治秩序，往往统治许多民族，有着灵活的疆域。它对人类最大的益处在，四处征服、掠夺财富后，不只是拿来养活军队，同时也赞助了艺术、科学、司法等的发展。全球的帝国有个共同点就是，在征服它国时，都带着“征服你们是为你们好”，“统治全世界，为全人类带来福祉”的动机，与排外相反，帝国展现更多的是<strong>包容</strong>。在帝国的统治下，帝国中的“它们”也渐渐认同了“我们”的概念，和帝国融为一体。在公元前200年左右，大多数人已经活在各个帝国之下。现如今，似乎要形成一个全球性的帝国。</p>\n<p>宗教的特点有二：1. 认为世界上有一种超人类的秩序，2. 宗教会以此发展出具有约束力的规范和价值观。只有具有<strong>普世特征</strong>和<strong>推广特质</strong>的才算得上是宗教。偶像崇拜发展大致是从泛神论到多神论再到一神论。多神论认为世界由一群神威浩荡的神灵统治，而主宰世界的最高权利不带有私心和偏见，在需要时，和特定的神进行交易就可以得偿所愿。随着时间推移，许多多神论者开始对自己信仰的某位神灵越来越虔诚，也慢慢偏离多神论概念，形成一神论。一神论者通常认为自己信奉的神就是唯一的神，自然会批评其他的神不可信，这点不同于多神论。</p>\n<p>二元论宗教为了解决“恶的难题”，即为什么世界会有苦难，人为什么会犯错，应运而生。对二元论者来说，掌握世界的不是一个无所不能的神，还有不受控制的恶。佛教认为人遇到事情会产生欲念，欲念会造成不满，释迦牟尼认为重点要看清事情本质，而不是它带来的感受，在专注于实际感受而非欲求和幻想时，原来的欲求就换来了圆满和寂静，称为涅槃。</p>\n<p>后世的崇拜对象由神变成了人或是智人的群体，从而产生了人文主义，而根据人文主义者对人性定义的不同，又有自由人文主义、社会人文主义等。</p>\n<h3 id=\"科学革命\"><a href=\"#科学革命\" class=\"headerlink\" title=\"科学革命\"></a>科学革命</h3><p>现代科学和以往的知识体系最大的不同在：</p>\n<ul>\n<li>愿意承认自己的无知</li>\n<li>以观察和数学为中心</li>\n<li>通过科学获得新能力（即技术）</li>\n</ul>\n<p>但是，若是假设我们并非无所不知，现有知识也非全对，那这也适用于那些让数百万人得以有效合作的虚构故事，社会秩序岂不是要崩溃。因此，要维持社会政治秩序稳定，只能依靠不科学的方法，别无选择。毕竟科学还是要依靠宗教、意识形态才能获得经费，并让研究正当化。</p>\n<p>在精确科学的趋势下，连生物学、经济学、社会学、心理学等学科也得依靠上数学工具，从而发展出数学的新分支——统计学。知识就是力量，意在考验科学的一大标准就是能否应用于实践。不能免俗的是，科学活动也像其他文化活动一样，收到经济、政治和宗教利益的影响，科学研究一定得和某些宗教或意识形态联手，才有蓬勃发展的可能。</p>\n<p>近现代，在欧洲，帝国带着征服的心态不断扩张。同时，不得不提的说资本主义的发展来自对未来的信任，<strong>信用-&gt;贷款-&gt;发展-&gt;回报-&gt;信用</strong>的良性循环，现代经济建立在信任的基础上，使得饼越来越大，有钱也不是一件可耻的事。然而上面循环的一个基础就是：<strong>生产的利润必须再投资于提高产量</strong>。这也是资本主义的原则，因此即使你是某个辛苦的工人，把收入的一部分拿出投资股票，你也算是个资本主义者。资本主义认为，经济发展就是至善。欧洲的商业型帝国就建立在资本主义的基础上，毕竟靠投资提高收入要好于缴税。</p>\n<p>哥伦布探索新大陆的举动，催生了帝国资本主义的奇妙循环：信贷-&gt;新发现-&gt;殖民地-&gt;利润-&gt;信任-&gt;信贷。然而探险也是有风险的，股份有限公司随着产生，一次探险失败所有股东分担，避免血本无归。荷兰、英国等国家在此基础上，渐渐采用出售股份的方式，让部分债权人也能享有部分获利，这种股票的转手和买卖大行其道，从而催生了证券交易所，专门进行股票交易。以至于后面的战争也可能成为商品的一种。</p>\n<p>伴随科技革命的是工业的发展壮大。蒸汽机的出现前，只能靠人体来进行能量间的转化，学会驾驭和转化这些能量的同时，人类可以使用的能源也大大提升。工业催生了冷漠和传送带，一切都以产量为标的。与此同时，产生了全新的问题：<strong>谁来买这些产品？</strong></p>\n<p>为了避免这种灾难，一种伦理观便被发明出来：消费主义。有史以来，人们生活窘迫，多以勤俭为口号。然而消费主义的没得就是消费更多的产品和服务，鼓励所有人善待自己，宠爱自己，即使因此走上绝路，也在所不惜。在传统农业社会，饥荒的阴影挥之不去，而今天，肥胖却成为一大健康问题。资本主义和消费主义的伦理可以分为两面：</p>\n<ul>\n<li>有钱人的指导原则是——<strong>“投资”</strong>！</li>\n<li>其他人的指导原则是——<strong>“购买”</strong>！</li>\n</ul>\n<h3 id=\"现代生活\"><a href=\"#现代生活\" class=\"headerlink\" title=\"现代生活\"></a>现代生活</h3><p>随着工业的出现和发展，时刻表和生产线的概念随之出现，人们关心上下班时间，列车也开始设计列车时刻表，时间变得越来越精细。1847年，英国的火车业者齐聚一堂，同意以格林尼治天文台的时间为准，协调火车时刻表。最终在1880年，英国成为是一个统一全国时间的国家。而现代的一切都得按时完成，时间无所不在。</p>\n<p>工业革命后个人的力量逐渐摆脱家庭和社群，个人的命运不再完全由家庭长辈或是家族左右，人类的生活和思考方式也不再预设自己属于社群。家庭和社群力量减弱的同时，国家和市场力量变强，从而进一步使得个人不避依赖社群生存。如今，社群更多是发挥一些重要的情感功能。现代兴起了两大想象社群——“民族”和“消费大众”，前者是国家的想象社群，而后者是市场的想象社群。后者是指消费者们可能彼此并不认识，却因为相同的消费习惯和兴趣成为“同一伙人”（如粉丝）。</p>\n<p>过去两世纪，社会秩序变动不休。狄更斯曾在法国大革命时说过：“这是最好的年代，也是最坏的年代”。这句话同样可以用于现在。</p>\n<p>快乐并不存在于任何财富、健康和社群之类的客观条件，而是客观条件和主管期望之间是否相符。所谓的快乐更可能只是让个人对意义的错觉和现行的集体错觉达成同步而已。</p>\n",
            "tags": [
                "读书笔记",
                "人类"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/10/13/css-definitive-guide-content/",
            "url": "http://shenlvmeng.github.com/blog/2017/10/13/css-definitive-guide-content/",
            "title": "《CSS权威指南》脉络",
            "date_published": "2017-10-13T05:56:33.000Z",
            "content_html": "<h3 id=\"CSS和文档\"><a href=\"#CSS和文档\" class=\"headerlink\" title=\"CSS和文档\"></a>CSS和文档</h3><ul>\n<li><p>CSS的出现和特点</p>\n</li>\n<li><p><code>&lt;link&gt;</code>、<code>&lt;style&gt;</code>和<code>@import</code></p>\n</li>\n<li><p>CSS注释</p>\n</li>\n<li><p>内联样式</p>\n</li>\n<li><p><code>@import</code>必须写在CSS文档的开头</p>\n</li>\n</ul>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><ul>\n<li><p>基本结构</p>\n</li>\n<li><p>元素选择器（分组选择器、通配选择器）</p>\n</li>\n<li><p>类选择器&#x2F;ID选择器</p>\n</li>\n<li><p>属性选择器（具体属性、部分属性）</p>\n</li>\n<li><p>后代选择器、兄弟选择器（<code>&gt;</code>, <code>+</code>）</p>\n</li>\n<li><p>伪类&#x2F;伪元素选择器</p>\n</li>\n<li><p><code>^=</code>, <code>$=</code>, <code>~=</code>, <code>*=</code>, <code>|=</code>用在属性选择中的部分匹配里，eg：<code>span[class~=&quot;bar&quot;]</code>，<br>其中<code>~=</code>匹配空格隔开的字符，<code>*=</code>匹配部分字符串，<code>|=</code>匹配完整字符串或以字符串开头</p>\n</li>\n<li><p>常用的伪类选择器有</p>\n<ul>\n<li><code>:link</code> 拥有<code>href</code>属性的<strong>未访问</strong>地址</li>\n<li><code>:visited</code></li>\n<li><code>:focus</code> 当前获得输入焦点的元素</li>\n<li><code>:hover</code></li>\n<li><code>:active</code> 被用户激活的元素</li>\n<li><code>:first-child</code> 第一个子元素，类似地还有<code>:last-child</code>和<code>nth-child()</code></li>\n<li><code>:lang()</code> 根据语言选择</li>\n<li><code>:first-letter</code>和<code>first-line</code>针对元素第一个字母和第一行文本</li>\n<li><code>:before</code>和<code>:after</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"层叠关系\"><a href=\"#层叠关系\" class=\"headerlink\" title=\"层叠关系\"></a>层叠关系</h3><ul>\n<li><p>优先级顺序（ID &gt; 类、属性、伪类 &gt; 元素、伪元素 &gt; 通配或结合符<code>,</code> &gt; 继承的属性）</p>\n</li>\n<li><p>内联样式和<code>!important</code>的特殊性</p>\n</li>\n<li><p>继承</p>\n</li>\n<li><p>层叠规则</p>\n</li>\n<li><p>来源权重关系（读者重要声明 &gt; 创作者的重要声明 &gt; 创作者正常声明 &gt; 读者正常声明 &gt; 用户代理声明）</p>\n</li>\n<li><p>LVHA（<code>:link</code> - <code>:visited</code> - <code>:hover</code> - <code>:active</code>的声明顺序）</p>\n</li>\n<li><p>一个声明出现的越后，它的权重越大</p>\n</li>\n</ul>\n<h3 id=\"值和单位\"><a href=\"#值和单位\" class=\"headerlink\" title=\"值和单位\"></a>值和单位</h3><ul>\n<li><p>数字</p>\n</li>\n<li><p>百分数</p>\n</li>\n<li><p>颜色（具名、rgb&#x2F;rgba、十六进制）、Web安全颜色</p>\n</li>\n<li><p>长度单位（in&#x2F;cm&#x2F;mm&#x2F;pt&#x2F;pc&#x2F;px，em&#x2F;ex&#x2F;rem&#x2F;vw&#x2F;vh&#x2F;vmin&#x2F;vmax）</p>\n</li>\n<li><p>URL（<code>url(protocol://server/pathname)</code>或<code>url(pathname)</code>）</p>\n</li>\n<li><p>关键字</p>\n</li>\n<li><p>角度&#x2F;时间&#x2F;频率</p>\n</li>\n<li><p>CSS2.1中有一个所有属性共有的关键字：<code>inherit</code></p>\n</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><ul>\n<li><p>通用字体（serif&#x2F;sans-serif&#x2F;monospace&#x2F;cursive&#x2F;fantasy）</p>\n</li>\n<li><p>指定字体</p>\n</li>\n<li><p>字体加粗（100~900，lighter&#x2F;bolder）</p>\n</li>\n<li><p>字体大小（xx-small ~ xx-large；绝对大小；百分数）</p>\n</li>\n<li><p>字体风格和变形（font-style，font-variant）</p>\n</li>\n<li><p><code>font</code>属性（<code>[&lt;font-style&gt; || &lt;font-variant&gt; || &lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;</code>）</p>\n</li>\n<li><p><code>font-face</code>规则（<code>font-family</code>，<code>font-style</code>，<code>src</code>等）</p>\n</li>\n<li><p>衬线字体包括Times，Georgia；非衬线字体包括Helvetiva，Geneva，Verdana，Arial；Monospace字体包括Courier，Courier New</p>\n</li>\n<li><p>字体名称中包含空格或特殊字符时，建议用引号包裹</p>\n</li>\n<li><p>一般地，400对应normal，700对应bold</p>\n</li>\n<li><p>字体大小是可以继承的，不过继承的是计算值而不是百分数</p>\n</li>\n<li><p><code>italic</code>是单独的字体风格，<code>oblique</code>则是正常文本的倾斜版本</p>\n</li>\n<li><p><code>small-caps</code>表示小型大写字母</p>\n</li>\n</ul>\n<h3 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h3><ul>\n<li><p>缩进（<code>text-indent</code>）</p>\n</li>\n<li><p>水平对齐（<code>text-align</code>）</p>\n</li>\n<li><p>垂直对齐（<code>line-height</code>和<code>vertical-align</code>）</p>\n</li>\n<li><p>字间隔和字母间隔（<code>word-spacing</code>和<code>letter-spacing</code>）</p>\n</li>\n<li><p>文本转换（<code>text-transfrom</code>）</p>\n</li>\n<li><p>文本装饰（<code>text-decoration</code>）</p>\n</li>\n<li><p>文本阴影（<code>text-shadow</code>）</p>\n</li>\n<li><p>空白符处理（<code>white-space</code>）</p>\n</li>\n<li><p>文本方向（<code>direction</code>和<code>unicode-bidi</code>）</p>\n</li>\n<li><p><code>text-indent</code>为负值时表示悬挂缩进效果</p>\n</li>\n<li><p><code>line-height</code>有继承性，表示文本基线（baseline）间的距离，继承的仍然是计算值</p>\n</li>\n<li><p>行内元素的行框由行间距和内容区组成</p>\n</li>\n<li><p><code>vertical-align</code>只应用于行内元素、替换元素和单元格，且不能继承。它可以取百分数和长度值，相对于自身line-height计算。</p>\n<ul>\n<li>在基线对齐时，将元素的<strong>底部</strong>和行框的基线对齐</li>\n<li>取值为<code>sub</code>或<code>super</code>时，元素的基线（或底端）将升高或降低</li>\n<li>取值<code>bottom</code>或<code>top</code>时，相对行框的顶端和底端</li>\n<li>取值为<code>middle</code>时，会把行内元素的中点与行框基线上方0.5ex（约为0.25em，因x-height而异）处对齐</li>\n<li>取值为数值时，会相对于父元素行框基线升高<br>最后，父元素的行框的行高会因此做调整</li>\n</ul>\n</li>\n<li><p><code>text-transform</code>有<code>uppercase</code>, <code>lowercase</code>, <code>capitalize</code>等几种选择，有继承性</p>\n</li>\n<li><p><code>text-decoration</code>有<code>underline</code>, <code>overline</code>, <code>line-through</code>, <code>blink</code>等几种选择，没有继承性</p>\n</li>\n<li><p><code>text-shadow</code>先确定阴影颜色，前两个长度值确定偏移距离，第三个值确定模糊半径，可以同时设置多个阴影效果</p>\n</li>\n<li><p><code>white-space</code>行为如下表</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>空白符</th>\n<th>换行符</th>\n<th>自动换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pre-line</td>\n<td>合并</td>\n<td>保留</td>\n<td>允许</td>\n</tr>\n<tr>\n<td>normal</td>\n<td>合并</td>\n<td>忽略</td>\n<td>允许</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>忽略</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>允许</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><ul>\n<li><p>基本框与包含块</p>\n</li>\n<li><p>正常流&#x2F;非替换元素&#x2F;替换元素&#x2F;块级元素&#x2F;行内元素</p>\n</li>\n<li><p>水平属性（<code>width</code>，<code>margin/border/padding-left/right</code>）</p>\n</li>\n<li><p>垂直属性（<code>height</code>，<code>margin/border/padding-top/bottom</code>）</p>\n</li>\n<li><p>行内元素（em框、内容区、行间距、行内框、行框）</p>\n</li>\n<li><p>元素的显示方式（<code>display</code>，<code>inline-block</code>和<code>run-in</code>）</p>\n</li>\n<li><p>在水平属性中只有<code>width</code>和外边距可以设置为<code>auto</code>，其余属性必须设置为特定的值或默认为0。使用<code>auto</code>将会弥补实际值和所需总和的差距，当格式化属性过度受限时，会强制把<code>margin-right</code>设置为<code>auto</code>。相反，不止一个<code>auto</code>出现时，若<code>width</code>不为<code>auto</code>，则会将元素居中，出现三个<code>auto</code>时，外边距都会设置为0。</p>\n</li>\n<li><p>垂直属性类似上面，不一样的是，元素间的外边距会合并，留下较大的外边距。</p>\n</li>\n<li><p>对于非替换元素，元素行内框高度等于<code>line-height</code>的值；对于替换元素，则由内容区高度决定</p>\n</li>\n<li><p>行内元素的边框边界由<code>font-size</code>决定，与<code>line-height</code>无关。类似，内外边距不会影响行框的形成和布局。</p>\n</li>\n<li><p>行内替换元素并没有自己的基线，所以说相对较好的方案是将其行内框底部和基线对齐。</p>\n</li>\n<li><p><code>inline-block</code>元素的<code>width</code>未定义或声明为<code>auto</code>时，元素会收缩来适应到框宽度刚好足够包含该内容</p>\n</li>\n</ul>\n<h3 id=\"边距和边框\"><a href=\"#边距和边框\" class=\"headerlink\" title=\"边距和边框\"></a>边距和边框</h3><ul>\n<li><p>基本元素框</p>\n</li>\n<li><p>外边距（负外边距和垂直外边距合并）</p>\n</li>\n<li><p>行内元素的外边距</p>\n</li>\n<li><p>边框</p>\n</li>\n<li><p>内边距</p>\n</li>\n<li><p>行内元素的内边距</p>\n</li>\n<li><p>外边距的空白不能放置其他元素</p>\n</li>\n<li><p>内外边距设置为百分数时，相对于父元素的<strong>宽度</strong>计算，这样做是为了避免高度上导致无限循环</p>\n</li>\n<li><p>对于行内元素，只有<code>line-height</code>，<code>font-size</code>和<code>vertical-align</code>可以改变元素行高，为替换元素设置的外边距会影响行高</p>\n</li>\n<li><p>边框的默认属性为<code>none medium &lt;color&gt;</code></p>\n</li>\n<li><p>元素的背景会延伸到内边距</p>\n</li>\n<li><p>左内&#x2F;外边距应用到行内元素开始处，右内&#x2F;外边距应用到行内元素结束处</p>\n</li>\n</ul>\n<h3 id=\"背景与颜色\"><a href=\"#背景与颜色\" class=\"headerlink\" title=\"背景与颜色\"></a>背景与颜色</h3><ul>\n<li><p>前景色（<code>color</code>）</p>\n</li>\n<li><p>背景色</p>\n</li>\n<li><p>背景图片</p>\n</li>\n<li><p>背景重复、背景定位（<code>background-position</code>）</p>\n</li>\n<li><p>背景大小（<code>background-size</code>，CSS3新增）</p>\n</li>\n<li><p>一般来说，前景包括元素的<strong>文本和边框</strong></p>\n</li>\n<li><p>前景色属性可以继承</p>\n</li>\n<li><p><strong>所有背景属性都不可继承</strong></p>\n</li>\n<li><p>背景图像放在指定的背景色之上</p>\n</li>\n<li><p><code>background</code>简写属性为<code>background-color || background-image || background-repeat || background-attachment || background-position</code></p>\n</li>\n</ul>\n<h3 id=\"浮动和定位\"><a href=\"#浮动和定位\" class=\"headerlink\" title=\"浮动和定位\"></a>浮动和定位</h3><ul>\n<li><p>浮动元素</p>\n</li>\n<li><p>浮动定位规则</p>\n</li>\n<li><p>浮动行为和浮动内容的的重叠</p>\n</li>\n<li><p>清除（<code>clear</code>）</p>\n</li>\n<li><p>定位类型（<code>position</code>）</p>\n</li>\n<li><p>宽高限制（<code>max/min-width</code>和<code>max/min-height</code>）</p>\n</li>\n<li><p>内容溢出（<code>overflow</code>和<code>clip</code>）</p>\n</li>\n<li><p>元素可见性（<code>visibility</code>）</p>\n</li>\n<li><p>绝对定位、固定定位、相对定位</p>\n</li>\n<li><p><code>z-index</code></p>\n</li>\n<li><p>浮动元素的外边距不会合并</p>\n</li>\n<li><p>浮动的非替换元素需要指定<code>width</code>，否则宽度将趋于0</p>\n</li>\n<li><p>浮动元素的包含块为距离最近的块级祖先元素</p>\n</li>\n<li><p>行内框和浮动元素重叠时，边框和内容都在浮动内容之上；块级元素重叠时，内容在之上，边框和背景在之下显示</p>\n</li>\n<li><p><code>clear</code>只应用于块级元素，清除区域不允许浮动元素进入</p>\n</li>\n<li><p><code>absolute</code>元素会形成一个块级框</p>\n</li>\n<li><p><code>top</code>等属性应用在<code>absolute</code>元素时，描述其距离<strong>外边距边界</strong>的距离</p>\n</li>\n<li><p>可以通过<code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code>这样的定位信息确定绝对定位元素的内容区大小</p>\n</li>\n<li><p><code>clip</code>通过<code>rect(top,right,bottom,left)</code>确定绝对定位元素的剪裁区域</p>\n</li>\n<li><p>绝对定位元素的静态位置为其<code>position</code>为<code>static</code>时的位置</p>\n</li>\n<li><p>对于绝对定位元素，垂直方向或水平方向设置<code>auto</code>可以垂直或水平居中</p>\n</li>\n<li><p>对于相对定位，如遇到过度受限的情况，一个值会设置为另一个的相反数，保证自洽。</p>\n</li>\n</ul>\n<h3 id=\"表布局\"><a href=\"#表布局\" class=\"headerlink\" title=\"表布局\"></a>表布局</h3><ul>\n<li><p>表显示值（即相关<code>display</code>）</p>\n</li>\n<li><p>以行为主</p>\n</li>\n<li><p>匿名表对象插入法则</p>\n</li>\n<li><p>表标题</p>\n</li>\n<li><p>表单元格（<code>border-collapse</code>, <code>border-spacing</code>, <code>empty-cells</code>）</p>\n</li>\n<li><p>单元格边框合并</p>\n</li>\n<li><p>表大小（<code>table-layout</code>, 高度, 对齐）</p>\n</li>\n<li><p>CSS的列和列组只能接受<code>border</code>，<code>background</code>，<code>width</code>，<code>visibility</code>四种属性</p>\n</li>\n<li><p>单元格垂直对齐有4种可选值，<code>top</code>, <code>bottom</code>, <code>middle</code>, <code>baseline</code></p>\n</li>\n</ul>\n<h3 id=\"列表和生成内容\"><a href=\"#列表和生成内容\" class=\"headerlink\" title=\"列表和生成内容\"></a>列表和生成内容</h3><ul>\n<li><p>列表类型、列表项图像、列表标志位置</p>\n</li>\n<li><p>插入生成内容（<code>content</code>，<code>attr(xxx)</code>, <code>quote</code>）</p>\n</li>\n<li><p>计数器（<code>counter-reset</code>, <code>counter-increment</code>）</p>\n</li>\n<li><p>列表样式可以简写为<code>&lt;list-style-type&gt; | &lt;list-style-image&gt; | &lt;list-style-position&gt;</code></p>\n</li>\n<li><p>在<code>quote</code>属性里指定开闭字符串后，可以通过content，结合<code>:before</code>，<code>:after</code>伪类插入开闭quote的标记</p>\n</li>\n</ul>\n<h3 id=\"用户界面样式\"><a href=\"#用户界面样式\" class=\"headerlink\" title=\"用户界面样式\"></a>用户界面样式</h3><ul>\n<li><p>系统字体（如<code>caption</code>等）</p>\n</li>\n<li><p>系统颜色（已废弃）</p>\n</li>\n<li><p>光标（<code>cursor</code>）</p>\n</li>\n<li><p>轮廓（<code>outline</code>）</p>\n</li>\n<li><p><code>cursor</code>有下面一些常见的值</p>\n<ul>\n<li><code>pointer</code> 用在超链接上</li>\n<li><code>text</code> 用来纯文本上</li>\n<li><code>move</code> 用来指示目标可以被拖动，相关的还有<code>e-resize</code>, <code>ne-resize</code>, <code>se-resize</code>等边缘的拖动标记</li>\n<li><code>crosshair</code> 用来指示可以选取范围，类似截屏的光标效果</li>\n<li><code>wait</code> 显示等待标记</li>\n<li><code>progress</code> 指示等待的状态，同时表示可以进行其他操作</li>\n<li><code>help</code> 显示帮助光标</li>\n<li><code>url()</code> 自定义光标图像，建议设置缺省值</li>\n</ul>\n</li>\n<li><p><code>outline</code>的设置类似<code>border</code>，由<code>outline-color</code>, <code>outline-style</code>, <code>outline-width</code>组成</p>\n</li>\n</ul>\n<h3 id=\"非屏幕媒体\"><a href=\"#非屏幕媒体\" class=\"headerlink\" title=\"非屏幕媒体\"></a>非屏幕媒体</h3><ul>\n<li><p>分页媒体（<code>size</code>和<code>page</code>等）</p>\n</li>\n<li><p>投影样式</p>\n</li>\n<li><p>声音样式（<code>speak</code>，<code>stress</code>，<code>richness</code>等）</p>\n</li>\n<li><p>可以在<code>&lt;link&gt;</code>标签的<code>media</code>属性里指定媒体类型，或是在CSS文件中通过<code>@media xxx &#123;&#125;</code>的形式指定</p>\n</li>\n</ul>\n",
            "tags": [
                "读书笔记",
                "CSS",
                "盒模型",
                "浮动"
            ]
        }
    ]
}
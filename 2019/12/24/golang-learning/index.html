<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="更多：go官网   题解：https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng&#x2F;go-learning-exercise  历史Go语言构想与2007年9月，于2009年11月发布。主要思想来自3种语言：  C，基础语法和编译 Pascal，包概念 CSP（Communication Sequential Process），并发思想  Go项目诞生是为了解决Google中系统复杂性太高的问">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言入门学习">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="更多：go官网   题解：https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng&#x2F;go-learning-exercise  历史Go语言构想与2007年9月，于2009年11月发布。主要思想来自3种语言：  C，基础语法和编译 Pascal，包概念 CSP（Communication Sequential Process），并发思想  Go项目诞生是为了解决Google中系统复杂性太高的问">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-24T15:03:54.000Z">
<meta property="article:modified_time" content="2020-05-12T14:34:39.296Z">
<meta property="article:author" content="shenlvmeng">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="语言学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/","path":"2019/12/24/golang-learning/","title":"go语言入门学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go语言入门学习 | Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Shenlvmeng's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">快速开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B1%EF%BC%9AHello-world"><span class="nav-number">2.1.</span> <span class="nav-text">范例1：Hello world</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B2%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">范例2：命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B3%EF%BC%9A%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="nav-number">2.3.</span> <span class="nav-text">范例3：寻找重复行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B4%EF%BC%9AGif"><span class="nav-number">2.4.</span> <span class="nav-text">范例4：Gif</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B5%EF%BC%9Afetch"><span class="nav-number">2.5.</span> <span class="nav-text">范例5：fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B6%EF%BC%9A%E5%B9%B6%E8%A1%8Cfetch"><span class="nav-number">2.6.</span> <span class="nav-text">范例6：并行fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B7%EF%BC%9Aweb-server"><span class="nav-number">2.7.</span> <span class="nav-text">范例7：web server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">2.8.</span> <span class="nav-text">杂项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">3.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">3.2.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%86%99%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">简写式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">3.3.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">new函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.3.4.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">3.4.</span> <span class="nav-text">赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7"><span class="nav-number">3.4.1.</span> <span class="nav-text">可赋值性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-number">3.5.</span> <span class="nav-text">类型声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-number">3.6.</span> <span class="nav-text">包和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#import"><span class="nav-number">3.6.1.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.6.2.</span> <span class="nav-text">包初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.7.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">复数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">布尔类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.5.1.</span> <span class="nav-text">字面量字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unicode%E8%A1%A8%E7%A4%BA"><span class="nav-number">4.5.2.</span> <span class="nav-text">Unicode表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CByte-Slices"><span class="nav-number">4.5.3.</span> <span class="nav-text">字符串和Byte Slices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B4%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.5.4.</span> <span class="nav-text">字符串和整型间的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">4.6.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E7%94%9F%E6%88%90%E5%99%A8iota"><span class="nav-number">4.6.1.</span> <span class="nav-text">常量生成器iota</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-number">4.6.2.</span> <span class="nav-text">无类型常量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">聚合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">5.1.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice"><span class="nav-number">5.2.</span> <span class="nav-text">slice</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#append%E5%92%8Ccopy"><span class="nav-number">5.2.1.</span> <span class="nav-text">append和copy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">5.3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct"><span class="nav-number">5.4.</span> <span class="nav-text">struct</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8Fstruct"><span class="nav-number">5.4.1.</span> <span class="nav-text">字面量struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct%E5%B5%8C%E5%85%A5%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%9F%9F"><span class="nav-number">5.4.2.</span> <span class="nav-text">struct嵌入与匿名域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON"><span class="nav-number">5.5.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML%E5%92%8C%E6%96%87%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.6.</span> <span class="nav-text">HTML和文本模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-1"><span class="nav-number">6.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">6.2.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.3.</span> <span class="nav-text">多返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">6.4.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">6.4.1.</span> <span class="nav-text">处理策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EOF"><span class="nav-number">6.4.2.</span> <span class="nav-text">EOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.3.</span> <span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.4.</span> <span class="nav-text">匿名函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">6.5.</span> <span class="nav-text">循环变量捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">变长参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88Deferred-Function-Calls%EF%BC%89"><span class="nav-number">6.7.</span> <span class="nav-text">延迟函数调用（Deferred Function Calls）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panic"><span class="nav-number">6.8.</span> <span class="nav-text">panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recover"><span class="nav-number">6.9.</span> <span class="nav-text">recover</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-2"><span class="nav-number">7.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88receiver"><span class="nav-number">7.2.</span> <span class="nav-text">指针receiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nil%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84Receiver"><span class="nav-number">7.3.</span> <span class="nav-text">Nil是合法的Receiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%92%8Cstruct-embedding"><span class="nav-number">7.4.</span> <span class="nav-text">组合和struct embedding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%80%BC%EF%BC%88method-value%EF%BC%89%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88method-expression%EF%BC%89"><span class="nav-number">7.5.</span> <span class="nav-text">方法值（method value）和方法表达式（method expression）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%EF%BC%9Abitset"><span class="nav-number">7.6.</span> <span class="nav-text">一个实例：bitset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">7.7.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">接口（interface）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E7%BA%A6%E5%AE%9A%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.1.</span> <span class="nav-text">作为约定的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%BB%A1%E8%B6%B3"><span class="nav-number">8.2.</span> <span class="nav-text">接口的满足</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8flag-Value%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用flag.Value解析命令行参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">8.3.</span> <span class="nav-text">接口值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%EF%BC%9Anil%E5%80%BC%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%9C%A8%E4%BA%8E%E9%9D%9Enil%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%80%BC%E4%B8%AD"><span class="nav-number">8.3.1.</span> <span class="nav-text">陷阱：nil值可以存在于非nil的接口值中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-Interface"><span class="nav-number">8.4.</span> <span class="nav-text">sort.Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-Handler%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.5.</span> <span class="nav-text">http.Handler接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.6.</span> <span class="nav-text">error接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8"><span class="nav-number">8.7.</span> <span class="nav-text">简单的数学表达式求值器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">8.8.</span> <span class="nav-text">类型断言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%86"><span class="nav-number">8.8.1.</span> <span class="nav-text">应用：错误类型区分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.8.2.</span> <span class="nav-text">方法查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-switch"><span class="nav-number">8.9.</span> <span class="nav-text">Type switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%BF%A0%E5%91%8A"><span class="nav-number">8.10.</span> <span class="nav-text">一些忠告</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine%E5%92%8C%E4%BF%A1%E9%81%93"><span class="nav-number">9.</span> <span class="nav-text">goroutine和信道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86goroutine"><span class="nav-number">9.1.</span> <span class="nav-text">认识goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">9.2.</span> <span class="nav-text">简单示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Clock-Server"><span class="nav-number">9.2.1.</span> <span class="nav-text">1. Clock Server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Echo-Server"><span class="nav-number">9.2.2.</span> <span class="nav-text">2. Echo Server</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%EF%BC%88channel%EF%BC%89"><span class="nav-number">9.3.</span> <span class="nav-text">信道（channel）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E4%BF%A1%E9%81%93%EF%BC%88Unbuffered-Channels%EF%BC%89"><span class="nav-number">9.3.1.</span> <span class="nav-text">无缓冲信道（Unbuffered Channels）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">9.3.2.</span> <span class="nav-text">流水线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E4%BF%A1%E9%81%93"><span class="nav-number">9.3.3.</span> <span class="nav-text">单向信道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E4%BF%A1%E9%81%93%EF%BC%88Buffered-Channel%EF%BC%89"><span class="nav-number">9.3.4.</span> <span class="nav-text">缓冲信道（Buffered Channel）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.4.</span> <span class="nav-text">并行循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E5%B9%B6%E5%8F%91web%E7%88%AC%E8%99%AB"><span class="nav-number">9.5.</span> <span class="nav-text">样例：并发web爬虫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B7%A5"><span class="nav-number">9.6.</span> <span class="nav-text">select实现多工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="nav-number">9.7.</span> <span class="nav-text">并发目录遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88"><span class="nav-number">9.8.</span> <span class="nav-text">取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">9.9.</span> <span class="nav-text">样例：聊天服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="nav-number">10.</span> <span class="nav-text">并发和共享变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E9%99%A9%EF%BC%88race-conditions%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">竞险（race conditions）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88sync-Mutex%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">互斥锁（sync.Mutex）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB-x2F-%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88sync-RWMutex%EF%BC%89"><span class="nav-number">10.3.</span> <span class="nav-text">读&#x2F;写互斥锁（sync.RWMutex）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="nav-number">10.4.</span> <span class="nav-text">内存同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88sync-Once%EF%BC%89"><span class="nav-number">10.5.</span> <span class="nav-text">懒初始化（sync.Once）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E9%99%A9%E6%A3%80%E6%B5%8B%E5%99%A8"><span class="nav-number">10.6.</span> <span class="nav-text">竞险检测器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%97%A0%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98"><span class="nav-number">10.7.</span> <span class="nav-text">样例：并发无阻塞缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.8.</span> <span class="nav-text">goroutine和线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%92%8CGo%E5%B7%A5%E5%85%B7"><span class="nav-number">11.</span> <span class="nav-text">包和Go工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#import%E8%B7%AF%E5%BE%84"><span class="nav-number">11.1.</span> <span class="nav-text">import路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8Cimport"><span class="nav-number">11.2.</span> <span class="nav-text">声明和import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%AF%BC%E5%85%A5"><span class="nav-number">11.3.</span> <span class="nav-text">空导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D-1"><span class="nav-number">11.4.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E5%B7%A5%E5%85%B7"><span class="nav-number">11.5.</span> <span class="nav-text">Go工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%BB%84%E7%BB%87"><span class="nav-number">11.5.1.</span> <span class="nav-text">工作区组织</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E4%B8%8B%E8%BD%BD"><span class="nav-number">11.5.2.</span> <span class="nav-text">包下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E6%9E%84%E5%BB%BA"><span class="nav-number">11.5.3.</span> <span class="nav-text">包构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E6%96%87%E6%A1%A3"><span class="nav-number">11.5.4.</span> <span class="nav-text">包文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%8C%85"><span class="nav-number">11.5.5.</span> <span class="nav-text">内部包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%8C%85"><span class="nav-number">11.5.6.</span> <span class="nav-text">查询包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">12.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-test%E5%B7%A5%E5%85%B7"><span class="nav-number">12.1.</span> <span class="nav-text">go test工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.</span> <span class="nav-text">测试函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.1.</span> <span class="nav-text">随机化测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="nav-number">12.2.2.</span> <span class="nav-text">测试一个命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.3.</span> <span class="nav-text">白盒测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E5%8C%85"><span class="nav-number">12.2.4.</span> <span class="nav-text">外部测试包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.5.</span> <span class="nav-text">写高效的测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E2%80%9C%E8%84%86%E5%BC%B1%E2%80%9D%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.6.</span> <span class="nav-text">避免“脆弱”的测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-number">12.3.</span> <span class="nav-text">覆盖率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.</span> <span class="nav-text">性能测试函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BE%A7%E5%86%99%EF%BC%88Profilling%EF%BC%89"><span class="nav-number">12.5.</span> <span class="nav-text">性能侧写（Profilling）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="nav-number">12.6.</span> <span class="nav-text">样例函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">13.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Type%E5%92%8Creflect-Value"><span class="nav-number">13.1.</span> <span class="nav-text">reflect.Type和reflect.Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%80%BC%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0Display"><span class="nav-number">13.2.</span> <span class="nav-text">递归值输出函数Display</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8reflect-Value%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-number">13.3.</span> <span class="nav-text">使用reflect.Value设置变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84field-tag"><span class="nav-number">13.4.</span> <span class="nav-text">访问结构体的field tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.5.</span> <span class="nav-text">展示类型的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%BF%A0%E5%91%8A-1"><span class="nav-number">13.6.</span> <span class="nav-text">一些忠告</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8E%E9%98%B6%E7%89%B9%E6%80%A7"><span class="nav-number">14.</span> <span class="nav-text">低阶特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe-Sizeof%EF%BC%8Cunsafe-Alignof%E5%92%8Cunsafe-Offsetof"><span class="nav-number">14.1.</span> <span class="nav-text">unsafe.Sizeof，unsafe.Alignof和unsafe.Offsetof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe-Pointer"><span class="nav-number">14.2.</span> <span class="nav-text">unsafe.Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cgo"><span class="nav-number">14.3.</span> <span class="nav-text">cgo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E4%B8%80%E4%BA%9B%E5%BF%A0%E5%91%8A"><span class="nav-number">14.4.</span> <span class="nav-text">再一些忠告</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">470</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go语言入门学习 | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go语言入门学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 23:03:54" itemprop="dateCreated datePublished" datetime="2019-12-24T23:03:54+08:00">2019-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-05-12 22:34:39" itemprop="dateModified" datetime="2020-05-12T22:34:39+08:00">2020-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2019/12/24/golang-learning/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/24/golang-learning/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>66k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:50</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>更多：<a target="_blank" rel="noopener" href="https://golang.org/">go官网</a></p>
</blockquote>
<blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://github.com/shenlvmeng/go-learning-exercise">https://github.com/shenlvmeng/go-learning-exercise</a></p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Go语言构想与2007年9月，于2009年11月发布。主要思想来自3种语言：</p>
<ul>
<li>C，基础语法和编译</li>
<li>Pascal，包概念</li>
<li>CSP（Communication Sequential Process），并发思想</li>
</ul>
<p>Go项目诞生是为了解决Google中系统复杂性太高的问题。因此，简单性是Go思想的重要部分。设计上，Go</p>
<ul>
<li>没有隐式类型转换</li>
<li>没有构造和析构函数</li>
<li>没有运算符重载</li>
<li>没有形参默认值</li>
<li>没有继承</li>
<li>没有泛型</li>
<li>没有异常</li>
<li>没有宏（macro）</li>
<li>没有函数注记</li>
<li>没有线程局部存储</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="范例1：Hello-world"><a href="#范例1：Hello-world" class="headerlink" title="范例1：Hello world"></a>范例1：Hello world</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在诸多语言中，C对Go的影响是最深的。<code>.go</code>文件需要经过编译成二进制文件才可以运行。</p>
<ul>
<li><code>go run</code>可以直接运行<code>.go</code>文件</li>
<li><code>go build</code>可以编译生成二进制文件，并在之后直接执行</li>
</ul>
<p>在代码结构上，</p>
<ul>
<li>先声明当前包名，其中命名为<code>main</code>的包名代表代码是可执行程序，而非一个库文件</li>
<li>再<code>import</code>依赖包，go自带100+内置包。在编译时，编译器会抛弃未被使用的包，减少体积</li>
<li>接下来是程序代码，命名为<code>main</code>的函数是执行的入口</li>
</ul>
<p>Go代码有着标准的代码格式，并可以通过<code>gofmt</code>格式化代码。<strong>代码中不需要在行尾写分号</strong>，后面紧跟特定token的换行符会自动转成分号。因此，Go代码中换行会影响代码编译。</p>
<h3 id="范例2：命令行参数"><a href="#范例2：命令行参数" class="headerlink" title="范例2：命令行参数"></a>范例2：命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 1</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s, sep <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">        s += setp + os.Args[i]</span><br><span class="line">        setp = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>切片（slice）是序列数组元素的表示方式，可以用<code>s[i]</code>或<code>s[m:n]</code>（m或n缺失是表示头和尾元素位置）获取1或n-m个元素。使用<code>len(s)</code>获取长度。</li>
<li>注释以<code>//</code>开头</li>
<li>import多个库时，可以用<code>()</code>包裹列表的形式声明，这种写法更为常见</li>
<li>使用<code>var</code>开头表示变量声明，未指定初始值的变量会隐式初始化为当前类型的“零值”（0或’’等）</li>
<li><code>:=</code>式的声明可以省去<code>var</code>更快地为一组变量初始化</li>
<li>go中的<strong>for循环是唯一的循环语句</strong>，分为以下三部分。缺失initialization和condition时可以表示while循环</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// zero or more statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 2</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s, sep := <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, arg := os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        s += sep + arg</span><br><span class="line">        sep = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环中，<code>range</code>可以生产一对值，index和value</li>
<li><code>_</code>专门用来替代不需要使用的变量名，否则go会报错</li>
<li>另外也可以直接用<code>strings.Join</code>方法实现效果</li>
</ul>
<h3 id="范例3：寻找重复行"><a href="#范例3：寻找重复行" class="headerlink" title="范例3：寻找重复行"></a>范例3：寻找重复行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    input = bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同<code>for</code>循环一样，<code>if</code>语句也不需要<code>()</code>包裹</li>
<li>内置的<code>make</code>函数可以创建一个新的map。map也可以被<code>for</code>循环遍历，每次循环的pair分别是key和value</li>
<li><code>counts[input.Text()]</code>中当key不存在时，会返回零值0</li>
<li>bufio库可以更方便地帮忙处理程序的输入（input）和输出（output）<ul>
<li><code>input.Scan()</code>获取下一行，并自动去掉末尾换行符，在没有内容时返回<code>false</code></li>
<li><code>input.Text()</code>获取当前位置的文本</li>
</ul>
</li>
<li><code>Printf</code>和C语言风格类似，里面行如<code>%s</code>，<code>%v</code>的特殊符号称为<em>verbs</em></li>
</ul>
<p>从文件中寻找代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    files := os.Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">        countlines(os.Stdin, counts)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">            f, err := os.Open(file)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">&quot;dup: %v\n&quot;</span>, err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            countLines(f, counts)</span><br><span class="line">            f.Close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, lines)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countlines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(f)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的流模式读取文件外，还可以直接把整个文件直接读进内存，再将二进制数据string化并处理。此处可以使用<code>io/ioutil</code>中的<code>ReadFile</code>方法。转换过程用<code>string(data)</code>完成。</p>
<p>日常使用时，通常借助bufio，ioutil等高层级API就可以完成任务，而不需要深入实现内部。</p>
<h3 id="范例4：Gif"><a href="#范例4：Gif" class="headerlink" title="范例4：Gif"></a>范例4：Gif</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;image&quot;</span></span><br><span class="line">	<span class="string">&quot;image/color&quot;</span></span><br><span class="line">	<span class="string">&quot;image/gif&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	whiteIndex = <span class="number">0</span></span><br><span class="line">	blackIndex = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lissajous(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		cycles  = <span class="number">5</span></span><br><span class="line">		res     = <span class="number">0.001</span></span><br><span class="line">		size    = <span class="number">100</span></span><br><span class="line">		nframes = <span class="number">64</span></span><br><span class="line">		delay   = <span class="number">8</span></span><br><span class="line">	)</span><br><span class="line">	freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">	phase := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">		img := image.NewPaletted(rect, palette)</span><br><span class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">			x := math.Sin(t)</span><br><span class="line">			y := math.Sin(t*freq + phase)</span><br><span class="line">			img.SetColorIndex(size+<span class="type">int</span>(x*size+<span class="number">0.5</span>), size+<span class="type">int</span>(y*size+<span class="number">0.5</span>), blackIndex)</span><br><span class="line">		&#125;</span><br><span class="line">		phase += <span class="number">0.1</span></span><br><span class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">	&#125;</span><br><span class="line">	gif.EncodeAll(out, &amp;anim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>const</code>声明常量，常量的值只能是number，string或boolean</li>
<li><code>gif.GIF&#123;...&#125;</code>是合成字面量的写法，其类型是struct，可以字面量声明其field，未声明fields均为零值（zero value）</li>
<li>image库API可以操作图像</li>
</ul>
<h3 id="范例5：fetch"><a href="#范例5：fetch" class="headerlink" title="范例5：fetch"></a>范例5：fetch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;http://&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.HasPrefix(url, prefix) &#123;</span><br><span class="line">			url = prefix + url</span><br><span class="line">		&#125;</span><br><span class="line">		resp, err := http.Get(url)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: %v\n&quot;</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		_, err = io.Copy(os.Stdout, resp.Body)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和网络相关的API都位于net库中，如<code>http.Get(url)</code></li>
<li><code>os.Exit(1)</code>代表异常退出</li>
</ul>
<h3 id="范例6：并行fetch"><a href="#范例6：并行fetch" class="headerlink" title="范例6：并行fetch"></a>范例6：并行fetch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">go</span> fetch(url, ch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2fs elapse\n&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	res, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprint(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	nbytes, err := io.Copy(ioutil.Discard, res.Body)</span><br><span class="line">	res.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprintf(<span class="string">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	secs := time.Since(start).Seconds()</span><br><span class="line">	ch &lt;- fmt.Sprintf(<span class="string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>goroutine是go中并行执行函数的表示，channel是goroutine间相互沟通的方式，传递特定类型数据。<strong>goroutine相互沟通时，沟通的两者会对其他goroutine block</strong>，保证没有冲突<ul>
<li>goroutine使用<code>go</code>创建，channel使用<code>chan</code>创建，<code>ch &lt;-</code>表示向channel发送，<code>&lt;- ch</code>表示从channel接收</li>
</ul>
</li>
<li><code>ioutil.Discard</code>输出流会直接丢弃流内容</li>
</ul>
<h3 id="范例7：web-server"><a href="#范例7：web-server" class="headerlink" title="范例7：web server"></a>范例7：web server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>http</code>库的<code>HandleFunc</code>和<code>ListenAndServer</code>可以便捷地启动一个服务器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handle)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/count&quot;</span>, counter)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;count %d\n&quot;</span>, count)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>server会为每个请求创建一个新的goroutine处理，为了避免并发读写count时的bug，使用了mutex锁保证读写是都是串行的</li>
<li><code>os.Stdout</code>,<code>ioutil.Discard</code>, <code>http.ResponseWriter</code>都实现了<code>io.Writer</code>接口，因此可以用在任何需要输出流的地方</li>
<li>if语句前可以增加前置语句，如<code>if err:=xxx; err != nil</code></li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li>go中的<code>switch</code>没有fall through机制，若需要，需要显示声明<code>fallthrough</code>。<code>case</code>支持表达式，<code>switch</code>后支持没有操作数，此时的switch称为tagless switch。<code>break</code>, <code>continue</code>, <code>goto</code>命令如常</li>
<li>go中有命名类型，类似ts中的<code>interface</code>，行如<code>type Point struct &#123; X, Y int &#125;</code></li>
<li>go中有指针，<code>*</code>表示去指针对应的值，<code>&amp;</code>表示取变量的指针，另外<strong>不支持指针上的算术运算</strong></li>
<li>go中的方法指命名类型上的函数，interface意义如常</li>
<li>可以去<a target="_blank" rel="noopener" href="https://golang.org/pkg">这里</a>寻找标准库的包，或去<a target="_blank" rel="noopener" href="https://godoc.org/">这里</a>寻找社区贡献的包</li>
<li>注释风格同其他语言，<code>//</code>表示单行注释，<code>/* */</code>表示多行注释。不支持嵌套注释</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>和JS类似</p>
<ul>
<li>以**Unicode字母或下划线<code>_</code>**开头</li>
<li>后跟<strong>Unicode字母或数字或下划线</strong></li>
<li><strong>大小写敏感</strong></li>
</ul>
<p>go目前（2020&#x2F;01&#x2F;01）有25个不允许用来命名的<strong>关键字</strong>，其中几个可能是对前端较难想到的是</p>
<ul>
<li><code>select</code></li>
<li><code>defer</code></li>
<li><code>chan</code></li>
<li><code>range</code></li>
<li><code>fallthrough</code></li>
</ul>
<p>另外，还有一些预定义常量、类型、函数<strong>可以用来命名</strong>，但很容易造成误解，下面举些例子：</p>
<ul>
<li>常量：<code>true</code> <code>iota</code> <code>nil</code></li>
<li>类型：<code>int</code> <code>complex128</code> <code>uintptr</code> <code>rune</code> <code>error</code></li>
<li>函数：<code>make</code> <code>len</code> <code>imag</code> <code>panic</code> <code>close</code></li>
</ul>
<p><strong>包名始终小写</strong>，在函数域内命名的函数只在函数域内可见，否则<strong>在整个包域内可见</strong>。整个包内声明的变量用首字母区分可见性：</p>
<ul>
<li><strong>首字母大写的可以被其他包访问</strong>，如<code>fmt.FPrintf</code></li>
<li>反之则只在包内可见</li>
</ul>
<p>命名长度没有限制，但建议<em>scope越大的变量命名越长</em>。Go使用驼峰风格的变量命名，首字母缩略词和首字母<strong>同大写或同小写</strong>。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明有4钟：</p>
<ul>
<li><code>var</code> 变量</li>
<li><code>const</code> 常量</li>
<li><code>type</code> 类型</li>
<li><code>func</code> 函数</li>
</ul>
<p>声明在函数域内可见，或在整个包域内可见。函数返回可以是一组变量。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = expression</span><br></pre></td></tr></table></figure>

<p>Go中的变量声明如上所示，其中的<code>type</code>部分或<code>expression</code>部分可以省略，<strong>但是不能同时省略</strong>。</p>
<ul>
<li>type缺失时，name的类型由expression字面量或返回值决定</li>
<li>expression缺失时，name的值<strong>自动设置为type类型的“零值”（zero value）</strong><ul>
<li>数值零值为0，字符串零值为<code>&quot;&quot;</code>，布尔类型零值为<code>false</code></li>
<li>其余接口或引用类型零值为<code>nil</code>，如指针、map、切片、函数、channel</li>
<li>聚合类型的零值即其所有组成元素的零值</li>
</ul>
</li>
</ul>
<p>所以，<strong>Go中不存在未初始化的变量</strong>。包级别变量在<code>main</code>函数开始前初始化，局部变量在声明过程中初始化。一组变量可以同时被初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">1.3</span>, <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">var</span> f, err = os.Open(name)</span><br></pre></td></tr></table></figure>

<h4 id="简写式"><a href="#简写式" class="headerlink" title="简写式"></a>简写式</h4><p>在<strong>函数域</strong>内的<strong>局部变量声明</strong>可以使用简写式，即<code>:=</code>。在已知变量初始值时可以省去写<code>var</code>。在初始值并不重要或最好显式写明类型时，还是使用<code>var foo type</code>的形式比较好。和<code>var</code>声明一样，也可以同时用简写式声明多个局部变量。但要注意，不要把这种写法和<em>元组赋值（tuple assignment）</em>搞混了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiple initialzier expression</span></span><br><span class="line">i, j := <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple assignment</span></span><br><span class="line">i, j = j, i</span><br></pre></td></tr></table></figure>

<p>另外，简写式声明里可以写<strong>部分</strong>已经声明的局部变量，在这里会当做赋值处理。但是简写式声明中要<strong>至少包含一个未声明变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.OpenFile(infile)</span><br><span class="line">out, err := os.OpenFile(outfile)</span><br></pre></td></tr></table></figure>

<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>Go中的指针和C中类似，用<code>&amp;</code>表示取一个<strong>变量</strong>的地址，用<code>*</code>表示访问某个地址所在的位置。指针的零值为<code>nil</code>，因此可以用<code>p != nil</code>来判断指针是否指向变量。</p>
<h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><code>new</code>函数</h4><p>可以通过<code>new</code>函数，声明类型<code>T</code>创建新的<strong>匿名</strong>变量，函数返回变量的指针即<code>*T</code>类型。这在不需要变量名时很好用。每次调用<code>new</code>函数新建变量时，返回的地址<strong>不同</strong>，<strong>除非类型不附加任何信息</strong>，如<code>struct &#123;&#125;</code>或<code>[0]int</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">*p = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>另外，由于<code>new</code>只是预定义函数，所以可以用来做变量名。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期即变量从创建到被回收的时间。包级别的变量会在整个程序执行过程中存在。局部变量则会在<em>未被引用（unreachable）</em>时释放内存。Go中的垃圾回收机制会自动帮你完成这件事。但是如果有下面这种情况出现，则会阻止垃圾回收释放内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	x = <span class="number">1</span></span><br><span class="line">	global = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，<code>x</code>局部变量从<code>f</code>函数中<strong>逃逸</strong>，并不会在<code>f</code>函数返回时被回收，持久存储在堆（heap）中。应尽量避免这种情况带来的额外内存损耗。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>和其余语言赋值没什么太大区别。</p>
<p>不同的是，额外增加了<strong>元组赋值</strong>。<code>=</code>右侧的一组变量会先求值，再赋给左侧变量。建议在不需要复杂运算时使用。同时，有些表达式和函数也会返回一组值，此时需要用元组赋值的方式接收。在不需要某个变量时，可以使用<code>_</code>占位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, y= y, x</span><br><span class="line"></span><br><span class="line">f, err = os.Open(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line">v, ok = m[key]</span><br><span class="line">v, ok = x.(T)</span><br><span class="line">v, ok = &lt;- ch</span><br></pre></td></tr></table></figure>

<h4 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h4><p>除了一些显式的赋值外，还有函数返回、字面量声明等。Go中的赋值<strong>当且仅当</strong><code>=</code>左右的值和变量<strong>类型相同</strong>才可进行（对于<code>==</code>和<code>!=</code>的判断也是这样）。<code>nil</code>可以赋值给任何复杂类型或引用类型。</p>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p>Go中可以定义类型。Go中的类型定义储存值的符号、它们的大小、固有操作以及方法，使用<code>type name underlying-name</code>声明。它通常出现在包级别，有些也会通过首字母大写的形式export出去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CTOF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123;</span><br><span class="line">	<span class="keyword">return</span> Fahrenheit(c * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FTOC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123;</span><br><span class="line">	<span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个有着相同底层类型的命名类型并不是同一种类型</strong>，也不能直接相互赋值和比较。但是可以使用<strong>强制类型转换</strong>转换到想同类型来比较。所有的类型<code>T</code>都有对应的强制类型转换操作<code>T(x)</code>。两个有相同类层类型或指向相同底层类型的未命名指针可以相互强制转换。另外，Go中的强制类型转换从不会在运行时出错。</p>
<p>比较特别的是，类型上还可以声明方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h3><p>Go中的包即其他语言中的库、模块。以实现模块化、封装、分发和重用。和Java类似，一个包的代码<strong>可以存放在多个文件内</strong>，通常位于同一个文件夹下。每个包都有相互隔离的命名空间，需要用·<code>image.Decode</code>的形式使用。需要<code>export</code>的变量、类型、函数使用<strong>首字母大写</strong>的形式。</p>
<p>建议在每个export出去的变量、类型、函数前使用注释说明。另外，建议在包开头留下<em>doc comment</em>，或将更多注释放在<code>doc.go</code>中。</p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;shenlvmeng/learning/tempconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		t, err := strconv.ParseFloat(arg, <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Strerr, <span class="string">&quot;convert error: %v\n&quot;</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		f := temconv.Fahrenheit(t)</span><br><span class="line">		c := tempconv.Celsius(c)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s = %s, %s = %s\n&quot;</span>, f, tempconv.FTOC(f), c, tempconv.CTOF(c))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个包都有自己的import路径，Go语言标准并不定义如何解释import路径，这一步交给解释工具完成。每个包的包名通常和路径的最后一段同名。为避免包名冲突，import可以指定包的别名。</p>
<p>在引用了未被使用的包时会报错。，借助<code>goimports</code>等工具和正确的IDE配置，可以在保存代码时自动标准化代码格式。</p>
<h4 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a>包初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">//third</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// first</span></span><br></pre></td></tr></table></figure>

<p>初始化时，先按照依赖的顺序初始化包级别变量。而<code>.go</code>文件的处理顺序则按照传给go编译器的顺序。初始化的过程是自底向上的，即当所有依赖包都初始化完成后，才会初始化<code>main</code>包，再执行<code>main</code>函数。对于初始化过程复杂的变量，可以在<code>init</code>函数中声明，而<code>init</code>是在程序启动时，按照声明的顺序一个一个执行的。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是编译时的，和运行时的生命周期概念相对应。作用域描述一个声明的可见范围。和C系列语言类似，用大括号<code>&#123;&#125;</code>包裹会形成<strong>词法块作用域</strong>。Go在<strong>全局作用域</strong>下预定义了一些常量、函数、类型等。在函数外声明的作用域是包级别的，<code>import</code>进来的包作用域是文件级别的。局部声明只在块作用域内。内部作用域会覆盖外部作用域的同名声明。</p>
<p>另外，Go中还有一些<strong>隐式</strong>的作用域，比如<code>for</code>，<code>if</code>，<code>switch</code>表达式中的作用域。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x := x[i]</span><br><span class="line">		<span class="keyword">if</span> x != <span class="string">&quot;o&quot;</span> &#123;</span><br><span class="line">			x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> <span class="comment">// 类似upperCase</span></span><br><span class="line">			fmt.Prinf(<span class="string">&quot;%c&quot;</span>, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>for</code>和<code>if</code>内部的x是一个单独的作用域。另外注意，简写式中会声明局部变量，会覆盖外部的同名变量，可能会带来意料之外的结果。可以通过<code>var xxx type</code>的形式声明变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cwd, err := os.Getwd() <span class="comment">// compile error: unused cwd</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><p>Go有4大类数据类型：</p>
<ul>
<li><strong>基础类型</strong>，即数字、字符串、布尔值</li>
<li><strong>聚合类型</strong>，即数组、struct</li>
<li><strong>引用类型</strong>，包括函数、指针、slice、map、channel</li>
<li><strong>接口类型</strong></li>
</ul>
<p>这一部分先说基础类型</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Go的数字类型包含了不同size的整型、浮点数和复数，以及它们的有无符号性。</p>
<p>整型有8、16、32、64四种长度，以及对应的signed和unsigned。组合一下即下面8种：</p>
<ul>
<li><code>int8</code></li>
<li><code>int16</code></li>
<li><code>int32</code></li>
<li><code>int64</code></li>
<li><code>uint8</code></li>
<li><code>uint16</code></li>
<li><code>uint32</code></li>
<li><code>uint64</code></li>
</ul>
<p>另外，<code>rune</code>是<code>int32</code>的别称，通常用来表示1个Unicode字符，<code>byte</code>是<code>unit8</code>的别称。<code>uintptr</code>用来表示一个可以承载任意指针值的无符号整型。</p>
<p>Go中对整型的处理和C风格很像。</p>
<ul>
<li>用首位表示符号位（signed int中）</li>
<li>类型承载范围和C一样，如int8表示-128到127</li>
<li>和C一样的操作符以及优先级，唯一区别是<code>&amp;^</code>表示位清除，<code>x &amp;^ y</code>表示根据y各位将x各位清0</li>
<li><code>&lt;&lt;</code>左移位，空位取0，<code>&gt;&gt;</code>右移位，无符号数补零，<strong>有符号数补符号位</strong></li>
<li>整型间除法会清除小数部分</li>
<li>取余<code>%</code>运算结果符号和被除数有关</li>
<li>超过位数的会溢出</li>
<li><code>0</code>开头表示八进制（通常用来表示POSIX系统中文件权限设置），<code>0x</code>表示十六进制</li>
</ul>
<p>不一样的是：</p>
<ul>
<li>相同类型才可比较大小，否则需要用<code>int()</code>强制转换为1种类型再比较。某些类型转换只改变值的使用方式，有些则会改变值，如<code>int</code>和<code>float</code>之间的转换</li>
<li>用<code>%d</code>, <code>%o</code>, <code>%x</code>分别表示整型、八进制和十六进制数</li>
<li>用<code>%c</code>表示显示对应的Unicode字符，<code>%q</code>显示带引号版本</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数有<code>float32</code>和<code>float64</code>两种类型，服从IEEE754标准。为保证精确性，通常使用<code>flaot64</code>。另外，还有以下特点</p>
<ul>
<li><code>.</code>前后的0可以省略</li>
<li><code>%g</code>, <code>%e</code>和<code>%f</code>分别打印最合适展示精确度版本、指数版本和原始版本</li>
<li>有<code>+Inf</code>, <code>-Inf</code>和<code>NaN</code>特殊值，表现类似JS</li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>Go有两种复数类型：<code>complex64</code>和<code>complex128</code>，它们其实是由<code>float32</code>和<code>float64</code>组成的。复数可以通过<code>complex</code>内置函数初始化，或者直接使用字面量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1 + 2i</span></span><br><span class="line">y := <span class="number">3</span> - <span class="number">4i</span></span><br></pre></td></tr></table></figure>

<p>复数间可以判断相等性，无法判断大小。<code>math/cmplx</code>包里包含一些复数的数学运算。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>即type <code>bool</code>，和其他语言类似，有短路行为，<code>&amp;&amp;</code>比<code>||</code>优先级更高。<code>bool</code>类型和整型之间不能相互隐式转换。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串表示<strong>一组不可修改的比特位序列</strong>，但通常用来承载可读的Unicode编码点。<code>len</code>返回字符串长度，<code>[i]</code>返回第<code>i</code>个<strong>字节</strong>处的值。越界读取会导致panic。</p>
<ul>
<li><code>s[i:j]</code>表示自带的substring操作，其中<code>i</code>和<code>j</code>均可省略</li>
<li>字符串间可以比较大小和相等性，其中大小通过逐字节子母序比较</li>
<li><code>+</code>可表示字符串拼接</li>
<li>不可变性：不允许修改字符串的值（如<code>s[0] = &#39;L&#39;</code>），这使得Go可以在底层复用字符串，节省内存</li>
</ul>
<h4 id="字面量字符串"><a href="#字面量字符串" class="headerlink" title="字面量字符串"></a>字面量字符串</h4><p>用双引号<code>&quot;</code>包裹，UTF-8编码。双引号中的反斜线<code>\</code>有特殊含义。如</p>
<ul>
<li><code>\n</code>表示换行</li>
<li><code>\t</code>表示制表符</li>
<li><code>\x</code>表示后接十六进制的高低位</li>
<li><code>\ooo</code>表示三个八进制位</li>
</ul>
<p>由反引号&#96;&#96; &#96;包裹的表示纯文本字面量，其中的换行和格式也会被跨平台保留。可以用来书写多行字符串。</p>
<h4 id="Unicode表示"><a href="#Unicode表示" class="headerlink" title="Unicode表示"></a>Unicode表示</h4><p>Go中使用UTF-8变长编码：</p>
<ul>
<li><code>0xxxxxxx</code>表示ASCII码</li>
<li><code>11xxxxxx 10xxxxxx</code> 表示两字节长度</li>
<li><code>110xxxxx 10xxxxxx 10xxxxxx</code>表示三字节长度</li>
<li><code>1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx</code> 表示四字节长度</li>
</ul>
<p>可以由<code>\uhhhh</code>表示16比特或<code>\U</code>表示32比特，如世界：<code>\u4e16\u754c</code>。<code>unicode</code>包和<code>unicode/utf8</code>包提供了编解码工具。<code>utf6.DecodeRuneInString</code>可以读取一个自然字符的数据，而非一个字节一个字节读取，<code>utf8.RuneCountInString</code>返回字符串的自然字符长度。幸运的是，<code>range</code>循环会自动调用utf8解码其中的自然字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode/uft8&quot;</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 13</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s) <span class="comment">// 9)</span></span><br></pre></td></tr></table></figure>

<p>当Go Unicode解析失败时，会使用特殊的Unicode占位符<code>\ufffd</code>，显示为带有问号的特殊字符。另外，<code>rune[]</code>可以直接将字符串转成编码后的每个Unicode编码点。这个rune数组进行<code>string()</code>强制类型转换后即原始字符串。当然你也可以直接<code>string()</code>装换一个整型数，不合规的整形数会得到上面提到的特殊字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;世界&quot;</span></span><br><span class="line">r := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="type">string</span>(r))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(<span class="number">65</span>))</span><br><span class="line">fmt.Printlf(<span class="type">string</span>(<span class="number">12341234</span>))</span><br></pre></td></tr></table></figure>

<h4 id="字符串和Byte-Slices"><a href="#字符串和Byte-Slices" class="headerlink" title="字符串和Byte Slices"></a>字符串和Byte Slices</h4><p><code>bytes</code>, <code>strings</code>, <code>strconv</code>, <code>unicode</code>是和string相关的几个包。<code>strings</code>提供基本的字符串搜索、比较、修改等操作，<code>bytes</code>提供修改字节数组的一些操作。有时，使用<code>byte.Buffer</code>类型，在操作字符串字节时会更有效率。<code>strconv</code>提供了将其他类型转成字符串和修饰字符串的操作函数。<code>unicode</code>提供了一些以rune为中心的函数，如<code>IsDigit</code>, <code>IsLetter</code>, <code>isUpper</code>等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basename removes directory and filename suffix</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basename</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	slash := strings.LastIndex(s, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">	s = s[slash+<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> dot := strings.LastIndex(s, <span class="string">&quot;.&quot;</span>); dot &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		s = s[:dot]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path</code>和<code>path/filepath</code>包提供了更多文件夹和目录的操作函数。</p>
<p>尽管字符串中的字节序列是不可更改的。<strong>其对应的字节序列数组则是可以自由修改的</strong>。<code>[]byte(s)</code>会分配一个字符串<code>s</code>的字节序列拷贝，也可以对应用<code>string(b)</code>还原。<code>bytes</code>包提供的<code>Buffer</code>类型可以很方便地承载<code>[]byte</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中，<code>WriteString</code>和<code>WriteByte</code>用于向Buffer中写入字节或字节序列，该类型还有许多其他应用场景。</p>
<h4 id="字符串和整型间的转换"><a href="#字符串和整型间的转换" class="headerlink" title="字符串和整型间的转换"></a>字符串和整型间的转换</h4><ul>
<li><strong>字符串 -&gt; 整型</strong>，<code>fmt.Sprintf</code>或<code>strconv.Itoa</code></li>
<li><strong>整型 -&gt; 字符串</strong>，<code>strconv.FormatInt</code>或<code>strconv.FormatUint</code>或<code>strconv.ParseInt</code>或<code>Atoi</code></li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量有以下几个基本特点:</p>
<ul>
<li>编译时即对编译器可知</li>
<li>必须是基础类型：boolean，string或number</li>
</ul>
<p>常量使用<code>const</code>声明，形式看起来和使用<code>var</code>类似，不过值是常量。对常量进行的所有操作，如数学运算、逻辑运算、比较、内置函数求值，都是在编译期就确定了。</p>
<p>常量可以组声明，声明时可以不显式声明类型，此时将使用右侧操作数推断常量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	noDelay time.Duration = <span class="number">0</span></span><br><span class="line">	timeout = <span class="number">5</span> * time.Minute</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, noDelay) <span class="comment">// &quot;time.Duration 0&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, timeout) <span class="comment">// &quot;time.Duration 5m0s&quot;</span></span><br></pre></td></tr></table></figure>

<p>还有个不常用的点：组声明时，<strong>除了第一个常量，剩下的常量可以不写右侧操作数</strong>，此时会使用<strong>上一个常量</strong>来初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b</span><br><span class="line">	c = <span class="number">2</span></span><br><span class="line">	d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="常量生成器iota"><a href="#常量生成器iota" class="headerlink" title="常量生成器iota"></a>常量生成器<code>iota</code></h4><p><code>iota</code>即常量生成器，它从0开始，每次常量声明后加一。利用这个规律可以方便地生成一组常量枚举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">	Monday</span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Saturday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="keyword">const</span> _ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * itoa)</span><br><span class="line">	KB</span><br><span class="line">	MB</span><br><span class="line">	GB</span><br><span class="line">	TB</span><br><span class="line">	PB</span><br><span class="line">	EB</span><br><span class="line">	ZB</span><br><span class="line">	YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h4><p>常量和变量不一样的点在，<strong>常量是可以不声明类型的</strong>，根据常量限定的类型，有下面一些类型：</p>
<ul>
<li>无类型整型</li>
<li>无类型Boolean</li>
<li>无类型rune</li>
<li>无类型浮点数</li>
<li>无类型复数</li>
<li>无类型字符串</li>
</ul>
<p>常量在使用时，会<strong>隐式</strong>转换成需要的类型，并在无法转换时抛出错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + i <span class="comment">// complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span> <span class="comment">// integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span> <span class="comment">// float -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span> <span class="comment">// rune -&gt; float64</span></span><br></pre></td></tr></table></figure>

<p>实际上，这些无类型常量有一个隐含类型，如:</p>
<ul>
<li>无类型整型 -&gt; <code>int</code></li>
<li>无类型浮点数 -&gt; <code>float64</code></li>
<li>无类型复数 -&gt; <code>complex128</code></li>
<li>无类型rune -&gt; <code>int32</code>（<code>rune</code>）</li>
</ul>
<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><p>基本类型是数据结构的组成“原子”。原子的组合就构成了“分子”——聚合类型：</p>
<ul>
<li>array</li>
<li>slices</li>
<li>maps</li>
<li>structs</li>
</ul>
<p>其中array和structs是聚合类型的基础，它们都有着<strong>固定大小</strong>。而slice和map则是动态大小。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])</span><br><span class="line">fmt.Println(f[<span class="built_in">len</span>(a)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<p>类似C风格，array表示由0或多个同一类型元素组成的<strong>定长序列</strong>。声明数组时，需要使用<strong>常量表达式</strong>作为数组长度。当数组元素全部列出时，可以用<code>...</code>代替长度。元素未声明初始值时，按零值（zero value）处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="number">1</span>[<span class="number">2</span>]) <span class="comment">// 0</span></span><br><span class="line">q = [...]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当元素较多时，还可以用index到value的键值对形式声明，未声明的值为零值。下面的例子中，<code>r</code>长度100，除了最后一个元素为-1之外，其余都为0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>若数组数组具有可比性，则数组也具有<strong>可比性</strong>。另外，不同长度的数组是不同类型。<code>[4]int</code>和<code>[3]int</code>不是同一类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := sha256.Sum256(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	c2 := sha256.Sum256(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\t\n&quot;</span>, c1 == c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go中将数组作为参数传递时，<strong>传递的是复制的新数组，而不是传入数组的引用</strong>，这是Go和其他语言不大一样的地方。当然可以通过传入数组指针的方式，实现在函数内修改数组内容。由于数组是定长的，在更多时候，函数参数使用slice类型传入。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice和array类型紧密相关，使用<code>[]T</code>声明。每个slice的底层都基于一个array。slice只是一个指针指向array中的某一个元素作为开始，除此之外，它还有<code>len</code>和<code>cap</code>函数分别用来表示切片长度，和切片最大容量（从切片开始到底层array结尾）。</p>
<p>因此不同slice可以共享同一个array，它们之间可以相互重叠。<code>s[i:j]</code>是从创建slice的方式，遵从左闭右开原则，<code>i</code>和<code>j</code>均可省略，省略时分别表示0和数组最末尾元素。<strong>创建可以基于一个array变量或一个array指针或其他slice</strong>。创建超过array范围会引起panic，只超过<code>len(s)</code>则会拓展这个slice。因为string实际上是<code>[]byte</code>切片，所以<code>s[i:j]</code>和<code>substring</code>是一个意思。</p>
<p>从上面可以看到，slice即一个指向数组元素的指针，所以传递一个slice时，可以修改底层array的值。下面这个反转数组的函数不限数组长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		s[i], s[j] := s[j], s[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>&#125;</span><br><span class="line">reverse(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// [5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>s</code>是一个切片字面量，和array的区别在于没有声明长度。这种写法实际上会生成以后面值为全部元素的数组，并把切片指向这个数组。类似地，还可以使用<code>make</code>创建一个切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>由于切片只是引用，从效率和可理解性上考虑，<strong>切片间不具有可比性</strong>。不过切片可以和<code>nil</code>比较，<code>nil</code>表示空切片，而非“没有元素”的切片。不过Go中slice相关的函数对待这两种切片行为一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> <span class="comment">// s == nil</span></span><br><span class="line">S = <span class="literal">nil</span> <span class="comment">// s == nil</span></span><br><span class="line">s = []<span class="type">int</span>(<span class="literal">nil</span>) <span class="comment">// s == nil</span></span><br><span class="line">s = []<span class="type">int</span>&#123;&#125; <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>

<h4 id="append和copy"><a href="#append和copy" class="headerlink" title="append和copy"></a><code>append</code>和<code>copy</code></h4><p><code>append</code>函数可以操作slice。如果append之后，slice长度超过了底层array的长度，<code>append</code>会自动拓展底层array长度。另外，append不仅可以追加单个元素，还可以追加任意个元素，或解构后的slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">	runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes)</span><br><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...)</span><br></pre></td></tr></table></figure>

<p>在不借助<code>append</code>实现类似<code>append</code>功能时，就需要自己借助<code>cap(x)</code>和<code>make</code>完成底层array的长度扩充。如同下面的一段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="type">int</span>, y ...<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="type">int</span></span><br><span class="line">	zlen := <span class="built_in">len</span>(x) + <span class="built_in">len</span>(y)</span><br><span class="line">	<span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">		z = x[:zlen]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		zcap := zlen</span><br><span class="line">		<span class="keyword">if</span> zcap &lt; <span class="number">2</span> * <span class="built_in">len</span>(x) &#123;</span><br><span class="line">			zcap := <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">		z = <span class="built_in">make</span>([]<span class="type">int</span>, zlen, zcap)</span><br><span class="line">		<span class="built_in">copy</span>(z, x)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(z[<span class="built_in">len</span>(x)], y)</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>...</code>表示剩余参数，</p>
<p>借助<code>copy</code>还能实现一些slice的原址操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="built_in">copy</span>(slice[i:], slice[i+<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map即键值对，其中<strong>key要求具有可比较性</strong>。map有两种构造方式：<code>make</code>或字面量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="string">&quot;Alice&quot;</span>: <span class="number">18</span>,</span><br><span class="line">	<span class="string">&quot;Bob&quot;</span>: <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map使用<strong>下标访问</strong>，使用<code>delete</code>删除键。另外，<strong>访问不存在的key时，值是<code>value</code>类型的零值</strong>。因此可以免去一些多余的初始化步骤。由于map的值并不是变量，所以不能用<code>&amp;</code>获取地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;Cindy&quot;</span>] = <span class="number">23</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;bob&quot;</span>)</span><br><span class="line"><span class="comment">// 新的key</span></span><br><span class="line">ages[<span class="string">&quot;Dred&quot;</span>] += <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">_ := &amp;ages[<span class="string">&quot;Cindy&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>map在遍历时，顺序是随机的。因此如果需要确定顺序，需要事先手动排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">	names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, names := <span class="keyword">range</span> names &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的<code>delete</code>，<code>len</code>，<code>range</code>和取值操作都可以对零值<code>nil</code>进行，但是存储到<code>nil</code>map时会报错。由于访问map不存在的key会返回默认的零值，所以下标操作用第二个参数返回是否对应的key，*且参数通常命名<code>ok</code>*。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;Ed&quot;</span>]; !ok &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go中没有<code>set</code>类型，可以用<code>map[string]bool</code>等价。当key可能不可比较时（如用slice做key），可以用额外的序列化使用。</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>struct类似ts中的<code>interface</code>。由<strong>零</strong>或多个fields组成，每个field使用<strong>点</strong>来访问。struct和field都是变量，所以可以用<code>&amp;</code>获取地址。对地址也可以使用点来访问field。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">	DoB time.Time</span><br><span class="line">	Position <span class="type">string</span></span><br><span class="line">	Salary <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e Employee</span><br><span class="line">e.Salary = <span class="number">1000</span></span><br><span class="line">pos := &amp;e.Position</span><br><span class="line">*pos = <span class="string">&quot;Senior &quot;</span> + *pos</span><br></pre></td></tr></table></figure>

<p>相同类型的两个key可以<strong>在一起声明</strong>。在Go的struct中，<strong>field的组合和排序都意味着不同的type</strong>。和包一样，大写的field被导出可被访问，这也是Go的一种通用的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Name, Address <span class="type">string</span></span><br><span class="line">	DoB time.Time</span><br><span class="line">	Position <span class="type">string</span></span><br><span class="line">	Salary <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct类型的field不能自指，但是允许包含自己类型的<strong>指针</strong>，比如最经典的二叉树场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left, right *tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct的零值由各field零值组成，不是nil，没有field的空struct写作<code>struct&#123;&#125;</code>。不携带信息，但可能在有些地方会有用。</p>
<h4 id="字面量struct"><a href="#字面量struct" class="headerlink" title="字面量struct"></a>字面量struct</h4><p>两种声明方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">int</span> &#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">anim := git.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有fields<strong>按顺序</strong>声明，struct的fields有任何改动都需要修改，所以通常只在小规模struct以及包内部使用</li>
<li>使用键值对方式声明，可以省略field，且对顺序不敏感</li>
</ul>
<p>另外，在Go中，所有的函数参数传递都是<strong>传值</strong>。因此，如果函数内部需要修改struct时，不能传递struct类型，而需要传递指针。由于struct传递指针的场景比较多，所以提供了类似<code>p := &amp;Point&#123;1, 1&#125;</code>的简写语法糖。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualPrize</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">	e.Salary = e.Salary * <span class="number">2</span> + <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果struct的所有field都具有可比性，则struct也具有可比性，可以比较是否相等。因此，struct在有些情况可以用来作为map的key。</p>
<h4 id="struct嵌入与匿名域"><a href="#struct嵌入与匿名域" class="headerlink" title="struct嵌入与匿名域"></a>struct嵌入与匿名域</h4><p>匿名域用于struct之间的组合，可以达到<em>类似</em>类继承的效果。在struct声明中，如果field类型是有名称的，则可以忽略掉field名，得到一个匿名域。匿名域类型或类型内的各field对应用struct可见。有点类似TS中<code>interface</code>的<code>extends</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point</span><br><span class="line">	Radius: <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">	Circle</span><br><span class="line">	Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span></span><br><span class="line">w.Y = <span class="number">10</span></span><br><span class="line">w.Radius = <span class="number">5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>换种说法，匿名域就是向下访问时可以省去不写的中间域。即使中间域类型是首字母小写不对外可见的，只要剩下域对外可见也可以访问。struct这种<strong>组合</strong>思想是Go在面向对象上的核心。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>编解码JSON数据的方法都位于<code>encoding/json</code>，其中编解码整块数据的函数分别为<code>json.Marshal</code>和<code>json.Unmarshal</code>，前者传入Go数据结构，返回压缩后的JSON字符串，使用<code>json.MarshalIndent</code>可以返回美化后的JSON字符串。编码时，<strong>只有被导出的域才会出现在JSON字符串中</strong>。且field之后的<em>field tag</em>可以作为metadata修改JSON行为，如指定被JSON字符串化之后的key名。或用下面的<code>omitempty</code>忽略掉零值的key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	Year <span class="type">int</span> <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">	Color <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">	Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相反，在解码JSON数据时，需要显式声明struct结构来接收JSON数据。<code>json.Unmarshal</code>方法的第二个入参即struct的指针。在解析JSON时，对key是不区分大小写的，因此只需要对<code>a_b</code>类型的JSON key指定<em>field tag</em>。</p>
<p>对于stream格式的JSON数据，使用<code>json.Encode</code>和<code>json.Decode</code>编解码。</p>
<h3 id="HTML和文本模板"><a href="#HTML和文本模板" class="headerlink" title="HTML和文本模板"></a>HTML和文本模板</h3><p><code>text/template</code>和<code>html/template</code>用于文本模板和HTML模板。它们都使用双花括号包裹带有逻辑的简单语句。其中，<code>html/template</code>还会默认对文本做escape脱敏处理（对<code>template.HTML</code>不会escape）。</p>
<ul>
<li>使用<code>template.New</code>创建模板</li>
<li><code>template.Funcs</code>向模板内插入函数</li>
<li><code>template.Must</code>保证模板有内容</li>
<li><code>template.Parse</code>解析模板</li>
<li>使用模板的<code>Execute</code>方法生成解析后内容</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = template.Must(template.New(<span class="string">&quot;issueList&quot;</span>)).Funcs(</span><br><span class="line">	template.FuncMap(<span class="string">&quot;daysAgo&quot;</span>: daysAgo)</span><br><span class="line">).Parse(templ)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result, err := github.SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相同类型入参可以聚合<code>x, y int</code></li>
<li>返回值为多个时，需要用<code>()</code>包裹</li>
<li>返回值也可以给予变量名，这种情况下，相当于提前为返回值声明变量</li>
<li>入参是<strong>传值</strong>，即入参会复制一份传递给函数内部，只有像slice、map、function、channel这种引用实现的类型在函数内改变会影响外部值</li>
<li>只有函数声明，没有函数体的函数表示函数由其他语言实现，如<code>func Sin(x float64) float64</code></li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Go的递归和其他语言无异。不同的是，传统语言的函数递归借助<strong>定长的栈</strong>实现，大小从64KB到2MB不等，而Go使用<strong>变长栈</strong>实现，避免的栈溢出的情况。</p>
<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>Go支持同时返回多个返回值。同类型返回值可以压缩，还可以声明有名称的返回值。在多返回值时，还可以直接传递给需要多个入参的函数，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.Println(findLinks(url))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">links, err := findLinks(url)</span><br><span class="line">log.Println(links, err)</span><br></pre></td></tr></table></figure>

<p>返回值有名称时，会<strong>作为函数体内最外层变量出现</strong>。因此，不需要显示<code>return</code>返回值，这种现象也称为“裸返回”（<em>bare return</em>）。由于裸返回时，<code>return</code>后不会跟随返回值，不利于代码可读性，所以只在需要的时候使用它。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>函数<em>返回</em>错误在Go中是普遍现象。有时，错误类型只需要有1种，这时通常用<code>bool</code>类型的<code>ok</code>表示。如对<code>map</code>类型的变量的访问。但大多数时候，错误原因可能要有比较多种，这时可以用<code>error</code>类型的<code>err</code>表示。</p>
<p>在Go中较少使用exception表示失败（尽管Go也有exception机制），Go只在真正的bug处，才使用异常打印stack trace信息。在Go中较常出现的是普通的error类型，它只作为普通控制流的一部分。</p>
<h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><p>error处理由调用方负责，有5种策略：</p>
<ul>
<li><strong>向上传递</strong>，在没有error时，可以用<code>fmt.Errorf</code>制造一个自定义错误信息的错误。Go建议仔细设计错误信息内容，<strong>不使用大写字母，不使用换行</strong>。建议函数的每一层补充上更多信息。</li>
<li><strong>重试</strong>，在有些场景下，如测试服务端连接</li>
<li><strong>退出</strong>，严重问题时，可以用<code>os.Exit(1)</code>退出，或者用<code>log.Fatalf</code>打印错误信息后退出</li>
<li><strong>打印日志后继续</strong>，对于简单问题，可以打印日志后继续流程</li>
<li><strong>忽略</strong>，在特殊情况下，可以直接忽略，如错误确实不会影响功能实现</li>
</ul>
<p>Go建议是使用函数时考虑错误处理的场景。</p>
<h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>EOF（End Of File）是一种特殊的错误类型，<code>io.EOF</code>表示输入流没有更多内容了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := is.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><blockquote>
<p>这一章很类似JS或TS</p>
</blockquote>
<p>Go中函数是<em>一级成员</em>。这意味着，它可以作为一种类型，传递给变量、入参或者返回，就像其他值的类型一样。函数是一种引用类型，所以可以为<code>nil</code>，但是<strong>执行<code>nil</code>会导致panic</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="literal">nil</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// call of nil panic</span></span><br></pre></td></tr></table></figure>

<p>再次基础上，就可以对函数做更灵活而精准的设计，拆分函数关注点和抽象层次。构造出更灵活的程序。以<code>strings.Map</code>为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;Admin&quot;</span>)) <span class="comment">// Benjo</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Go中只能在包级别声明有名函数，而匿名函数可以在块作用域、函数作用域内声明。因此，<strong>高阶函数</strong>、<strong>闭包</strong>等概念Go中也有。由于这些概念JS中也有，这里就不再赘述。</p>
<h3 id="循环变量捕获"><a href="#循环变量捕获" class="headerlink" title="循环变量捕获"></a>循环变量捕获</h3><blockquote>
<p>JS也有类似问题，不过原因不同</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一段会有问题的代码</span></span><br><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的for循环中，循环变量<code>dir</code>在<code>append</code>的回调中有使用，我们回忆一下，for循环中循环变量位于for语句块外，在整个for循环后才销毁。所以这会导致每一个回调执行时，dir都被更新为最新的值。将dir在循环体内再次赋值即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    <span class="comment">// 可以运行</span></span><br><span class="line">    dir := dir</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似JS中的剩余参数，Go中也使用<code>rest ...type</code>表示函数的剩余入参。rest需要声明类型，rest为slice类型。要注意的是，这种函数和直接传入一个slice参数的函数类型并不一样。另外，在剩余参数类型不明确时，可以用<code>interface&#123;&#125;</code>表示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在变量后使用`...`表示解构</span></span><br><span class="line">val := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(sum(values...))</span><br></pre></td></tr></table></figure>

<h3 id="延迟函数调用（Deferred-Function-Calls）"><a href="#延迟函数调用（Deferred-Function-Calls）" class="headerlink" title="延迟函数调用（Deferred Function Calls）"></a>延迟函数调用（Deferred Function Calls）</h3><p>在语句前加上<code>defer</code>标识符，会让<code>defer</code>后的<strong>函数调用</strong>推迟到所在函数的**<code>return</code>之后**执行。<code>defer</code>后的函数和表达式会立即求值。<code>defer</code>的函数调用在函数panic后仍然会被调用。可以用来执行一些释放资源的操作，如以下场景：</p>
<ul>
<li>open和close</li>
<li>connect和disconnect</li>
<li>lock和unlock</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最合适的使用时机是在刚刚获得资源之后</strong>。还可以利用defer完成<em>进入</em>和<em>离开</em>函数的成对操作做一些调试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> trace(<span class="string">&quot;bigSlowOperation&quot;</span>)()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    log.Printf(<span class="string">&quot;enter %s&quot;</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于defer在函数最后执行的特点，甚至可以在defer中<strong>获取和修改函数返回值</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时也由于defer的这个特点，在for循环中使用defer一定要谨慎。</p>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>Go中的panic类似于其他语言的exception，它一般代表程序中存在bug和不应该出现的情况。panic后，正常程序执行停止，<strong>defer的函数被倒序执行</strong>，然后函数崩溃并带有错误信息。</p>
<p>除了系统触发的panic，还可以直接通过<code>panic(&quot;certain message&quot;)</code>手动触发一个panic。一些包中以<strong>Must</strong>开头的API通常表示，在不符合规范的时候API会panic。<strong>建议只在内部可信任环境下使用这种API</strong>。</p>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>就像其他语言中的try catch一样，Go中的panic同样有机制去妥善处理。Go有内置的<code>recover</code>函数，可以用于在panic中恢复。</p>
<ul>
<li><code>recover</code>需要在defer的函数中使用</li>
<li><code>recover</code>函数会返回panic的value，在没有panic的情况下，该函数返回<code>nil</code></li>
</ul>
<p>下面是一些使用<code>recover</code>的建议：</p>
<ul>
<li>不要毫无条件地从panic中recover，这可能会掩盖一些潜在的bug或资源泄露</li>
<li>在panic后，可以使用<code>runtime.Stack</code>这样的方法打印一下错误的详细信息，再recover</li>
<li>可以定义一些外部不可见的类型，在调用panic时传入，在recover返回时判断类型，从而做到针对特定情况panic执行recover，其余情况仍旧panic</li>
<li>对于预期中的error不使用panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span></span> (title <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            <span class="comment">// no panic</span></span><br><span class="line">        <span class="keyword">case</span> bailout&#123;&#125;:</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;multiple titles&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">panic</span>(p) <span class="comment">// resume panic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go也有OOP的特性，即<em>对象</em>上具有<em>方法</em>，方法需要关联在一个特定类型上。</p>
<h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明里，在普通声明的函数名前，增加函数绑定的类型receiver，即完成了方法的声明。Go中没有<code>this</code>和<code>self</code>这样的保留字。类型receiver中的变量，即方法可以访问的类型变量。变量名由于会比较常用，所以通常取类型首字母。</p>
<p>其他方法的行为类似其他OOP语言：诸如方法名和函数名不在一个命名空间，所以可以重名；方法名之间不能重名；<strong>方法名不能和属性名相同</strong>。由于Go中声明命名类型比较自由，而方法可以很方便绑定在命名类型上，所以可以给基础类型，如数字、字符串等，增加新方法。</p>
<h3 id="指针receiver"><a href="#指针receiver" class="headerlink" title="指针receiver"></a>指针receiver</h3><p>上面提到，访问方法需要一个receiver。除了变量本身，指针也可以作为receiver。在Go中函数入参都是传值的，也就是传入值的复制。所以除了map、slice这种引用类型，其余类型的值在方法内改变并不会影响到外部。如果需要方法改变receiver本身的话，可以指定将方法绑定在指针类型上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r)</span><br></pre></td></tr></table></figure>

<p>通常会规定，如果类型上有方法是指针类型的receiver，所有的方法都需要有一个指针类型receiver。类似struct一节介绍的，如果变量具有类型<code>T</code>，而方法的receiver是<code>*T</code>，我们可以直接使用简写的<code>p.ScaleBy(2)</code>而不需要写成<code>(&amp;p).ScaleBy(2)</code>。相反地，receiver要求类型<code>T</code>，变量传入<code>*T</code>也是可以的。</p>
<p>但是，直接将字面量传入给指针类型的receiver是不允许的，如<code>Point&#123;1, 2&#125;.ScaleBy(2)</code>。</p>
<h3 id="Nil是合法的Receiver"><a href="#Nil是合法的Receiver" class="headerlink" title="Nil是合法的Receiver"></a>Nil是合法的Receiver</h3><p>Go中，<code>nil</code>在很多时候是合法的零值。同样也可以作为receiver。当然在你的命名类型中，最好对合法的<code>nil</code>类型加以说明。Go的内置类型和操作，如slice，map、struct、append、make等也可以正常地处理<code>nil</code>。</p>
<h3 id="组合和struct-embedding"><a href="#组合和struct-embedding" class="headerlink" title="组合和struct embedding"></a>组合和struct embedding</h3><p>在此前的struct一节中，已经介绍了Go的struct embedding设计。这里结合方法继续讨论一下。首先我们先回忆下struct embedding是啥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">cp.X = <span class="number">1</span></span><br><span class="line">fmt.Println(cp.Point.X)</span><br><span class="line">cp.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Print;n(cp.Y)</span><br></pre></td></tr></table></figure>

<p>匿名的field会直接将field类型中的<strong>成员和方法</strong>都<strong>组合</strong>（composite）进当前类型中（和TS中的extends有点像）。如上面的<code>ColoredPoint</code>就直接拥有了<code>Point</code>的<code>Distance</code>和<code>ScaleBy</code>功能（当然也可以访问Point）。Go更希望用<strong>组合</strong>（composition）而非<strong>派生</strong>（derivation）构造更复杂的类型。比如，上面的<code>ColoredPoint</code>并不是一个<code>Point</code>，并不能当做一个Point访问和使用。</p>
<p>匿名field如果是指针类型，除了上面的特性，还能实现让两个变量共享一个底层的结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line">p := ColoredPoint&#123;&amp;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line">q := ColoredPoint&#123;&amp;Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">p.Point = q.Point</span><br></pre></td></tr></table></figure>

<p>在访问receiver上的方法时，Go首先会去直接声明的field中寻找，然后再去embedded的field中寻找，再向下寻找。方法只能在命名类型和其指针类型上定义，但是借助struct embedding也可以实现，将<strong>功能聚合</strong>在一起。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    v := mapping[key]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面重写之后的代码表现力明显更好了。</p>
<h3 id="方法值（method-value）和方法表达式（method-expression）"><a href="#方法值（method-value）和方法表达式（method-expression）" class="headerlink" title="方法值（method value）和方法表达式（method expression）"></a>方法值（method value）和方法表达式（method expression）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">distanceFromP := p.Distance</span><br><span class="line">fmt.Println(distanceFromP(q))</span><br><span class="line"></span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second(), r.Launch)</span><br></pre></td></tr></table></figure>

<p><code>p.Distance</code>会得到一个method value，它是一个绑定到了特定receiver上的一个方法，本身也是一个函数。可以当做函数类型的值用作入参或返回值。这个和JS还比较像。</p>
<p>类似的，Go中还有method expression的概念。即直接用类型名加点（<code>.</code>）访问方法得到一个method expression。它也是一个函数，可以<strong>看做是一个没有绑定receiver的方法</strong>。调用函数时，传入的第一个入参会当做receiver，后续的作为方法入参。这个特性在需要根据情况灵活选择方法时很好用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Add(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Sub(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> path []Point</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> TranslateBy(offset Point, add <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span></span> Point</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        op = Point.Add</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = Point.Sub</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        path[i] = op(path[i], offset)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个实例：bitset"><a href="#一个实例：bitset" class="headerlink" title="一个实例：bitset"></a>一个实例：bitset</h3><ul>
<li><code>bytes.Buffer</code>经常用来拼接字符串</li>
<li><code>fmt</code>的print打印字符串时会调用变量的<code>String</code>方法</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>首先，Go的封装细粒度只到package一层，package内不控制可见性</strong>。所以当你想要控制可见性时，需要用拆分package实现。</p>
<p>封装用来掩盖不需要像使用者展示的信息和细节。Go中唯一用来控制可见性的手段是一个<strong>大小写约定</strong>：大写表示从包中导出，小写表示包内可见，对于struct中的field以及类型的method也是如此（包外访问不了，包内随便访问）。通常来讲，<strong>当需要封装对象时，我们都会使用struct</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    words []<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不建议</span></span><br><span class="line"><span class="keyword">type</span> IntSet []<span class="type">uint64</span></span><br></pre></td></tr></table></figure>

<p>使用struct封装本来就很简单的类型有以下几个原因：</p>
<ul>
<li>使用方无法修改对象值，这样只用查阅更少的声明，就能得到对象值大致的可能范围</li>
<li>对使用方掩盖实现细节，可以避免让使用方依赖那些可能改变的内容，也给开发者重构空间，开发者可以在不改变API兼容性的情况下灵活调整内部实现</li>
<li>避免使用方任意修改对象值，造成更多边缘情况，提高程序编写难度和程序不稳定性</li>
</ul>
<p>有时，封装也会暴露出一些<strong>getter</strong>和<strong>setter</strong>。通常命名上，会直接使用field的首字母大写形式，省去不必要的<code>Get</code>，<code>Fetch</code>，<code>Lookup</code>前缀。实际上，Go并不禁止导出field，只是在有些情况下，导出field会影响代码可靠性。</p>
<p>封装并不总是必要的。有时，底层数据结构是目标数据结构的<strong>充要表示</strong>，不多不少，场景变数不多，这时可以不用struct封装。但是，像IntSet这种，实现细节变数多，程序实现稳定性低，需要被保护起来，避免影响使用者。从而要采取封装的方式，把那些变数变得“不透明”。</p>
<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><p>如其他OOP语言一样，Go中也有用于标识抽象类型的接口描述。不同的是，Go中的接口都是<strong>隐式</strong>满足的，松耦合。</p>
<h3 id="作为约定的接口"><a href="#作为约定的接口" class="headerlink" title="作为约定的接口"></a>作为约定的接口</h3><p>之前介绍过的所有类型都是<strong>具体类型</strong>（concrete type），具体类型指数据表示和行为实现在类型确定后，就已一清二楚。为了保证语言灵活性，Go中还有<strong>接口类型</strong>（interface type）。这种类型不暴露内在结构和实现细节，而是给出接口输入输出，作为一种<strong>约定</strong>交由具体实现方完成，从而实现依赖反转（DI）。这一概念的设计上和其他OOP语言无二。不过在使用上，Go并不要求实现方明确依赖关系，只需实现约定即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span> &#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ...comments</span></span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，实现<code>String</code>方法也让类型隐式满足了<code>fmt.Stringer</code>的定义。Go中单方法interface的命名，通常以动词的名词形态为主。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中也有类似struct embedding的<strong>嵌入式写法</strong>，简化interface的组合成本。另外，interface中方法的顺序不影响interface类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的满足"><a href="#接口的满足" class="headerlink" title="接口的满足"></a>接口的满足</h3><p>Go中变量可以是接口类型，在给接口类型变量赋值时，需要检查值的方法是否满足了接口的类型定义，这一点和其他OOP语言相似。要注意，尽管Go有将变量<code>T</code>转成<code>*T</code>的隐式转换，但是类型<code>T</code>的方法和<code>*T</code>的方法receiver并不同。而通常具体类型中会在接口声明的方法中做一些写操作，因而指定receiver为指针类型，这有可能会导致无法满足接口定义。</p>
<p>接口覆盖了其包裹的内部类型，所以，<strong>即使内部类型满足其他方法，赋值给接口类型后，也只能方法接口拥有的方法</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK</span></span><br><span class="line">w.Close() <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>Go中还有一个通用的不可或缺的类型<code>interface&#123;&#125;</code>它表示对类型没有任何要求，同时也意味着该类型变量上无法执行任何操作，类似ts中的<code>Unknown</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>Go中具体类型对接口类型的满足都是隐式的，无需显式声明。所以一个具体类型可能会同时满足很多接口类型。可以把接口类型认为是将一些具体类型中公共的部分抽象出来的共同行为，将之作为<strong>grouping</strong>出来的共性。</p>
<h4 id="使用flag-Value解析命令行参数"><a href="#使用flag-Value解析命令行参数" class="headerlink" title="使用flag.Value解析命令行参数"></a>使用<code>flag.Value</code>解析命令行参数</h4><ul>
<li><code>fmt.Sscanf</code>可以从输入中按格式解析出特定类型参数</li>
</ul>
<h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>Go中，接口类型可以作为变量的合法类型。接口类型值因此具有<strong>动态类型</strong>和<strong>动态值</strong>。在Go中可以近似用类型描述符（type descriptor）表示，其中type表示具体类型，value表示具体值。在初始化时，type和value都是<code>nil</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        +-----------+</span><br><span class="line">type    |    nil    |</span><br><span class="line">        +-----------+</span><br><span class="line">value   |    nil    |</span><br><span class="line">        +-----------+</span><br></pre></td></tr></table></figure>

<p>而在第二和第三行，为w赋值为<code>os.Stdout</code>以及<code>*bytes.Buffer</code>类型时，type分别会变成<code>os.Stdout</code>和<code>*bytes.Buffer</code>，同时value也会被设置为对应初始值的指针。这个过程会完成类似于<code>io.Writer(os.Stdout)</code>的隐式类型转换。此时访问<code>w</code>的方法，会被动态分配到value上实现。而在最后又将<code>w</code>还原为初始值<code>nil</code>。</p>
<p>接口类型之间<strong>不一定</strong>可以比较，当接口值都为<code>nil</code>或接口值对应的具体类型相同以及具体值相同时，接口值相同。然而，如果具体类型不可比较时（如slice，function等），接口类型也不可比较。Go的<code>fmt</code>中，可以用<code>%T</code>打印变量类型。</p>
<h4 id="陷阱：nil值可以存在于非nil的接口值中"><a href="#陷阱：nil值可以存在于非nil的接口值中" class="headerlink" title="陷阱：nil值可以存在于非nil的接口值中"></a>陷阱：nil值可以存在于非nil的接口值中</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;</span><br><span class="line">    f(buf)</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;woops!\n&quot;</span>)) <span class="comment">// panic: nil pointer derefence</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的判断中，<code>out</code>已经有了具体的类型，因此接口类型的<code>out</code>不等于<code>nil</code>，然而<code>out</code>的具体值却是<code>nil</code>，这使得<code>Write</code>行为无法保证。解决办法是，在一开始为<code>buf</code>声明为<code>io.Writer</code>类型即可。</p>
<h3 id="sort-Interface"><a href="#sort-Interface" class="headerlink" title="sort.Interface"></a><code>sort.Interface</code></h3><p>Go使用sort包中的<code>sort.Interface</code>实现排序功能。同时对于常见类型string、int等也有事先封装好的<code>sort.Strings()</code>，<code>sort.Int()</code>。对于自定义类型，在实现<code>sort.Interface</code>接口后，也可使用<code>sort.Sort</code>排序。接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个方法分别用来<strong>返回长度</strong>、<strong>比较大小</strong>和<strong>交换顺序</strong>。这也是排序的几个基本操作。下面给出了字符串排序的内部实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在排序struct等复杂类型slice时，建议定义指针类型数组，这样可以让swap时速度更快</strong>。</p>
<p>sort还有一个方便的反向排序方法<code>sort.Reverse</code>，它借助了struct embedding，用一个内部类型<code>reverse</code>封装了外部实现接口的类型，另外，直接在<code>reverse</code>上定义了Less，覆盖了<code>Interface</code>的实现，从而实现了反向排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123; Interface &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less (i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> r.Interface.Less(j, i) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(i Interface)</span></span> Interface &#123; <span class="keyword">return</span> reverse&#123;i&#125; &#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(sort.Reverse(byArtist(tracks)))</span><br></pre></td></tr></table></figure>

<p>除了slice类型外，其他实现了<code>sort.Interface</code>接口的类型一样可以排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    t []*Track</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.t) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Swap(i, j <span class="type">int</span>) &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><code>http.Handler</code>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="type">string</span>, h Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>实现了这个接口的可以传递给<code>ListenAndServe</code>。但通常用不到这种原始的方式。Go的http包提供的<code>ServeMux</code>类型可以给请求分路，聚合一堆<code>http.Handlers</code>。写起来像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoe&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>http.HandlerFunc</code>将传入的函数包裹成了满足<code>Handler</code>接口的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的使用还是要写一些模板代码，对此可以将<code>mux.Handler</code>简写成<code>mux.HandlerFunc(&quot;list&quot;, db.list)</code>。可以再减少一点代码。实际上，http还提供了一个全局的<code>ServeMux</code>对象实例<code>DefaultServeMux</code>，不需要手动创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    http.HandlerFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">    http.HandlerFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>go中每一个handler都在一个单独的goroutine上，要妥善处理好并发的情况。</strong></p>
<h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><code>error</code>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code>类型实现了<code>error</code>接口。整个<code>errors</code>包都围绕这个接口设计，除了<code>errors.New()</code>方法，还可以直接通过<code>fmt.Errorf</code>返回一个格式化后的error值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="type">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.text &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, arags ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单的数学表达式求值器"><a href="#简单的数学表达式求值器" class="headerlink" title="简单的数学表达式求值器"></a>简单的数学表达式求值器</h3><p>递归的AST解析</p>
<p>略。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（type assertion），写作<code>x.(T)</code>，通常用来将动态类型限定到更严格的类型。</p>
<ul>
<li><code>T</code>是具体类型时，会判断<code>x</code>类型是否和<code>T</code><strong>一致</strong>，是则将<code>x</code>类型设置为<code>T</code>，否则<code>panic</code></li>
<li><code>T</code>是抽象类型interface时，会判断<code>x</code>是否<strong>满足</strong><code>T</code>接口，是则将<code>x</code>类型设置为接口<code>T</code>，否则panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)</span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// panic</span></span><br></pre></td></tr></table></figure>

<p><strong>当对<code>nil</code>进行类型断言时时，断言一定失败</strong>。另外，类型断言可以支持第二个返回参数<code>ok</code>表示是否成功，此时不会panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use w...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用：错误类型区分"><a href="#应用：错误类型区分" class="headerlink" title="应用：错误类型区分"></a>应用：错误类型区分</h4><p>借助类型断言，可以将判断抛出的具体错误类型，<code>os</code>包提供了<code>IsExist</code>，<code>isNotExist</code>，<code>isPermission</code>用来区分文件已存在，文件不存在，不允许几种错误。我们以文件不存在为例，此时抛出的<code>PathError</code>类型错误包含了具体的错误类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 满足Error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/path&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, err)</span><br><span class="line"><span class="comment">// Output: &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/path&quot;, Err:0x2&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用断言后，就可以从<code>err</code>中拿到具体错误类型，从而判断是否是文件不存在导致的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class="line">        err = pe.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，建议在错误抛出时就进行检测，在聚合后，原始错误的数据结构可能会丢失从而无法判断。</p>
<h4 id="方法查询"><a href="#方法查询" class="headerlink" title="方法查询"></a>方法查询</h4><p>抽象类型如<code>io.Writer</code>可能缺少使用者需要的方法如<code>io.WriteString</code>（尽管满足<code>io.Writer</code>的大多数具体类型除了必须满足的<code>Write</code>方法外，都对写入字符串支持了<code>WriteString</code>方法）。</p>
<p>可以定义一个临时接口类型，判断满足抽象类型的变量是否具有指定方法。因为Go中接口的满足是隐式的（类似鸭子类型），不像许多强类型语言一样，需要显式声明。之前使用弱类型语言的可能能很好接受。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w io.Writer, s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteString(<span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sw.WriteString(s) <span class="comment">// 更有效率的方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w.Write([]<span class="type">byte</span>(s))  <span class="comment">// 兜底方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，<code>fmt.Sprintf</code>打印不同类型的变量时，也借助了类型断言，对于特定类型调用特定方法，最后再使用<strong>反射</strong>处理其他类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatOnValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err, ok := x.(<span class="type">error</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> err.Error()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> str, ok := x.(Stringer); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> str.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h3><p>interface除了之前说的<strong>让多个具体类型有一致表现</strong>的用法外，还可以作为<strong>可区分具体类型的合集</strong>来使用。这种时候需要结合type switch的用法。如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>: <span class="comment">//...</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在确定了<code>x</code>的类型后，还需要直接使用<code>x</code>。此时可以写作<code>switch x:= x.(type)</code>。</p>
<p>这种用法和之前的用法不同在于：这里接口不作为有<strong>一致表现</strong>而存在，它只是用来暂存将要区分开的具体类型，而这些具体类型往往时有<strong>不同表现</strong>的。所以这种用法里的接口<strong>几乎没有方法</strong>。换一种说法，之前的用法里，接口背后的具体类型细节需要被掩盖来使用，而这里需要使用具体类型的细节。</p>
<h3 id="一些忠告"><a href="#一些忠告" class="headerlink" title="一些忠告"></a>一些忠告</h3><p>和上一章方法类似，接口是一种很好使用的面向对象的特性。但<strong>不建议上来就从定义一堆接口</strong>开始，这样通常会产生一大堆只有一个具体类型实现的接口。接口是抽象类型，是通过具体类型抽象得来的。通常是在<strong>需要用统一的方式处理不同类型</strong>时，拿来使用。</p>
<p>同时，大多数Go程序中，接口往往小且包含比较少的方法。像是<code>io.Writer</code>或<code>fmt.Stringer</code>。和方法一章一样，它们虽然是面向对象的特性，但是不是Go中一定要使用的语言特性。只在需要的时候使用。大多数时候，直接使用函数就足够了。在书中，方法如<code>input.Write</code>的使用就远不如函数如<code>fmt.Printf</code>来得频繁。</p>
<h2 id="goroutine和信道"><a href="#goroutine和信道" class="headerlink" title="goroutine和信道"></a>goroutine和信道</h2><p>Go支持两种并发编程的风格，第一种在本章介绍，通过goroutines和channels支持<strong>通信顺序进程（Communicating sequential processes，CSP）</strong>，这种情况下，值会在goroutine间来回传递，而变量在多数情况下被限制自单个活动中。下一章介绍的共享变量风格的并发编程更接近传统的并发风格。</p>
<h3 id="认识goroutine"><a href="#认识goroutine" class="headerlink" title="认识goroutine"></a>认识goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">    fibN := fib(n) <span class="comment">// slow</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, r = <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>goroutine类似线程，有着定量而非定性的差异</li>
<li><code>main</code>函数也会启动一个<em>main goroutine</em></li>
<li>goroutine通过<code>go</code>启动一个函数或方法调用，并在声明后立即返回</li>
<li>除了<code>main</code>函数返回或程序结束（<code>os.Exit</code>）外，一个goroutine没有办法直接停止另一个，但可以通过传值的方式间接实现。</li>
</ul>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>服务器处理请求是最典型的并发场景。</p>
<h4 id="1-Clock-Server"><a href="#1-Clock-Server" class="headerlink" title="1. Clock Server"></a>1. Clock Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleConn(conn) <span class="comment">// go handleConn(conn)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := io.WriteString(c, time.Now().Format(<span class="string">&quot;15:04:05\n&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// e.g. client disconnect</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>listener.Accept</code>会在接收到TCP连接请求前一直阻塞</li>
<li><code>time.Format</code>方法通过一个<strong>特殊的样例</strong>（15:04:05）表示要格式化的格式，<code>time.Parse</code>也是如此</li>
<li>client端可以用<code>net.Dial</code>发起一个TCP连接请求</li>
</ul>
<p>上述的服务端是<strong>串行</strong>处理client的请求，并每秒打印当前时间，在<code>handleConn(conn)</code>前加上<code>go</code>关键字后，即可让服务端<strong>并行</strong>处理client的请求。</p>
<h4 id="2-Echo-Server"><a href="#2-Echo-Server" class="headerlink" title="2. Echo Server"></a>2. Echo Server</h4><p>上面的例子是在一个连接中使用一个goroutine，当然每个连接也可以创建多个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="type">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToUpper(shout))</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, shout)</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(c)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        echo(c, input.Text(), <span class="number">1</span>*time.Second) <span class="comment">// go echo(...)</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">go</span> mustCopy(os.Stdout, conn)</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>echo</code>前加上<code>go</code>即可让服务器同时相应多个请求，返回“回声”。同理，在client端打印服务端返回的代码前加上<code>go</code>即可让使用者输入的同时打印返回的“回声”。</p>
<h3 id="信道（channel）"><a href="#信道（channel）" class="headerlink" title="信道（channel）"></a>信道（channel）</h3><p><code>go</code>启动并行的活动，信道作为活动间通信的通道，借助它可以发送和接收消息。信道通过<code>make</code>构造，需要指定传输消息的类型，作为信道类型。可以使用<code>close</code>关闭信道。后续的<strong>发送</strong>操作会panic，<strong>接收</strong>操作会得所有到已发送的值，而再之后的后续<strong>接收</strong>操作只能得到信道类型对应的<em>零值</em>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- x</span><br><span class="line">x = &lt;-ch</span><br><span class="line"><span class="comment">// 直接丢弃channel来的值</span></span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>信道还分为有缓冲区和无缓冲区两种类型，上述的<code>make</code>构造的都是无缓冲区的信道，指定第二个参数可以构造有缓冲区的信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 有缓冲区</span></span><br></pre></td></tr></table></figure>

<h4 id="无缓冲信道（Unbuffered-Channels）"><a href="#无缓冲信道（Unbuffered-Channels）" class="headerlink" title="无缓冲信道（Unbuffered Channels）"></a>无缓冲信道（Unbuffered Channels）</h4><p>向无缓冲区<strong>发送消息</strong>会<strong>阻塞发送所在的goroutine</strong>，直到对应的goroutine在同一个信道上执行接收操作。相反地，<strong>接收消息</strong>在先的话，也会阻塞直到同一个信道上执行了发送操作。这种机制会<strong>同步</strong>两个goroutine的执行进度。如果发送信息在先，则接收信息会在发送所在的goroutine之前发生。从而，我们可以基于这个假设的前提保证一些事实。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(os.Stdout, conn)</span><br><span class="line">        log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// signal the main goroutine</span></span><br><span class="line">    &#125;()</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">    conn.Close()</span><br><span class="line">    &lt;-done <span class="comment">// wait for background goroutine to finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序里，会在接收完服务端返回后，才会关闭客户端。这里需要的是一个<strong>事件</strong>，使用的信道类型其实并不重要，所以使用了<code>struct&#123;&#125;</code>。实际应用中会使用<code>bool</code>或是<code>int</code>这样的简单类型。</p>
<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>借助上面提到的无缓冲区信道，可以实现多个goroutine之间的接续传递，也可以叫做<em>流水线</em>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------+         +-----------+         +-----------+</span><br><span class="line">|  Counter  |   --&gt;   |  Squarer  |   --&gt;   |  Printer  |</span><br><span class="line">+-----------+         +-----------+         +-----------+</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span> ;x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := &lt;-naturals</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的流水线中，Counter在打印100个自然数后，会关闭信道。会有之前所说的一些特性：</p>
<ul>
<li>向关闭信道写入消息会panic</li>
<li>从关闭信道读取信息会得到所有未发送的消息，再之后只能得到零值</li>
<li>关闭信道不会影响其他goroutine执行</li>
</ul>
<p>所以在上面的程序中，Printer会继续打印0，只有Counter正常退出。Go中没有<em>直接</em>的获取信道是否关闭的方法，但是对于从信道中读取消息有第二个<code>ok</code>参数，为<code>false</code>时表示信道已关闭且<strong>读取完所有消息</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, ok := naturals</span><br><span class="line"><span class="keyword">if</span> !ok &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的模板代码，go用<code>range</code>已封装好，不必重复书写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">        squares &lt;- x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不是所有信道在不用后都要显式关闭</strong>，只在需要传达信道关闭信息时再手动<code>close</code>关闭。其余的信道会在gc过程中回收。但这不意味着文件读取也可以不显式关闭：文件的读写操作后一定要执行关闭操作。关闭一个已关闭的信道会panic，关闭<code>nil</code>的信道也是一样。</p>
<h4 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h4><p>以上一小节为例，有三个goroutine，函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out, in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中的信道入参分别用来<strong>接收</strong><em>或</em><strong>发送</strong>消息（绝大多数信道也是如此）。因此对于这两种信道的细分，go类型系统提供了<strong>单向信道类型</strong>，即只读或只写。同时提供了类型助记符：</p>
<ul>
<li><code>chan&lt;-</code>表示只读，只可读取消息，不可关闭</li>
<li><code>&lt;-chan</code>表示只写，只可发送消息<strong>和关闭</strong></li>
</ul>
<p>违背只读只写上述规则，会在编译期间抛出错误。同时，<strong>双向信道可以隐式covert到单向信道，反之不可以</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲信道（Buffered-Channel）"><a href="#缓冲信道（Buffered-Channel）" class="headerlink" title="缓冲信道（Buffered Channel）"></a>缓冲信道（Buffered Channel）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>可以用队列类别缓冲信道，不同的是缓冲信道和goroutine是紧密相连的。</p>
<ul>
<li>写操作会在<strong>队列充满</strong>时阻塞</li>
<li>读操作会在<strong>队列为空</strong>时阻塞</li>
</ul>
<p>通过<code>cap</code>和<code>len</code>可以查看缓冲信道的实时容量和长度。虽然缓冲信道可以按队列去理解，但是不要把它拿去当队列来用。那么和无缓冲信道相比，缓冲信道应用场景有什么不同呢？</p>
<p>我们用流水线举例，流水线上的各道工序复杂程度有难有易，如果工作空间有限，每一道工序后都需要在下一道工序空闲时才能交付，一些简单工序就需要等待。这时就像<strong>无缓冲信道</strong>。假设工作空间宽裕，每道工序完成后，如果下游还未就绪，可以先放在空闲空间下，直接继续工作。这就是<strong>缓冲信道</strong>，多出来的工作空间即<strong>缓冲区</strong>，工序即<strong>goroutine</strong>。缓冲区可以弥补上下游工序工作效率的<em>些微差异</em>，缓冲区越大，可以容忍的效率差异就越大。如果工序间有明显差异，比如始终更快或更慢，此时增加缓冲区无法提供帮助，可以采用增加工序工人来提高工作效率，即<strong>在同一信道上使用更多goroutine</strong>。</p>
<p>从上面的比喻，可以得出两种信道的区别：</p>
<ul>
<li>无缓冲信道重点在<strong>同步</strong>，它可以确保上下游goroutine的同步性</li>
<li>缓冲信道则使用了队列来<strong>解耦</strong>上下游goroutine，使之不因为阻塞影响工作效率</li>
</ul>
<p>所以，我们假设有多个网站<em>镜像</em>来为网络请求提供服务，就可以使用缓冲信道，优先响应的可以直接提供服务，且在响应后可以继续工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirroredQuery</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    responses := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;asia.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;europe.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;america.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">return</span> &lt;-responses</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(hostname <span class="type">string</span>)</span></span> (res <span class="type">string</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行循环"><a href="#并行循环" class="headerlink" title="并行循环"></a>并行循环</h3><p>有些任务可以拆分成等效的<strong>相互独立</strong>的小任务，这种情况也被称为“令人尴尬的并行”，是最简单的并行工作场景，它的工作量和并行数呈线性关系。我们假设有一个并行处理图片缩小的程序，能返回缩小后的文件总体积，并在合适的时候停止。在程序编写过程中，会遇到一些问题：</p>
<ul>
<li>有错误出现时，未关闭剩余信道，导致goroutine泄露，并造成程序不响应或内存耗尽</li>
<li>for循环结合延迟执行代码时，循环描述体中的变量陷阱</li>
<li>要支持任意长度的图片列表，不能写死缓存信道的容量</li>
<li>无从直接得知goroutine是否执行完成</li>
</ul>
<p>最终得到下面的最终版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails</span><span class="params">(filenames &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    sizes := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// worker</span></span><br><span class="line">        <span class="comment">// avoid loop variable pitfall</span></span><br><span class="line">        <span class="keyword">go</span> runc(f <span class="type">string</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录任务完成</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumb, err := thumbnail.ImageFile(f)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            info, _ = os.Stat(thumb)</span><br><span class="line">            sizes &lt;- info.Size()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// closer</span></span><br><span class="line">    <span class="comment">// 必须写成goroutine的形式</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(sizes)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> size := <span class="keyword">range</span> sizes &#123;</span><br><span class="line">        total += size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序里面有几点需要特别说明：</p>
<ul>
<li>第一个for循环会将信道输入的图片文件列表转成任务的列表，然后再启动一个goroutine负责关闭信道，最后从信道中拿出所有的大小加总返回</li>
<li>关闭函数必须写成goroutine的形式。因为<code>sizes</code>的range结束依赖于<code>sizes</code>信道的关闭，同时<code>sizes</code>信道又必须<strong>等待</strong>所有图片处理任务执行完之后再关闭。等待和加总图片大小需要并行，所以需要一个新的goroutine去做</li>
<li>任务完成借助<code>sync.WaitGroup</code>完成，<code>wg.Wait()</code>会阻塞直到<code>wg.Done()</code>将所有任务清零</li>
</ul>
<h3 id="样例：并发web爬虫"><a href="#样例：并发web爬虫" class="headerlink" title="样例：并发web爬虫"></a>样例：并发web爬虫</h3><p>将第5章中的<code>worklist</code>由<code>slice</code>改为<code>channel</code>，让爬取网页内容的过程并发执行即可得到一个并发的web爬虫。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 无缓冲信道，也可以使用缓冲信道</span></span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">    <span class="comment">// 初始化channel</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line"></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 从channel中读取</span></span><br><span class="line">    <span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序在执行了一段时间后，会因为客观限制出现报错信息。这是因为程序<strong>过于并发</strong>了。由于硬件资源的限制，当并发数超过一定界限后，程序性能反而不如以前甚至会无法运行。因此需要手动限制并发量。这里有两种思路：</p>
<ul>
<li>通过限制发放许可证（token）的方式限制爬取goroutine是否执行，许可证数量有限，许可证用完后，阻止goroutine执行。当然作为信道的token，是在多个爬取goroutine间共享的。</li>
<li>限制爬取goroutine总数，只创建固定个数的goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量，占有表示被使用中</span></span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    token &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    &lt;-tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面代码<code>main</code>函数中的<code>worklist</code>延迟在for循环内赋值，使用<code>n</code>记录当前任务中的正在执行的任务数，可以实现在所有任务执行完成后退出程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    n++</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> ; n &lt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select实现多工"><a href="#select实现多工" class="headerlink" title="select实现多工"></a><code>select</code>实现多工</h3><p>在之前的例子里，从信道中读取&#x2F;写入值，会阻塞当前goroutine进度。如果需要同时接收两个信道的值，需要<code>select</code>语句块。<code>select</code>语句块使用类似<code>switch</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;- ch2</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个<code>case</code>可以是接收或是发送消息的语句，<code>select</code>语句在其中一个case发生后，才会继续（<code>select&#123;&#125;</code>会一直等待程序执行）。<code>default</code>可以指定没有任何一个case发生时的处理方式。</p>
<p>原文中给出的<code>time.Tick</code>例子会返回一个channel，并以设定的时间间隔发送消息。但是，再不从channel读取信息后，会造成goroutine泄露。因此只在整个生命周期都需要时才会使用。倒计时这种场景下建议使用更复杂的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">&lt;- ticker.C</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>

<p>对于一个nil信道的发送和接收会一直阻塞，select中的case也不会被选中。利用这个特性可以实现取消等功能。</p>
<h3 id="并发目录遍历"><a href="#并发目录遍历" class="headerlink" title="并发目录遍历"></a>并发目录遍历</h3><p>借助<code>ioutil.ReadDir</code>可以实现遍历根文件夹下所有文件体积的功能。下面是一个纯单线程版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkDir</span><span class="params">(dir <span class="type">string</span>, fileSizes <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> dirents(dir) &#123;</span><br><span class="line">        <span class="keyword">if</span> entry.IsDir() &#123;</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileSIzes &lt;- entry.Size()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;du1: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的版本可以实现功能，但是速度很慢，而且不能实时显示进度。这里我们用<code>time.Ticker</code>定时打印进度，同时通过命令行参数<code>p</code>控制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = flag.Bool(<span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;show progress&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> tick &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">    <span class="keyword">if</span> *progress &#123;</span><br><span class="line">        tick = time.Tick(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nFiles, nBytes <span class="type">int64</span></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> size, ok := fileSizes:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            nFiles++</span><br><span class="line">            nBytes += size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            printDiskUsage(nFiles, nBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    printDiskUsage(nFiles, nBytes) <span class="comment">// final print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>if *progress</code>语句在没有传递<code>-p</code>参数时，不会为tick赋值，而nil的tick值会让select中永远不会进入这个case，从而不打印进度。</p>
<p>在遍历根目录下的递归调用<code>walkDir</code>中，也可以使用goroutine，并通过<code>sync.WaitGroup</code>保证执行完成后关闭<code>fileSizes</code>信道。当然，无限制的创建goroutine会出现和上上小节一样的问题，所以也需要<em>信号量（semaphore）</em>，保证不至于创建过多goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取token</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sema &#125;() <span class="comment">// 释放token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>一样的，一个goroutine没有直接关闭另一个goroutine的办法。按照之前提到的<strong>通过信道传递消息</strong>的思路，但是一个信道只会被消费一次，我们这里的场景需要<strong>广播</strong>更合适。</p>
<p>之前提到，一个被关闭的信道在传递完信道内的消息后，后续再从这个信道获取值，会立即返回一个零值。可以利用这个特性，在执行取消操作后，将信道关闭即可，可以写出下面这样的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span> <span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在程序的<strong>瓶颈处</strong>，检查这个函数的返回值，一旦返回<code>true</code>则立即中止程序。比如，之前提到获取token的函数里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// acquire token</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sema &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按上面这种方式退出程序后，有可能出现goroutine还没有妥善关闭的情况，可以在调试时，程序的最后用<code>panic</code>打印系统信息，查看具体情况。</p>
<h3 id="样例：聊天服务器"><a href="#样例：聊天服务器" class="headerlink" title="样例：聊天服务器"></a>样例：聊天服务器</h3><p>聊天服务器也是并发和各种信道常用的场景，它包括：</p>
<ul>
<li>用户的接入、退出</li>
<li>用户信息的广播</li>
<li>用户session的维护</li>
</ul>
<p>我们可以用一个信道表示一个接入的用户，在一个全局的文件中处理用户登入、登出，即信道的信息维护，这里可以用map表示，对于接收到的消息，像注册的所有信道逐个发送，即广播。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> client <span class="keyword">chan</span>&lt;- <span class="type">string</span> <span class="comment">// 只写信道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    entering = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">    messages = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    leaving = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcaster</span><span class="params">()</span></span> &#123;</span><br><span class="line">    clients := <span class="built_in">make</span>(<span class="keyword">map</span>[client]<span class="type">bool</span>) <span class="comment">// 用户session维护</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-entering:</span><br><span class="line">            clients[cli] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-leaving:</span><br><span class="line">            <span class="built_in">delete</span>(clients, cli)</span><br><span class="line">            <span class="built_in">close</span>(cli)</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">            <span class="keyword">for</span> cli := <span class="keyword">range</span> clients &#123;</span><br><span class="line">                cli &lt;- msg</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，启动一个tcp服务器，单独启动一个goroutine负责上面的信道管理，另外对于每一个接入的连接，启动一个独立的goroutine处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> broadcaster()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理tcp连接的函数里，负责接入客户端，同时将连接中的内容写入到<code>messages</code>信道中，以便广播给其他客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> clientWriter(conn, ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一标识生成，也可以使用其他规则</span></span><br><span class="line">    who := conn.RemoteAddr().String()</span><br><span class="line">    ch &lt;- <span class="string">&quot;You are &quot;</span> + who</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has arrived&quot;</span></span><br><span class="line">    entering &lt;- ch</span><br><span class="line"></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        messages &lt;- who + <span class="string">&quot;: &quot;</span> + input.Text()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    leaving &lt;- ch</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has left&quot;</span></span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientWriter</span><span class="params">(conn net.Conn, ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Fprintln(conn, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的map没有使用lock操作，是因为它的读写都限制在了一个goroutine内，因此是<strong>并发安全</strong>的，其他并发使用的信道和<code>net.Conn</code>也是并发安全的。</p>
<h2 id="并发和共享变量"><a href="#并发和共享变量" class="headerlink" title="并发和共享变量"></a>并发和共享变量</h2><p>使用信道在goroutine间沟通是一种并发的范式，其中也略过了一些关键而细小的问题，这些在后面这种并发编程模式中会经常讨论。</p>
<h3 id="竞险（race-conditions）"><a href="#竞险（race-conditions）" class="headerlink" title="竞险（race conditions）"></a>竞险（race conditions）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    balance += amount</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> balance &#125;</span><br></pre></td></tr></table></figure>

<p>上面以银行为例，实际上给出了一个可以读写的变量。在串行执行场景下，不会有问题。在并发场景下，对<code>balance</code>读写的同时进行，就会造成一些问题。这种情况也叫<strong>数据争用（data race）</strong>，即<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。这种数据争用有时候还会带来未定义的行为。</p>
<p>在使用共享变量的模式并发编程时，如果不小心处理，很容易遇到数据争用的情况。然而，绝大多数的数据争用都“来者不善”，以至于我们要留心发生数据争用的场景：<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。下面有三种方式去避免：</p>
<ul>
<li><strong>不要写变量</strong>，比如将变量初始化好之后，使之只读或不可变</li>
<li><strong>避免在多个goroutine上操作变量</strong>，将操作限制在一个goroutine上，就像前一章中的broadcaster，这样的goroutine也叫做<em>调度者goroutine</em>。Go中有句箴言总结的很好：<strong>不要通过共享变量传递消息，通过传递消息来共享变量</strong>。这里的传递消息就是指通过信道发送和接收。当实在无法限制多个goroutine访问一个变量，也尽量限制访问，通过信道传递给其他goroutine，达到<strong>串行限制（serial confinement）</strong>的效果。</li>
<li><strong>在同一时间仅允许一个goroutine访问变量</strong>，即后面会提到的<strong>互斥锁</strong></li>
</ul>
<h3 id="互斥锁（sync-Mutex）"><a href="#互斥锁（sync-Mutex）" class="headerlink" title="互斥锁（sync.Mutex）"></a>互斥锁（<code>sync.Mutex</code>）</h3><p>互斥锁和之前提到的信号量（counting semaphore）很类似，更像是一个容量为1的信号量，即<em>二进制信号量（binary semaphore）</em>。每次执行后续操作前，都需要从一个全局信道中获取token，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用token</span></span><br><span class="line">    balance = balance + amount</span><br><span class="line">    &lt;-sema <span class="comment">// 释放token</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用token</span></span><br><span class="line">    b := balance</span><br><span class="line">    &lt;-sema <span class="comment">// 释放token</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的信号量表示使用<code>sync.Mutex</code>替代就是互斥锁的使用方式：</p>
<ul>
<li><code>var sema = make(chan struct&#123;&#125;, 1)</code> &#x3D;&gt; <code>var mu sync.Mutex</code></li>
<li><code>sema &lt;- struct&#123;&#125;&#123;&#125;</code> &#x3D;&gt; <code>mu.Lock()</code></li>
<li><code>&lt;-sema</code> &#x3D;&gt; <code>mu.Unlock()</code></li>
</ul>
<p>通常来说，互斥锁使用的范围很小，这一区域也叫临界区（critical section），被mutex守护的共享变量会紧跟在<code>Lock</code>之后。在程序较长时，为了避免在所有返回处显式<code>Unlock</code>可以使用<code>defer</code>，这会稍微增加一些显式<code>Unlock</code>的成本，但会让代码更简洁。</p>
<p>另外，互斥锁是不可重入的，即不能对一个已经上锁的共享变量上锁，这会导致死锁，因此确保互斥锁和其守护的变量不被导出。</p>
<h3 id="读-x2F-写互斥锁（sync-RWMutex）"><a href="#读-x2F-写互斥锁（sync-RWMutex）" class="headerlink" title="读&#x2F;写互斥锁（sync.RWMutex）"></a>读&#x2F;写互斥锁（<code>sync.RWMutex</code>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sync.RWMutex</code>可以限制写操作，而允许多个读操作同时进行。<code>RLock</code>方法开启，<code>RUnlock</code>关闭互斥锁。注意，只在确定没有对共享变量写操作发生的时候使用<code>RLock</code>方法，我们不能简单的假设一个<strong>逻辑</strong>读操作，在背后没有注入写入缓存或更新计数器等行为。如果不确定，请使用完整的互斥锁。</p>
<p>同时，<code>sync.RWMutex</code>只在大多数读操作在争用锁时会比较合适。其更复杂的实现，让它在其他场景下工作慢于普通的互斥锁。</p>
<h3 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h3><p>上面提到的对于<code>Balance</code>这个只读的函数也使用的互斥锁或者信道来限制多个goroutine访问共享变量，其中一个明显的原因是：读取操作发生在写操作如<code>Withdraw</code>或<code>Deposit</code>中间时，也会造成问题。另一个不那么明显的原因是，类似互斥锁、信道这种同步操作也会同步内存。</p>
<p>简单点说，在现代CPU架构中，多个处理器内很可能有缓存，每个goroutine对共享变量的修改很可能在多个缓存中，而对其他goroutine不可见，直到同步操作把缓存中的修改同步到主内存中，保证对所有goroutine可见且一致。</p>
<p>同一个goroutine内部是串行稳定的，但goroutine之间无法保证顺序。还有一种<strong>错误</strong>认识，goroutine的代码会<strong>逐行交错</strong>（interleaving）执行。但在现代的CPU架构和编译器中，并不是这么实现的。总而言之，把对变量的使用限制在同一个goroutine内，对其他变量使用互斥锁。</p>
<h3 id="懒初始化（sync-Once）"><a href="#懒初始化（sync-Once）" class="headerlink" title="懒初始化（sync.Once）"></a>懒初始化（<code>sync.Once</code>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化写操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，我们会推迟一个计算量比较大的初始化操作到使用时才进行，如上面<code>Icon</code>函数做的那样。很显然<code>Icon</code>函数不是并发安全的。在其中混有读写操作，且和外界共享icons变量。这时我们需要在初始化的时候对<code>loadIcons</code>函数加锁。加锁时要区分<code>icons</code>的是否初始化状态，可以对只读操作使用读&#x2F;写锁，再对写入操作使用互斥锁。像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        icon := icons[name]</span><br><span class="line">        mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> icon</span><br><span class="line">    &#125;</span><br><span class="line">    mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">// 因为在Lock前，有短暂的Unlock的时间段，有可能会被其他goroutine初始化，因此需要再次判断</span></span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    icon := icons[name]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面就是一个只做一次的操作（通常是初始化操作），为了维护一个是否完成的bool值，额外增加了一些操作，较容易出错。go对这种情况提供了<code>sync.Once</code>支持，在<code>Do</code>方法中传入只执行的函数，这个互斥锁会在第一次执行时上锁并将对变量的改动同步到其他goroutine中，同时维护一个bool值，在后续的执行中，直接跳过这一步。重写之后的<code>Icon</code>变得简单了很多。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="竞险检测器"><a href="#竞险检测器" class="headerlink" title="竞险检测器"></a>竞险检测器</h3><p>很多时候goroutine访问共享变量导致的竞险并不那么容易发现和避免。Go的配套工具链提供了<code>-race</code>标志位用来检查程序中可能存在的竞险情况，在<code>go run</code>, <code>go build</code>, <code>go test</code>后添加都可以。它可以记录对共享变量所做的所有读写操作以及对应的goroutine，还有程序中由<code>sync</code>和信道触发的同步操作。竞险检测器在分析这些事件流的时候可以给出包含共享变量和对其读写goroutine报告。在绝大多数情况下已经足够你查问题了。</p>
<p>竞险检测器只能报告程序覆盖到代码的竞险情况，所以尽量让测试覆盖到所有代码。竞险检查会稍微占用更多时间和内存，但是是可以接受的。</p>
<h3 id="样例：并发无阻塞缓存"><a href="#样例：并发无阻塞缓存" class="headerlink" title="样例：并发无阻塞缓存"></a>样例：并发无阻塞缓存</h3><p>实现这么一个并发数据结构，大抵有两种构建思路：</p>
<ul>
<li>使用有锁的共享变量</li>
<li>借助信道和通信实现串行化</li>
</ul>
<p>不同场景下，他们实现的复杂度可能会稍有不同。</p>
<h3 id="goroutine和线程"><a href="#goroutine和线程" class="headerlink" title="goroutine和线程"></a>goroutine和线程</h3><p>goroutine和线程有些很多小地方上的区别，这些区别让goroutine和线程有着较大区别。</p>
<ul>
<li>线程的栈一般是固定的（通常是2MB），goroutine的栈是灵活的，从较少的大小开始（通常是2KB），可以扩大和缩小</li>
<li>goroutine有自己的调度机制（m:n调度），把m个goroutine复用或调度到n的操作系统的线程</li>
<li><code>GOMAXPROCS</code>环境变量决定了Go代码可以使用多少个操作系统线程</li>
</ul>
<p>最后，goroutine没有其他操作系统或编程语言中用来支持多线程的为每个线程添加一个唯一标识的设计。这个是特别设计的，用来避免线程池的滥用。Go更推荐只由入参显式决定函数表现的风格，避免让函数收到执行线程的影响。</p>
<h2 id="包和Go工具"><a href="#包和Go工具" class="headerlink" title="包和Go工具"></a>包和Go工具</h2><p>如今中小型的程序可能会包含10000个函数，其中绝大多数来自其他人的包。包可以将程序中相互关联的特性整理到独立的单元中，进而在组织或社区中重用、分享。包名和导出的类型、变量、函数名都应简短清晰，Go使用首字母大小写控制可见性，从而掩盖实现细节，保证稳定性或实现互斥锁。</p>
<p>Go的构建速度算是比较快的。主要有3个原因：</p>
<ul>
<li>Go在每个文件开头都显式列出了引入的文件，无需读取整个文件</li>
<li>Go中没有引入是一个有向无环图，因此可以并行编译</li>
<li>编译好的Go包的目标文件会包含自身和<strong>自身的依赖</strong>，每一次的import只需读取一遍目标文件即可</li>
</ul>
<h3 id="import路径"><a href="#import路径" class="headerlink" title="import路径"></a>import路径</h3><p>Go的语言规范并没有规定import路径，路径的实现是由相关工具决定的。但是为了避免冲突，除了标准包以外的包，都需要以域名或组织名开头，如<code>encoding/json</code>，<code>golang.org/x/net/html</code>。</p>
<h3 id="声明和import"><a href="#声明和import" class="headerlink" title="声明和import"></a>声明和import</h3><p>每一个Go文件的开头，都需要以<code>package xxx</code>的形式标识包名。通常，包名是import路径的最后一段。但是有3个例外情况：</p>
<ul>
<li><code>main</code>包名表示告诉<code>go build</code>需要构建一个可执行文件</li>
<li>目录下包含<code>_test</code>后缀文件名的，在执行<code>go test</code>时会额外被构建用于测试的包</li>
<li>有的报名后面会跟版本号，这个时候以没有版本号的作为包名</li>
</ul>
<p>在import时，如果引入包较多时，可以用圆括号列表形式引入。列表间可以用空行隔开，通常用来分组域名，这个在按照字母顺序排序import时有用——排序会在每组内进行。如果不同域内的包名一样，如<code>math/rand</code>和<code>crypto/rand</code>，可以用重命名引入（renaming import）。像下面这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">    mrand <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这种重命名只在当前文件内有效。重命名通常可以避免包名冲突，或者简化一些复杂的包名，在简化时，注意对同样的原名，使用同样的缩写名。<code>go build</code>会报告编译中循环依赖。</p>
<h3 id="空导入"><a href="#空导入" class="headerlink" title="空导入"></a>空导入</h3><p>有的时候，我们的引入的<strong>目的在包的副作用</strong>，如其中全局变量的初始化或<code>init</code>函数的执行。这个时候可以用空白标识符<code>_</code>进行重命名即可，如<code>import _ &quot;image/png&quot;</code>。这种即空导入。</p>
<p>在书中例子里，对<code>image/png</code>的空导入，实现了png解码相关配置的全局注册（<code>image.RegisterFormat</code>），从而可以解码png图片。类似的思路在<code>database/sql</code>包中也有用到。</p>
<h3 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h3><p>对于包名，有下面一些建议的命名规范：</p>
<ul>
<li>使用简短明了的包名</li>
<li>使用有描述性且没有歧义的名字，且最好不要使用经常会用来命名局部变量的包名，如<code>path</code></li>
<li>包名通常使用单数形式，需要和其他情况区分开时，如<code>strings</code>，<code>bytes</code></li>
<li>避免使用具有隐藏含义的名称，如<code>temp</code></li>
</ul>
<p>对于包中的成员名：</p>
<ul>
<li>考虑和包名一起构成完整的含义，不需要包含包名，如<code>flat.Int</code>，<code>http.Get</code></li>
<li>有的包名表示一种类型，在内部会有对应的类型定义和<code>New</code>操作</li>
<li>即使对于有着很多成员的包，其最关键的几个方法仍然是最简单的</li>
</ul>
<h3 id="Go工具"><a href="#Go工具" class="headerlink" title="Go工具"></a>Go工具</h3><p>Go工具像一个瑞士军刀，它的各个子命令提供了诸如包管理器（<code>go get</code>）、构建系统（<code>go build</code>, <code>go run</code>, <code>go install</code>）、测试驱动（<code>go test</code>）等等。</p>
<h4 id="工作区组织"><a href="#工作区组织" class="headerlink" title="工作区组织"></a>工作区组织</h4><p>日常经常使用的是<code>GOPATH</code>环境变量，用于说明当前工作区的根路径。<code>GOROOT</code>表示go源码的根路径，<code>GOOS</code>表示操作系统，<code>GOARCH</code>表示处理器架构。更多配置可以执行<code>go env</code>查看。</p>
<h4 id="包下载"><a href="#包下载" class="headerlink" title="包下载"></a>包下载</h4><p>执行<code>go get</code>下载，下载时不仅包含源码的拷贝，还包含源码的版本控制信息。Go工具会自动判断流行的代码托管方式。对于不那么有名的托管网站，需要自己显式说明保本控制的协议，可以通过<code>go help importpath</code>查看细节。</p>
<p>Go工具在访问包的导入路径域名如<code>golang.org</code>时，会试图从网页的<code>&lt;meta&gt;</code>标签中寻找类似下面这样指示目标路径的信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;go-import&quot;</span> <span class="attr">content</span>=<span class="string">&quot;golang.org/x/net git https://go.googlesource.com/net&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，执行<code>go get -u</code>时会获取所有包的最新版本，在需要锁定版本时比较麻烦，可以借助<em>vendor</em>解决，在<code>go help gopath</code>中有介绍。</p>
<h4 id="包构建"><a href="#包构建" class="headerlink" title="包构建"></a>包构建</h4><ul>
<li>使用<code>go build</code>构建时，对于库类型代码只会检查错误，对于main包，则会构建可执行文件</li>
<li><strong>一个目录包含一个包</strong>，因此导入时，要么指定导入路径，要么指定相对路径，否则会以当前目录为基础构建。构建得到的可执行文件名称是go文件的前缀。</li>
<li><code>go build</code>构建时，会丢弃已编译的代码，只保留可执行文件。</li>
<li><code>go install</code>构建时，会保留已编译的代码，编译好的包位于<code>$GOPATH/pkg</code>下，编译得到的执行文件位于<code>$GOPATH/bin</code>下。再之后，<code>go build</code>和<code>go install</code>不会编译未被改变的包或命令，从而让执行过程更快。<code>go build -i</code>可以安装项目的所有依赖</li>
<li>修改<code>GOOS</code>和<code>GOARCH</code>可以改变包目标的平台和架构，默认只会针对当前平台和架构打包。</li>
<li>文件末尾以诸如<code>_linux.go</code>，<code>axm_amd64.s</code>结尾时，只会在打对应平台包的时候才会编译此文件。另外还可以以<code>// +build linux darwin</code>的注释形式做到更好的细粒度。<code>// +build ignore</code>表示编译时跳过该文件。</li>
</ul>
<p><code>go doc go/build</code>下有更多介绍。</p>
<h4 id="包文档"><a href="#包文档" class="headerlink" title="包文档"></a>包文档</h4><p>Go建议在导出的包成员和包声明前使用描述用途和用法的注释。注释宜简单且清晰，对于大段的注释，使用同名的文档文件（通常名为<code>doc.go</code>）进行说明。如果行为本身就足够明显，就不需要写注释。</p>
<p><code>go doc</code>命令可以查看包、包成员、包方法的文档。还有个很相似的命令<code>godoc</code>，它可以托管一个能够查看当前工作目录下文档的服务器。</p>
<h4 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h4><p>有些包可能希望导出只对个别信任的包可见，对于这种包，导入路径中需要包含<code>internal</code>。这些内部包只对<code>internal</code>的父目录下文件可见，如<code>net/http/internal/chunked</code>对<code>net/http/httputil</code>可见，但对<code>net/url</code>不可见。</p>
<h4 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h4><p><code>go list</code>工具可以查询包的导入路径。使用<code>...</code>通配符可以查到更多内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go list github.com/go-sql-driver/mysql</span><br><span class="line">go list ...</span><br><span class="line">go list gopl.io/ch3/...</span><br><span class="line">go list ...xml...</span><br></pre></td></tr></table></figure>

<p>结合<code>-json</code>可以打印json格式的包详情，或者结合<code>-f</code>加上<code>text/template</code>语法打印特定格式的字符串。</p>
<p>更多使用方式查看<code>go help list</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>同行评审和测试是两种避免代码错误的方式。Go尽量让写自动化测试代码不是一件很困难的事。在Go中进行测试，你需要了解的只不过是普通的Go语法规范和一些约定而已。</p>
<h3 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a><code>go test</code>工具</h3><p>Go的测试都借助<code>go test</code>完成。所有和测试相关的文件必须以<code>_test.go</code>结尾，这些文件不会在打包时包括进去，只会在运行测试时运行。在文件中有三类函数会被特殊处理：</p>
<ul>
<li>测试函数：必须以<code>Test</code>开头，表示检测一些逻辑的正确性，运行后会给出<code>PASS</code>或<code>FAIL</code></li>
<li>基准测试函数：必须以<code>Benchmark</code>开头，表示测量一些操作的性能，运行后会给出运行时间</li>
<li>样例函数：必须以<code>Example</code>开头，表示提供一些格式化的文档</li>
</ul>
<p><code>go test</code>运行完成时，会生成一个临时的<code>main</code>包，构建并运行，最后给出结果并清理现场</p>
<h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><p>测试函数均以<code>Test</code>开头，函数入参是test包提供的用来打印错误或其他日志的工具集。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSin</span><span class="params">(t *test.T)</span></span> &#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接着就像写普通Go代码一样去执行case就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">&quot;kayak&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;kayak&quot;) = false`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时，结合<code>-v</code>标记可以打印详细信息，结合<code>-run</code>标识可以只运行符合指定模式的case。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run=<span class="string">&quot;French|Canal&quot;</span> </span><br></pre></td></tr></table></figure>

<p>case之间的代码相似性很高，建议用配置的方式批量运行case，减少模板代码书写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPalindrome</span><span class="params">(t *tesing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="type">string</span></span><br><span class="line">        want <span class="type">bool</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ab&quot;</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="keyword">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;IsPalindrome(%q) = %v&quot;</span>, test.input, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>go test</code>在运行测试时，每个case的错误不会中断其他case的执行，也不会panic，来保证一次运行能获得所有case的执行结果。对于需要中断的情况，可以使用<code>t.Fatal</code>或者<code>t.Fatalf</code>。</p>
<h4 id="随机化测试"><a href="#随机化测试" class="headerlink" title="随机化测试"></a>随机化测试</h4><p>不同于上面提到的选择特定case进行测试。随机化测试可以覆盖更广的范围。在验证随机化测试是否符合预期上，有两种思路：</p>
<ul>
<li>使用另外一种方式给出结果，对比两种方式的结果是否相同</li>
<li>使用固定的模式生成随机化case，使其预期结果可以事先推导出来</li>
</ul>
<p>另外，在随机化测试时还要考虑能否再次复现问题case的情况。</p>
<h4 id="测试一个命令"><a href="#测试一个命令" class="headerlink" title="测试一个命令"></a>测试一个命令</h4><p>对于<code>go test</code>而言，<code>main</code>包只是一个库，可以将<code>main</code>函数中需要测试的逻辑抽离成函数，在<code>*_test.go</code>中测试即可。最好将<code>log.Fatal</code>或者<code>os.Exit</code>这种中断程序执行的语句放在<code>main</code>函数中，避免中断测试流程。</p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试即在对测试对象有清楚认识的情形下进行测试；黑盒测试则相反，更站在客户端的角度去测试包。在白盒测试下，我们可以修改原先包的一些实现方式，使之更易被测试。比如，可以将其中会有副作用的部分，如发邮件、写数据库、发短信的函数覆盖。（类似mock的思路）</p>
<p>但是，在覆盖后，别忘了还原回去，避免影响后续测试。类似下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckQuotaNotificationUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    saved := notifyUser</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; notifyUser = saved &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    notifyUser = <span class="function"><span class="keyword">func</span><span class="params">(user, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        notifiedUser, notifiedMsg = user, msg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种覆盖方式正常情况下不会有风险，因为<code>go test</code>通常不会并行运行多个测试。</p>
<h4 id="外部测试包"><a href="#外部测试包" class="headerlink" title="外部测试包"></a>外部测试包</h4><p>上面提到的都是直接在包下新建<code>*_test.go</code>文件的方式进行测试。有些情况下，如果测试文件内需要引用更高层包，会产生循环引用，这是上一章提到不允许的。这时可以定义为外部包。如：</p>
<p><code>net/url</code>下的测试文件导入了<code>net/http</code>包，而<code>net/http</code>包中又导入了<code>net/url</code>。这个时候在<code>net/url</code>下的测试文件使用<code>package url_test</code>声明，表示是另一个包<code>net/url_test</code>。然后，通过导入<code>net/url</code>和<code>net/http</code>的方式进行测试。就可以避免循环引用。</p>
<p>可以通过<code>go list -f</code>指定<code>.GoFiles</code>，<code>.TestGoFiles</code>和<code>.XTestGoFiles</code>分别查看包中的源文件、测试文件和外部测试包文件。</p>
<p>然而，外部测试包并不能访问到包内对外不可见的变量或函数。这个时候，可以在包内创建一个后门测试文件，用于导出一些内部变量或函数对外部包测试可见，通常命名为<code>export_test.go</code>。这类文件内不包含实际的测试。如<code>fmt</code>包下的<code>export_test.go</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IsSpace = isSpace</span><br></pre></td></tr></table></figure>

<h4 id="写高效的测试"><a href="#写高效的测试" class="headerlink" title="写高效的测试"></a>写高效的测试</h4><p>Go在设计上和其他很多语言不同，并不包含一个大而全的测试框架，也没有创建、清除操作，和常用的断言、判断方法等。Go认为写case是作者自己的事，而且就像写普通的程序一样，不要有死记硬背和长篇大论，只需简明扼要地表达测试意图。</p>
<p>在写测试代码时，避免过早抽象，先想着把功能实现，然后再想怎么通过抽象减少重复和复杂度。</p>
<h4 id="避免“脆弱”的测试"><a href="#避免“脆弱”的测试" class="headerlink" title="避免“脆弱”的测试"></a>避免“脆弱”的测试</h4><p>有两种应用：一种是真正bug很多的（buggy），另一种是合理改动也过不了case的（brittle）。而这里过不了case可能只是因为判断逻辑写的不够宽容，死抠细节导致很容易过时。避免这种情况一个很直接的办法是只检查你关心的特性，使用更简单和时间稳定的方式检查，如不要依赖字符串匹配。去检查本质。</p>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><blockquote>
<p>Testing shows the presence, not the absence of bugs —— Edsger Dijkstra</p>
</blockquote>
<p>覆盖率一定程度上能对测试的覆盖程度有启发性的指示作用。使用<code>go test -coverprofile</code>可以指定覆盖率数据输出，如果不需要输出，只看摘要，可以只用<code>go test -cover</code>。使用<code>go tool cover</code>可以显示覆盖率使用介绍。</p>
<p>最后要说明的是，被覆盖到的代码并不是没有bug，测试是一种<strong>务实</strong>的努力。它是在写测试代价和失败代价的中间的一个折中。</p>
<h3 id="性能测试函数"><a href="#性能测试函数" class="headerlink" title="性能测试函数"></a>性能测试函数</h3><p>这类函数都以<code>Benchmark</code>开头，和测试函数类似，函数入参是<code>*testing.B</code>类型的变量。默认情况下，不会执行任何性能测试，需要指定<code>-bench</code>值，去匹配对应函数执行，“<code>.</code>”表示匹配所有。如<code>go test -bench=.</code>性能测试函数写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsPalindrome</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以需要自己在基准测试函数中写循环，而不集成在测试驱动中，是避免一些一次性操作影响执行时间测量。<code>-benchmem</code>标识会显示内存分配的使用情况。性能测试函数可以用来对比两种策略或算法的相对时间优劣，以及通过调整循环次数，整体上考察代码设计。</p>
<h3 id="性能侧写（Profilling）"><a href="#性能侧写（Profilling）" class="headerlink" title="性能侧写（Profilling）"></a>性能侧写（Profilling）</h3><p>性能测试函数能帮你发现整体的性能好坏，但不能告诉你哪里做得不够好。</p>
<p>Knuth曾说过“不要过早优化”，然而结合上下文的原话的意思则是，寻找性能优化点并不那么容易，程序员们在写需求前浪费了大量时间在寻找优化点上，先把事情做出来，不要杞人忧天过早优化。但是优秀的程序员会努力找到优化点并改善之。</p>
<p>寻找关键点的方式就叫<em>profiling</em>。profile通过采样的方式给出占用时间、资源最多的对象，从而可以对应去优化。Go提供3种profile</p>
<ul>
<li>CPU profile，标记占用CPU时间最长的函数</li>
<li>heap profile，标记分配内存最多的声明</li>
<li>blocking profile，标记阻塞goroutine时间最久的操作</li>
</ul>
<p>对应在<code>go test</code>上的标识为<code>-cpuprofile</code>，<code>-memprofile</code>，<code>-blockprofile</code>。借助<code>go tool pprof</code>可以打印侧写数据，以及可视化数据。</p>
<h3 id="样例函数"><a href="#样例函数" class="headerlink" title="样例函数"></a>样例函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleIsPalindrome</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>))</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;palindrome&quot;</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一种会被<code>go test</code>特殊处理的是样例函数，这类函数以<code>Example</code>开头，并没有入参，也没有返回。它的作用主要有以下3点：</p>
<ul>
<li>文档记录，且更能传达意图，同时由于样例函数是实际的Go代码，对比文档，随着代码演化，不会有过期风险。命名单纯叫<code>Example</code>的函数作为整个包的样例函数。</li>
<li>函数最火包含<code>// Output:</code>注释的话，<code>go test</code>会检查标准输出是否能匹配注释中的输出</li>
<li>在<code>godoc</code>中可以作为playground，提供给用户动态编辑、运行的功能</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射能在<strong>运行时</strong>不知道变量类型情况下去修改和查询变量值。反射还能让我们将类型作为第一成员的值来使用。类似<code>fmt.Sprintf</code>和<code>text/template</code>中就有用到这个特性</p>
<h3 id="reflect-Type和reflect-Value"><a href="#reflect-Type和reflect-Value" class="headerlink" title="reflect.Type和reflect.Value"></a><code>reflect.Type</code>和<code>reflect.Value</code></h3><p><code>reflect.Type</code>和<code>reflect.Value</code>分别表示变量的类型和值。其中类型通过<code>reflect.TypeOf</code>得到，得到的<code>reflect.Type</code>可以保存任何类型值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(<span class="number">3</span>) <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Println(t) <span class="comment">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<p>返回的类型总是interface的动态类型，所以总是确切类型。</p>
<p><code>reflect.ValueOf</code>可以得到任意类型的变量值。返回的<code>reflect.Value</code>满足<code>fmt.Stringer</code>接口，不过打印出来的是变量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">3</span>) <span class="comment">// a reflect.Value</span></span><br><span class="line">fmt.Println(v) <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, v) <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(v.String()) <span class="comment">// &quot;&lt;int Value&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>reflect.Value.Interface</code>方法返回一个保存相同值的<code>interface&#123;&#125;</code>类型。它和<code>reflect.Value</code>不同在于，一个<code>interface&#123;&#125;</code>类型的变量掩盖了外部表现和内部实现细节，因此无从对其操作。&#96;&#96;reflect.Value<code>的</code>Kind&#96;方法可以返回类型的底层表示方法，因此使用时，可以只关心Go中定义的类型。</p>
<h3 id="递归值输出函数Display"><a href="#递归值输出函数Display" class="headerlink" title="递归值输出函数Display"></a>递归值输出函数<code>Display</code></h3><p>利用上面提到的<code>Kind</code>方法，可以实现递归打印任意类型值的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="type">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind()&#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = invalid\n&quot;</span>, path)</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fieldPath := fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)</span><br><span class="line">            display(fieldPath, v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%s]&quot;</span>, path, formatAtom(key), v.MapIndex(key)))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;(*%s)&quot;</span>, path), v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Interface:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s.type = %s\n&quot;</span>, path, v.Elem().Type())</span><br><span class="line">            display(path+<span class="string">&quot;.value&quot;</span>, v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 基础类型、信道、函数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = %s\n&quot;</span>, path, formatAtom(v))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到了许多<code>reflect.Value</code>的方法，不是所有的都安全：</p>
<ul>
<li><code>v.Index()</code>和<code>v.Len()</code>类似<code>len()</code>和<code>[i]</code>下标取值</li>
<li><code>v.NumbField()</code>返回结构体中的字段数目，<code>v.Field(i)</code>则返回第i位的<code>reflect.Value</code>类型值</li>
<li><code>v.MapKeys()</code>返回无序的map key</li>
<li><code>v.IsNil()</code>和<code>v.Elem()</code>分别判断是否为空和获取值</li>
</ul>
<p>上述方法在遇到有环的数据结构时，会无限打印，可以借助下一章里的<code>unsafe</code>包解决。</p>
<h3 id="使用reflect-Value设置变量"><a href="#使用reflect-Value设置变量" class="headerlink" title="使用reflect.Value设置变量"></a>使用<code>reflect.Value</code>设置变量</h3><p>Go中的变量都是有地址的，可以通过这个地址去修改变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">a := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">b := reflect.ValueOf(x)</span><br><span class="line">c := reflect.ValueOf(&amp;x)</span><br><span class="line">d := c.Elem() <span class="comment">// variable</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>d</code>即变量<code>x</code>。借助这个方式我们可以用<code>Addr()</code>获取地址，用<code>Interface()</code>获取<code>interface&#123;&#125;</code>类型的值，再使用类型断言转成具体的变量类型。像下面这样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">px := d.Addr().Interface().(*<span class="type">int</span>)</span><br><span class="line">*px = <span class="number">3</span></span><br><span class="line">fmt.Println(x) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>又或者，可以通过<code>Set</code>方法设置一个<code>reflect.Value</code>。针对特定类型，还有<code>SetInt</code>、<code>SetUint</code>、<code>SetString</code>这样的方法。注意，这些方法只使用在特定类型上，对于<code>interface&#123;&#125;</code>或其他类型使用，会引起panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d.Set(reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ry := reflect.ValueOf(&amp;y).Elem()</span><br><span class="line">ry.SetInt(<span class="number">2</span>) <span class="comment">// panic: SetInt called on interface Value</span></span><br><span class="line">ry.SetInt(reflect.Value(<span class="number">3</span>)) <span class="comment">// OK, y = int(3)</span></span><br></pre></td></tr></table></figure>

<p>另外，反射不能更新那些没有对外导出的结构体字段，尽管这些字段可以在发射中读取到。<code>CanSet()</code>可以判断一个<code>reflect.Value</code>是否可以修改，类似的，<code>CanAddr()</code>可以判断一个<code>reflect.Value</code>是否可以获取到地址。</p>
<p>利用上面的特性，可以实现encoding&#x2F;json中类似的解析JSON字符串的效果。</p>
<h3 id="访问结构体的field-tag"><a href="#访问结构体的field-tag" class="headerlink" title="访问结构体的field tag"></a>访问结构体的field tag</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    Labels []<span class="type">string</span> <span class="string">`http:&quot;l&quot;`</span></span><br><span class="line">    MaxResults <span class="type">int</span> <span class="string">`http:&quot;max&quot;`</span></span><br><span class="line">    Exact <span class="type">bool</span> <span class="string">`http:&quot;x&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在JSON一节提到，可以在结构体后使用<em>field tag</em>作为JSON解析过程中的metadata。实际上，除了<code>json</code>还可以设置其他tag。这个tag也可以通过反射特性拿到。</p>
<p><code>reflect.Type</code>的<code>Field()</code>方法可以返回一个<code>reflect.StructField</code>类型，其中包含了字段名、字段类型以及可选的标签。其中<code>Tag</code>字段即field tag对应的字符串，它的<code>Get</code>方法可以返回特定标识后的标签值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpack</span><span class="params">(req *http.Request, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := req.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]reflect.Value)</span><br><span class="line">    v := reflect.ValueOf(ptr).Elem()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">        fieldInfo := v.Type().Field(i) <span class="comment">// reflect.StructField类型</span></span><br><span class="line">        tag := fieldInfo.Tag <span class="comment">// reflect.StructTag类型</span></span><br><span class="line">        name := tag.Get(<span class="string">&quot;http&quot;</span>) <span class="comment">// 获取http标识</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            name = strings.ToLower(fieldInfo.Name)</span><br><span class="line">        &#125;</span><br><span class="line">        field[name] = v.Field(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展示类型的方法"><a href="#展示类型的方法" class="headerlink" title="展示类型的方法"></a>展示类型的方法</h3><p><code>reflect.Type</code>和<code>reflect.Value</code>都有一个<code>Method()</code>方法。<code>reflect.Type</code>中的方法返回<code>reflect.Method</code>实例，结构体中包含方法名和方法类型。<code>reflect.Value</code>中的<code>Method()</code>方法则返回一个<code>reflect.Value</code>类型，即一个绑定到receiver上的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    t := v.Type()</span><br><span class="line">    fmt.Println(<span class="string">&quot;type %s\n&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;func (%s) %s%s\n&quot;</span>, t, t.Method(i).Name, strings.TrimPrefix(methType.String(), <span class="string">&quot;func&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些忠告-1"><a href="#一些忠告-1" class="headerlink" title="一些忠告"></a>一些忠告</h3><p>反射在规范的类型系统外，引入了更高自由度和编程的灵活性，但同时也带来了弱类型解释型语言（没错，JS就是你）的弊病：编译期问题会变成运行时问题、代码可读性变差、性能更差。</p>
<p>反射虽然提供了很强大的功能，但是失去了类型的保护，需要额外处理类型的边界case，否则很容易在运行时出现panic。而这些在使用特定类型时会在编译期就被发现。因此，在使用时，建议将包中使用反射的部分完全封装在内，不对外暴露，同时做一些额外的动态检查。同时，在出错时，给出类型上更友好的提示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%d %s\n&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">42</span>) <span class="comment">// &quot;%!d(string=hello) %!s(int=42)&quot;</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>interface&#123;&#125;</code>类型和大量出现的反射代码会让代码安逸理解，需要辅以更加完善的文档和注释来解释。</p>
<p>最后，基于反射的函数执行速度比普通基于特定类型的函数慢至少一两个级别。因此，尽量不要在代码执行的关键路径上使用反射实现，类似测试代码这种小数据量和执行覆盖频率的代码就可以使用。</p>
<h2 id="低阶特性"><a href="#低阶特性" class="headerlink" title="低阶特性"></a>低阶特性</h2><p>Go已经尽量掩盖了它在底层的实现，用来避免出现难以调试的神秘问题。但在有些时候，比如为了追求性能，或者希望和操作系统底层交互，可能希望绕开这个限制。这一章的内容介绍的<code>unsafe</code>包提供了这么一个窗口，<code>cgo</code>工具可以将创建C库和Go的绑定关系。</p>
<h3 id="unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof"><a href="#unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof" class="headerlink" title="unsafe.Sizeof，unsafe.Alignof和unsafe.Offsetof"></a><code>unsafe.Sizeof</code>，<code>unsafe.Alignof</code>和<code>unsafe.Offsetof</code></h3><p>这三个API能让你了解一些Go在内存结构上的一些细节。其中</p>
<ul>
<li><code>Sizeof</code>返回操作数在内存中占用的大小</li>
<li><code>Alignof</code>返回操作数“对齐”需要的内存大小</li>
<li><code>Offsetof</code>返回结构体中字段在结构体内存的偏移量</li>
</ul>
<p>这几个API并不像它们名字里写的不安全，对于了解底层的内存表示是有帮助的，比如在需要优化内存性能时。</p>
<h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a><code>unsafe.Pointer</code></h3><p><code>unsafe.Pointer</code>是一个可以指向任意类型变量的指针，同时<strong>也可以把<code>unsafe.Pointer</code>类型指针转换回特定类型指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123; <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f)) &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#016x\n&quot;</span>, Float64bits(<span class="number">1.0</span>)) <span class="comment">// &quot;03xff00000000000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时<code>unsafe.Pointer</code>可以转换为<code>uintptr</code>类型，这个类型用整数表示了地址。这个整数类型足够大，足以表示任何类型的指针。但在使用时要多加注意，因为Go的垃圾回收机制使得一个变量的地址很可能会在运行过程中改变，从而使之前的<code>uintptr</code>类型变量失去意义。建议尽可能减少<code>unsafe.Pointer</code>到<code>uintptr</code>和对<code>uintptr</code>的使用。如果有包返回了一个<code>uintptr</code>类型，建议立即将其转换为<code>unsafe.Pointer</code>类型，确保指针能指向同一个变量。</p>
<h3 id="cgo"><a href="#cgo" class="headerlink" title="cgo"></a>cgo</h3><p>使用cgo可以在go中使用C语言，反之亦然，这里从略，具体参考<a target="_blank" rel="noopener" href="https://golang.org/cmd/cgo%E3%80%82">https://golang.org/cmd/cgo。</a></p>
<h3 id="再一些忠告"><a href="#再一些忠告" class="headerlink" title="再一些忠告"></a>再一些忠告</h3><p><code>unsafe</code>包和<code>reflect</code>包很像，提供了一些高级特性，但是更甚。它绕开了语言对不可控因素的隔离，会带来一些风险。所以，在特殊场景下，经过仔细考量和验证证实，使用<code>unsafe</code>确实会带来关键性能提升时，再在代码的关键位置使用<code>unsafe</code>，同时，尽量保证对代码其他地方透明。</p>
<p>最后，忘掉最后两章吧，先去踏踏实实写一些Go程序，在能用上<code>reflect</code>和<code>unsafe</code>的时候，你自然回想起来的。</p>
<p>祝，happy Go programming。</p>
<p><em>-END-</em></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/golang/" rel="tag"># golang</a>
              <a href="/blog/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" rel="tag"># 语言学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2019/12/02/clean-code/" rel="prev" title="《代码整洁之道》——有一个好的代码品味">
                  <i class="fa fa-chevron-left"></i> 《代码整洁之道》——有一个好的代码品味
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2020/01/04/2019-to-2020/" rel="next" title="2019回顾暨2020展望">
                  2019回顾暨2020展望 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:47</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

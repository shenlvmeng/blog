<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="前言Elm提出于2012年，最初出现在Evan Czaplicki的毕业论文中（掩面）。目标是提出一个面向web的函数式编程语言。它拥有诸多特性  强类型语言 一次编译，no runtime error 状态不可修改 函数是一级公民等  Elm是门新语言，它是一个类似React（但绝对和它不一样）的前端框架。在Web App的设计它甚至启发了Flux设计的提出。在如今前端框架吸收函数式编程以及强类">
<meta property="og:type" content="article">
<meta property="og:title" content="Elm——函数式前端框架介绍">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="前言Elm提出于2012年，最初出现在Evan Czaplicki的毕业论文中（掩面）。目标是提出一个面向web的函数式编程语言。它拥有诸多特性  强类型语言 一次编译，no runtime error 状态不可修改 函数是一级公民等  Elm是门新语言，它是一个类似React（但绝对和它不一样）的前端框架。在Web App的设计它甚至启发了Flux设计的提出。在如今前端框架吸收函数式编程以及强类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://guide.elm-lang.org/architecture/effects/beginnerProgram.svg">
<meta property="og:image" content="https://guide.elm-lang.org/architecture/effects/program.svg">
<meta property="article:published_time" content="2017-06-19T09:36:01.000Z">
<meta property="article:modified_time" content="2018-02-21T16:28:59.110Z">
<meta property="article:author" content="shenlvmeng">
<meta property="article:tag" content="Elm">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="函数式编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://guide.elm-lang.org/architecture/effects/beginnerProgram.svg">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/","path":"2017/06/19/elm-introduction/","title":"Elm——函数式前端框架介绍"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Elm——函数式前端框架介绍 | Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Shenlvmeng's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%89%B9%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">语法特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-number">3.2.1.</span> <span class="nav-text">类型声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Union%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">Union类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">控制结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">3.5.</span> <span class="nav-text">杂项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elm%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">Elm架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Effects"><span class="nav-number">4.1.</span> <span class="nav-text">Effects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Task"><span class="nav-number">5.1.</span> <span class="nav-text">Task</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">互操作性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EJSON"><span class="nav-number">6.1.</span> <span class="nav-text">与JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EJavaScript"><span class="nav-number">6.2.</span> <span class="nav-text">与JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5"><span class="nav-number">7.</span> <span class="nav-text">工程实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FAQ"><span class="nav-number">7.1.</span> <span class="nav-text">FAQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">430</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/06/19/elm-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Elm——函数式前端框架介绍 | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Elm——函数式前端框架介绍
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-19 17:36:01" itemprop="dateCreated datePublished" datetime="2017-06-19T17:36:01+08:00">2017-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-02-22 00:28:59" itemprop="dateModified" datetime="2018-02-22T00:28:59+08:00">2018-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/06/19/elm-introduction/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/19/elm-introduction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Elm提出于2012年，最初出现在Evan Czaplicki的毕业论文中（掩面）。目标是提出一个面向web的函数式编程语言。它拥有诸多特性</p>
<ul>
<li>强类型语言</li>
<li>一次编译，no runtime error</li>
<li>状态不可修改</li>
<li>函数是一级公民等</li>
</ul>
<p>Elm是门新语言，它是一个类似React（但绝对和它不一样）的前端框架。在Web App的设计它甚至启发了Flux设计的提出。在如今前端框架吸收函数式编程以及强类型语言优点的形势下，学习Elm可能会开启对Web前端开发的重新认识。</p>
<p>再看完下面的介绍后，建议阅读两篇对Elm的评价，相信更有助于对这门年轻语言特点的理解：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@ericdreichert/my-thoughts-on-elm-lang-b609d69cfa4d">My thoughts on Elm Lang</a></li>
<li><a target="_blank" rel="noopener" href="https://hackernoon.com/some-thoughts-on-elm-development-39a0f8a9002a">Some thoughts on Elm Development</a></li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Elm是通过将代码编译成JavaScript工作的。一个最简单的Elm App大概像下面这样：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Html <span class="keyword">exposing</span> (<span class="type">Html</span>, button, div, text)</span><br><span class="line"><span class="keyword">import</span> Html.Events <span class="keyword">exposing</span> (onClick)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> =</span><br><span class="line">  <span class="type">Html</span>.beginnerProgram &#123; model = <span class="number">0</span>, view = view, update = update &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">Msg</span> = <span class="type">Increment</span> | <span class="type">Decrement</span></span><br><span class="line"></span><br><span class="line"><span class="title">update</span> msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Increment</span> -&gt;</span><br><span class="line">      model + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Decrement</span> -&gt;</span><br><span class="line">      model - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">view</span> model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick <span class="type">Decrement</span> ] [ text <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    , div [] [ text (toString model) ]</span><br><span class="line">    , button [ onClick <span class="type">Increment</span> ] [ text <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>那么这样一个Elm文件是怎么应用在页面中呢？</p>
<p>在<a target="_blank" rel="noopener" href="http://elm-lang.org/">Elm</a>安装完成后，会有4个Elm相关的包：</p>
<ul>
<li>elm-repl 命令行操作，在cli中感受Elm的语法特点</li>
<li>elm-reactor 快速脚手架搭建</li>
<li>elm-make 编译工具</li>
<li>elm-package 包管理工具</li>
</ul>
<p>麻雀虽小，五脏俱全。</p>
<h2 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h2><p>Elm在<a target="_blank" rel="noopener" href="http://elm-lang.org/docs/syntax">语法</a>上不同于C风格的所有语言，和Haskell更为靠近。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用<code>--</code>开启单行注释，结合<code>&#123;&#125;</code>进行多行注释</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- a single line comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- a multiline comment</span></span><br><span class="line"><span class="comment">   <span class="comment">&#123;- can be nested -&#125;</span></span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Elm是强类型语言，有Bool，Int，Float，Char，String 5种基本类型。有意思的是，<strong>Elm没有Null</strong>。这也是特别<a target="_blank" rel="noopener" href="https://guide.elm-lang.org/error_handling/">设计</a>的。</p>
<div class="tip">注意：Elm中Char类型用单引号`'`包裹，而String类型用双引号`"`包裹。
</div>

<p>除了基本类型，Elm中还有List，Array，Tuple，Dict，Record几种泛型。其中List，Record设计类似JavaScript中的Array和Object。</p>
<div class="tip">在Elm中`Array`和`List`是两种不同的类型，前者通过链表实现，后者通过Relaxed Radix Tree实现。前者在增删节点上高效，后者在随机查询时高效。</div>

<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> :: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: []</span><br><span class="line"><span class="title">point</span> =                         <span class="comment">-- create a record</span></span><br><span class="line">  &#123; x = <span class="number">3</span>, y = <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">point</span>.x                         <span class="comment">-- access field</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span>.map .x [point,&#123;x=<span class="number">0</span>,y=<span class="number">0</span>&#125;]   <span class="comment">-- field access function</span></span><br><span class="line"></span><br><span class="line">&#123; point | x = <span class="number">6</span> &#125;               <span class="comment">-- update a field</span></span><br><span class="line"></span><br><span class="line">&#123; point |                       <span class="comment">-- update many fields</span></span><br><span class="line">    x = point.x + <span class="number">1</span>,</span><br><span class="line">    y = point.y + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*(值得注意的是，上面的<code>::</code>和<code>.x</code>实际上都是函数)*。</p>
<h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>类型是Elm中重要的一环，每个变量都需要有类型，编译时需要进行检查。因此显式地声明变量类型很重要。</p>
<p>当我们需要通过基本类型构造复杂类型时，可以通过<code>type alias</code>的形式为record创建新的类型。在新类型创建的同时，会同步生成一个record构造函数。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Before：麻烦的函数写法</span></span><br><span class="line"><span class="title">hasBio</span> : &#123; name : <span class="type">String</span>, bio : <span class="type">String</span>, pic : <span class="type">String</span> &#125; -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">hasBio</span> user =</span><br><span class="line">  <span class="type">String</span>.length user.bio &gt; <span class="number">0</span></span><br><span class="line"><span class="comment">-- After：简便的写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">alias</span> <span class="type">User</span> =</span><br><span class="line">  &#123; name : <span class="type">String</span></span><br><span class="line">  , bio : <span class="type">String</span></span><br><span class="line">  , pic : <span class="type">String</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="title">hasBio</span> : <span class="type">User</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">hasBio</span> user =</span><br><span class="line">  <span class="type">String</span>.length user.bio &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="Union类型"><a href="#Union类型" class="headerlink" title="Union类型"></a>Union类型</h4><p>之所以单独拿出来说，是因为Union Type的设计几乎是Elm的精髓。首先，它类似于枚举（enum）的概念，通过<code>type enum = A | B | C</code>的形式定义一个类型。这是简单的Union Type的使用。</p>
<p>Union Type还有Tagged Union的用法。即下面这样。这意味着<strong>User可以是不带信息的Anonymous或带有String信息的Named</strong>。<code>Anonymous</code>和<code>Named</code>是User的两个构造函数。其中Named接受一个String类型入参构造User类型。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">User</span> = <span class="type">Anonymous</span> | <span class="type">Named</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>

<div class="tip">注意：不同Union Type间的Tag构造函数不能同名，即不能出现下面的情况。同时Tag后的额外消息是泛型`a`时，需要在type名后也加上，便于type check</div>

<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">User</span> = <span class="type">Named</span> | <span class="type">Named</span> <span class="type">String</span> <span class="comment">-- Wrong!</span></span><br></pre></td></tr></table></figure>

<p>结合上面的特点，可以很容易地将相似数据结构或设计抽象为单一模板，如<a target="_blank" rel="noopener" href="https://guide.elm-lang.org/types/union_types.html">举例</a>中的将时间轴、日志等统一抽象为widget。思路：<strong>逐个击破，合而为一</strong></p>
<p>由于Union Type可以递归定义，通过Union Type甚至可以构建链表和<a target="_blank" rel="noopener" href="http://elm-lang.org/examples/binary-tree">二叉树</a>。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">List</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">List</span> a)</span><br><span class="line"><span class="keyword">type</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">Tree</span> a) (<span class="type">Tree</span> a)</span><br></pre></td></tr></table></figure>

<p>此外，Elm中的错误处理<a target="_blank" rel="noopener" href="https://guide.elm-lang.org/error_handling/maybe.html">Maybe</a>和<a target="_blank" rel="noopener" href="https://guide.elm-lang.org/error_handling/result.html">Result</a>也是基于Union Type实现的。</p>
<p>因为Union Type的不同子类型可以有自己独特的构造函数，且支持解构赋值，因此非常适合用作实现状态管理的事件。Web App中的update函数接受的Html Msg类型实际上也是Union Type实现的。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>除了不能手动更改状态的变量（因此<strong>递归完全替代了循环结构</strong>），函数是Elm中最常见的存在。命令式编程中，函数用作告诉电脑该怎么做。函数式编程中，函数用作描述一种映射关系，告诉电脑要什么。Elm中函数像下面这样声明：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square</span> n =</span><br><span class="line">  n^<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">hypotenuse</span> : <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">hypotenuse</span> a b =</span><br><span class="line">  sqrt (square a + square b)</span><br><span class="line"></span><br><span class="line"><span class="title">distance</span> (a,b) (x,y) =</span><br><span class="line">  hypotenuse (a-x) (b-y)</span><br></pre></td></tr></table></figure>

<p>入参在上，返回值在下。入参间通过空格隔开，由于Elm支持函数柯里化，所以在函数的类型声明中，也是通过<code>-&gt;</code>隔开每个入参以及返回值的。由于函数变成了纯粹的“通道”，函数体中声明临时变量的语法通过<code>let ... in</code>的形式实现。</p>
<p>Elm中也有匿名函数，像下面这样，由反斜线<code>\</code>开头：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square</span> =</span><br><span class="line">  \n -&gt; n^<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">squares</span> =</span><br><span class="line">  <span class="type">List</span>.map (\n -&gt; n^<span class="number">2</span>) (<span class="type">List</span>.range <span class="number">1</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>函数间通过<code>|&gt;</code>和<code>&lt;|</code>连接减少括号的使用。例如下面这样</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">viewNames1</span> names =</span><br><span class="line">  <span class="type">String</span>.join <span class="string">&quot;, &quot;</span> (<span class="type">List</span>.sort names)</span><br><span class="line"></span><br><span class="line"><span class="title">viewNames2</span> names =</span><br><span class="line">  names</span><br><span class="line">    |&gt; <span class="type">List</span>.sort</span><br><span class="line">    |&gt; <span class="type">String</span>.join <span class="string">&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (arg |&gt; func) is the same as (func arg)</span></span><br></pre></td></tr></table></figure>

<p>同时，可以通过<code>&gt;&gt;</code>和<code>&lt;&lt;</code>构造复合函数。<code>``</code>用来将第<code>n</code>个函数入参前置，使得居于更符合语法习惯，如<code>buyMilk `then` drinkMilk</code>中<code>buyMilk</code>参数被提前。<code>n</code>可以通过<code>infixr</code>设置。</p>
<p>其中可能较难理解的是<strong>递归完全替代了循环结构</strong>，Elm类似其他函数式语言，没有<code>for</code>和<code>while</code>。它用描述问题的方式，通过递归解决普通的循环问题，下面举两个例子：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse</span> : <span class="type">List</span> a -&gt; <span class="type">List</span> a</span><br><span class="line"><span class="title">reverse</span> list =</span><br><span class="line">  <span class="keyword">case</span> list <span class="keyword">of</span></span><br><span class="line">    [] -&gt; []</span><br><span class="line">    (x::xs) -&gt; reverse xs ++ [x]</span><br><span class="line"></span><br><span class="line"><span class="title">quicksort</span> : <span class="type">List</span> comparable -&gt; <span class="type">List</span> comparable</span><br><span class="line"><span class="title">quicksort</span> list = </span><br><span class="line">  <span class="keyword">case</span> list <span class="keyword">of</span></span><br><span class="line">    [] -&gt; []</span><br><span class="line">    (x::xs) -&gt;</span><br><span class="line">      <span class="keyword">let</span> </span><br><span class="line">        smallerSorted = quicksort (<span class="type">List</span>.filter ((&gt;) x) xs)</span><br><span class="line">        biggerSorted = quicksort (<span class="type">List</span>.filter ((&lt;=) x) xs)</span><br><span class="line">      <span class="keyword">in</span>  </span><br><span class="line">        smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure>

<p>可以找到规律：</p>
<blockquote>
<p>Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest.</p>
</blockquote>
<p>更具体的解释可以看参考链接3。</p>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>Elm中没有<code>for</code>和<code>while</code>循环（都通过递归实现了）。但是存在<code>if</code>和<code>case</code>语句。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if</span> powerLevel &gt; <span class="number">9000</span> <span class="keyword">then</span> <span class="string">&quot;OVER 9000!!!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;meh&quot;</span></span><br><span class="line"><span class="title">case</span> maybe <span class="keyword">of</span></span><br><span class="line">  <span class="type">Just</span> xs -&gt; xs</span><br><span class="line">  <span class="type">Nothing</span> -&gt; []</span><br><span class="line"></span><br><span class="line"><span class="title">case</span> xs <span class="keyword">of</span></span><br><span class="line">  hd::tl -&gt; <span class="type">Just</span> (hd,tl)</span><br><span class="line">  []     -&gt; <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">case</span> n <span class="keyword">of</span></span><br><span class="line">  <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">  <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line">  _ -&gt; fib (n<span class="number">-1</span>) + fib (n<span class="number">-2</span>) <span class="comment">-- _表示不接受入参</span></span><br></pre></td></tr></table></figure>

<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li><code>++</code>连接字符串，<code>+</code>表示相加</li>
<li>Elm不会进行强制类型转换</li>
<li>缩进会影响语句解析</li>
<li>list中所有元素类型必须一致</li>
<li>tuples设计类似python</li>
<li>records类型不允许访问不存在的属性</li>
<li><code>//</code>用来进行C风格的除法</li>
<li>Elm中!用于连接Model和Cmd，用<code>/=</code>表示<code>!=</code>，同<code>not</code>表示<code>!</code></li>
</ul>
<p>Elm的语言设定大不同于C风格，所以，多写去熟悉它的语法风格吧。</p>
<h2 id="Elm架构"><a href="#Elm架构" class="headerlink" title="Elm架构"></a>Elm架构</h2><p>Elm构建Web App的架构为MVU（不考虑Cmd和Subscription的话），这和目前大部分MVVM框架一样，致力于减少UI维护，减少不必要的状态修改来更好地定位错误。有意思的是，Elm也<a target="_blank" rel="noopener" href="http://elm-lang.org/blog/blazing-fast-html">采用了Virtual DOM的设计</a>。</p>
<ul>
<li>Model，类似Web App的state，通常为<code>records</code>类型</li>
<li>Update，更新state的唯一方式（类似于action或commit），通常类型为<code>Msg -&gt; Model -&gt; (Model, Cmd Msg)</code></li>
<li>View，根据state渲染HTML的方式，通常类型为<code>Model -&gt; Html Msg</code></li>
</ul>
<p>Update部分，通常像下面这样，接受Union Type的Msg，并通过<code>case ... of</code>接受到附在Msg上的payload。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">update</span> : <span class="type">Msg</span> -&gt; <span class="type">Model</span> -&gt; <span class="type">Model</span></span><br><span class="line"><span class="title">update</span> msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Change</span> newContent -&gt;</span><br><span class="line">      &#123; model | content = newContent &#125;</span><br></pre></td></tr></table></figure>

<p>View部分，所有常用的标签名和属性名都被封装为函数，接受属性列表和子元素列表两个入参，像下面这样。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">view</span> : <span class="type">Model</span> -&gt; <span class="type">Html</span> <span class="type">Msg</span></span><br><span class="line"><span class="title">view</span> model =</span><br><span class="line">  div []</span><br><span class="line">    [ input [ placeholder <span class="string">&quot;Text to reverse&quot;</span>, onInput <span class="type">Change</span> ] []</span><br><span class="line">    , div [] [ text (<span class="type">String</span>.reverse model.content) ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>将M、V、U三部分结合在一起就可以构造简单的web应用了。当有异步任务等复杂情况出现时，需要通过Cmd和Subscription实现。</p>
<h3 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h3><p><img src="https://guide.elm-lang.org/architecture/effects/beginnerProgram.svg" alt="Elm Architecture"></p>
<p>说这两位之前，我们要回顾下之前的工作流。仔细观察就能发现，我们所做的事只是描述了接受Html Msg后如何生产新的Model并根据新的Model生产新的Html Msg交给Elm Runtime，之后的脏活累活都交给Elm干了。根据Elm的描述，除了vDOM外，它还使用了下面两个手段提升效率：</p>
<ul>
<li><strong>Skip Work</strong>，通过<code>lazy</code>（类似React的<code>shouldComponentUpdate</code>）限制更新频率</li>
<li><strong>Align Work</strong>，通过<code>Html.keyed</code>（类似React的<code>key</code>）减少无意义的diffing。</li>
</ul>
<p>回到正题，Cmd和Subscription也是对Msg所做的外层包装而已。除了能向Elm Runtime pipe Html Msg外，当然也可以发送命令或订阅事件</p>
<p><img src="https://guide.elm-lang.org/architecture/effects/program.svg"></p>
<p>。Html, Cmd, Sub三者实际上没太大区别，都是我们将生成的数据交给Elm Runtime，剩下的做甩手掌柜。它可以帮助我们：</p>
<ul>
<li>更好的debug</li>
<li>确保Elm函数的线性时不变</li>
<li>优化HTTP连接，缓存effects</li>
</ul>
<p>下面是一个Sub的例子：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SUBSCRIPTIONS</span></span><br><span class="line"></span><br><span class="line"><span class="title">subscriptions</span> : <span class="type">Model</span> -&gt; <span class="type">Sub</span> <span class="type">Msg</span></span><br><span class="line"><span class="title">subscriptions</span> model =</span><br><span class="line">  <span class="type">Time</span>.every second <span class="type">Tick</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UPDATE</span></span><br><span class="line"></span><br><span class="line"><span class="title">update</span> : <span class="type">Msg</span> -&gt; <span class="type">Model</span> -&gt; (<span class="type">Model</span>, <span class="type">Cmd</span> <span class="type">Msg</span>)</span><br><span class="line"><span class="title">update</span> msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Tick</span> newTime -&gt;</span><br><span class="line">      (newTime, <span class="type">Cmd</span>.none)</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>之前提到过Elm致力于“编辑时无bug&#x3D;&gt;Runtime无bug”。除了强类型和无状态（实际上是Immutable的状态）外，还有Maybe和Result的辅助。</p>
<blockquote>
<p>Elm treats errors as data.</p>
</blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">null的糟糕设计</a>，Elm通过</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span><br></pre></td></tr></table></figure>
<p>定义了Maybe类型。结合<code>case of</code>的特殊情况处理，通过<strong>option types</strong>的方法<strong>替代Null</strong>。<a target="_blank" rel="noopener" href="http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Maybe">core&#x2F;Maybe</a>模块还有<code>withDefault</code>，<code>andThen</code>等其他方法。</p>
<p>类似于Maybe，Result用Union Type的形式定义了不可靠操作的返回值。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Result</span> error value = <span class="type">Err</span> error | <span class="type">Ok</span> value</span><br></pre></td></tr></table></figure>
<p>通过Err和Ok两种类型，隐含了其他语言中的<code>try catch</code>操作，<strong>避免exception</strong>的出现。Elm库函数是实现了Result类型的，如<code>Http.get</code>。Result预定义在<a target="_blank" rel="noopener" href="http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Result">core&#x2F;Result</a>中</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>另外，Elm中有Task用来处理异步操作中的失败情况。类似于JS中的Promise。使用思路是先通过succeed方法和fail方法定义Task再使用。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">alias</span> <span class="type">Task</span> err ok =</span><br><span class="line">  <span class="type">Task</span> err ok</span><br><span class="line"><span class="title">succeed</span> : a -&gt; <span class="type">Task</span> x a</span><br><span class="line"><span class="title">fail</span> : x -&gt; <span class="type">Task</span> x a</span><br></pre></td></tr></table></figure>

<p>在Elm由0.17升级到0.18时，有两种方式执行一个Task。<code>Task.perform</code>和<code>Task.attempt</code>。前者针对<strong>从不返回错误</strong>的task，后者针对<strong>可能出错</strong>的task。更重要的是，在<code>Task.attempt</code>中结合了熟悉的Result模型。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">perform</span> : (a -&gt; msg) -&gt; <span class="type">Task</span> <span class="type">Never</span> a -&gt; <span class="type">Cmd</span> msg</span><br><span class="line"><span class="title">attempt</span> : (<span class="type">Result</span> x a -&gt; msg) -&gt; <span class="type">Task</span> x a -&gt; <span class="type">Cmd</span> msg</span><br><span class="line"><span class="comment">-- example</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">Msg</span> = <span class="type">Click</span> | <span class="type">NewTime</span> <span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="title">update</span> : <span class="type">Msg</span> -&gt; <span class="type">Model</span> -&gt; ( <span class="type">Model</span>, <span class="type">Cmd</span> <span class="type">Msg</span> )</span><br><span class="line"><span class="title">update</span> msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Click</span> -&gt;</span><br><span class="line">      ( model, <span class="type">Task</span>.perform <span class="type">NewTime</span> <span class="type">Time</span>.now )</span><br><span class="line"></span><br><span class="line">    <span class="type">NewTime</span> time -&gt;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<h2 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h2><p>Elm的互操作性体现在和JSON以及JavaScript上。</p>
<h3 id="与JSON"><a href="#与JSON" class="headerlink" title="与JSON"></a>与JSON</h3><p>通过Json.Decode和Json.Encode完成相关工作。解析部分由<code>decodeString</code>完成。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">decodeString</span> : <span class="type">Decoder</span> a -&gt; <span class="type">String</span> -&gt; <span class="type">Result</span> <span class="type">String</span> a</span><br></pre></td></tr></table></figure>
<p>由第一个参数指定decoder类型，如 <code>decodeString int &quot;42&quot;</code>就指定了一个整数的解析器。在多数情况下，JSON字符串并没这么简单。这时，需要先利用基本的int、string、list、dict解析器结合map2、map3等构造相应的Decoder，再交给decodeString处理。<strong>函数返回<code>Result</code>类型</strong>。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Json.Decode <span class="keyword">exposing</span> (..)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">alias</span> <span class="type">Point</span> = &#123; x : <span class="type">Int</span>, y : <span class="type">Int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">pointDecoder</span> = map2 <span class="type">Point</span> (field <span class="string">&quot;x&quot;</span> int) (field <span class="string">&quot;y&quot;</span> int)</span><br><span class="line"></span><br><span class="line"><span class="title">decodeString</span> pointDecoder <span class="string">&quot;&quot;</span><span class="string">&quot;&#123; &quot;</span>x<span class="string">&quot;: 3, &quot;</span>y<span class="string">&quot;: 4 &#125;&quot;</span><span class="string">&quot;&quot;</span> <span class="comment">-- Ok &#123; x = 3, y = 4 &#125; : Result String Point</span></span><br></pre></td></tr></table></figure>

<p>是不是很麻烦。不像JavaScript里一个<code>JSON.parse()</code>完事，确实Elm解析JSON的笨拙为人诟病，官方的<a target="_blank" rel="noopener" href="http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest">pipeline</a>包通过<code>|&gt;</code>组合Decoder，让语法稍微好了一点。最新的0.18版本下有<a target="_blank" rel="noopener" href="http://package.elm-lang.org/packages/elm-community/json-extra/2.6.0/Json-Decode-Extra">json-extra</a>提供更方便的decoder选择。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Json.Decode.Pipeline <span class="keyword">exposing</span> (decode, required)</span><br><span class="line"></span><br><span class="line"><span class="title">pointDecoder</span> : <span class="type">Decoder</span> <span class="type">Point</span></span><br><span class="line"><span class="title">pointDecoder</span> =</span><br><span class="line">  decode <span class="type">Point</span></span><br><span class="line">    |&gt; required <span class="string">&quot;x&quot;</span> int</span><br><span class="line">    |&gt; required <span class="string">&quot;y&quot;</span> int</span><br></pre></td></tr></table></figure>

<p>可这距离<code>JSON.parse</code>还是不够啊。于是有人写了个根据Records类型<a target="_blank" rel="noopener" href="https://github.com/eeue56/json-to-elm">生成decoder的工具</a>，或者<a target="_blank" rel="noopener" href="http://noredink.github.io/json-to-elm/">在线生成</a>。</p>
<p>相比之下，<a target="_blank" rel="noopener" href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode">encode</a>过程就简单多了。</p>
<h3 id="与JavaScript"><a href="#与JavaScript" class="headerlink" title="与JavaScript"></a>与JavaScript</h3><p>有两种方式，port或flag。</p>
<p>前者类似于在Elm应用上凿洞，用类似订阅发布的模式工作。需要在文件开头的module声明前，额外加上<code>port</code>关键词，同时需要暴露的接口前也需要<code>port</code>关键词。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">port</span> <span class="keyword">module</span> Spelling <span class="keyword">exposing</span> (..)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- port for sending strings out to JavaScript</span></span><br><span class="line"><span class="keyword">port</span> check : String -&gt; Cmd msg</span><br><span class="line"></span><br><span class="line"><span class="comment">-- port for listening for suggestions from JavaScript</span></span><br><span class="line"><span class="keyword">port</span> suggestions : (<span class="type">List</span> <span class="type">String</span> -&gt; msg) -&gt; Sub msg</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="title class_">Elm</span>.<span class="property">Spelling</span>.<span class="title function_">fullscreen</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="property">ports</span>.<span class="property">check</span>.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> suggestions = <span class="title function_">spellCheck</span>(word);</span><br><span class="line">  app.<span class="property">ports</span>.<span class="property">suggestions</span>.<span class="title function_">send</span>(suggestions);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">spellCheck</span>(<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="comment">// have a real implementation!</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后者暴露program的init给外部JavaScript。在声明Elm program时，使用<code>programWithFlags</code>而非<code>program</code>。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">init</span> : <span class="type">Flags</span> -&gt; ( <span class="type">Model</span>, <span class="type">Cmd</span> <span class="type">Msg</span> )</span><br><span class="line"><span class="title">init</span> flags =</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> =</span><br><span class="line">  programWithFlags &#123; init = init, ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="title class_">Elm</span>.<span class="property">MyApp</span>.<span class="title function_">fullscreen</span>(&#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">token</span>: <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Elm的思路是不向后兼容，避免过去问题的引入。只通过port和flags的方式，借由Elm runtime和外部JS沟通，避免自身的runtime exception，把问题只留在JavaScript部分。</p>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><p>使用Elm编写简单的应用时，可能一个.elm文件完成后，就可以直接<code>elm-make index.elm --output index.js</code>就OK了。当工程较大时（目前还没怎么看到生产环境用Elm的），必然需要拆分组件。</p>
<p>Elm在设计上，拆分的比MVVM框架更细。它拆分到了函数的级别，由于它pure function的特点，不受状态的束缚，重用函数比MVVM框架顾虑少太多了。如，重用view函数就相当于React和Vue中的函数式组件。重用update函数，可以实现MVVM中“组件A改变组件B，组件B改变组件C，组件C改变组件A”的史诗级难题。</p>
<p>封装和应用是通过<code>module ... exposing ...</code>和<code>import ... exposing ...</code>的语法完成的。Elm会去elm-package.json中的<code>source-directories</code>以及<code>dependencies</code>中声明的路径和包下寻找<code>import</code>对应的东西。剩下的，只要控制好复用程度，在习惯Elm语法后，就可以轻松且高逼格地编写Web应用了。</p>
<p>Elm编写好，且通过<code>elm-make</code>成功编译后，会得到一个<code>.js</code>文件，在需要的HTML文件中引入，会得到一个<code>Elm</code>全局对象，存储了所有的program。<strong>每个program都有<code>embed</code>方法和<code>fullscreen</code>方法绑定在HTML文件中</strong>。之后，大功告成！</p>
<p>参考作者所写的<a target="_blank" rel="noopener" href="https://github.com/evancz/elm-todomvc">TODOMVC</a>是个不错的开始。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p><strong>Q：Where are my components? And how do they communicate?</strong><br>A：参见<a target="_blank" rel="noopener" href="https://guide.elm-lang.org/reuse/">Scaling The Elm Architecture</a></p>
<p><strong>Q：What’s the “Elm style”?</strong><br>A：回头看看<a href="#%E5%89%8D%E8%A8%80">前言</a>一节最后放的两个Elm开发感受，Elm中，View和Updates两部分均可以拆解成多个&#x2F;组helper functions。最后在一个门面文件中汇总。Elm将state、updates、view放在一个文件，对开发更友好。Elm的优势在于函数式编程特点的帮助（无副作用&#x2F;纯函数&#x2F;强类型&#x2F;出色的错误处理机制）和对人机交互模式的优异抽象。它的问题在</p>
<ul>
<li>不完善的文档</li>
<li>蹩脚的互操作（interop）设计（port和flag）</li>
<li>学习曲线陡峭</li>
<li>缺乏成熟的成套解决方案</li>
<li>坑爹的JSON支持</li>
</ul>
<p><strong>Q：Who will save my front-end routing?</strong><br>A：有的，借助<a target="_blank" rel="noopener" href="https://github.com/elm-lang/navigation">Elm Navigation package</a>就可以做到，具体如何和状态变化绑定起来参见<a target="_blank" rel="noopener" href="https://www.elm-tutorial.org/en/07-routing/01-intro.html">tutorial的routing部分</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://guide.elm-lang.org/">An Introduction to Elm</a></li>
<li><a target="_blank" rel="noopener" href="http://elm-lang.org/docs/syntax">syntax</a></li>
<li><a target="_blank" rel="noopener" href="https://learnyouanelm.github.io/pages/05-recursion.html">Recursion | Elm</a></li>
<li><a target="_blank" rel="noopener" href="https://infi.nl/nieuws/why-i-became-an-elm-evangelist/">Why I became an Elm evangelist</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/isRuslan/awesome-elm">awesome-elm</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Elm/" rel="tag"># Elm</a>
              <a href="/blog/tags/%E6%A1%86%E6%9E%B6/" rel="tag"># 框架</a>
              <a href="/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"># 函数式编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2017/05/19/Frontend-FAQ-part3/" rel="prev" title="前端常见面试问题 part 3">
                  <i class="fa fa-chevron-left"></i> 前端常见面试问题 part 3
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2017/06/20/functional-programming-brief/" rel="next" title="函数式编程扫盲">
                  函数式编程扫盲 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">974k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">27:04</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

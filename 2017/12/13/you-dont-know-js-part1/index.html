<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.png">
  <link rel="mask-icon" href="/blog/favicon.png" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenlvmeng.github.com","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"N573WZGUR1","apiKey":"f4b654279103617a4cefb92a132ff0c3","indexName":"blog","hits":{"per_page":10}}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="原作：You-Dont-Know-JS本文的99.9%的内容都来自《You dont know JS》的电子中文版 传送门：《You don’t know JS》 下（类型文法&amp;异步&amp;ES6与未来）  入门与进阶值和类型JavaScript只有带类型的值，没有带类型的变量。大家都知道JS的基本类型共6类：  undefined null boolean number string">
<meta property="og:type" content="article">
<meta property="og:title" content="《You don&#39;t know JS》 上（入门&amp;作用域&amp;对象）">
<meta property="og:url" content="http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/">
<meta property="og:site_name" content="Shenlvmeng&#39;s Blog">
<meta property="og:description" content="原作：You-Dont-Know-JS本文的99.9%的内容都来自《You dont know JS》的电子中文版 传送门：《You don’t know JS》 下（类型文法&amp;异步&amp;ES6与未来）  入门与进阶值和类型JavaScript只有带类型的值，没有带类型的变量。大家都知道JS的基本类型共6类：  undefined null boolean number string">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-12-13T12:54:12.000Z">
<meta property="article:modified_time" content="2017-12-15T13:09:30.626Z">
<meta property="article:author" content="shenlvmeng">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/","path":"2017/12/13/you-dont-know-js-part1/","title":"《You don't know JS》 上（入门&作用域&对象）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《You don't know JS》 上（入门&作用域&对象） | Shenlvmeng's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Shenlvmeng's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6"><span class="nav-number">1.</span> <span class="nav-text">入门与进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">值和类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Strict%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">Strict模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="nav-number">1.4.</span> <span class="nav-text">函数作为值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E4%BB%A3%E5%92%8Cprototype"><span class="nav-number">1.5.</span> <span class="nav-text">this指代和prototype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">新的特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">2.</span> <span class="nav-text">作用域与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.2.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.3.</span> <span class="nav-text">块作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87"><span class="nav-number">2.4.</span> <span class="nav-text">提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">2.5.</span> <span class="nav-text">闭包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">this与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">this是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97"><span class="nav-number">3.2.</span> <span class="nav-text">this豁然开朗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="nav-number">3.3.1.</span> <span class="nav-text">计算型属性名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Immutability"><span class="nav-number">3.3.2.</span> <span class="nav-text">Immutability</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getter%E4%B8%8Esetter"><span class="nav-number">3.3.3.</span> <span class="nav-text">getter与setter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%EF%BC%88%E6%B7%86%EF%BC%89%E2%80%9C%E7%B1%BB%E2%80%9D%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.4.</span> <span class="nav-text">混合（淆）“类”的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-number">3.6.</span> <span class="nav-text">原型继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.6.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98"><span class="nav-number">3.7.</span> <span class="nav-text">行为委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%87%AA%E7%9C%81"><span class="nav-number">3.8.</span> <span class="nav-text">类型自省</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84class%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.9.</span> <span class="nav-text">新的class关键字</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shenlvmeng"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">shenlvmeng</p>
  <div class="site-description" itemprop="description">Be sharp, my friend.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">438</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shenlvmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/shenlvmeng" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;shenlvmeng" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shenlvmeng.github.com/blog/2017/12/13/you-dont-know-js-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="shenlvmeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shenlvmeng's Blog">
      <meta itemprop="description" content="Be sharp, my friend.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《You don't know JS》 上（入门&作用域&对象） | Shenlvmeng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《You don't know JS》 上（入门&作用域&对象）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-13 20:54:12" itemprop="dateCreated datePublished" datetime="2017-12-13T20:54:12+08:00">2017-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-12-15 21:09:30" itemprop="dateModified" datetime="2017-12-15T21:09:30+08:00">2017-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2017/12/13/you-dont-know-js-part1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/13/you-dont-know-js-part1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>原作：<a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a><br>本文的99.9%的内容都来自《You dont know JS》的<a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN">电子中文版</a></p>
<p>传送门：<a target="_blank" rel="noopener" href="https://shenlvmeng.github.io/blog/2017/12/15/you-dont-know-js-part2/">《You don’t know JS》 下（类型文法&amp;异步&amp;ES6与未来）</a></p>
</blockquote>
<h2 id="入门与进阶"><a href="#入门与进阶" class="headerlink" title="入门与进阶"></a>入门与进阶</h2><h3 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h3><p>JavaScript只有带类型的值，没有带类型的变量。大家都知道JS的基本类型共6类：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>object</li>
</ul>
<p>但是在ES6之后，需要新增一类<code>symbol</code>。另外，对null使用<code>typeof</code>将得到“object”的结果。</p>
<p>JavaScript中对“falsy”的定义包括：</p>
<ul>
<li>“”</li>
<li>0, -0, NaN</li>
<li>null, undefined</li>
<li>false</li>
</ul>
<p>除此之外的值都是truthy。</p>
<p>关于JavaScript中的<code>==</code>和<code>===</code>，作者的看法是在必要的时候<code>==</code>会很好地改善程序。然而<code>==</code>的<a target="_blank" rel="noopener" href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">判断规则</a>比较复杂，可以总结出一些情况便于我们选择是否使用<code>==</code>：</p>
<ul>
<li>如果一个比较的两个值之一可能是<code>true</code>或<code>false</code>，避免&#x3D;&#x3D;而使用&#x3D;&#x3D;&#x3D;。</li>
<li>如果一个比较的两个值之一可能是<code>0</code>&#x2F;<code>&quot;&quot;</code>&#x2F;<code>[]</code>，避免&#x3D;&#x3D;而使用&#x3D;&#x3D;&#x3D;。</li>
<li>其他情况下，放心使用<code>==</code>。不仅安全，在许多情况下它可以简化你的代码并改善可读性。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>一个变量标识符必须以a-z，A-Z，$，或<code>_</code>开头。它可以包含任意这些字符外加数字0-9，但不能使用保留字。</p>
<p>变量作用域提升（var定义）和嵌套就不多说了。</p>
<h3 id="Strict模式"><a href="#Strict模式" class="headerlink" title="Strict模式"></a>Strict模式</h3><p>让代码更严谨，同样可以选择用在全局或是函数中。</p>
<h3 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h3><p><strong>IIFE</strong>（立即执行函数）和<strong>闭包</strong>是JS中值得玩味的特性。除了使用<code>()</code>包裹，还可以用<code>void</code>打头开始一个IIFE。</p>
<p>闭包经常用来包装模块。</p>
<h3 id="this指代和prototype"><a href="#this指代和prototype" class="headerlink" title="this指代和prototype"></a>this指代和prototype</h3><p>略</p>
<h3 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h3><p>填充（polyfill）和转译（transpile）</p>
<h2 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域与LHS，RHS。在非Strict模式下，如果到全局作用域还找不到变量，会在作用域内创建一个新的同名变量。在Strict模式下，不允许这种行为（意外地创建全局变量），此时会抛出ReferenceError，即找不到变量。如果找到了值，但是并不能对它做一些事情，就会抛出TypeError。</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JavaScript使用词法作用域，即变量和作用域在编写代码阶段已经确定。JS引擎也可以在这个阶段针对作用域和变量对代码进行优化，但是<code>eval()</code>和<code>with()</code>会在代码中动态改变作用域，从而使得引擎无法进行优化，使代码运行得更慢。在strict模式下，<code>eval()</code>的不安全用法（修改作用域）以及<code>with()</code>都是不允许使用的。</p>
<p>词法作用域是编写时的，而动态作用域（和this）是运行时的。词法作用域关心的是函数<strong>在何处被声明</strong>，但是动态作用域关心的是函数<strong>从何处被调用</strong>。</p>
<p><code>this</code>在JS中始终是运行时的，即根据运行时的调用情况有不同的值。在<strong>箭头函数</strong>中则是词法this的，即声明时决定。</p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>封装、匿名函数、IIFE。</p>
<p>for循环、if、while、switch等流程控制语句的<code>&#123;&#125;</code>，都是<em>假的</em>块作用域，其中的内容都依附于外部的函数作用域。with（不建议使用），try catch，let，const可以形成新的块作用域。</p>
<p>在ES6到ES5的转译时，具有块作用域的代码，会采用<code>try catch</code>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(a) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><ul>
<li>在代码被执行前，所有的声明，变量和函数，都会首先被处理。处理的只有“声明”，而没有“赋值”。</li>
<li>函数提升优先于变量的提升</li>
<li>后续的提升会覆盖此前的同名提升</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。</p>
</blockquote>
<p>循环加闭包会出现面试中的经典问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码为啥不好用？</p>
<p>从之前关于作用域的讨论来看，每次setTimeout只是完成了函数声明，并丢进队列里而已。当定时器函数在其词法作用域外执行时，因为闭包的特点会保留有父级的作用域。而这5个函数都定义在同一个父级函数作用域内，对变量i的引用自然是同一个了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有IIFE的加持，父级作用域现在变成了每个IIFE而非for循环所在的作用域。即每个变量i来自不同的独立作用域，自然就可以得到理想的效果了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不就是想要个块作用域嘛，使用<code>let</code>关键字后变量将不是只为循环声明一次，而是为每次迭代声明一次。每次都能得到一个新的块作用域，自然得到和IIFE一样的效果。</p>
<h2 id="this与对象"><a href="#this与对象" class="headerlink" title="this与对象"></a><code>this</code>与对象</h2><h3 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a><code>this</code>是什么</h3><p>也许JS已经入门的前端程序员们早就对this在不同环境下的不同值烂熟在心。但可能没有想过这种情况的本质：上一部分提到的<strong>JS中的this是运行时的</strong>，和作用域完全不一样。</p>
<p>对比一下按照传统OOP理解下的JS代码，从不同的角度看，能进一步得到对this的认识：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;foo: &quot;</span> + num );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="title function_">foo</span>( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo` 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( foo.<span class="property">count</span> ); <span class="comment">// 0 -- 这他妈怎么回事……？</span></span><br></pre></td></tr></table></figure>

<p>虽然看上去很愚蠢，但是从词法作用域的角度去理解，是不是能更清楚看到JS中<code>this</code>的特殊之处。</p>
<h3 id="this豁然开朗"><a href="#this豁然开朗" class="headerlink" title="this豁然开朗"></a><code>this</code>豁然开朗</h3><p>根据上面的描述，<code>this</code>是根据调用点确定含义的。下面的4个规则，在准备JS面试的时候肯定都见过：</p>
<ul>
<li>默认绑定，独立函数调用。可以认为这种this规则是在没有其他规则适用时的默认规则。此时<code>this</code>指向全局对象，在strict mode下，<code>this</code>指向undefined。</li>
<li>隐含绑定，调用点有一个环境对象，即作为函数方法，但是下面的情况下会回退到默认绑定，因为调用点实际位于独立函数内<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// `a`也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// &quot;oops, global&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">fn</span>(); <span class="comment">// &lt;-- 调用点!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// `a`也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>( obj.<span class="property">foo</span> ); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>显式绑定，<code>call</code>与<code>apply</code>可以显式attach context到函数上，使用<code>bind</code>可以避免前面那种<code>this</code>丢失的情况。</li>
<li>new绑定，函数作为构造函数调用时，<code>this</code>指向即将返回的新对象。</li>
</ul>
<p>从优先级上看，new &gt; 硬绑定 &gt; 隐含绑定 &gt; 默认绑定。其中“new &gt; 硬绑定”有趣的一点是，使用<code>bind</code>在第一个后的参数实际上会作为函数的默认入参（类似于函数柯里化），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p1,p2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里使用 `null` 是因为在这种场景下我们不关心 `this` 的硬绑定</span></span><br><span class="line"><span class="comment">// 而且反正它将会被 `new` 调用覆盖掉！</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( <span class="literal">null</span>, <span class="string">&quot;p1&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="string">&quot;p2&quot;</span> );</span><br><span class="line"></span><br><span class="line">baz.<span class="property">val</span>; <span class="comment">// p1p2</span></span><br></pre></td></tr></table></figure>

<p>除了上面的规则，还有一些特例：</p>
<p>传递<code>null</code>或<code>undefined</code>给<code>call</code>，<code>apply</code>或<code>bind</code>时，那么这些值会被忽略掉，取而代之的是<strong>默认绑定</strong>规则将适用于这个调用。单纯使用apply数组化输入参数（现在已经可以用<code>[...foo]</code>了）和bind柯里化函数时常用到。</p>
<p>不过，这么做还是有风险，建议用<code>Object.create(null)</code>创建的对象替代<code>null</code>，既能表示无意义的值，又能避免<strong>默认绑定</strong>的行为。</p>
<p>作者给出了软绑定的工具方法，提高了硬绑定的灵活性，又避免了<strong>默认绑定</strong>的问题。逻辑是在绑定时检查<code>this</code>是否是全局对象，如果是才使用输入的<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">    <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="variable language_">this</span>,</span><br><span class="line">            curried = [].<span class="property">slice</span>.<span class="title function_">call</span>( <span class="variable language_">arguments</span>, <span class="number">1</span> ),</span><br><span class="line">            bound = <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">                    (!<span class="variable language_">this</span> ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">                            <span class="variable language_">this</span> === <span class="variable language_">window</span>) ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">                            <span class="variable language_">this</span> === <span class="variable language_">global</span>)</span><br><span class="line">                    ) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">                    curried.<span class="property">concat</span>.<span class="title function_">apply</span>( curried, <span class="variable language_">arguments</span> )</span><br><span class="line">                );</span><br><span class="line">            &#125;;</span><br><span class="line">        bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>( fn.<span class="property"><span class="keyword">prototype</span></span> );</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外，前面提到的箭头函数具有词法<code>this</code>，等同在调用前声明<code>self = this</code>，再把<code>self</code>传入的效果。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>内建对象中，只有<code>Date()</code>是必须要使用<code>new</code>创建的。</p>
<p>对象的属性有两种访问方法：<code>.</code>操作符或<code>[ ]</code>操作符。不同的是<code>.</code>操作符后只能使用标识符兼容的属性名，<code>[...]</code>操作符后可以使用任何合理的UTF-8的字符串。另外，对象的属性名总是字符串，如果使用了其他类型值，会进行强制转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">myObject[<span class="literal">true</span>] = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">myObject[<span class="number">3</span>] = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">myObject[myObject] = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"></span><br><span class="line">myObject[<span class="string">&quot;true&quot;</span>];               <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">myObject[<span class="string">&quot;3&quot;</span>];                  <span class="comment">// &quot;bar&quot;</span></span><br><span class="line">myObject[<span class="string">&quot;[object Object]&quot;</span>];    <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="计算型属性名"><a href="#计算型属性名" class="headerlink" title="计算型属性名"></a>计算型属性名</h4><p>ES6中新增了<em>计算型属性名</em>，允许使用表达式作为一个键名称，表达式用<code>[ ]</code>括起来。像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    [prefix + <span class="string">&quot;bar&quot;</span>]: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    [prefix + <span class="string">&quot;baz&quot;</span>]: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject[<span class="string">&quot;foobar&quot;</span>]; <span class="comment">// hello</span></span><br><span class="line">myObject[<span class="string">&quot;foobaz&quot;</span>]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<p>深、浅复制与对象属性描述符（description），<code>writable</code>和<code>configurable</code>，<code>getOwnPropertyDescriptor()</code>与<code>defineProperty()</code>。在JS中，<code>delete</code>仅用于直接从目标对象移除该对象的（可以被移除的）属性，与释放内存并无直接关系。</p>
<h4 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h4><p><strong>注意：所有这些方法创建的都是浅不可变性。也就是，它们仅影响对象和它的直属属性的性质。如果对象拥有对其他对象（数组、对象、函数等）的引用，那个对象的内容不会受影响，任然保持可变</strong>。</p>
<p>属性描述符里的<code>writable</code>和<code>configuratable</code>限制了对属性和属性值的修改。<code>preventExtensions()</code>方法可以防止对象被添加新属性。</p>
<ul>
<li><code>seal()</code> &#x3D; <code>configuratable: false</code> + <code>preventExtensions()</code></li>
<li><code>freeze()</code> &#x3D; <code>seal()</code> + <code>writable: false</code></li>
</ul>
<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a>getter与setter</h4><p>除了使用<code>defineProperty</code>外，可以直接用字面量的形式，通过<code>get prop1()</code>或<code>set prop1(val)</code>的形式设置getter和setter。</p>
<p><code>for in</code>和<code>for of</code>。</p>
<h3 id="混合（淆）“类”的对象"><a href="#混合（淆）“类”的对象" class="headerlink" title="混合（淆）“类”的对象"></a>混合（淆）“类”的对象</h3><blockquote>
<p>有些语言（比如Java）不给你选择，所以这根本没什么 选择性 —— 一切都是类。其他语言如C&#x2F;C++或PHP同时给你过程式和面向类的语法，在使用哪种风格合适或混合风格上，留给开发者更多选择。</p>
</blockquote>
<p><strong>类意味着拷贝。</strong></p>
<p>当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。多态也是拷贝行为的结果。</p>
<p>但是：</p>
<ul>
<li>第一，JavaScript并<strong>不会</strong>自动地 （像类那样）在对象间创建拷贝；</li>
<li>第二，显式mixin只能复制函数或对象的<strong>引用</strong>，而不是自身。</li>
</ul>
<blockquote>
<p>正如我们在第四章讲解的，在 JavaScript 中，对于对象来说没有抽象模式&#x2F;蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p>
<p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p>
<p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p>
<p>总之，JavaScript中面向对象的部分和大多数OOP语言不完全一样。这使得在JS中模拟类编程将既累又会埋下很多坑。</p>
</blockquote>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>使用<code>[[get]]</code>查询属性时，也会在<code>[[prototype]]</code>链上寻找，因此修改对象属性的时候，应该注意<strong>属性遮蔽</strong>（即在<code>[[prototype]]</code>中找到）的情况。它会增加代码的复杂度和可读性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="title class_">Object</span>.<span class="title function_">create</span>( anotherObject );</span><br><span class="line"></span><br><span class="line">anotherObject.<span class="property">a</span>; <span class="comment">// 2</span></span><br><span class="line">myObject.<span class="property">a</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">anotherObject.<span class="title function_">hasOwnProperty</span>( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.<span class="title function_">hasOwnProperty</span>( <span class="string">&quot;a&quot;</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObject.<span class="property">a</span>++; <span class="comment">// 噢，隐式遮蔽！</span></span><br><span class="line"></span><br><span class="line">anotherObject.<span class="property">a</span>; <span class="comment">// 2</span></span><br><span class="line">myObject.<span class="property">a</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">myObject.<span class="title function_">hasOwnProperty</span>( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在<code>for in</code>循环中，同样注意用<code>hasOwnProperty()</code>排除<code>[[prototype]]</code>上的属性。</p>
<p>所有用<code>constructor</code>构建的对象都有所指向的prototype，而在prototype中的<code>.constructor</code>又会指回<code>constructor</code>。但是这个关系是可以被覆盖的。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>作者认为，JS中的对象是通过链接组织起来的。说是原型继承，实际上就是在两个原型间建立了<code>[[prototype]]</code>的关系。这个关系的建立方法很多，各有优劣。最简单的还是用ES5提供的<code>Object.create()</code>方法，对<code>__proto__</code>和<code>constructor</code>等视而不见。它的polyfill像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="property">create</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params">o</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>Object.create()</code>第一个后面的参数可以用来声明对象属性描述符，不过用得不多。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>虽然这些JavaScript机制看起来和传统面向类语言的“初始化类”和“类继承”类似，而在JavaScript中的关键区别是，没有拷贝发生。取而代之的是对象最终通过<code>[[Prototype]]</code>链链接在一起。</p>
<p>相反，“委托”是一个更确切的术语，因为这些关系不是拷贝而是委托链接。</p>
</blockquote>
<p>从这个角度去看<code>new Foo()</code>过程中发生的事，除了返回一个新的对象外，<code>Foo()</code>还会将这个对象和<code>Foo.prototype</code>链接起来（通过指定<code>[[prototype]]</code>），<code>Foo.prototype</code>和别的对象并没有本质区别。</p>
<h3 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h3><p>在上面一章提到，<code>[[prototype]]</code>是存在于对象内部的引用另一个对象的内部连接。当一个属性&#x2F;方法引用在一个对象上发生，而这样的属性&#x2F;方法又不存在时，这个链接就会被使用。在这种情况下，<code>[[Prototype]]</code>链接告诉引擎去那个被链接的对象上寻找该属性&#x2F;方法。接下来，如果那个对象也不能满足查询，就沿着它的<code>[[Prototype]]</code>查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。</p>
<p>其重要的实质<strong>全部在于被连接到其他对象的对象</strong>。</p>
<p>下面是一段OLOO（链接到其他对象的对象）风格的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Task</span> = &#123;</span><br><span class="line">    <span class="attr">setID</span>: <span class="keyword">function</span>(<span class="params">ID</span>) &#123; <span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable constant_">ID</span>; &#125;,</span><br><span class="line">    <span class="attr">outputID</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">id</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 `XYZ` 委托到 `Task`</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">XYZ</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>( <span class="title class_">Task</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XYZ</span>.<span class="property">prepareTask</span> = <span class="keyword">function</span>(<span class="params">ID,Label</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setID</span>( <span class="variable constant_">ID</span> );</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">label</span> = <span class="title class_">Label</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XYZ</span>.<span class="property">outputTaskDetails</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">outputID</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">label</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>它的特点在于：</p>
<ul>
<li>状态保留在委托者上</li>
<li>避免<code>[[prototype]]</code>链上的重复命名</li>
<li>行为委托用在内部实现，避免暴露在API的设计上</li>
</ul>
<p><strong>思维的转变</strong></p>
<p>放弃传统OO思路在JS中的蹩脚实现（像下面这样），抓住<code>[[prototype]]</code>链接对象以及“原型链”的特殊性，可以让思路更加自然且符合JS的特点（像下面的下面那样）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">who</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">me</span> = who;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">identify</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am &quot;</span> + <span class="variable language_">this</span>.<span class="property">me</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params">who</span>) &#123;</span><br><span class="line">    <span class="title class_">Foo</span>.<span class="title function_">call</span>( <span class="variable language_">this</span>, who );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>( <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> );</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>( <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">identify</span>() + <span class="string">&quot;.&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="title class_">Bar</span>( <span class="string">&quot;b1&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="title class_">Bar</span>( <span class="string">&quot;b2&quot;</span> );</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>();</span><br><span class="line">b2.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    <span class="attr">init</span>: <span class="keyword">function</span>(<span class="params">who</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">me</span> = who;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">identify</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am &quot;</span> + <span class="variable language_">this</span>.<span class="property">me</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bar</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>( <span class="title class_">Foo</span> );</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>( <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">identify</span>() + <span class="string">&quot;.&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="title class_">Object</span>.<span class="title function_">create</span>( <span class="title class_">Bar</span> );</span><br><span class="line">b1.<span class="title function_">init</span>( <span class="string">&quot;b1&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="title class_">Object</span>.<span class="title function_">create</span>( <span class="title class_">Bar</span> );</span><br><span class="line">b2.<span class="title function_">init</span>( <span class="string">&quot;b2&quot;</span> );</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>();</span><br><span class="line">b2.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<p>在这种委托的思路下，不存在严格的父子关系，甚至不存在继承和类的说法。全程通过<code>Object.create()</code>建立起对象和对象的联系，连<code>new</code>也是不建议使用的。</p>
<p>但是这种思路也有个明显的问题，“子类”没法定义“父类”的同名方法，因为整个程序建立在<code>[[prototype]]</code>联系的基础上，重复命名将会隔断连接。</p>
<p>作者并不推荐匿名函数的使用，认为：1，追踪调试栈困难；2，难以自引用；3，代码变得不好理解。这点上我是保留意见的。</p>
<h3 id="类型自省"><a href="#类型自省" class="headerlink" title="类型自省"></a>类型自省</h3><p>类型自省即<code>instanceof</code>，而这个操作符是依赖于<code>[[prototype]]</code>中的constructor属性的，这个属性除了不可枚举外，相较其他属性并没有特别之处。重写或者<code>[[prototype]]</code>的改变就可以改变它。因此，<code>instanceof</code>在很多情况下可能并不会那么可靠。</p>
<p>使用鸭子类型的类型自省就更加不可靠了。</p>
<p>在作者提出的OLOO范式中，采取<code>isPrototypeOf()</code>和<code>Object.getPrototypeOf()</code>进行类型自省。</p>
<h3 id="新的class关键字"><a href="#新的class关键字" class="headerlink" title="新的class关键字"></a>新的<code>class</code>关键字</h3><p>为了便于“类”思维编程者，<code>class</code>可以说是一大福音。</p>
<ul>
<li>不再有<code>.prototype</code>的困扰</li>
<li><code>extends</code>一键式继承</li>
<li><code>super</code>对多态的支持</li>
<li>语法上使用更加贴近OOP语言</li>
</ul>
<p>但实际上，这里的<code>class</code>只是语法糖，它还是没实现从类（“蓝图”）到实例（“建筑”）以及从父类到子类的复制，还建立在<code>[[prototype]]</code>的基础上。<a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/apA.md">原文</a>给出了很多例子说明这点。</p>
<blockquote>
<p>在传统面向类的语言中，你从不会在晚些时候调整类的定义，所以类设计模式不提供这样的能力。但是JS的一个最强大的部分就是它是动态的，而且任何对象的定义都是（除非你将它设定为不可变）不固定的可变的东西。</p>
</blockquote>
<blockquote>
<p>换句话说，class 好像在告诉你：“动态太坏了，所以这可能不是一个好主意。这里有看似静态语法，把你的东西静态编码。”</p>
<p>关于 JavaScript 的评论是多么悲伤啊：动态太难了，让我们假装成（但实际上不是！）静态吧。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
              <a href="/blog/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2017/12/11/raven/" rel="prev" title="Sentry Raven.js学习">
                  <i class="fa fa-chevron-left"></i> Sentry Raven.js学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2017/12/15/you-dont-know-js-part2/" rel="next" title="《You don't know JS》 下（类型文法&异步&ES6与未来）">
                  《You don't know JS》 下（类型文法&异步&ES6与未来） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenlvmeng</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">27:55</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.2/instantsearch.production.min.js" integrity="sha256-Nu8yqoXoRZEVYyZf4/eY1V4FsenbiCw85RY3gWjN3zQ=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/algolia-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"shenlvmengs-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "Shenlvmeng's Blog • All posts by \"语言\" category",
    "description": "Be sharp, my friend.",
    "home_page_url": "http://shenlvmeng.github.com/blog",
    "items": [
        {
            "id": "http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/",
            "url": "http://shenlvmeng.github.com/blog/2019/12/24/golang-learning/",
            "title": "go语言入门学习",
            "date_published": "2019-12-24T15:03:54.000Z",
            "content_html": "<blockquote>\n<p>更多：<a href=\"https://golang.org/\">go官网</a></p>\n</blockquote>\n<blockquote>\n<p>题解：<a href=\"https://github.com/shenlvmeng/go-learning-exercise\">https://github.com/shenlvmeng/go-learning-exercise</a></p>\n</blockquote>\n<h2 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h2><p>Go语言构想与2007年9月，于2009年11月发布。主要思想来自3种语言：</p>\n<ul>\n<li>C，基础语法和编译</li>\n<li>Pascal，包概念</li>\n<li>CSP（Communication Sequential Process），并发思想</li>\n</ul>\n<p>Go项目诞生是为了解决Google中系统复杂性太高的问题。因此，简单性是Go思想的重要部分。设计上，Go</p>\n<ul>\n<li>没有隐式类型转换</li>\n<li>没有构造和析构函数</li>\n<li>没有运算符重载</li>\n<li>没有形参默认值</li>\n<li>没有继承</li>\n<li>没有泛型</li>\n<li>没有异常</li>\n<li>没有宏（macro）</li>\n<li>没有函数注记</li>\n<li>没有线程局部存储</li>\n</ul>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"范例1：Hello-world\"><a href=\"#范例1：Hello-world\" class=\"headerlink\" title=\"范例1：Hello world\"></a>范例1：Hello world</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello world!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在诸多语言中，C对Go的影响是最深的。<code>.go</code>文件需要经过编译成二进制文件才可以运行。</p>\n<ul>\n<li><code>go run</code>可以直接运行<code>.go</code>文件</li>\n<li><code>go build</code>可以编译生成二进制文件，并在之后直接执行</li>\n</ul>\n<p>在代码结构上，</p>\n<ul>\n<li>先声明当前包名，其中命名为<code>main</code>的包名代表代码是可执行程序，而非一个库文件</li>\n<li>再<code>import</code>依赖包，go自带100+内置包。在编译时，编译器会抛弃未被使用的包，减少体积</li>\n<li>接下来是程序代码，命名为<code>main</code>的函数是执行的入口</li>\n</ul>\n<p>Go代码有着标准的代码格式，并可以通过<code>gofmt</code>格式化代码。<strong>代码中不需要在行尾写分号</strong>，后面紧跟特定token的换行符会自动转成分号。因此，Go代码中换行会影响代码编译。</p>\n<h3 id=\"范例2：命令行参数\"><a href=\"#范例2：命令行参数\" class=\"headerlink\" title=\"范例2：命令行参数\"></a>范例2：命令行参数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s, sep <span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(os.Args); i++ &#123;</span><br><span class=\"line\">        s += setp + os.Args[i]</span><br><span class=\"line\">        setp = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>切片（slice）是序列数组元素的表示方式，可以用<code>s[i]</code>或<code>s[m:n]</code>（m或n缺失是表示头和尾元素位置）获取1或n-m个元素。使用<code>len(s)</code>获取长度。</li>\n<li>注释以<code>//</code>开头</li>\n<li>import多个库时，可以用<code>()</code>包裹列表的形式声明，这种写法更为常见</li>\n<li>使用<code>var</code>开头表示变量声明，未指定初始值的变量会隐式初始化为当前类型的“零值”（0或’’等）</li>\n<li><code>:=</code>式的声明可以省去<code>var</code>更快地为一组变量初始化</li>\n<li>go中的<strong>for循环是唯一的循环语句</strong>，分为以下三部分。缺失initialization和condition时可以表示while循环</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> initialization; condition; post &#123;</span><br><span class=\"line\">    <span class=\"comment\">// zero or more statements</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 2</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    s, sep := <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, arg := os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        s += sep + arg</span><br><span class=\"line\">        sep = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在循环中，<code>range</code>可以生产一对值，index和value</li>\n<li><code>_</code>专门用来替代不需要使用的变量名，否则go会报错</li>\n<li>另外也可以直接用<code>strings.Join</code>方法实现效果</li>\n</ul>\n<h3 id=\"范例3：寻找重复行\"><a href=\"#范例3：寻找重复行\" class=\"headerlink\" title=\"范例3：寻找重复行\"></a>范例3：寻找重复行</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">    input = bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>同<code>for</code>循环一样，<code>if</code>语句也不需要<code>()</code>包裹</li>\n<li>内置的<code>make</code>函数可以创建一个新的map。map也可以被<code>for</code>循环遍历，每次循环的pair分别是key和value</li>\n<li><code>counts[input.Text()]</code>中当key不存在时，会返回零值0</li>\n<li>bufio库可以更方便地帮忙处理程序的输入（input）和输出（output）<ul>\n<li><code>input.Scan()</code>获取下一行，并自动去掉末尾换行符，在没有内容时返回<code>false</code></li>\n<li><code>input.Text()</code>获取当前位置的文本</li>\n</ul>\n</li>\n<li><code>Printf</code>和C语言风格类似，里面行如<code>%s</code>，<code>%v</code>的特殊符号称为<em>verbs</em></li>\n</ul>\n<p>从文件中寻找代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">    files := os.Args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(files) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        countlines(os.Stdin, counts)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, file := <span class=\"keyword\">range</span> files &#123;</span><br><span class=\"line\">            f, err := os.Open(file)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;dup: %v\\n&quot;</span>, err)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            countLines(f, counts)</span><br><span class=\"line\">            f.Close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, lines)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countlines</span><span class=\"params\">(f *os.File, counts <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    input := bufio.NewScanner(f)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error handling</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了上面的流模式读取文件外，还可以直接把整个文件直接读进内存，再将二进制数据string化并处理。此处可以使用<code>io/ioutil</code>中的<code>ReadFile</code>方法。转换过程用<code>string(data)</code>完成。</p>\n<p>日常使用时，通常借助bufio，ioutil等高层级API就可以完成任务，而不需要深入实现内部。</p>\n<h3 id=\"范例4：Gif\"><a href=\"#范例4：Gif\" class=\"headerlink\" title=\"范例4：Gif\"></a>范例4：Gif</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;image&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;image/color&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;image/gif&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\twhiteIndex = <span class=\"number\">0</span></span><br><span class=\"line\">\tblackIndex = <span class=\"number\">1</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlissajous(os.Stdout)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lissajous</span><span class=\"params\">(out io.Writer)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t\tcycles  = <span class=\"number\">5</span></span><br><span class=\"line\">\t\tres     = <span class=\"number\">0.001</span></span><br><span class=\"line\">\t\tsize    = <span class=\"number\">100</span></span><br><span class=\"line\">\t\tnframes = <span class=\"number\">64</span></span><br><span class=\"line\">\t\tdelay   = <span class=\"number\">8</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfreq := rand.Float64() * <span class=\"number\">3.0</span></span><br><span class=\"line\">\tanim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class=\"line\">\tphase := <span class=\"number\">0.0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; nframes; i++ &#123;</span><br><span class=\"line\">\t\trect := image.Rect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\timg := image.NewPaletted(rect, palette)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> t := <span class=\"number\">0.0</span>; t &lt; cycles*<span class=\"number\">2</span>*math.Pi; t += res &#123;</span><br><span class=\"line\">\t\t\tx := math.Sin(t)</span><br><span class=\"line\">\t\t\ty := math.Sin(t*freq + phase)</span><br><span class=\"line\">\t\t\timg.SetColorIndex(size+<span class=\"type\">int</span>(x*size+<span class=\"number\">0.5</span>), size+<span class=\"type\">int</span>(y*size+<span class=\"number\">0.5</span>), blackIndex)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tphase += <span class=\"number\">0.1</span></span><br><span class=\"line\">\t\tanim.Delay = <span class=\"built_in\">append</span>(anim.Delay, delay)</span><br><span class=\"line\">\t\tanim.Image = <span class=\"built_in\">append</span>(anim.Image, img)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgif.EncodeAll(out, &amp;anim)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>const</code>声明常量，常量的值只能是number，string或boolean</li>\n<li><code>gif.GIF&#123;...&#125;</code>是合成字面量的写法，其类型是struct，可以字面量声明其field，未声明fields均为零值（zero value）</li>\n<li>image库API可以操作图像</li>\n</ul>\n<h3 id=\"范例5：fetch\"><a href=\"#范例5：fetch\" class=\"headerlink\" title=\"范例5：fetch\"></a>范例5：fetch</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> prefix = <span class=\"string\">&quot;http://&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !strings.HasPrefix(url, prefix) &#123;</span><br><span class=\"line\">\t\t\turl = prefix + url</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tresp, err := http.Get(url)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: %v\\n&quot;</span>, err)</span><br><span class=\"line\">\t\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_, err = io.Copy(os.Stdout, resp.Body)</span><br><span class=\"line\">\t\tresp.Body.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: reading %s: %v\\n&quot;</span>, url, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>和网络相关的API都位于net库中，如<code>http.Get(url)</code></li>\n<li><code>os.Exit(1)</code>代表异常退出</li>\n</ul>\n<h3 id=\"范例6：并行fetch\"><a href=\"#范例6：并行fetch\" class=\"headerlink\" title=\"范例6：并行fetch\"></a>范例6：并行fetch</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> fetch(url, ch)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\t\tfmt.Println(&lt;-ch)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2fs elapse\\n&quot;</span>, time.Since(start).Seconds())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetch</span><span class=\"params\">(url <span class=\"type\">string</span>, ch <span class=\"keyword\">chan</span>&lt;- <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">\tres, err := http.Get(url)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tch &lt;- fmt.Sprint(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnbytes, err := io.Copy(ioutil.Discard, res.Body)</span><br><span class=\"line\">\tres.Body.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tch &lt;- fmt.Sprintf(<span class=\"string\">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsecs := time.Since(start).Seconds()</span><br><span class=\"line\">\tch &lt;- fmt.Sprintf(<span class=\"string\">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>goroutine是go中并行执行函数的表示，channel是goroutine间相互沟通的方式，传递特定类型数据。<strong>goroutine相互沟通时，沟通的两者会对其他goroutine block</strong>，保证没有冲突<ul>\n<li>goroutine使用<code>go</code>创建，channel使用<code>chan</code>创建，<code>ch &lt;-</code>表示向channel发送，<code>&lt;- ch</code>表示从channel接收</li>\n</ul>\n</li>\n<li><code>ioutil.Discard</code>输出流会直接丢弃流内容</li>\n</ul>\n<h3 id=\"范例7：web-server\"><a href=\"#范例7：web-server\" class=\"headerlink\" title=\"范例7：web server\"></a>范例7：web server</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">&quot;Path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>http</code>库的<code>HandleFunc</code>和<code>ListenAndServer</code>可以便捷地启动一个服务器</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handle)</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/count&quot;</span>, counter)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handle</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\tcount++</span><br><span class=\"line\">\tmu.Unlock()</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">&quot;path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">&quot;count %d\\n&quot;</span>, count)</span><br><span class=\"line\">\tmu.Unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>server会为每个请求创建一个新的goroutine处理，为了避免并发读写count时的bug，使用了mutex锁保证读写是都是串行的</li>\n<li><code>os.Stdout</code>,<code>ioutil.Discard</code>, <code>http.ResponseWriter</code>都实现了<code>io.Writer</code>接口，因此可以用在任何需要输出流的地方</li>\n<li>if语句前可以增加前置语句，如<code>if err:=xxx; err != nil</code></li>\n</ul>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><ul>\n<li>go中的<code>switch</code>没有fall through机制，若需要，需要显示声明<code>fallthrough</code>。<code>case</code>支持表达式，<code>switch</code>后支持没有操作数，此时的switch称为tagless switch。<code>break</code>, <code>continue</code>, <code>goto</code>命令如常</li>\n<li>go中有命名类型，类似ts中的<code>interface</code>，行如<code>type Point struct &#123; X, Y int &#125;</code></li>\n<li>go中有指针，<code>*</code>表示去指针对应的值，<code>&amp;</code>表示取变量的指针，另外<strong>不支持指针上的算术运算</strong></li>\n<li>go中的方法指命名类型上的函数，interface意义如常</li>\n<li>可以去<a href=\"https://golang.org/pkg\">这里</a>寻找标准库的包，或去<a href=\"https://godoc.org/\">这里</a>寻找社区贡献的包</li>\n<li>注释风格同其他语言，<code>//</code>表示单行注释，<code>/* */</code>表示多行注释。不支持嵌套注释</li>\n</ul>\n<h2 id=\"程序结构\"><a href=\"#程序结构\" class=\"headerlink\" title=\"程序结构\"></a>程序结构</h2><h3 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h3><p>和JS类似</p>\n<ul>\n<li>以**Unicode字母或下划线<code>_</code>**开头</li>\n<li>后跟<strong>Unicode字母或数字或下划线</strong></li>\n<li><strong>大小写敏感</strong></li>\n</ul>\n<p>go目前（2020&#x2F;01&#x2F;01）有25个不允许用来命名的<strong>关键字</strong>，其中几个可能是对前端较难想到的是</p>\n<ul>\n<li><code>select</code></li>\n<li><code>defer</code></li>\n<li><code>chan</code></li>\n<li><code>range</code></li>\n<li><code>fallthrough</code></li>\n</ul>\n<p>另外，还有一些预定义常量、类型、函数<strong>可以用来命名</strong>，但很容易造成误解，下面举些例子：</p>\n<ul>\n<li>常量：<code>true</code> <code>iota</code> <code>nil</code></li>\n<li>类型：<code>int</code> <code>complex128</code> <code>uintptr</code> <code>rune</code> <code>error</code></li>\n<li>函数：<code>make</code> <code>len</code> <code>imag</code> <code>panic</code> <code>close</code></li>\n</ul>\n<p><strong>包名始终小写</strong>，在函数域内命名的函数只在函数域内可见，否则<strong>在整个包域内可见</strong>。整个包内声明的变量用首字母区分可见性：</p>\n<ul>\n<li><strong>首字母大写的可以被其他包访问</strong>，如<code>fmt.FPrintf</code></li>\n<li>反之则只在包内可见</li>\n</ul>\n<p>命名长度没有限制，但建议<em>scope越大的变量命名越长</em>。Go使用驼峰风格的变量命名，首字母缩略词和首字母<strong>同大写或同小写</strong>。</p>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>声明有4钟：</p>\n<ul>\n<li><code>var</code> 变量</li>\n<li><code>const</code> 常量</li>\n<li><code>type</code> 类型</li>\n<li><code>func</code> 函数</li>\n</ul>\n<p>声明在函数域内可见，或在整个包域内可见。函数返回可以是一组变量。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"keyword\">type</span> = expression</span><br></pre></td></tr></table></figure>\n\n<p>Go中的变量声明如上所示，其中的<code>type</code>部分或<code>expression</code>部分可以省略，<strong>但是不能同时省略</strong>。</p>\n<ul>\n<li>type缺失时，name的类型由expression字面量或返回值决定</li>\n<li>expression缺失时，name的值<strong>自动设置为type类型的“零值”（zero value）</strong><ul>\n<li>数值零值为0，字符串零值为<code>&quot;&quot;</code>，布尔类型零值为<code>false</code></li>\n<li>其余接口或引用类型零值为<code>nil</code>，如指针、map、切片、函数、channel</li>\n<li>聚合类型的零值即其所有组成元素的零值</li>\n</ul>\n</li>\n</ul>\n<p>所以，<strong>Go中不存在未初始化的变量</strong>。包级别变量在<code>main</code>函数开始前初始化，局部变量在声明过程中初始化。一组变量可以同时被初始化。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b, f, s = <span class=\"literal\">true</span>, <span class=\"number\">1.3</span>, <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f, err = os.Open(name)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"简写式\"><a href=\"#简写式\" class=\"headerlink\" title=\"简写式\"></a>简写式</h4><p>在<strong>函数域</strong>内的<strong>局部变量声明</strong>可以使用简写式，即<code>:=</code>。在已知变量初始值时可以省去写<code>var</code>。在初始值并不重要或最好显式写明类型时，还是使用<code>var foo type</code>的形式比较好。和<code>var</code>声明一样，也可以同时用简写式声明多个局部变量。但要注意，不要把这种写法和<em>元组赋值（tuple assignment）</em>搞混了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// multiple initialzier expression</span></span><br><span class=\"line\">i, j := <span class=\"number\">1</span>, <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tuple assignment</span></span><br><span class=\"line\">i, j = j, i</span><br></pre></td></tr></table></figure>\n\n<p>另外，简写式声明里可以写<strong>部分</strong>已经声明的局部变量，在这里会当做赋值处理。但是简写式声明中要<strong>至少包含一个未声明变量</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in, err := os.OpenFile(infile)</span><br><span class=\"line\">out, err := os.OpenFile(outfile)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h4><p>Go中的指针和C中类似，用<code>&amp;</code>表示取一个<strong>变量</strong>的地址，用<code>*</code>表示访问某个地址所在的位置。指针的零值为<code>nil</code>，因此可以用<code>p != nil</code>来判断指针是否指向变量。</p>\n<h4 id=\"new函数\"><a href=\"#new函数\" class=\"headerlink\" title=\"new函数\"></a><code>new</code>函数</h4><p>可以通过<code>new</code>函数，声明类型<code>T</code>创建新的<strong>匿名</strong>变量，函数返回变量的指针即<code>*T</code>类型。这在不需要变量名时很好用。每次调用<code>new</code>函数新建变量时，返回的地址<strong>不同</strong>，<strong>除非类型不附加任何信息</strong>，如<code>struct &#123;&#125;</code>或<code>[0]int</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p := <span class=\"built_in\">new</span>(<span class=\"type\">int</span>)</span><br><span class=\"line\">*p = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，由于<code>new</code>只是预定义函数，所以可以用来做变量名。</p>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>生命周期即变量从创建到被回收的时间。包级别的变量会在整个程序执行过程中存在。局部变量则会在<em>未被引用（unreachable）</em>时释放内存。Go中的垃圾回收机制会自动帮你完成这件事。但是如果有下面这种情况出现，则会阻止垃圾回收释放内存。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global *<span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x <span class=\"type\">int</span></span><br><span class=\"line\">\tx = <span class=\"number\">1</span></span><br><span class=\"line\">\tglobal = &amp;x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述情况下，<code>x</code>局部变量从<code>f</code>函数中<strong>逃逸</strong>，并不会在<code>f</code>函数返回时被回收，持久存储在堆（heap）中。应尽量避免这种情况带来的额外内存损耗。</p>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>和其余语言赋值没什么太大区别。</p>\n<p>不同的是，额外增加了<strong>元组赋值</strong>。<code>=</code>右侧的一组变量会先求值，再赋给左侧变量。建议在不需要复杂运算时使用。同时，有些表达式和函数也会返回一组值，此时需要用元组赋值的方式接收。在不需要某个变量时，可以使用<code>_</code>占位。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, y= y, x</span><br><span class=\"line\"></span><br><span class=\"line\">f, err = os.Open(<span class=\"string\">&quot;foo.txt&quot;</span>)</span><br><span class=\"line\">v, ok = m[key]</span><br><span class=\"line\">v, ok = x.(T)</span><br><span class=\"line\">v, ok = &lt;- ch</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可赋值性\"><a href=\"#可赋值性\" class=\"headerlink\" title=\"可赋值性\"></a>可赋值性</h4><p>除了一些显式的赋值外，还有函数返回、字面量声明等。Go中的赋值<strong>当且仅当</strong><code>=</code>左右的值和变量<strong>类型相同</strong>才可进行（对于<code>==</code>和<code>!=</code>的判断也是这样）。<code>nil</code>可以赋值给任何复杂类型或引用类型。</p>\n<h3 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h3><p>Go中可以定义类型。Go中的类型定义储存值的符号、它们的大小、固有操作以及方法，使用<code>type name underlying-name</code>声明。它通常出现在包级别，有些也会通过首字母大写的形式export出去。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"type\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CTOF</span><span class=\"params\">(c Celsius)</span></span> Fahrenheit &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fahrenheit(c * <span class=\"number\">9</span> / <span class=\"number\">5</span> + <span class=\"number\">32</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FTOC</span><span class=\"params\">(f Fahrenheit)</span></span> Celsius &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>两个有着相同底层类型的命名类型并不是同一种类型</strong>，也不能直接相互赋值和比较。但是可以使用<strong>强制类型转换</strong>转换到想同类型来比较。所有的类型<code>T</code>都有对应的强制类型转换操作<code>T(x)</code>。两个有相同类层类型或指向相同底层类型的未命名指针可以相互强制转换。另外，Go中的强制类型转换从不会在运行时出错。</p>\n<p>比较特别的是，类型上还可以声明方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Celsius)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%g°C&quot;</span>, c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"包和文件\"><a href=\"#包和文件\" class=\"headerlink\" title=\"包和文件\"></a>包和文件</h3><p>Go中的包即其他语言中的库、模块。以实现模块化、封装、分发和重用。和Java类似，一个包的代码<strong>可以存放在多个文件内</strong>，通常位于同一个文件夹下。每个包都有相互隔离的命名空间，需要用·<code>image.Decode</code>的形式使用。需要<code>export</code>的变量、类型、函数使用<strong>首字母大写</strong>的形式。</p>\n<p>建议在每个export出去的变量、类型、函数前使用注释说明。另外，建议在包开头留下<em>doc comment</em>，或将更多注释放在<code>doc.go</code>中。</p>\n<h4 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;shenlvmeng/learning/tempconv&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\t\tt, err := strconv.ParseFloat(arg, <span class=\"number\">64</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Fprintf(os.Strerr, <span class=\"string\">&quot;convert error: %v\\n&quot;</span>, err)</span><br><span class=\"line\">\t\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tf := temconv.Fahrenheit(t)</span><br><span class=\"line\">\t\tc := tempconv.Celsius(c)</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%s = %s, %s = %s\\n&quot;</span>, f, tempconv.FTOC(f), c, tempconv.CTOF(c))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每一个包都有自己的import路径，Go语言标准并不定义如何解释import路径，这一步交给解释工具完成。每个包的包名通常和路径的最后一段同名。为避免包名冲突，import可以指定包的别名。</p>\n<p>在引用了未被使用的包时会报错。，借助<code>goimports</code>等工具和正确的IDE配置，可以在保存代码时自动标准化代码格式。</p>\n<h4 id=\"包初始化\"><a href=\"#包初始化\" class=\"headerlink\" title=\"包初始化\"></a>包初始化</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = b + c <span class=\"comment\">//third</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = f() <span class=\"comment\">// second</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">1</span> <span class=\"comment\">// first</span></span><br></pre></td></tr></table></figure>\n\n<p>初始化时，先按照依赖的顺序初始化包级别变量。而<code>.go</code>文件的处理顺序则按照传给go编译器的顺序。初始化的过程是自底向上的，即当所有依赖包都初始化完成后，才会初始化<code>main</code>包，再执行<code>main</code>函数。对于初始化过程复杂的变量，可以在<code>init</code>函数中声明，而<code>init</code>是在程序启动时，按照声明的顺序一个一个执行的。</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域是编译时的，和运行时的生命周期概念相对应。作用域描述一个声明的可见范围。和C系列语言类似，用大括号<code>&#123;&#125;</code>包裹会形成<strong>词法块作用域</strong>。Go在<strong>全局作用域</strong>下预定义了一些常量、函数、类型等。在函数外声明的作用域是包级别的，<code>import</code>进来的包作用域是文件级别的。局部声明只在块作用域内。内部作用域会覆盖外部作用域的同名声明。</p>\n<p>另外，Go中还有一些<strong>隐式</strong>的作用域，比如<code>for</code>，<code>if</code>，<code>switch</code>表达式中的作用域。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tx := <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(x); i++ &#123;</span><br><span class=\"line\">\t\tx := x[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> x != <span class=\"string\">&quot;o&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tx := x + <span class=\"string\">&#x27;A&#x27;</span> - <span class=\"string\">&#x27;a&#x27;</span> <span class=\"comment\">// 类似upperCase</span></span><br><span class=\"line\">\t\t\tfmt.Prinf(<span class=\"string\">&quot;%c&quot;</span>, x)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>for</code>和<code>if</code>内部的x是一个单独的作用域。另外注意，简写式中会声明局部变量，会覆盖外部的同名变量，可能会带来意料之外的结果。可以通过<code>var xxx type</code>的形式声明变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cwd <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcwd, err := os.Getwd() <span class=\"comment\">// compile error: unused cwd</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础数据结构\"><a href=\"#基础数据结构\" class=\"headerlink\" title=\"基础数据结构\"></a>基础数据结构</h2><p>Go有4大类数据类型：</p>\n<ul>\n<li><strong>基础类型</strong>，即数字、字符串、布尔值</li>\n<li><strong>聚合类型</strong>，即数组、struct</li>\n<li><strong>引用类型</strong>，包括函数、指针、slice、map、channel</li>\n<li><strong>接口类型</strong></li>\n</ul>\n<p>这一部分先说基础类型</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>Go的数字类型包含了不同size的整型、浮点数和复数，以及它们的有无符号性。</p>\n<p>整型有8、16、32、64四种长度，以及对应的signed和unsigned。组合一下即下面8种：</p>\n<ul>\n<li><code>int8</code></li>\n<li><code>int16</code></li>\n<li><code>int32</code></li>\n<li><code>int64</code></li>\n<li><code>uint8</code></li>\n<li><code>uint16</code></li>\n<li><code>uint32</code></li>\n<li><code>uint64</code></li>\n</ul>\n<p>另外，<code>rune</code>是<code>int32</code>的别称，通常用来表示1个Unicode字符，<code>byte</code>是<code>unit8</code>的别称。<code>uintptr</code>用来表示一个可以承载任意指针值的无符号整型。</p>\n<p>Go中对整型的处理和C风格很像。</p>\n<ul>\n<li>用首位表示符号位（signed int中）</li>\n<li>类型承载范围和C一样，如int8表示-128到127</li>\n<li>和C一样的操作符以及优先级，唯一区别是<code>&amp;^</code>表示位清除，<code>x &amp;^ y</code>表示根据y各位将x各位清0</li>\n<li><code>&lt;&lt;</code>左移位，空位取0，<code>&gt;&gt;</code>右移位，无符号数补零，<strong>有符号数补符号位</strong></li>\n<li>整型间除法会清除小数部分</li>\n<li>取余<code>%</code>运算结果符号和被除数有关</li>\n<li>超过位数的会溢出</li>\n<li><code>0</code>开头表示八进制（通常用来表示POSIX系统中文件权限设置），<code>0x</code>表示十六进制</li>\n</ul>\n<p>不一样的是：</p>\n<ul>\n<li>相同类型才可比较大小，否则需要用<code>int()</code>强制转换为1种类型再比较。某些类型转换只改变值的使用方式，有些则会改变值，如<code>int</code>和<code>float</code>之间的转换</li>\n<li>用<code>%d</code>, <code>%o</code>, <code>%x</code>分别表示整型、八进制和十六进制数</li>\n<li>用<code>%c</code>表示显示对应的Unicode字符，<code>%q</code>显示带引号版本</li>\n</ul>\n<h3 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h3><p>浮点数有<code>float32</code>和<code>float64</code>两种类型，服从IEEE754标准。为保证精确性，通常使用<code>flaot64</code>。另外，还有以下特点</p>\n<ul>\n<li><code>.</code>前后的0可以省略</li>\n<li><code>%g</code>, <code>%e</code>和<code>%f</code>分别打印最合适展示精确度版本、指数版本和原始版本</li>\n<li>有<code>+Inf</code>, <code>-Inf</code>和<code>NaN</code>特殊值，表现类似JS</li>\n</ul>\n<h3 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h3><p>Go有两种复数类型：<code>complex64</code>和<code>complex128</code>，它们其实是由<code>float32</code>和<code>float64</code>组成的。复数可以通过<code>complex</code>内置函数初始化，或者直接使用字面量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"type\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1 + 2i</span></span><br><span class=\"line\">y := <span class=\"number\">3</span> - <span class=\"number\">4i</span></span><br></pre></td></tr></table></figure>\n\n<p>复数间可以判断相等性，无法判断大小。<code>math/cmplx</code>包里包含一些复数的数学运算。</p>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><p>即type <code>bool</code>，和其他语言类似，有短路行为，<code>&amp;&amp;</code>比<code>||</code>优先级更高。<code>bool</code>类型和整型之间不能相互隐式转换。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串表示<strong>一组不可修改的比特位序列</strong>，但通常用来承载可读的Unicode编码点。<code>len</code>返回字符串长度，<code>[i]</code>返回第<code>i</code>个<strong>字节</strong>处的值。越界读取会导致panic。</p>\n<ul>\n<li><code>s[i:j]</code>表示自带的substring操作，其中<code>i</code>和<code>j</code>均可省略</li>\n<li>字符串间可以比较大小和相等性，其中大小通过逐字节子母序比较</li>\n<li><code>+</code>可表示字符串拼接</li>\n<li>不可变性：不允许修改字符串的值（如<code>s[0] = &#39;L&#39;</code>），这使得Go可以在底层复用字符串，节省内存</li>\n</ul>\n<h4 id=\"字面量字符串\"><a href=\"#字面量字符串\" class=\"headerlink\" title=\"字面量字符串\"></a>字面量字符串</h4><p>用双引号<code>&quot;</code>包裹，UTF-8编码。双引号中的反斜线<code>\\</code>有特殊含义。如</p>\n<ul>\n<li><code>\\n</code>表示换行</li>\n<li><code>\\t</code>表示制表符</li>\n<li><code>\\x</code>表示后接十六进制的高低位</li>\n<li><code>\\ooo</code>表示三个八进制位</li>\n</ul>\n<p>由反引号&#96;&#96; &#96;包裹的表示纯文本字面量，其中的换行和格式也会被跨平台保留。可以用来书写多行字符串。</p>\n<h4 id=\"Unicode表示\"><a href=\"#Unicode表示\" class=\"headerlink\" title=\"Unicode表示\"></a>Unicode表示</h4><p>Go中使用UTF-8变长编码：</p>\n<ul>\n<li><code>0xxxxxxx</code>表示ASCII码</li>\n<li><code>11xxxxxx 10xxxxxx</code> 表示两字节长度</li>\n<li><code>110xxxxx 10xxxxxx 10xxxxxx</code>表示三字节长度</li>\n<li><code>1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx</code> 表示四字节长度</li>\n</ul>\n<p>可以由<code>\\uhhhh</code>表示16比特或<code>\\U</code>表示32比特，如世界：<code>\\u4e16\\u754c</code>。<code>unicode</code>包和<code>unicode/utf8</code>包提供了编解码工具。<code>utf6.DecodeRuneInString</code>可以读取一个自然字符的数据，而非一个字节一个字节读取，<code>utf8.RuneCountInString</code>返回字符串的自然字符长度。幸运的是，<code>range</code>循环会自动调用utf8解码其中的自然字符。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;unicode/uft8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;Hello, 世界&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(s)) <span class=\"comment\">// 13</span></span><br><span class=\"line\">fmt.Println(utf8.RuneCountInString(s) <span class=\"comment\">// 9)</span></span><br></pre></td></tr></table></figure>\n\n<p>当Go Unicode解析失败时，会使用特殊的Unicode占位符<code>\\ufffd</code>，显示为带有问号的特殊字符。另外，<code>rune[]</code>可以直接将字符串转成编码后的每个Unicode编码点。这个rune数组进行<code>string()</code>强制类型转换后即原始字符串。当然你也可以直接<code>string()</code>装换一个整型数，不合规的整形数会得到上面提到的特殊字符。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">r := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">fmt.Println(<span class=\"type\">string</span>(r))</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"type\">string</span>(<span class=\"number\">65</span>))</span><br><span class=\"line\">fmt.Printlf(<span class=\"type\">string</span>(<span class=\"number\">12341234</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串和Byte-Slices\"><a href=\"#字符串和Byte-Slices\" class=\"headerlink\" title=\"字符串和Byte Slices\"></a>字符串和Byte Slices</h4><p><code>bytes</code>, <code>strings</code>, <code>strconv</code>, <code>unicode</code>是和string相关的几个包。<code>strings</code>提供基本的字符串搜索、比较、修改等操作，<code>bytes</code>提供修改字节数组的一些操作。有时，使用<code>byte.Buffer</code>类型，在操作字符串字节时会更有效率。<code>strconv</code>提供了将其他类型转成字符串和修饰字符串的操作函数。<code>unicode</code>提供了一些以rune为中心的函数，如<code>IsDigit</code>, <code>IsLetter</code>, <code>isUpper</code>等。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// basename removes directory and filename suffix</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">basename</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\tslash := strings.LastIndex(s, <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">\ts = s[slash+<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> dot := strings.LastIndex(s, <span class=\"string\">&quot;.&quot;</span>); dot &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\ts = s[:dot]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>path</code>和<code>path/filepath</code>包提供了更多文件夹和目录的操作函数。</p>\n<p>尽管字符串中的字节序列是不可更改的。<strong>其对应的字节序列数组则是可以自由修改的</strong>。<code>[]byte(s)</code>会分配一个字符串<code>s</code>的字节序列拷贝，也可以对应用<code>string(b)</code>还原。<code>bytes</code>包提供的<code>Buffer</code>类型可以很方便地承载<code>[]byte</code>类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intsToString</span><span class=\"params\">(values []<span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> buf bytes.Buffer</span><br><span class=\"line\">\tbuf.WriteByte(<span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tbuf.WriteString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Fprintf(&amp;buf, <span class=\"string\">&quot;%d&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbuf.WriteByte(<span class=\"string\">&#x27;]&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述函数中，<code>WriteString</code>和<code>WriteByte</code>用于向Buffer中写入字节或字节序列，该类型还有许多其他应用场景。</p>\n<h4 id=\"字符串和整型间的转换\"><a href=\"#字符串和整型间的转换\" class=\"headerlink\" title=\"字符串和整型间的转换\"></a>字符串和整型间的转换</h4><ul>\n<li><strong>字符串 -&gt; 整型</strong>，<code>fmt.Sprintf</code>或<code>strconv.Itoa</code></li>\n<li><strong>整型 -&gt; 字符串</strong>，<code>strconv.FormatInt</code>或<code>strconv.FormatUint</code>或<code>strconv.ParseInt</code>或<code>Atoi</code></li>\n</ul>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量有以下几个基本特点:</p>\n<ul>\n<li>编译时即对编译器可知</li>\n<li>必须是基础类型：boolean，string或number</li>\n</ul>\n<p>常量使用<code>const</code>声明，形式看起来和使用<code>var</code>类似，不过值是常量。对常量进行的所有操作，如数学运算、逻辑运算、比较、内置函数求值，都是在编译期就确定了。</p>\n<p>常量可以组声明，声明时可以不显式声明类型，此时将使用右侧操作数推断常量类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tnoDelay time.Duration = <span class=\"number\">0</span></span><br><span class=\"line\">\ttimeout = <span class=\"number\">5</span> * time.Minute</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%T %[1]v\\n&quot;</span>, noDelay) <span class=\"comment\">// &quot;time.Duration 0&quot;</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%T %[1]v\\n&quot;</span>, timeout) <span class=\"comment\">// &quot;time.Duration 5m0s&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>还有个不常用的点：组声明时，<strong>除了第一个常量，剩下的常量可以不写右侧操作数</strong>，此时会使用<strong>上一个常量</strong>来初始化。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ta = <span class=\"number\">1</span></span><br><span class=\"line\">\tb</span><br><span class=\"line\">\tc = <span class=\"number\">2</span></span><br><span class=\"line\">\td</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常量生成器iota\"><a href=\"#常量生成器iota\" class=\"headerlink\" title=\"常量生成器iota\"></a>常量生成器<code>iota</code></h4><p><code>iota</code>即常量生成器，它从0开始，每次常量声明后加一。利用这个规律可以方便地生成一组常量枚举。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tSunday Weekday = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tMonday</span><br><span class=\"line\">\tTuesday</span><br><span class=\"line\">\tWednesday</span><br><span class=\"line\">\tThursday</span><br><span class=\"line\">\tFriday</span><br><span class=\"line\">\tSaturday</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> _ = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">10</span> * itoa)</span><br><span class=\"line\">\tKB</span><br><span class=\"line\">\tMB</span><br><span class=\"line\">\tGB</span><br><span class=\"line\">\tTB</span><br><span class=\"line\">\tPB</span><br><span class=\"line\">\tEB</span><br><span class=\"line\">\tZB</span><br><span class=\"line\">\tYB</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"无类型常量\"><a href=\"#无类型常量\" class=\"headerlink\" title=\"无类型常量\"></a>无类型常量</h4><p>常量和变量不一样的点在，<strong>常量是可以不声明类型的</strong>，根据常量限定的类型，有下面一些类型：</p>\n<ul>\n<li>无类型整型</li>\n<li>无类型Boolean</li>\n<li>无类型rune</li>\n<li>无类型浮点数</li>\n<li>无类型复数</li>\n<li>无类型字符串</li>\n</ul>\n<p>常量在使用时，会<strong>隐式</strong>转换成需要的类型，并在无法转换时抛出错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"type\">float64</span> = <span class=\"number\">3</span> + i <span class=\"comment\">// complex -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">2</span> <span class=\"comment\">// integer -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">1e123</span> <span class=\"comment\">// float -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"string\">&#x27;a&#x27;</span> <span class=\"comment\">// rune -&gt; float64</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，这些无类型常量有一个隐含类型，如:</p>\n<ul>\n<li>无类型整型 -&gt; <code>int</code></li>\n<li>无类型浮点数 -&gt; <code>float64</code></li>\n<li>无类型复数 -&gt; <code>complex128</code></li>\n<li>无类型rune -&gt; <code>int32</code>（<code>rune</code>）</li>\n</ul>\n<h2 id=\"聚合类型\"><a href=\"#聚合类型\" class=\"headerlink\" title=\"聚合类型\"></a>聚合类型</h2><p>基本类型是数据结构的组成“原子”。原子的组合就构成了“分子”——聚合类型：</p>\n<ul>\n<li>array</li>\n<li>slices</li>\n<li>maps</li>\n<li>structs</li>\n</ul>\n<p>其中array和structs是聚合类型的基础，它们都有着<strong>固定大小</strong>。而slice和map则是动态大小。</p>\n<h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"type\">int</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>])</span><br><span class=\"line\">fmt.Println(f[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n\n<p>类似C风格，array表示由0或多个同一类型元素组成的<strong>定长序列</strong>。声明数组时，需要使用<strong>常量表达式</strong>作为数组长度。当数组元素全部列出时，可以用<code>...</code>代替长度。元素未声明初始值时，按零值（zero value）处理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q [<span class=\"number\">3</span>]<span class=\"type\">int</span> = [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>[<span class=\"number\">2</span>]) <span class=\"comment\">// 0</span></span><br><span class=\"line\">q = [...]<span class=\"type\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，当元素较多时，还可以用index到value的键值对形式声明，未声明的值为零值。下面的例子中，<code>r</code>长度100，除了最后一个元素为-1之外，其余都为0.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"type\">int</span>&#123;<span class=\"number\">99</span>: <span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若数组数组具有可比性，则数组也具有<strong>可比性</strong>。另外，不同长度的数组是不同类型。<code>[4]int</code>和<code>[3]int</code>不是同一类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;crypto/sha256&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc1 := sha256.Sum256(<span class=\"string\">&quot;x&quot;</span>)</span><br><span class=\"line\">\tc2 := sha256.Sum256(<span class=\"string\">&quot;X&quot;</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;\\t\\n&quot;</span>, c1 == c2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go中将数组作为参数传递时，<strong>传递的是复制的新数组，而不是传入数组的引用</strong>，这是Go和其他语言不大一样的地方。当然可以通过传入数组指针的方式，实现在函数内修改数组内容。由于数组是定长的，在更多时候，函数参数使用slice类型传入。</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><p>slice和array类型紧密相关，使用<code>[]T</code>声明。每个slice的底层都基于一个array。slice只是一个指针指向array中的某一个元素作为开始，除此之外，它还有<code>len</code>和<code>cap</code>函数分别用来表示切片长度，和切片最大容量（从切片开始到底层array结尾）。</p>\n<p>因此不同slice可以共享同一个array，它们之间可以相互重叠。<code>s[i:j]</code>是从创建slice的方式，遵从左闭右开原则，<code>i</code>和<code>j</code>均可省略，省略时分别表示0和数组最末尾元素。<strong>创建可以基于一个array变量或一个array指针或其他slice</strong>。创建超过array范围会引起panic，只超过<code>len(s)</code>则会拓展这个slice。因为string实际上是<code>[]byte</code>切片，所以<code>s[i:j]</code>和<code>substring</code>是一个意思。</p>\n<p>从上面可以看到，slice即一个指向数组元素的指针，所以传递一个slice时，可以修改底层array的值。下面这个反转数组的函数不限数组长度：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>; i &lt; j; i, j = i+<span class=\"number\">1</span>, j<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\ts[i], s[j] := s[j], s[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">reverse(s)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// [5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>s</code>是一个切片字面量，和array的区别在于没有声明长度。这种写法实际上会生成以后面值为全部元素的数组，并把切片指向这个数组。类似地，还可以使用<code>make</code>创建一个切片。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span>)</span><br><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span>, <span class=\"built_in\">cap</span>)</span><br></pre></td></tr></table></figure>\n\n<p>由于切片只是引用，从效率和可理解性上考虑，<strong>切片间不具有可比性</strong>。不过切片可以和<code>nil</code>比较，<code>nil</code>表示空切片，而非“没有元素”的切片。不过Go中slice相关的函数对待这两种切片行为一样。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"type\">int</span> <span class=\"comment\">// s == nil</span></span><br><span class=\"line\">S = <span class=\"literal\">nil</span> <span class=\"comment\">// s == nil</span></span><br><span class=\"line\">s = []<span class=\"type\">int</span>(<span class=\"literal\">nil</span>) <span class=\"comment\">// s == nil</span></span><br><span class=\"line\">s = []<span class=\"type\">int</span>&#123;&#125; <span class=\"comment\">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"append和copy\"><a href=\"#append和copy\" class=\"headerlink\" title=\"append和copy\"></a><code>append</code>和<code>copy</code></h4><p><code>append</code>函数可以操作slice。如果append之后，slice长度超过了底层array的长度，<code>append</code>会自动拓展底层array长度。另外，append不仅可以追加单个元素，还可以追加任意个元素，或解构后的slice。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> runes []<span class=\"type\">rune</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> <span class=\"string\">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class=\"line\">\trunes = <span class=\"built_in\">append</span>(runes, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%q\\n&quot;</span>, runes)</span><br><span class=\"line\"><span class=\"keyword\">var</span> x []<span class=\"type\">int</span></span><br><span class=\"line\">x = <span class=\"built_in\">append</span>(x, <span class=\"number\">1</span>)</span><br><span class=\"line\">x = <span class=\"built_in\">append</span>(x, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">x = <span class=\"built_in\">append</span>(x, x...)</span><br></pre></td></tr></table></figure>\n\n<p>在不借助<code>append</code>实现类似<code>append</code>功能时，就需要自己借助<code>cap(x)</code>和<code>make</code>完成底层array的长度扩充。如同下面的一段代码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">appendInt</span><span class=\"params\">(x []<span class=\"type\">int</span>, y ...<span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> z []<span class=\"type\">int</span></span><br><span class=\"line\">\tzlen := <span class=\"built_in\">len</span>(x) + <span class=\"built_in\">len</span>(y)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> zlen &lt;= <span class=\"built_in\">cap</span>(x) &#123;</span><br><span class=\"line\">\t\tz = x[:zlen]</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzcap := zlen</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> zcap &lt; <span class=\"number\">2</span> * <span class=\"built_in\">len</span>(x) &#123;</span><br><span class=\"line\">\t\t\tzcap := <span class=\"number\">2</span> * <span class=\"built_in\">len</span>(x)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tz = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, zlen, zcap)</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(z, x)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(z[<span class=\"built_in\">len</span>(x)], y)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>...</code>表示剩余参数，</p>\n<p>借助<code>copy</code>还能实现一些slice的原址操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">(slice []<span class=\"type\">int</span>, i <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(slice[i:], slice[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slice[:<span class=\"built_in\">len</span>(slice)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>map即键值对，其中<strong>key要求具有可比较性</strong>。map有两种构造方式：<code>make</code>或字面量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">ages := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Alice&quot;</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Bob&quot;</span>: <span class=\"number\">27</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>map使用<strong>下标访问</strong>，使用<code>delete</code>删除键。另外，<strong>访问不存在的key时，值是<code>value</code>类型的零值</strong>。因此可以免去一些多余的初始化步骤。由于map的值并不是变量，所以不能用<code>&amp;</code>获取地址。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;Cindy&quot;</span>] = <span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">&quot;bob&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 新的key</span></span><br><span class=\"line\">ages[<span class=\"string\">&quot;Dred&quot;</span>] += <span class=\"number\">1</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ := &amp;ages[<span class=\"string\">&quot;Cindy&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>map在遍历时，顺序是随机的。因此如果需要确定顺序，需要事先手动排序。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names []<span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> name := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">\tnames = <span class=\"built_in\">append</span>(names, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sort.Strings(names)</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, names := <span class=\"keyword\">range</span> names &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\t%d\\n&quot;</span>, name, ages[name])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>map的<code>delete</code>，<code>len</code>，<code>range</code>和取值操作都可以对零值<code>nil</code>进行，但是存储到<code>nil</code>map时会报错。由于访问map不存在的key会返回默认的零值，所以下标操作用第二个参数返回是否对应的key，*且参数通常命名<code>ok</code>*。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> age, ok := ages[<span class=\"string\">&quot;Ed&quot;</span>]; !ok &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go中没有<code>set</code>类型，可以用<code>map[string]bool</code>等价。当key可能不可比较时（如用slice做key），可以用额外的序列化使用。</p>\n<h3 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h3><p>struct类似ts中的<code>interface</code>。由<strong>零</strong>或多个fields组成，每个field使用<strong>点</strong>来访问。struct和field都是变量，所以可以用<code>&amp;</code>获取地址。对地址也可以使用点来访问field。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tId <span class=\"type\">int</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">\tAddress <span class=\"type\">string</span></span><br><span class=\"line\">\tDoB time.Time</span><br><span class=\"line\">\tPosition <span class=\"type\">string</span></span><br><span class=\"line\">\tSalary <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e Employee</span><br><span class=\"line\">e.Salary = <span class=\"number\">1000</span></span><br><span class=\"line\">pos := &amp;e.Position</span><br><span class=\"line\">*pos = <span class=\"string\">&quot;Senior &quot;</span> + *pos</span><br></pre></td></tr></table></figure>\n\n<p>相同类型的两个key可以<strong>在一起声明</strong>。在Go的struct中，<strong>field的组合和排序都意味着不同的type</strong>。和包一样，大写的field被导出可被访问，这也是Go的一种通用的设计。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee2 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tId <span class=\"type\">int</span></span><br><span class=\"line\">\tName, Address <span class=\"type\">string</span></span><br><span class=\"line\">\tDoB time.Time</span><br><span class=\"line\">\tPosition <span class=\"type\">string</span></span><br><span class=\"line\">\tSalary <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>struct类型的field不能自指，但是允许包含自己类型的<strong>指针</strong>，比如最经典的二叉树场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalue <span class=\"type\">int</span></span><br><span class=\"line\">\tleft, right *tree</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>struct的零值由各field零值组成，不是nil，没有field的空struct写作<code>struct&#123;&#125;</code>。不携带信息，但可能在有些地方会有用。</p>\n<h4 id=\"字面量struct\"><a href=\"#字面量struct\" class=\"headerlink\" title=\"字面量struct\"></a>字面量struct</h4><p>两种声明方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"type\">int</span> &#125;</span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">anim := git.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将所有fields<strong>按顺序</strong>声明，struct的fields有任何改动都需要修改，所以通常只在小规模struct以及包内部使用</li>\n<li>使用键值对方式声明，可以省略field，且对顺序不敏感</li>\n</ul>\n<p>另外，在Go中，所有的函数参数传递都是<strong>传值</strong>。因此，如果函数内部需要修改struct时，不能传递struct类型，而需要传递指针。由于struct传递指针的场景比较多，所以提供了类似<code>p := &amp;Point&#123;1, 1&#125;</code>的简写语法糖。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AwardAnnualPrize</span><span class=\"params\">(e *Employee)</span></span> &#123;</span><br><span class=\"line\">\te.Salary = e.Salary * <span class=\"number\">2</span> + <span class=\"number\">1000</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果struct的所有field都具有可比性，则struct也具有可比性，可以比较是否相等。因此，struct在有些情况可以用来作为map的key。</p>\n<h4 id=\"struct嵌入与匿名域\"><a href=\"#struct嵌入与匿名域\" class=\"headerlink\" title=\"struct嵌入与匿名域\"></a>struct嵌入与匿名域</h4><p>匿名域用于struct之间的组合，可以达到<em>类似</em>类继承的效果。在struct声明中，如果field类型是有名称的，则可以忽略掉field名，得到一个匿名域。匿名域类型或类型内的各field对应用struct可见。有点类似TS中<code>interface</code>的<code>extends</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPoint</span><br><span class=\"line\">\tRadius: <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCircle</span><br><span class=\"line\">\tSpokes <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">10</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p>换种说法，匿名域就是向下访问时可以省去不写的中间域。即使中间域类型是首字母小写不对外可见的，只要剩下域对外可见也可以访问。struct这种<strong>组合</strong>思想是Go在面向对象上的核心。</p>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><p>编解码JSON数据的方法都位于<code>encoding/json</code>，其中编解码整块数据的函数分别为<code>json.Marshal</code>和<code>json.Unmarshal</code>，前者传入Go数据结构，返回压缩后的JSON字符串，使用<code>json.MarshalIndent</code>可以返回美化后的JSON字符串。编码时，<strong>只有被导出的域才会出现在JSON字符串中</strong>。且field之后的<em>field tag</em>可以作为metadata修改JSON行为，如指定被JSON字符串化之后的key名。或用下面的<code>omitempty</code>忽略掉零值的key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle <span class=\"type\">string</span></span><br><span class=\"line\">\tYear <span class=\"type\">int</span> <span class=\"string\">`json:&quot;released&quot;`</span></span><br><span class=\"line\">\tColor <span class=\"type\">bool</span> <span class=\"string\">`json:&quot;color,omitempty&quot;`</span></span><br><span class=\"line\">\tActors []<span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相反，在解码JSON数据时，需要显式声明struct结构来接收JSON数据。<code>json.Unmarshal</code>方法的第二个入参即struct的指针。在解析JSON时，对key是不区分大小写的，因此只需要对<code>a_b</code>类型的JSON key指定<em>field tag</em>。</p>\n<p>对于stream格式的JSON数据，使用<code>json.Encode</code>和<code>json.Decode</code>编解码。</p>\n<h3 id=\"HTML和文本模板\"><a href=\"#HTML和文本模板\" class=\"headerlink\" title=\"HTML和文本模板\"></a>HTML和文本模板</h3><p><code>text/template</code>和<code>html/template</code>用于文本模板和HTML模板。它们都使用双花括号包裹带有逻辑的简单语句。其中，<code>html/template</code>还会默认对文本做escape脱敏处理（对<code>template.HTML</code>不会escape）。</p>\n<ul>\n<li>使用<code>template.New</code>创建模板</li>\n<li><code>template.Funcs</code>向模板内插入函数</li>\n<li><code>template.Must</code>保证模板有内容</li>\n<li><code>template.Parse</code>解析模板</li>\n<li>使用模板的<code>Execute</code>方法生成解析后内容</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> report = template.Must(template.New(<span class=\"string\">&quot;issueList&quot;</span>)).Funcs(</span><br><span class=\"line\">\ttemplate.FuncMap(<span class=\"string\">&quot;daysAgo&quot;</span>: daysAgo)</span><br><span class=\"line\">).Parse(templ)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tresult, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := report.Execute(os.Stdout, result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"声明-1\"><a href=\"#声明-1\" class=\"headerlink\" title=\"声明\"></a>声明</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span> <span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> (z <span class=\"type\">int</span>) &#123; z = x - y; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">first</span><span class=\"params\">(x <span class=\"type\">int</span>, _ <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> x &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">zero</span> <span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>相同类型入参可以聚合<code>x, y int</code></li>\n<li>返回值为多个时，需要用<code>()</code>包裹</li>\n<li>返回值也可以给予变量名，这种情况下，相当于提前为返回值声明变量</li>\n<li>入参是<strong>传值</strong>，即入参会复制一份传递给函数内部，只有像slice、map、function、channel这种引用实现的类型在函数内改变会影响外部值</li>\n<li>只有函数声明，没有函数体的函数表示函数由其他语言实现，如<code>func Sin(x float64) float64</code></li>\n</ul>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>Go的递归和其他语言无异。不同的是，传统语言的函数递归借助<strong>定长的栈</strong>实现，大小从64KB到2MB不等，而Go使用<strong>变长栈</strong>实现，避免的栈溢出的情况。</p>\n<h3 id=\"多返回值\"><a href=\"#多返回值\" class=\"headerlink\" title=\"多返回值\"></a>多返回值</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Size</span><span class=\"params\">(rect image.Rectangle)</span></span> (width, height <span class=\"type\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Go支持同时返回多个返回值。同类型返回值可以压缩，还可以声明有名称的返回值。在多返回值时，还可以直接传递给需要多个入参的函数，</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.Println(findLinks(url))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">links, err := findLinks(url)</span><br><span class=\"line\">log.Println(links, err)</span><br></pre></td></tr></table></figure>\n\n<p>返回值有名称时，会<strong>作为函数体内最外层变量出现</strong>。因此，不需要显示<code>return</code>返回值，这种现象也称为“裸返回”（<em>bare return</em>）。由于裸返回时，<code>return</code>后不会跟随返回值，不利于代码可读性，所以只在需要的时候使用它。</p>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><p>函数<em>返回</em>错误在Go中是普遍现象。有时，错误类型只需要有1种，这时通常用<code>bool</code>类型的<code>ok</code>表示。如对<code>map</code>类型的变量的访问。但大多数时候，错误原因可能要有比较多种，这时可以用<code>error</code>类型的<code>err</code>表示。</p>\n<p>在Go中较少使用exception表示失败（尽管Go也有exception机制），Go只在真正的bug处，才使用异常打印stack trace信息。在Go中较常出现的是普通的error类型，它只作为普通控制流的一部分。</p>\n<h4 id=\"处理策略\"><a href=\"#处理策略\" class=\"headerlink\" title=\"处理策略\"></a>处理策略</h4><p>error处理由调用方负责，有5种策略：</p>\n<ul>\n<li><strong>向上传递</strong>，在没有error时，可以用<code>fmt.Errorf</code>制造一个自定义错误信息的错误。Go建议仔细设计错误信息内容，<strong>不使用大写字母，不使用换行</strong>。建议函数的每一层补充上更多信息。</li>\n<li><strong>重试</strong>，在有些场景下，如测试服务端连接</li>\n<li><strong>退出</strong>，严重问题时，可以用<code>os.Exit(1)</code>退出，或者用<code>log.Fatalf</code>打印错误信息后退出</li>\n<li><strong>打印日志后继续</strong>，对于简单问题，可以打印日志后继续流程</li>\n<li><strong>忽略</strong>，在特殊情况下，可以直接忽略，如错误确实不会影响功能实现</li>\n</ul>\n<p>Go建议是使用函数时考虑错误处理的场景。</p>\n<h4 id=\"EOF\"><a href=\"#EOF\" class=\"headerlink\" title=\"EOF\"></a>EOF</h4><p>EOF（End Of File）是一种特殊的错误类型，<code>io.EOF</code>表示输入流没有更多内容了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in := bufio.NewReader(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    r, _, err := is.ReadRune()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h4><blockquote>\n<p>这一章很类似JS或TS</p>\n</blockquote>\n<p>Go中函数是<em>一级成员</em>。这意味着，它可以作为一种类型，传递给变量、入参或者返回，就像其他值的类型一样。函数是一种引用类型，所以可以为<code>nil</code>，但是<strong>执行<code>nil</code>会导致panic</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"literal\">nil</span></span><br><span class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// call of nil panic</span></span><br></pre></td></tr></table></figure>\n\n<p>再次基础上，就可以对函数做更灵活而精准的设计，拆分函数关注点和抽象层次。构造出更灵活的程序。以<code>strings.Map</code>为例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add1</span><span class=\"params\">(r <span class=\"type\">rune</span>)</span></span> <span class=\"type\">rune</span> &#123; <span class=\"keyword\">return</span> r + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">fmt.Println(strings.Map(add1, <span class=\"string\">&quot;Admin&quot;</span>)) <span class=\"comment\">// Benjo</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>Go中只能在包级别声明有名函数，而匿名函数可以在块作用域、函数作用域内声明。因此，<strong>高阶函数</strong>、<strong>闭包</strong>等概念Go中也有。由于这些概念JS中也有，这里就不再赘述。</p>\n<h3 id=\"循环变量捕获\"><a href=\"#循环变量捕获\" class=\"headerlink\" title=\"循环变量捕获\"></a>循环变量捕获</h3><blockquote>\n<p>JS也有类似问题，不过原因不同</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一段会有问题的代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rmdirs []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, dir := <span class=\"keyword\">range</span> tempDirs() &#123;</span><br><span class=\"line\">    os.MkdirAll(dir, <span class=\"number\">0755</span>)</span><br><span class=\"line\">    rmdirs = <span class=\"built_in\">append</span>(rmdirs, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        os.RemoveAll(dir)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的for循环中，循环变量<code>dir</code>在<code>append</code>的回调中有使用，我们回忆一下，for循环中循环变量位于for语句块外，在整个for循环后才销毁。所以这会导致每一个回调执行时，dir都被更新为最新的值。将dir在循环体内再次赋值即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rmdirs []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, dir := <span class=\"keyword\">range</span> tempDirs() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以运行</span></span><br><span class=\"line\">    dir := dir</span><br><span class=\"line\">    os.MkdirAll(dir, <span class=\"number\">0755</span>)</span><br><span class=\"line\">    rmdirs = <span class=\"built_in\">append</span>(rmdirs, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        os.RemoveAll(dir)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变长参数\"><a href=\"#变长参数\" class=\"headerlink\" title=\"变长参数\"></a>变长参数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(vals ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    total := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> vals &#123;</span><br><span class=\"line\">        total += val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似JS中的剩余参数，Go中也使用<code>rest ...type</code>表示函数的剩余入参。rest需要声明类型，rest为slice类型。要注意的是，这种函数和直接传入一个slice参数的函数类型并不一样。另外，在剩余参数类型不明确时，可以用<code>interface&#123;&#125;</code>表示。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在变量后使用`...`表示解构</span></span><br><span class=\"line\">val := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(sum(values...))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延迟函数调用（Deferred-Function-Calls）\"><a href=\"#延迟函数调用（Deferred-Function-Calls）\" class=\"headerlink\" title=\"延迟函数调用（Deferred Function Calls）\"></a>延迟函数调用（Deferred Function Calls）</h3><p>在语句前加上<code>defer</code>标识符，会让<code>defer</code>后的<strong>函数调用</strong>推迟到所在函数的**<code>return</code>之后**执行。<code>defer</code>后的函数和表达式会立即求值。<code>defer</code>的函数调用在函数panic后仍然会被调用。可以用来执行一些释放资源的操作，如以下场景：</p>\n<ul>\n<li>open和close</li>\n<li>connect和disconnect</li>\n<li>lock和unlock</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lookup</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m[key]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>最合适的使用时机是在刚刚获得资源之后</strong>。还可以利用defer完成<em>进入</em>和<em>离开</em>函数的成对操作做一些调试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bigSlowOperation</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> trace(<span class=\"string\">&quot;bigSlowOperation&quot;</span>)()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trace</span><span class=\"params\">(msg <span class=\"type\">string</span>)</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    start := time.Now()</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;enter %s&quot;</span>, msg)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于defer在函数最后执行的特点，甚至可以在defer中<strong>获取和修改函数返回值</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">triple</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> (result <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; result += x &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> double(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(triple(<span class=\"number\">4</span>)) <span class=\"comment\">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时也由于defer的这个特点，在for循环中使用defer一定要谨慎。</p>\n<h3 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic\"></a>panic</h3><p>Go中的panic类似于其他语言的exception，它一般代表程序中存在bug和不应该出现的情况。panic后，正常程序执行停止，<strong>defer的函数被倒序执行</strong>，然后函数崩溃并带有错误信息。</p>\n<p>除了系统触发的panic，还可以直接通过<code>panic(&quot;certain message&quot;)</code>手动触发一个panic。一些包中以<strong>Must</strong>开头的API通常表示，在不符合规范的时候API会panic。<strong>建议只在内部可信任环境下使用这种API</strong>。</p>\n<h3 id=\"recover\"><a href=\"#recover\" class=\"headerlink\" title=\"recover\"></a>recover</h3><p>就像其他语言中的try catch一样，Go中的panic同样有机制去妥善处理。Go有内置的<code>recover</code>函数，可以用于在panic中恢复。</p>\n<ul>\n<li><code>recover</code>需要在defer的函数中使用</li>\n<li><code>recover</code>函数会返回panic的value，在没有panic的情况下，该函数返回<code>nil</code></li>\n</ul>\n<p>下面是一些使用<code>recover</code>的建议：</p>\n<ul>\n<li>不要毫无条件地从panic中recover，这可能会掩盖一些潜在的bug或资源泄露</li>\n<li>在panic后，可以使用<code>runtime.Stack</code>这样的方法打印一下错误的详细信息，再recover</li>\n<li>可以定义一些外部不可见的类型，在调用panic时传入，在recover返回时判断类型，从而做到针对特定情况panic执行recover，其余情况仍旧panic</li>\n<li>对于预期中的error不使用panic</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">soleTitle</span><span class=\"params\">(doc *html.Node)</span></span> (title <span class=\"type\">string</span>, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> bailout <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> p := <span class=\"built_in\">recover</span>(); p &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"literal\">nil</span>:</span><br><span class=\"line\">            <span class=\"comment\">// no panic</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> bailout&#123;&#125;:</span><br><span class=\"line\">            err = fmt.Errorf(<span class=\"string\">&quot;multiple titles&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(p) <span class=\"comment\">// resume panic</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Go也有OOP的特性，即<em>对象</em>上具有<em>方法</em>，方法需要关联在一个特定类型上。</p>\n<h3 id=\"声明-2\"><a href=\"#声明-2\" class=\"headerlink\" title=\"声明\"></a>声明</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"type\">float64</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> Distance(q Point) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>声明里，在普通声明的函数名前，增加函数绑定的类型receiver，即完成了方法的声明。Go中没有<code>this</code>和<code>self</code>这样的保留字。类型receiver中的变量，即方法可以访问的类型变量。变量名由于会比较常用，所以通常取类型首字母。</p>\n<p>其他方法的行为类似其他OOP语言：诸如方法名和函数名不在一个命名空间，所以可以重名；方法名之间不能重名；<strong>方法名不能和属性名相同</strong>。由于Go中声明命名类型比较自由，而方法可以很方便绑定在命名类型上，所以可以给基础类型，如数字、字符串等，增加新方法。</p>\n<h3 id=\"指针receiver\"><a href=\"#指针receiver\" class=\"headerlink\" title=\"指针receiver\"></a>指针receiver</h3><p>上面提到，访问方法需要一个receiver。除了变量本身，指针也可以作为receiver。在Go中函数入参都是传值的，也就是传入值的复制。所以除了map、slice这种引用类型，其余类型的值在方法内改变并不会影响到外部。如果需要方法改变receiver本身的话，可以指定将方法绑定在指针类型上。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point)</span></span> ScaleBy(factor <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">    p.X *= factor</span><br><span class=\"line\">    p.Y *= factor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">t := &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">r.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(*r)</span><br></pre></td></tr></table></figure>\n\n<p>通常会规定，如果类型上有方法是指针类型的receiver，所有的方法都需要有一个指针类型receiver。类似struct一节介绍的，如果变量具有类型<code>T</code>，而方法的receiver是<code>*T</code>，我们可以直接使用简写的<code>p.ScaleBy(2)</code>而不需要写成<code>(&amp;p).ScaleBy(2)</code>。相反地，receiver要求类型<code>T</code>，变量传入<code>*T</code>也是可以的。</p>\n<p>但是，直接将字面量传入给指针类型的receiver是不允许的，如<code>Point&#123;1, 2&#125;.ScaleBy(2)</code>。</p>\n<h3 id=\"Nil是合法的Receiver\"><a href=\"#Nil是合法的Receiver\" class=\"headerlink\" title=\"Nil是合法的Receiver\"></a>Nil是合法的Receiver</h3><p>Go中，<code>nil</code>在很多时候是合法的零值。同样也可以作为receiver。当然在你的命名类型中，最好对合法的<code>nil</code>类型加以说明。Go的内置类型和操作，如slice，map、struct、append、make等也可以正常地处理<code>nil</code>。</p>\n<h3 id=\"组合和struct-embedding\"><a href=\"#组合和struct-embedding\" class=\"headerlink\" title=\"组合和struct embedding\"></a>组合和struct embedding</h3><p>在此前的struct一节中，已经介绍了Go的struct embedding设计。这里结合方法继续讨论一下。首先我们先回忆下struct embedding是啥。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;image/color&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"type\">float64</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ColoredPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Point</span><br><span class=\"line\">    Color color.RGBA</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cp ColoredPoint</span><br><span class=\"line\">cp.X = <span class=\"number\">1</span></span><br><span class=\"line\">fmt.Println(cp.Point.X)</span><br><span class=\"line\">cp.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Print;n(cp.Y)</span><br></pre></td></tr></table></figure>\n\n<p>匿名的field会直接将field类型中的<strong>成员和方法</strong>都<strong>组合</strong>（composite）进当前类型中（和TS中的extends有点像）。如上面的<code>ColoredPoint</code>就直接拥有了<code>Point</code>的<code>Distance</code>和<code>ScaleBy</code>功能（当然也可以访问Point）。Go更希望用<strong>组合</strong>（composition）而非<strong>派生</strong>（derivation）构造更复杂的类型。比如，上面的<code>ColoredPoint</code>并不是一个<code>Point</code>，并不能当做一个Point访问和使用。</p>\n<p>匿名field如果是指针类型，除了上面的特性，还能实现让两个变量共享一个底层的结构。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ColoredPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *Point</span><br><span class=\"line\">    Color color.RGBA</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p := ColoredPoint&#123;&amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, red&#125;</span><br><span class=\"line\">q := ColoredPoint&#123;&amp;Point&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;, blue&#125;</span><br><span class=\"line\">p.Point = q.Point</span><br></pre></td></tr></table></figure>\n\n<p>在访问receiver上的方法时，Go首先会去直接声明的field中寻找，然后再去embedded的field中寻找，再向下寻找。方法只能在命名类型和其指针类型上定义，但是借助struct embedding也可以实现，将<strong>功能聚合</strong>在一起。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    mu sync.Mutex</span><br><span class=\"line\">    mapping = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Lookup</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    v := mapping[key]</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重构后</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cache = <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    sync.Mutex</span><br><span class=\"line\">    mapping <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span></span><br><span class=\"line\">&#125; &#123;</span><br><span class=\"line\">    mapping: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Lookup</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    cache.Lock()</span><br><span class=\"line\">    v := cache.mapping[key]</span><br><span class=\"line\">    cache.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面重写之后的代码表现力明显更好了。</p>\n<h3 id=\"方法值（method-value）和方法表达式（method-expression）\"><a href=\"#方法值（method-value）和方法表达式（method-expression）\" class=\"headerlink\" title=\"方法值（method value）和方法表达式（method expression）\"></a>方法值（method value）和方法表达式（method expression）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">distanceFromP := p.Distance</span><br><span class=\"line\">fmt.Println(distanceFromP(q))</span><br><span class=\"line\"></span><br><span class=\"line\">time.AfterFunc(<span class=\"number\">10</span> * time.Second(), r.Launch)</span><br></pre></td></tr></table></figure>\n\n<p><code>p.Distance</code>会得到一个method value，它是一个绑定到了特定receiver上的一个方法，本身也是一个函数。可以当做函数类型的值用作入参或返回值。这个和JS还比较像。</p>\n<p>类似的，Go中还有method expression的概念。即直接用类型名加点（<code>.</code>）访问方法得到一个method expression。它也是一个函数，可以<strong>看做是一个没有绑定receiver的方法</strong>。调用函数时，传入的第一个入参会当做receiver，后续的作为方法入参。这个特性在需要根据情况灵活选择方法时很好用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> Add(q Point) Point &#123; <span class=\"keyword\">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> Sub(q Point) Point &#123; <span class=\"keyword\">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> path []Point</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(path Path)</span></span> TranslateBy(offset Point, add <span class=\"type\">bool</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> op <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(p, q Point)</span></span> Point</span><br><span class=\"line\">    <span class=\"keyword\">if</span> add &#123;</span><br><span class=\"line\">        op = Point.Add</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        op = Point.Sub</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> path &#123;</span><br><span class=\"line\">        path[i] = op(path[i], offset)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一个实例：bitset\"><a href=\"#一个实例：bitset\" class=\"headerlink\" title=\"一个实例：bitset\"></a>一个实例：bitset</h3><ul>\n<li><code>bytes.Buffer</code>经常用来拼接字符串</li>\n<li><code>fmt</code>的print打印字符串时会调用变量的<code>String</code>方法</li>\n</ul>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p><strong>首先，Go的封装细粒度只到package一层，package内不控制可见性</strong>。所以当你想要控制可见性时，需要用拆分package实现。</p>\n<p>封装用来掩盖不需要像使用者展示的信息和细节。Go中唯一用来控制可见性的手段是一个<strong>大小写约定</strong>：大写表示从包中导出，小写表示包内可见，对于struct中的field以及类型的method也是如此（包外访问不了，包内随便访问）。通常来讲，<strong>当需要封装对象时，我们都会使用struct</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建议</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntSet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    words []<span class=\"type\">uint64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不建议</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntSet []<span class=\"type\">uint64</span></span><br></pre></td></tr></table></figure>\n\n<p>使用struct封装本来就很简单的类型有以下几个原因：</p>\n<ul>\n<li>使用方无法修改对象值，这样只用查阅更少的声明，就能得到对象值大致的可能范围</li>\n<li>对使用方掩盖实现细节，可以避免让使用方依赖那些可能改变的内容，也给开发者重构空间，开发者可以在不改变API兼容性的情况下灵活调整内部实现</li>\n<li>避免使用方任意修改对象值，造成更多边缘情况，提高程序编写难度和程序不稳定性</li>\n</ul>\n<p>有时，封装也会暴露出一些<strong>getter</strong>和<strong>setter</strong>。通常命名上，会直接使用field的首字母大写形式，省去不必要的<code>Get</code>，<code>Fetch</code>，<code>Lookup</code>前缀。实际上，Go并不禁止导出field，只是在有些情况下，导出field会影响代码可靠性。</p>\n<p>封装并不总是必要的。有时，底层数据结构是目标数据结构的<strong>充要表示</strong>，不多不少，场景变数不多，这时可以不用struct封装。但是，像IntSet这种，实现细节变数多，程序实现稳定性低，需要被保护起来，避免影响使用者。从而要采取封装的方式，把那些变数变得“不透明”。</p>\n<h2 id=\"接口（interface）\"><a href=\"#接口（interface）\" class=\"headerlink\" title=\"接口（interface）\"></a>接口（interface）</h2><p>如其他OOP语言一样，Go中也有用于标识抽象类型的接口描述。不同的是，Go中的接口都是<strong>隐式</strong>满足的，松耦合。</p>\n<h3 id=\"作为约定的接口\"><a href=\"#作为约定的接口\" class=\"headerlink\" title=\"作为约定的接口\"></a>作为约定的接口</h3><p>之前介绍过的所有类型都是<strong>具体类型</strong>（concrete type），具体类型指数据表示和行为实现在类型确定后，就已一清二楚。为了保证语言灵活性，Go中还有<strong>接口类型</strong>（interface type）。这种类型不暴露内在结构和实现细节，而是给出接口输入输出，作为一种<strong>约定</strong>交由具体实现方完成，从而实现依赖反转（DI）。这一概念的设计上和其他OOP语言无二。不过在使用上，Go并不要求实现方明确依赖关系，只需实现约定即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fprintf</span><span class=\"params\">(w io.Writer, format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (<span class=\"type\">int</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sprintf</span><span class=\"params\">(format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span> &#123;&#125;)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf bytes.Buffer</span><br><span class=\"line\">    Fprintf(&amp;buf, format, args...)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf.String()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...comments</span></span><br><span class=\"line\">    Write(p []<span class=\"type\">byte</span>) (n <span class=\"type\">int</span>, err <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的，实现<code>String</code>方法也让类型隐式满足了<code>fmt.Stringer</code>的定义。Go中单方法interface的命名，通常以动词的名词形态为主。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stringer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    String() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口中也有类似struct embedding的<strong>嵌入式写法</strong>，简化interface的组合成本。另外，interface中方法的顺序不影响interface类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Read(p []<span class=\"type\">byte</span>) (n <span class=\"type\">int</span>, err <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Closer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Close() <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Reader</span><br><span class=\"line\">    Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"接口的满足\"><a href=\"#接口的满足\" class=\"headerlink\" title=\"接口的满足\"></a>接口的满足</h3><p>Go中变量可以是接口类型，在给接口类型变量赋值时，需要检查值的方法是否满足了接口的类型定义，这一点和其他OOP语言相似。要注意，尽管Go有将变量<code>T</code>转成<code>*T</code>的隐式转换，但是类型<code>T</code>的方法和<code>*T</code>的方法receiver并不同。而通常具体类型中会在接口声明的方法中做一些写操作，因而指定receiver为指针类型，这有可能会导致无法满足接口定义。</p>\n<p>接口覆盖了其包裹的内部类型，所以，<strong>即使内部类型满足其他方法，赋值给接口类型后，也只能方法接口拥有的方法</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w io.Writer</span><br><span class=\"line\">w = os.Stdout</span><br><span class=\"line\">w.Write([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;hello&quot;</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\">w.Close() <span class=\"comment\">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>\n\n<p>Go中还有一个通用的不可或缺的类型<code>interface&#123;&#125;</code>它表示对类型没有任何要求，同时也意味着该类型变量上无法执行任何操作，类似ts中的<code>Unknown</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> any <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">any = <span class=\"literal\">true</span></span><br><span class=\"line\">any = <span class=\"number\">12.34</span></span><br><span class=\"line\">any = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">any = <span class=\"built_in\">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>\n\n<p>Go中具体类型对接口类型的满足都是隐式的，无需显式声明。所以一个具体类型可能会同时满足很多接口类型。可以把接口类型认为是将一些具体类型中公共的部分抽象出来的共同行为，将之作为<strong>grouping</strong>出来的共性。</p>\n<h4 id=\"使用flag-Value解析命令行参数\"><a href=\"#使用flag-Value解析命令行参数\" class=\"headerlink\" title=\"使用flag.Value解析命令行参数\"></a>使用<code>flag.Value</code>解析命令行参数</h4><ul>\n<li><code>fmt.Sscanf</code>可以从输入中按格式解析出特定类型参数</li>\n</ul>\n<h3 id=\"接口值\"><a href=\"#接口值\" class=\"headerlink\" title=\"接口值\"></a>接口值</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w io.Writer</span><br><span class=\"line\">w = os.Stdout</span><br><span class=\"line\">w = <span class=\"built_in\">new</span>(bytes.Buffer)</span><br><span class=\"line\">w = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n\n<p>Go中，接口类型可以作为变量的合法类型。接口类型值因此具有<strong>动态类型</strong>和<strong>动态值</strong>。在Go中可以近似用类型描述符（type descriptor）表示，其中type表示具体类型，value表示具体值。在初始化时，type和value都是<code>nil</code>。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        +-----------+</span><br><span class=\"line\">type    |    nil    |</span><br><span class=\"line\">        +-----------+</span><br><span class=\"line\">value   |    nil    |</span><br><span class=\"line\">        +-----------+</span><br></pre></td></tr></table></figure>\n\n<p>而在第二和第三行，为w赋值为<code>os.Stdout</code>以及<code>*bytes.Buffer</code>类型时，type分别会变成<code>os.Stdout</code>和<code>*bytes.Buffer</code>，同时value也会被设置为对应初始值的指针。这个过程会完成类似于<code>io.Writer(os.Stdout)</code>的隐式类型转换。此时访问<code>w</code>的方法，会被动态分配到value上实现。而在最后又将<code>w</code>还原为初始值<code>nil</code>。</p>\n<p>接口类型之间<strong>不一定</strong>可以比较，当接口值都为<code>nil</code>或接口值对应的具体类型相同以及具体值相同时，接口值相同。然而，如果具体类型不可比较时（如slice，function等），接口类型也不可比较。Go的<code>fmt</code>中，可以用<code>%T</code>打印变量类型。</p>\n<h4 id=\"陷阱：nil值可以存在于非nil的接口值中\"><a href=\"#陷阱：nil值可以存在于非nil的接口值中\" class=\"headerlink\" title=\"陷阱：nil值可以存在于非nil的接口值中\"></a>陷阱：nil值可以存在于非nil的接口值中</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> debug = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf *bytes.Buffer</span><br><span class=\"line\">    <span class=\"keyword\">if</span> debug &#123;</span><br><span class=\"line\">        buf = <span class=\"built_in\">new</span>(bytes.Buffer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f(buf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> debug &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">(out io.Writer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> out != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        out.Write([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;woops!\\n&quot;</span>)) <span class=\"comment\">// panic: nil pointer derefence</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的判断中，<code>out</code>已经有了具体的类型，因此接口类型的<code>out</code>不等于<code>nil</code>，然而<code>out</code>的具体值却是<code>nil</code>，这使得<code>Write</code>行为无法保证。解决办法是，在一开始为<code>buf</code>声明为<code>io.Writer</code>类型即可。</p>\n<h3 id=\"sort-Interface\"><a href=\"#sort-Interface\" class=\"headerlink\" title=\"sort.Interface\"></a><code>sort.Interface</code></h3><p>Go使用sort包中的<code>sort.Interface</code>实现排序功能。同时对于常见类型string、int等也有事先封装好的<code>sort.Strings()</code>，<code>sort.Int()</code>。对于自定义类型，在实现<code>sort.Interface</code>接口后，也可使用<code>sort.Sort</code>排序。接口定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sort</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Len() <span class=\"type\">int</span></span><br><span class=\"line\">    Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">    Swap(i, j <span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三个方法分别用来<strong>返回长度</strong>、<strong>比较大小</strong>和<strong>交换顺序</strong>。这也是排序的几个基本操作。下面给出了字符串排序的内部实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StringSlice []<span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StringSlice)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StringSlice)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StringSlice)</span></span> Swap(i, j <span class=\"type\">int</span>) &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在排序struct等复杂类型slice时，建议定义指针类型数组，这样可以让swap时速度更快</strong>。</p>\n<p>sort还有一个方便的反向排序方法<code>sort.Reverse</code>，它借助了struct embedding，用一个内部类型<code>reverse</code>封装了外部实现接口的类型，另外，直接在<code>reverse</code>上定义了Less，覆盖了<code>Interface</code>的实现，从而实现了反向排序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sort</span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123; Interface &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span></span> Less (i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> r.Interface.Less(j, i) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(i Interface)</span></span> Interface &#123; <span class=\"keyword\">return</span> reverse&#123;i&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sort.Sort(sort.Reverse(byArtist(tracks)))</span><br></pre></td></tr></table></figure>\n\n<p>除了slice类型外，其他实现了<code>sort.Interface</code>接口的类型一样可以排序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> customSort <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    t []*Track</span><br><span class=\"line\">    less <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y *Track)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(x customSort)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(x.t) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(x customSort)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(x customSort)</span></span> Swap(i, j <span class=\"type\">int</span>) &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"http-Handler接口\"><a href=\"#http-Handler接口\" class=\"headerlink\" title=\"http.Handler接口\"></a><code>http.Handler</code>接口</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> http</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(address <span class=\"type\">string</span>, h Handler)</span></span> <span class=\"type\">error</span></span><br></pre></td></tr></table></figure>\n\n<p>实现了这个接口的可以传递给<code>ListenAndServe</code>。但通常用不到这种原始的方式。Go的http包提供的<code>ServeMux</code>类型可以给请求分路，聚合一堆<code>http.Handlers</code>。写起来像下面这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    db := database&#123;<span class=\"string\">&quot;shoe&quot;</span>: <span class=\"number\">50</span>, <span class=\"string\">&quot;socks&quot;</span>: <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\">    mux.Handle(<span class=\"string\">&quot;/list&quot;</span>, http.HandlerFunc(db.list))</span><br><span class=\"line\">    mux.Handle(<span class=\"string\">&quot;/price&quot;</span>, http.HandlerFunc(db.price))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> database <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item, price := <span class=\"keyword\">range</span> db &#123;</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;%s: %s\\n&quot;</span>, item, price)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>http.HandlerFunc</code>将传入的函数包裹成了满足<code>Handler</code>接口的类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> http</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于上面的使用还是要写一些模板代码，对此可以将<code>mux.Handler</code>简写成<code>mux.HandlerFunc(&quot;list&quot;, db.list)</code>。可以再减少一点代码。实际上，http还提供了一个全局的<code>ServeMux</code>对象实例<code>DefaultServeMux</code>，不需要手动创建。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    db := database&#123;<span class=\"string\">&quot;shoes&quot;</span>: <span class=\"number\">50</span>, <span class=\"string\">&quot;socks&quot;</span>: <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">    http.HandlerFunc(<span class=\"string\">&quot;/list&quot;</span>, db.list)</span><br><span class=\"line\">    http.HandlerFunc(<span class=\"string\">&quot;/price&quot;</span>, db.price)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>go中每一个handler都在一个单独的goroutine上，要妥善处理好并发的情况。</strong></p>\n<h3 id=\"error接口\"><a href=\"#error接口\" class=\"headerlink\" title=\"error接口\"></a><code>error</code>接口</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">error</span> <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>error</code>类型实现了<code>error</code>接口。整个<code>errors</code>包都围绕这个接口设计，除了<code>errors.New()</code>方法，还可以直接通过<code>fmt.Errorf</code>返回一个格式化后的error值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span> &#123; <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123; text <span class=\"type\">string</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span></span> Error() <span class=\"type\">string</span> &#123; <span class=\"keyword\">return</span> e.text &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Errorf</span><span class=\"params\">(format <span class=\"type\">string</span>, arags ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(Sprintf(format, args...))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单的数学表达式求值器\"><a href=\"#简单的数学表达式求值器\" class=\"headerlink\" title=\"简单的数学表达式求值器\"></a>简单的数学表达式求值器</h3><p>递归的AST解析</p>\n<p>略。</p>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>类型断言（type assertion），写作<code>x.(T)</code>，通常用来将动态类型限定到更严格的类型。</p>\n<ul>\n<li><code>T</code>是具体类型时，会判断<code>x</code>类型是否和<code>T</code><strong>一致</strong>，是则将<code>x</code>类型设置为<code>T</code>，否则<code>panic</code></li>\n<li><code>T</code>是抽象类型interface时，会判断<code>x</code>是否<strong>满足</strong><code>T</code>接口，是则将<code>x</code>类型设置为接口<code>T</code>，否则panic</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w io.Writer</span><br><span class=\"line\">w = os.Stdout</span><br><span class=\"line\">f := w.(*os.File)</span><br><span class=\"line\">c := w.(*bytes.Buffer) <span class=\"comment\">// panic</span></span><br><span class=\"line\"></span><br><span class=\"line\">w = <span class=\"built_in\">new</span>(ByteCounter)</span><br><span class=\"line\">rw := w.(io.ReadWriter) <span class=\"comment\">// panic</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>当对<code>nil</code>进行类型断言时时，断言一定失败</strong>。另外，类型断言可以支持第二个返回参数<code>ok</code>表示是否成功，此时不会panic。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...use w...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"应用：错误类型区分\"><a href=\"#应用：错误类型区分\" class=\"headerlink\" title=\"应用：错误类型区分\"></a>应用：错误类型区分</h4><p>借助类型断言，可以将判断抛出的具体错误类型，<code>os</code>包提供了<code>IsExist</code>，<code>isNotExist</code>，<code>isPermission</code>用来区分文件已存在，文件不存在，不允许几种错误。我们以文件不存在为例，此时抛出的<code>PathError</code>类型错误包含了具体的错误类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PathError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Op <span class=\"type\">string</span></span><br><span class=\"line\">    Path <span class=\"type\">string</span></span><br><span class=\"line\">    Err <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 满足Error接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *PathError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.Op + <span class=\"string\">&quot; &quot;</span> + e.Path + <span class=\"string\">&quot;: &quot;</span> + e.Err.Error()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_, err := os.Open(<span class=\"string\">&quot;/no/such/path&quot;</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, err)</span><br><span class=\"line\"><span class=\"comment\">// Output: &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/path&quot;, Err:0x2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用断言后，就可以从<code>err</code>中拿到具体错误类型，从而判断是否是文件不存在导致的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;syscall&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsNotExist</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class=\"line\">        err = pe.Err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，建议在错误抛出时就进行检测，在聚合后，原始错误的数据结构可能会丢失从而无法判断。</p>\n<h4 id=\"方法查询\"><a href=\"#方法查询\" class=\"headerlink\" title=\"方法查询\"></a>方法查询</h4><p>抽象类型如<code>io.Writer</code>可能缺少使用者需要的方法如<code>io.WriteString</code>（尽管满足<code>io.Writer</code>的大多数具体类型除了必须满足的<code>Write</code>方法外，都对写入字符串支持了<code>WriteString</code>方法）。</p>\n<p>可以定义一个临时接口类型，判断满足抽象类型的变量是否具有指定方法。因为Go中接口的满足是隐式的（类似鸭子类型），不像许多强类型语言一样，需要显式声明。之前使用弱类型语言的可能能很好接受。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">writeString</span><span class=\"params\">(w io.Writer, s <span class=\"type\">string</span>)</span></span> (n <span class=\"type\">int</span>, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> stringWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">        WriteString(<span class=\"type\">string</span>) (n <span class=\"type\">int</span>, err <span class=\"type\">error</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sw.WriteString(s) <span class=\"comment\">// 更有效率的方案</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w.Write([]<span class=\"type\">byte</span>(s))  <span class=\"comment\">// 兜底方案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，<code>fmt.Sprintf</code>打印不同类型的变量时，也借助了类型断言，对于特定类型调用特定方法，最后再使用<strong>反射</strong>处理其他类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">formatOnValue</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err, ok := x.(<span class=\"type\">error</span>); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err.Error()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> str, ok := x.(Stringer); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.String()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Type-switch\"><a href=\"#Type-switch\" class=\"headerlink\" title=\"Type switch\"></a>Type switch</h3><p>interface除了之前说的<strong>让多个具体类型有一致表现</strong>的用法外，还可以作为<strong>可区分具体类型的合集</strong>来使用。这种时候需要结合type switch的用法。如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> x.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"literal\">nil</span>: <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"type\">int</span>, <span class=\"type\">uint</span>: <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"type\">bool</span>: <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"type\">string</span>: <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">default</span>: <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常在确定了<code>x</code>的类型后，还需要直接使用<code>x</code>。此时可以写作<code>switch x:= x.(type)</code>。</p>\n<p>这种用法和之前的用法不同在于：这里接口不作为有<strong>一致表现</strong>而存在，它只是用来暂存将要区分开的具体类型，而这些具体类型往往时有<strong>不同表现</strong>的。所以这种用法里的接口<strong>几乎没有方法</strong>。换一种说法，之前的用法里，接口背后的具体类型细节需要被掩盖来使用，而这里需要使用具体类型的细节。</p>\n<h3 id=\"一些忠告\"><a href=\"#一些忠告\" class=\"headerlink\" title=\"一些忠告\"></a>一些忠告</h3><p>和上一章方法类似，接口是一种很好使用的面向对象的特性。但<strong>不建议上来就从定义一堆接口</strong>开始，这样通常会产生一大堆只有一个具体类型实现的接口。接口是抽象类型，是通过具体类型抽象得来的。通常是在<strong>需要用统一的方式处理不同类型</strong>时，拿来使用。</p>\n<p>同时，大多数Go程序中，接口往往小且包含比较少的方法。像是<code>io.Writer</code>或<code>fmt.Stringer</code>。和方法一章一样，它们虽然是面向对象的特性，但是不是Go中一定要使用的语言特性。只在需要的时候使用。大多数时候，直接使用函数就足够了。在书中，方法如<code>input.Write</code>的使用就远不如函数如<code>fmt.Printf</code>来得频繁。</p>\n<h2 id=\"goroutine和信道\"><a href=\"#goroutine和信道\" class=\"headerlink\" title=\"goroutine和信道\"></a>goroutine和信道</h2><p>Go支持两种并发编程的风格，第一种在本章介绍，通过goroutines和channels支持<strong>通信顺序进程（Communicating sequential processes，CSP）</strong>，这种情况下，值会在goroutine间来回传递，而变量在多数情况下被限制自单个活动中。下一章介绍的共享变量风格的并发编程更接近传统的并发风格。</p>\n<h3 id=\"认识goroutine\"><a href=\"#认识goroutine\" class=\"headerlink\" title=\"认识goroutine\"></a>认识goroutine</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> spinner(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = <span class=\"number\">45</span></span><br><span class=\"line\">    fibN := fib(n) <span class=\"comment\">// slow</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;\\rFibonacci(%d) = %d\\n&quot;</span>, n, fibN)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">spinner</span><span class=\"params\">(delay time.Duration)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, r = <span class=\"keyword\">range</span> <span class=\"string\">`-\\|/`</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;\\r%c&quot;</span>, r)</span><br><span class=\"line\">            time.Sleep(delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(x<span class=\"number\">-1</span>) + fib(x<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>goroutine类似线程，有着定量而非定性的差异</li>\n<li><code>main</code>函数也会启动一个<em>main goroutine</em></li>\n<li>goroutine通过<code>go</code>启动一个函数或方法调用，并在声明后立即返回</li>\n<li>除了<code>main</code>函数返回或程序结束（<code>os.Exit</code>）外，一个goroutine没有办法直接停止另一个，但可以通过传值的方式间接实现。</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><p>服务器处理请求是最典型的并发场景。</p>\n<h4 id=\"1-Clock-Server\"><a href=\"#1-Clock-Server\" class=\"headerlink\" title=\"1. Clock Server\"></a>1. Clock Server</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    listener, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8000&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        conn, err := listener.Accept()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Print(err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleConn(conn) <span class=\"comment\">// go handleConn(conn)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleConn</span><span class=\"params\">(c net.Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> c.Close()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        _, err := io.WriteString(c, time.Now().Format(<span class=\"string\">&quot;15:04:05\\n&quot;</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"comment\">// e.g. client disconnect</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>listener.Accept</code>会在接收到TCP连接请求前一直阻塞</li>\n<li><code>time.Format</code>方法通过一个<strong>特殊的样例</strong>（15:04:05）表示要格式化的格式，<code>time.Parse</code>也是如此</li>\n<li>client端可以用<code>net.Dial</code>发起一个TCP连接请求</li>\n</ul>\n<p>上述的服务端是<strong>串行</strong>处理client的请求，并每秒打印当前时间，在<code>handleConn(conn)</code>前加上<code>go</code>关键字后，即可让服务端<strong>并行</strong>处理client的请求。</p>\n<h4 id=\"2-Echo-Server\"><a href=\"#2-Echo-Server\" class=\"headerlink\" title=\"2. Echo Server\"></a>2. Echo Server</h4><p>上面的例子是在一个连接中使用一个goroutine，当然每个连接也可以创建多个goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">echo</span><span class=\"params\">(c net.Conn, shout <span class=\"type\">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(c, <span class=\"string\">&quot;\\t&quot;</span>, strings.ToUpper(shout))</span><br><span class=\"line\">    time.Sleep(delay)</span><br><span class=\"line\">    fmt.Fprintln(c, <span class=\"string\">&quot;\\t&quot;</span>, shout)</span><br><span class=\"line\">    time.Sleep(delay)</span><br><span class=\"line\">    fmt.Fprintln(c, <span class=\"string\">&quot;\\t&quot;</span>, strings.ToLower(shout))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleConn</span><span class=\"params\">(c net.Conn)</span></span> &#123;</span><br><span class=\"line\">    input := bufio.NewScanner(c)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        echo(c, input.Text(), <span class=\"number\">1</span>*time.Second) <span class=\"comment\">// go echo(...)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := net.Dial(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8000&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> mustCopy(os.Stdout, conn)</span><br><span class=\"line\">    mustCopy(conn, os.Stdin)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>echo</code>前加上<code>go</code>即可让服务器同时相应多个请求，返回“回声”。同理，在client端打印服务端返回的代码前加上<code>go</code>即可让使用者输入的同时打印返回的“回声”。</p>\n<h3 id=\"信道（channel）\"><a href=\"#信道（channel）\" class=\"headerlink\" title=\"信道（channel）\"></a>信道（channel）</h3><p><code>go</code>启动并行的活动，信道作为活动间通信的通道，借助它可以发送和接收消息。信道通过<code>make</code>构造，需要指定传输消息的类型，作为信道类型。可以使用<code>close</code>关闭信道。后续的<strong>发送</strong>操作会panic，<strong>接收</strong>操作会得所有到已发送的值，而再之后的后续<strong>接收</strong>操作只能得到信道类型对应的<em>零值</em>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ch &lt;- x</span><br><span class=\"line\">x = &lt;-ch</span><br><span class=\"line\"><span class=\"comment\">// 直接丢弃channel来的值</span></span><br><span class=\"line\">&lt;-ch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch)</span><br></pre></td></tr></table></figure>\n\n<p>信道还分为有缓冲区和无缓冲区两种类型，上述的<code>make</code>构造的都是无缓冲区的信道，指定第二个参数可以构造有缓冲区的信道。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) <span class=\"comment\">// 无缓冲区</span></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">0</span>) <span class=\"comment\">// 无缓冲区</span></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 有缓冲区</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"无缓冲信道（Unbuffered-Channels）\"><a href=\"#无缓冲信道（Unbuffered-Channels）\" class=\"headerlink\" title=\"无缓冲信道（Unbuffered Channels）\"></a>无缓冲信道（Unbuffered Channels）</h4><p>向无缓冲区<strong>发送消息</strong>会<strong>阻塞发送所在的goroutine</strong>，直到对应的goroutine在同一个信道上执行接收操作。相反地，<strong>接收消息</strong>在先的话，也会阻塞直到同一个信道上执行了发送操作。这种机制会<strong>同步</strong>两个goroutine的执行进度。如果发送信息在先，则接收信息会在发送所在的goroutine之前发生。从而，我们可以基于这个假设的前提保证一些事实。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := net.Dial(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8000&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        io.Copy(os.Stdout, conn)</span><br><span class=\"line\">        log.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">        done &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// signal the main goroutine</span></span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    mustCopy(conn, os.Stdin)</span><br><span class=\"line\">    conn.Close()</span><br><span class=\"line\">    &lt;-done <span class=\"comment\">// wait for background goroutine to finish</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述程序里，会在接收完服务端返回后，才会关闭客户端。这里需要的是一个<strong>事件</strong>，使用的信道类型其实并不重要，所以使用了<code>struct&#123;&#125;</code>。实际应用中会使用<code>bool</code>或是<code>int</code>这样的简单类型。</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>借助上面提到的无缓冲区信道，可以实现多个goroutine之间的接续传递，也可以叫做<em>流水线</em>。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------+         +-----------+         +-----------+</span><br><span class=\"line\">|  Counter  |   --&gt;   |  Squarer  |   --&gt;   |  Printer  |</span><br><span class=\"line\">+-----------+         +-----------+         +-----------+</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    naturals: <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    squares: <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Counter</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; <span class=\"number\">100</span> ;x++ &#123;</span><br><span class=\"line\">            naturals &lt;- x</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(naturals)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"comment\">// Squarer</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">            x := &lt;-naturals</span><br><span class=\"line\">            squares &lt;- x * x</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        fmt.Println(&lt;-squares)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的流水线中，Counter在打印100个自然数后，会关闭信道。会有之前所说的一些特性：</p>\n<ul>\n<li>向关闭信道写入消息会panic</li>\n<li>从关闭信道读取信息会得到所有未发送的消息，再之后只能得到零值</li>\n<li>关闭信道不会影响其他goroutine执行</li>\n</ul>\n<p>所以在上面的程序中，Printer会继续打印0，只有Counter正常退出。Go中没有<em>直接</em>的获取信道是否关闭的方法，但是对于从信道中读取消息有第二个<code>ok</code>参数，为<code>false</code>时表示信道已关闭且<strong>读取完所有消息</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, ok := naturals</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的模板代码，go用<code>range</code>已封装好，不必重复书写。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> naturals &#123;</span><br><span class=\"line\">        squares &lt;- x * x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> squares &#123;</span><br><span class=\"line\">    fmt.Println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不是所有信道在不用后都要显式关闭</strong>，只在需要传达信道关闭信息时再手动<code>close</code>关闭。其余的信道会在gc过程中回收。但这不意味着文件读取也可以不显式关闭：文件的读写操作后一定要执行关闭操作。关闭一个已关闭的信道会panic，关闭<code>nil</code>的信道也是一样。</p>\n<h4 id=\"单向信道\"><a href=\"#单向信道\" class=\"headerlink\" title=\"单向信道\"></a>单向信道</h4><p>以上一小节为例，有三个goroutine，函数签名如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">(out <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">squarer</span><span class=\"params\">(out, in <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printer</span><span class=\"params\">(in <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>其中的信道入参分别用来<strong>接收</strong><em>或</em><strong>发送</strong>消息（绝大多数信道也是如此）。因此对于这两种信道的细分，go类型系统提供了<strong>单向信道类型</strong>，即只读或只写。同时提供了类型助记符：</p>\n<ul>\n<li><code>chan&lt;-</code>表示只读，只可读取消息，不可关闭</li>\n<li><code>&lt;-chan</code>表示只写，只可发送消息<strong>和关闭</strong></li>\n</ul>\n<p>违背只读只写上述规则，会在编译期间抛出错误。同时，<strong>双向信道可以隐式covert到单向信道，反之不可以</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    naturals := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    squares := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> counter(naturals)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> squarer(squares, naturals)</span><br><span class=\"line\">    printer(squares)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"缓冲信道（Buffered-Channel）\"><a href=\"#缓冲信道（Buffered-Channel）\" class=\"headerlink\" title=\"缓冲信道（Buffered Channel）\"></a>缓冲信道（Buffered Channel）</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以用队列类别缓冲信道，不同的是缓冲信道和goroutine是紧密相连的。</p>\n<ul>\n<li>写操作会在<strong>队列充满</strong>时阻塞</li>\n<li>读操作会在<strong>队列为空</strong>时阻塞</li>\n</ul>\n<p>通过<code>cap</code>和<code>len</code>可以查看缓冲信道的实时容量和长度。虽然缓冲信道可以按队列去理解，但是不要把它拿去当队列来用。那么和无缓冲信道相比，缓冲信道应用场景有什么不同呢？</p>\n<p>我们用流水线举例，流水线上的各道工序复杂程度有难有易，如果工作空间有限，每一道工序后都需要在下一道工序空闲时才能交付，一些简单工序就需要等待。这时就像<strong>无缓冲信道</strong>。假设工作空间宽裕，每道工序完成后，如果下游还未就绪，可以先放在空闲空间下，直接继续工作。这就是<strong>缓冲信道</strong>，多出来的工作空间即<strong>缓冲区</strong>，工序即<strong>goroutine</strong>。缓冲区可以弥补上下游工序工作效率的<em>些微差异</em>，缓冲区越大，可以容忍的效率差异就越大。如果工序间有明显差异，比如始终更快或更慢，此时增加缓冲区无法提供帮助，可以采用增加工序工人来提高工作效率，即<strong>在同一信道上使用更多goroutine</strong>。</p>\n<p>从上面的比喻，可以得出两种信道的区别：</p>\n<ul>\n<li>无缓冲信道重点在<strong>同步</strong>，它可以确保上下游goroutine的同步性</li>\n<li>缓冲信道则使用了队列来<strong>解耦</strong>上下游goroutine，使之不因为阻塞影响工作效率</li>\n</ul>\n<p>所以，我们假设有多个网站<em>镜像</em>来为网络请求提供服务，就可以使用缓冲信道，优先响应的可以直接提供服务，且在响应后可以继续工作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mirroredQuery</span><span class=\"params\">()</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    responses := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; responses &lt;- request(<span class=\"string\">&quot;asia.gopl.io&quot;</span>) &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; responses &lt;- request(<span class=\"string\">&quot;europe.gopl.io&quot;</span>) &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; responses &lt;- request(<span class=\"string\">&quot;america.gopl.io&quot;</span>) &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;-responses</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">request</span><span class=\"params\">(hostname <span class=\"type\">string</span>)</span></span> (res <span class=\"type\">string</span>) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并行循环\"><a href=\"#并行循环\" class=\"headerlink\" title=\"并行循环\"></a>并行循环</h3><p>有些任务可以拆分成等效的<strong>相互独立</strong>的小任务，这种情况也被称为“令人尴尬的并行”，是最简单的并行工作场景，它的工作量和并行数呈线性关系。我们假设有一个并行处理图片缩小的程序，能返回缩小后的文件总体积，并在合适的时候停止。在程序编写过程中，会遇到一些问题：</p>\n<ul>\n<li>有错误出现时，未关闭剩余信道，导致goroutine泄露，并造成程序不响应或内存耗尽</li>\n<li>for循环结合延迟执行代码时，循环描述体中的变量陷阱</li>\n<li>要支持任意长度的图片列表，不能写死缓存信道的容量</li>\n<li>无从直接得知goroutine是否执行完成</li>\n</ul>\n<p>最终得到下面的最终版本：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeThumbnails</span><span class=\"params\">(filenames &lt;-<span class=\"keyword\">chan</span> <span class=\"type\">string</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">    sizes := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int64</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">    <span class=\"keyword\">for</span> f := <span class=\"keyword\">range</span> filenames &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">// worker</span></span><br><span class=\"line\">        <span class=\"comment\">// avoid loop variable pitfall</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> runc(f <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录任务完成</span></span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            thumb, err := thumbnail.ImageFile(f)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Println(err)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            info, _ = os.Stat(thumb)</span><br><span class=\"line\">            sizes &lt;- info.Size()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// closer</span></span><br><span class=\"line\">    <span class=\"comment\">// 必须写成goroutine的形式</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        wg.Wait()</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(sizes)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> total <span class=\"type\">int64</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> size := <span class=\"keyword\">range</span> sizes &#123;</span><br><span class=\"line\">        total += size</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面程序里面有几点需要特别说明：</p>\n<ul>\n<li>第一个for循环会将信道输入的图片文件列表转成任务的列表，然后再启动一个goroutine负责关闭信道，最后从信道中拿出所有的大小加总返回</li>\n<li>关闭函数必须写成goroutine的形式。因为<code>sizes</code>的range结束依赖于<code>sizes</code>信道的关闭，同时<code>sizes</code>信道又必须<strong>等待</strong>所有图片处理任务执行完之后再关闭。等待和加总图片大小需要并行，所以需要一个新的goroutine去做</li>\n<li>任务完成借助<code>sync.WaitGroup</code>完成，<code>wg.Wait()</code>会阻塞直到<code>wg.Done()</code>将所有任务清零</li>\n</ul>\n<h3 id=\"样例：并发web爬虫\"><a href=\"#样例：并发web爬虫\" class=\"headerlink\" title=\"样例：并发web爬虫\"></a>样例：并发web爬虫</h3><p>将第5章中的<code>worklist</code>由<code>slice</code>改为<code>channel</code>，让爬取网页内容的过程并发执行即可得到一个并发的web爬虫。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">crawl</span><span class=\"params\">(url <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    fmt.Println(url)</span><br><span class=\"line\">    list, err := links.Extract(url)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Print(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 无缓冲信道，也可以使用缓冲信道</span></span><br><span class=\"line\">    worklist := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> []<span class=\"type\">string</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 初始化channel</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; worklist &lt;- os.Args[<span class=\"number\">1</span>:] &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    seen := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 从channel中读取</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> list := <span class=\"keyword\">range</span> worklist &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, link := <span class=\"keyword\">range</span> list &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> !seen[link] &#123;</span><br><span class=\"line\">                seen[link] = <span class=\"literal\">true</span></span><br><span class=\"line\">                <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(link <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">                    worklist &lt;- crawl(link)</span><br><span class=\"line\">                &#125;(link)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的程序在执行了一段时间后，会因为客观限制出现报错信息。这是因为程序<strong>过于并发</strong>了。由于硬件资源的限制，当并发数超过一定界限后，程序性能反而不如以前甚至会无法运行。因此需要手动限制并发量。这里有两种思路：</p>\n<ul>\n<li>通过限制发放许可证（token）的方式限制爬取goroutine是否执行，许可证数量有限，许可证用完后，阻止goroutine执行。当然作为信道的token，是在多个爬取goroutine间共享的。</li>\n<li>限制爬取goroutine总数，只创建固定个数的goroutine</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 信号量，占有表示被使用中</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tokens = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">crawl</span><span class=\"params\">(url)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    fmt.Println(url)</span><br><span class=\"line\">    token &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">    list, err := links.Extract(url)</span><br><span class=\"line\">    &lt;-tokens</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将上面代码<code>main</code>函数中的<code>worklist</code>延迟在for循环内赋值，使用<code>n</code>记录当前任务中的正在执行的任务数，可以实现在所有任务执行完成后退出程序。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> n <span class=\"type\">int</span></span><br><span class=\"line\">    n++</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    seen := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; n &lt; <span class=\"number\">0</span>; n-- &#123;</span><br><span class=\"line\">        list := &lt;-worklist</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, link := <span class=\"keyword\">range</span> list &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> !seen[link] &#123;</span><br><span class=\"line\">                seen[link] = <span class=\"literal\">true</span></span><br><span class=\"line\">                n++</span><br><span class=\"line\">                <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(link <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">                    worklist &lt;- crawl(link)</span><br><span class=\"line\">                &#125;(link)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"select实现多工\"><a href=\"#select实现多工\" class=\"headerlink\" title=\"select实现多工\"></a><code>select</code>实现多工</h3><p>在之前的例子里，从信道中读取&#x2F;写入值，会阻塞当前goroutine进度。如果需要同时接收两个信道的值，需要<code>select</code>语句块。<code>select</code>语句块使用类似<code>switch</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> &lt;- ch1:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> x := &lt;- ch2</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> ch3 &lt;- y:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每一个<code>case</code>可以是接收或是发送消息的语句，<code>select</code>语句在其中一个case发生后，才会继续（<code>select&#123;&#125;</code>会一直等待程序执行）。<code>default</code>可以指定没有任何一个case发生时的处理方式。</p>\n<p>原文中给出的<code>time.Tick</code>例子会返回一个channel，并以设定的时间间隔发送消息。但是，再不从channel读取信息后，会造成goroutine泄露。因此只在整个生命周期都需要时才会使用。倒计时这种场景下建议使用更复杂的方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ticker := time.NewTicker(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">&lt;- ticker.C</span><br><span class=\"line\">ticker.Stop()</span><br></pre></td></tr></table></figure>\n\n<p>对于一个nil信道的发送和接收会一直阻塞，select中的case也不会被选中。利用这个特性可以实现取消等功能。</p>\n<h3 id=\"并发目录遍历\"><a href=\"#并发目录遍历\" class=\"headerlink\" title=\"并发目录遍历\"></a>并发目录遍历</h3><p>借助<code>ioutil.ReadDir</code>可以实现遍历根文件夹下所有文件体积的功能。下面是一个纯单线程版本。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">walkDir</span><span class=\"params\">(dir <span class=\"type\">string</span>, fileSizes <span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> dirents(dir) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> entry.IsDir() &#123;</span><br><span class=\"line\">            subdir := filepath.Join(dir, entry.Name())</span><br><span class=\"line\">            walkDir(subdir, fileSizes)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fileSIzes &lt;- entry.Size()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dirents</span><span class=\"params\">(dir <span class=\"type\">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class=\"line\">    entries, err := ioutil.ReadDir(dir)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;du1: %v\\n&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entries</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的版本可以实现功能，但是速度很慢，而且不能实时显示进度。这里我们用<code>time.Ticker</code>定时打印进度，同时通过命令行参数<code>p</code>控制。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> progress = flag.Bool(<span class=\"string\">&quot;v&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;show progress&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tick &lt;-<span class=\"keyword\">chan</span> time.Time</span><br><span class=\"line\">    <span class=\"keyword\">if</span> *progress &#123;</span><br><span class=\"line\">        tick = time.Tick(<span class=\"number\">500</span> * time.Millisecond)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> nFiles, nBytes <span class=\"type\">int64</span></span><br><span class=\"line\">loop:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> size, ok := fileSizes:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> loop</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nFiles++</span><br><span class=\"line\">            nBytes += size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-tick:</span><br><span class=\"line\">            printDiskUsage(nFiles, nBytes)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printDiskUsage(nFiles, nBytes) <span class=\"comment\">// final print</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>if *progress</code>语句在没有传递<code>-p</code>参数时，不会为tick赋值，而nil的tick值会让select中永远不会进入这个case，从而不打印进度。</p>\n<p>在遍历根目录下的递归调用<code>walkDir</code>中，也可以使用goroutine，并通过<code>sync.WaitGroup</code>保证执行完成后关闭<code>fileSizes</code>信道。当然，无限制的创建goroutine会出现和上上小节一样的问题，所以也需要<em>信号量（semaphore）</em>，保证不至于创建过多goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sema = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dirents</span><span class=\"params\">(dir <span class=\"type\">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class=\"line\">    sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// 获取token</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; &lt;-sema &#125;() <span class=\"comment\">// 释放token</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取消\"><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h3><p>一样的，一个goroutine没有直接关闭另一个goroutine的办法。按照之前提到的<strong>通过信道传递消息</strong>的思路，但是一个信道只会被消费一次，我们这里的场景需要<strong>广播</strong>更合适。</p>\n<p>之前提到，一个被关闭的信道在传递完信道内的消息后，后续再从这个信道获取值，会立即返回一个零值。可以利用这个特性，在执行取消操作后，将信道关闭即可，可以写出下面这样的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cancelled</span> <span class=\"params\">()</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;- done:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在程序的<strong>瓶颈处</strong>，检查这个函数的返回值，一旦返回<code>true</code>则立即中止程序。比如，之前提到获取token的函数里。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dirents</span><span class=\"params\">(dir <span class=\"type\">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;: <span class=\"comment\">// acquire token</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-done:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; &lt;-sema &#125;()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按上面这种方式退出程序后，有可能出现goroutine还没有妥善关闭的情况，可以在调试时，程序的最后用<code>panic</code>打印系统信息，查看具体情况。</p>\n<h3 id=\"样例：聊天服务器\"><a href=\"#样例：聊天服务器\" class=\"headerlink\" title=\"样例：聊天服务器\"></a>样例：聊天服务器</h3><p>聊天服务器也是并发和各种信道常用的场景，它包括：</p>\n<ul>\n<li>用户的接入、退出</li>\n<li>用户信息的广播</li>\n<li>用户session的维护</li>\n</ul>\n<p>我们可以用一个信道表示一个接入的用户，在一个全局的文件中处理用户登入、登出，即信道的信息维护，这里可以用map表示，对于接收到的消息，像注册的所有信道逐个发送，即广播。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> client <span class=\"keyword\">chan</span>&lt;- <span class=\"type\">string</span> <span class=\"comment\">// 只写信道</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    entering = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> client)</span><br><span class=\"line\">    messages = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>)</span><br><span class=\"line\">    leaving = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> client)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">broadcaster</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    clients := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[client]<span class=\"type\">bool</span>) <span class=\"comment\">// 用户session维护</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> cli := &lt;-entering:</span><br><span class=\"line\">            clients[cli] = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> cli := &lt;-leaving:</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(clients, cli)</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(cli)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> msg := &lt;-messages:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> cli := <span class=\"keyword\">range</span> clients &#123;</span><br><span class=\"line\">                cli &lt;- msg</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，启动一个tcp服务器，单独启动一个goroutine负责上面的信道管理，另外对于每一个接入的连接，启动一个独立的goroutine处理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    listener, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8000&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> broadcaster()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        conn, err := listener.Accept()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Print(err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> handleConn(conn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在处理tcp连接的函数里，负责接入客户端，同时将连接中的内容写入到<code>messages</code>信道中，以便广播给其他客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleConn</span><span class=\"params\">(conn net.Conn)</span></span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> clientWriter(conn, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 唯一标识生成，也可以使用其他规则</span></span><br><span class=\"line\">    who := conn.RemoteAddr().String()</span><br><span class=\"line\">    ch &lt;- <span class=\"string\">&quot;You are &quot;</span> + who</span><br><span class=\"line\">    messages &lt;- who + <span class=\"string\">&quot; has arrived&quot;</span></span><br><span class=\"line\">    entering &lt;- ch</span><br><span class=\"line\"></span><br><span class=\"line\">    input := bufio.NewScanner(conn)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        messages &lt;- who + <span class=\"string\">&quot;: &quot;</span> + input.Text()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    leaving &lt;- ch</span><br><span class=\"line\">    messages &lt;- who + <span class=\"string\">&quot; has left&quot;</span></span><br><span class=\"line\">    conn.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">clientWriter</span><span class=\"params\">(conn net.Conn, ch <span class=\"keyword\">chan</span> <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> msg := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">        fmt.Fprintln(conn, msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的map没有使用lock操作，是因为它的读写都限制在了一个goroutine内，因此是<strong>并发安全</strong>的，其他并发使用的信道和<code>net.Conn</code>也是并发安全的。</p>\n<h2 id=\"并发和共享变量\"><a href=\"#并发和共享变量\" class=\"headerlink\" title=\"并发和共享变量\"></a>并发和共享变量</h2><p>使用信道在goroutine间沟通是一种并发的范式，其中也略过了一些关键而细小的问题，这些在后面这种并发编程模式中会经常讨论。</p>\n<h3 id=\"竞险（race-conditions）\"><a href=\"#竞险（race-conditions）\" class=\"headerlink\" title=\"竞险（race conditions）\"></a>竞险（race conditions）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> bank</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> balance <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    balance += amount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> balance &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面以银行为例，实际上给出了一个可以读写的变量。在串行执行场景下，不会有问题。在并发场景下，对<code>balance</code>读写的同时进行，就会造成一些问题。这种情况也叫<strong>数据争用（data race）</strong>，即<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。这种数据争用有时候还会带来未定义的行为。</p>\n<p>在使用共享变量的模式并发编程时，如果不小心处理，很容易遇到数据争用的情况。然而，绝大多数的数据争用都“来者不善”，以至于我们要留心发生数据争用的场景：<strong>有两个goroutine并发访问一个变量，且至少有一个是写操作</strong>。下面有三种方式去避免：</p>\n<ul>\n<li><strong>不要写变量</strong>，比如将变量初始化好之后，使之只读或不可变</li>\n<li><strong>避免在多个goroutine上操作变量</strong>，将操作限制在一个goroutine上，就像前一章中的broadcaster，这样的goroutine也叫做<em>调度者goroutine</em>。Go中有句箴言总结的很好：<strong>不要通过共享变量传递消息，通过传递消息来共享变量</strong>。这里的传递消息就是指通过信道发送和接收。当实在无法限制多个goroutine访问一个变量，也尽量限制访问，通过信道传递给其他goroutine，达到<strong>串行限制（serial confinement）</strong>的效果。</li>\n<li><strong>在同一时间仅允许一个goroutine访问变量</strong>，即后面会提到的<strong>互斥锁</strong></li>\n</ul>\n<h3 id=\"互斥锁（sync-Mutex）\"><a href=\"#互斥锁（sync-Mutex）\" class=\"headerlink\" title=\"互斥锁（sync.Mutex）\"></a>互斥锁（<code>sync.Mutex</code>）</h3><p>互斥锁和之前提到的信号量（counting semaphore）很类似，更像是一个容量为1的信号量，即<em>二进制信号量（binary semaphore）</em>。每次执行后续操作前，都需要从一个全局信道中获取token，</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    sema = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">1</span>)</span><br><span class=\"line\">    balance <span class=\"type\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// 占用token</span></span><br><span class=\"line\">    balance = balance + amount</span><br><span class=\"line\">    &lt;-sema <span class=\"comment\">// 释放token</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// 占用token</span></span><br><span class=\"line\">    b := balance</span><br><span class=\"line\">    &lt;-sema <span class=\"comment\">// 释放token</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将上面的信号量表示使用<code>sync.Mutex</code>替代就是互斥锁的使用方式：</p>\n<ul>\n<li><code>var sema = make(chan struct&#123;&#125;, 1)</code> &#x3D;&gt; <code>var mu sync.Mutex</code></li>\n<li><code>sema &lt;- struct&#123;&#125;&#123;&#125;</code> &#x3D;&gt; <code>mu.Lock()</code></li>\n<li><code>&lt;-sema</code> &#x3D;&gt; <code>mu.Unlock()</code></li>\n</ul>\n<p>通常来说，互斥锁使用的范围很小，这一区域也叫临界区（critical section），被mutex守护的共享变量会紧跟在<code>Lock</code>之后。在程序较长时，为了避免在所有返回处显式<code>Unlock</code>可以使用<code>defer</code>，这会稍微增加一些显式<code>Unlock</code>的成本，但会让代码更简洁。</p>\n<p>另外，互斥锁是不可重入的，即不能对一个已经上锁的共享变量上锁，这会导致死锁，因此确保互斥锁和其守护的变量不被导出。</p>\n<h3 id=\"读-x2F-写互斥锁（sync-RWMutex）\"><a href=\"#读-x2F-写互斥锁（sync-RWMutex）\" class=\"headerlink\" title=\"读&#x2F;写互斥锁（sync.RWMutex）\"></a>读&#x2F;写互斥锁（<code>sync.RWMutex</code>）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.RWMutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> balance <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mu.RUnlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> balance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sync.RWMutex</code>可以限制写操作，而允许多个读操作同时进行。<code>RLock</code>方法开启，<code>RUnlock</code>关闭互斥锁。注意，只在确定没有对共享变量写操作发生的时候使用<code>RLock</code>方法，我们不能简单的假设一个<strong>逻辑</strong>读操作，在背后没有注入写入缓存或更新计数器等行为。如果不确定，请使用完整的互斥锁。</p>\n<p>同时，<code>sync.RWMutex</code>只在大多数读操作在争用锁时会比较合适。其更复杂的实现，让它在其他场景下工作慢于普通的互斥锁。</p>\n<h3 id=\"内存同步\"><a href=\"#内存同步\" class=\"headerlink\" title=\"内存同步\"></a>内存同步</h3><p>上面提到的对于<code>Balance</code>这个只读的函数也使用的互斥锁或者信道来限制多个goroutine访问共享变量，其中一个明显的原因是：读取操作发生在写操作如<code>Withdraw</code>或<code>Deposit</code>中间时，也会造成问题。另一个不那么明显的原因是，类似互斥锁、信道这种同步操作也会同步内存。</p>\n<p>简单点说，在现代CPU架构中，多个处理器内很可能有缓存，每个goroutine对共享变量的修改很可能在多个缓存中，而对其他goroutine不可见，直到同步操作把缓存中的修改同步到主内存中，保证对所有goroutine可见且一致。</p>\n<p>同一个goroutine内部是串行稳定的，但goroutine之间无法保证顺序。还有一种<strong>错误</strong>认识，goroutine的代码会<strong>逐行交错</strong>（interleaving）执行。但在现代的CPU架构和编译器中，并不是这么实现的。总而言之，把对变量的使用限制在同一个goroutine内，对其他变量使用互斥锁。</p>\n<h3 id=\"懒初始化（sync-Once）\"><a href=\"#懒初始化（sync-Once）\" class=\"headerlink\" title=\"懒初始化（sync.Once）\"></a>懒初始化（<code>sync.Once</code>）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]image.Image</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadIcons</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化写操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"type\">string</span>)</span></span> image.Image &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> icons == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        loadIcons()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常来说，我们会推迟一个计算量比较大的初始化操作到使用时才进行，如上面<code>Icon</code>函数做的那样。很显然<code>Icon</code>函数不是并发安全的。在其中混有读写操作，且和外界共享icons变量。这时我们需要在初始化的时候对<code>loadIcons</code>函数加锁。加锁时要区分<code>icons</code>的是否初始化状态，可以对只读操作使用读&#x2F;写锁，再对写入操作使用互斥锁。像下面这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.RWMutex</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"type\">string</span>)</span></span> image.Image &#123;</span><br><span class=\"line\">    mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> icons == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        icon := icons[name]</span><br><span class=\"line\">        mu.RUnlock()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> icon</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    <span class=\"comment\">// 因为在Lock前，有短暂的Unlock的时间段，有可能会被其他goroutine初始化，因此需要再次判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> icons == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        loadIcons()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    icon := icons[name]</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> icon</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，上面就是一个只做一次的操作（通常是初始化操作），为了维护一个是否完成的bool值，额外增加了一些操作，较容易出错。go对这种情况提供了<code>sync.Once</code>支持，在<code>Do</code>方法中传入只执行的函数，这个互斥锁会在第一次执行时上锁并将对变量的改动同步到其他goroutine中，同时维护一个bool值，在后续的执行中，直接跳过这一步。重写之后的<code>Icon</code>变得简单了很多。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loadIconsOnce sync.Once</span><br><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]image.Image</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发安全</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"type\">string</span>)</span></span> image.Image &#123;</span><br><span class=\"line\">    loadIconsOnce.Do(loadIcons)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"竞险检测器\"><a href=\"#竞险检测器\" class=\"headerlink\" title=\"竞险检测器\"></a>竞险检测器</h3><p>很多时候goroutine访问共享变量导致的竞险并不那么容易发现和避免。Go的配套工具链提供了<code>-race</code>标志位用来检查程序中可能存在的竞险情况，在<code>go run</code>, <code>go build</code>, <code>go test</code>后添加都可以。它可以记录对共享变量所做的所有读写操作以及对应的goroutine，还有程序中由<code>sync</code>和信道触发的同步操作。竞险检测器在分析这些事件流的时候可以给出包含共享变量和对其读写goroutine报告。在绝大多数情况下已经足够你查问题了。</p>\n<p>竞险检测器只能报告程序覆盖到代码的竞险情况，所以尽量让测试覆盖到所有代码。竞险检查会稍微占用更多时间和内存，但是是可以接受的。</p>\n<h3 id=\"样例：并发无阻塞缓存\"><a href=\"#样例：并发无阻塞缓存\" class=\"headerlink\" title=\"样例：并发无阻塞缓存\"></a>样例：并发无阻塞缓存</h3><p>实现这么一个并发数据结构，大抵有两种构建思路：</p>\n<ul>\n<li>使用有锁的共享变量</li>\n<li>借助信道和通信实现串行化</li>\n</ul>\n<p>不同场景下，他们实现的复杂度可能会稍有不同。</p>\n<h3 id=\"goroutine和线程\"><a href=\"#goroutine和线程\" class=\"headerlink\" title=\"goroutine和线程\"></a>goroutine和线程</h3><p>goroutine和线程有些很多小地方上的区别，这些区别让goroutine和线程有着较大区别。</p>\n<ul>\n<li>线程的栈一般是固定的（通常是2MB），goroutine的栈是灵活的，从较少的大小开始（通常是2KB），可以扩大和缩小</li>\n<li>goroutine有自己的调度机制（m:n调度），把m个goroutine复用或调度到n的操作系统的线程</li>\n<li><code>GOMAXPROCS</code>环境变量决定了Go代码可以使用多少个操作系统线程</li>\n</ul>\n<p>最后，goroutine没有其他操作系统或编程语言中用来支持多线程的为每个线程添加一个唯一标识的设计。这个是特别设计的，用来避免线程池的滥用。Go更推荐只由入参显式决定函数表现的风格，避免让函数收到执行线程的影响。</p>\n<h2 id=\"包和Go工具\"><a href=\"#包和Go工具\" class=\"headerlink\" title=\"包和Go工具\"></a>包和Go工具</h2><p>如今中小型的程序可能会包含10000个函数，其中绝大多数来自其他人的包。包可以将程序中相互关联的特性整理到独立的单元中，进而在组织或社区中重用、分享。包名和导出的类型、变量、函数名都应简短清晰，Go使用首字母大小写控制可见性，从而掩盖实现细节，保证稳定性或实现互斥锁。</p>\n<p>Go的构建速度算是比较快的。主要有3个原因：</p>\n<ul>\n<li>Go在每个文件开头都显式列出了引入的文件，无需读取整个文件</li>\n<li>Go中没有引入是一个有向无环图，因此可以并行编译</li>\n<li>编译好的Go包的目标文件会包含自身和<strong>自身的依赖</strong>，每一次的import只需读取一遍目标文件即可</li>\n</ul>\n<h3 id=\"import路径\"><a href=\"#import路径\" class=\"headerlink\" title=\"import路径\"></a>import路径</h3><p>Go的语言规范并没有规定import路径，路径的实现是由相关工具决定的。但是为了避免冲突，除了标准包以外的包，都需要以域名或组织名开头，如<code>encoding/json</code>，<code>golang.org/x/net/html</code>。</p>\n<h3 id=\"声明和import\"><a href=\"#声明和import\" class=\"headerlink\" title=\"声明和import\"></a>声明和import</h3><p>每一个Go文件的开头，都需要以<code>package xxx</code>的形式标识包名。通常，包名是import路径的最后一段。但是有3个例外情况：</p>\n<ul>\n<li><code>main</code>包名表示告诉<code>go build</code>需要构建一个可执行文件</li>\n<li>目录下包含<code>_test</code>后缀文件名的，在执行<code>go test</code>时会额外被构建用于测试的包</li>\n<li>有的报名后面会跟版本号，这个时候以没有版本号的作为包名</li>\n</ul>\n<p>在import时，如果引入包较多时，可以用圆括号列表形式引入。列表间可以用空行隔开，通常用来分组域名，这个在按照字母顺序排序import时有用——排序会在每组内进行。如果不同域内的包名一样，如<code>math/rand</code>和<code>crypto/rand</code>，可以用重命名引入（renaming import）。像下面这样</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;crypto/rand&quot;</span></span><br><span class=\"line\">    mrand <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>这种重命名只在当前文件内有效。重命名通常可以避免包名冲突，或者简化一些复杂的包名，在简化时，注意对同样的原名，使用同样的缩写名。<code>go build</code>会报告编译中循环依赖。</p>\n<h3 id=\"空导入\"><a href=\"#空导入\" class=\"headerlink\" title=\"空导入\"></a>空导入</h3><p>有的时候，我们的引入的<strong>目的在包的副作用</strong>，如其中全局变量的初始化或<code>init</code>函数的执行。这个时候可以用空白标识符<code>_</code>进行重命名即可，如<code>import _ &quot;image/png&quot;</code>。这种即空导入。</p>\n<p>在书中例子里，对<code>image/png</code>的空导入，实现了png解码相关配置的全局注册（<code>image.RegisterFormat</code>），从而可以解码png图片。类似的思路在<code>database/sql</code>包中也有用到。</p>\n<h3 id=\"命名-1\"><a href=\"#命名-1\" class=\"headerlink\" title=\"命名\"></a>命名</h3><p>对于包名，有下面一些建议的命名规范：</p>\n<ul>\n<li>使用简短明了的包名</li>\n<li>使用有描述性且没有歧义的名字，且最好不要使用经常会用来命名局部变量的包名，如<code>path</code></li>\n<li>包名通常使用单数形式，需要和其他情况区分开时，如<code>strings</code>，<code>bytes</code></li>\n<li>避免使用具有隐藏含义的名称，如<code>temp</code></li>\n</ul>\n<p>对于包中的成员名：</p>\n<ul>\n<li>考虑和包名一起构成完整的含义，不需要包含包名，如<code>flat.Int</code>，<code>http.Get</code></li>\n<li>有的包名表示一种类型，在内部会有对应的类型定义和<code>New</code>操作</li>\n<li>即使对于有着很多成员的包，其最关键的几个方法仍然是最简单的</li>\n</ul>\n<h3 id=\"Go工具\"><a href=\"#Go工具\" class=\"headerlink\" title=\"Go工具\"></a>Go工具</h3><p>Go工具像一个瑞士军刀，它的各个子命令提供了诸如包管理器（<code>go get</code>）、构建系统（<code>go build</code>, <code>go run</code>, <code>go install</code>）、测试驱动（<code>go test</code>）等等。</p>\n<h4 id=\"工作区组织\"><a href=\"#工作区组织\" class=\"headerlink\" title=\"工作区组织\"></a>工作区组织</h4><p>日常经常使用的是<code>GOPATH</code>环境变量，用于说明当前工作区的根路径。<code>GOROOT</code>表示go源码的根路径，<code>GOOS</code>表示操作系统，<code>GOARCH</code>表示处理器架构。更多配置可以执行<code>go env</code>查看。</p>\n<h4 id=\"包下载\"><a href=\"#包下载\" class=\"headerlink\" title=\"包下载\"></a>包下载</h4><p>执行<code>go get</code>下载，下载时不仅包含源码的拷贝，还包含源码的版本控制信息。Go工具会自动判断流行的代码托管方式。对于不那么有名的托管网站，需要自己显式说明保本控制的协议，可以通过<code>go help importpath</code>查看细节。</p>\n<p>Go工具在访问包的导入路径域名如<code>golang.org</code>时，会试图从网页的<code>&lt;meta&gt;</code>标签中寻找类似下面这样指示目标路径的信息。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;go-import&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;golang.org/x/net git https://go.googlesource.com/net&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，执行<code>go get -u</code>时会获取所有包的最新版本，在需要锁定版本时比较麻烦，可以借助<em>vendor</em>解决，在<code>go help gopath</code>中有介绍。</p>\n<h4 id=\"包构建\"><a href=\"#包构建\" class=\"headerlink\" title=\"包构建\"></a>包构建</h4><ul>\n<li>使用<code>go build</code>构建时，对于库类型代码只会检查错误，对于main包，则会构建可执行文件</li>\n<li><strong>一个目录包含一个包</strong>，因此导入时，要么指定导入路径，要么指定相对路径，否则会以当前目录为基础构建。构建得到的可执行文件名称是go文件的前缀。</li>\n<li><code>go build</code>构建时，会丢弃已编译的代码，只保留可执行文件。</li>\n<li><code>go install</code>构建时，会保留已编译的代码，编译好的包位于<code>$GOPATH/pkg</code>下，编译得到的执行文件位于<code>$GOPATH/bin</code>下。再之后，<code>go build</code>和<code>go install</code>不会编译未被改变的包或命令，从而让执行过程更快。<code>go build -i</code>可以安装项目的所有依赖</li>\n<li>修改<code>GOOS</code>和<code>GOARCH</code>可以改变包目标的平台和架构，默认只会针对当前平台和架构打包。</li>\n<li>文件末尾以诸如<code>_linux.go</code>，<code>axm_amd64.s</code>结尾时，只会在打对应平台包的时候才会编译此文件。另外还可以以<code>// +build linux darwin</code>的注释形式做到更好的细粒度。<code>// +build ignore</code>表示编译时跳过该文件。</li>\n</ul>\n<p><code>go doc go/build</code>下有更多介绍。</p>\n<h4 id=\"包文档\"><a href=\"#包文档\" class=\"headerlink\" title=\"包文档\"></a>包文档</h4><p>Go建议在导出的包成员和包声明前使用描述用途和用法的注释。注释宜简单且清晰，对于大段的注释，使用同名的文档文件（通常名为<code>doc.go</code>）进行说明。如果行为本身就足够明显，就不需要写注释。</p>\n<p><code>go doc</code>命令可以查看包、包成员、包方法的文档。还有个很相似的命令<code>godoc</code>，它可以托管一个能够查看当前工作目录下文档的服务器。</p>\n<h4 id=\"内部包\"><a href=\"#内部包\" class=\"headerlink\" title=\"内部包\"></a>内部包</h4><p>有些包可能希望导出只对个别信任的包可见，对于这种包，导入路径中需要包含<code>internal</code>。这些内部包只对<code>internal</code>的父目录下文件可见，如<code>net/http/internal/chunked</code>对<code>net/http/httputil</code>可见，但对<code>net/url</code>不可见。</p>\n<h4 id=\"查询包\"><a href=\"#查询包\" class=\"headerlink\" title=\"查询包\"></a>查询包</h4><p><code>go list</code>工具可以查询包的导入路径。使用<code>...</code>通配符可以查到更多内容。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go list github.com/go-sql-driver/mysql</span><br><span class=\"line\">go list ...</span><br><span class=\"line\">go list gopl.io/ch3/...</span><br><span class=\"line\">go list ...xml...</span><br></pre></td></tr></table></figure>\n\n<p>结合<code>-json</code>可以打印json格式的包详情，或者结合<code>-f</code>加上<code>text/template</code>语法打印特定格式的字符串。</p>\n<p>更多使用方式查看<code>go help list</code>。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>同行评审和测试是两种避免代码错误的方式。Go尽量让写自动化测试代码不是一件很困难的事。在Go中进行测试，你需要了解的只不过是普通的Go语法规范和一些约定而已。</p>\n<h3 id=\"go-test工具\"><a href=\"#go-test工具\" class=\"headerlink\" title=\"go test工具\"></a><code>go test</code>工具</h3><p>Go的测试都借助<code>go test</code>完成。所有和测试相关的文件必须以<code>_test.go</code>结尾，这些文件不会在打包时包括进去，只会在运行测试时运行。在文件中有三类函数会被特殊处理：</p>\n<ul>\n<li>测试函数：必须以<code>Test</code>开头，表示检测一些逻辑的正确性，运行后会给出<code>PASS</code>或<code>FAIL</code></li>\n<li>基准测试函数：必须以<code>Benchmark</code>开头，表示测量一些操作的性能，运行后会给出运行时间</li>\n<li>样例函数：必须以<code>Example</code>开头，表示提供一些格式化的文档</li>\n</ul>\n<p><code>go test</code>运行完成时，会生成一个临时的<code>main</code>包，构建并运行，最后给出结果并清理现场</p>\n<h3 id=\"测试函数\"><a href=\"#测试函数\" class=\"headerlink\" title=\"测试函数\"></a>测试函数</h3><p>测试函数均以<code>Test</code>开头，函数入参是test包提供的用来打印错误或其他日志的工具集。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSin</span><span class=\"params\">(t *test.T)</span></span> &#123; <span class=\"comment\">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着就像写普通Go代码一样去执行case就行了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> word</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPalindrome</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !IsPalindrome(<span class=\"string\">&quot;kayak&quot;</span>) &#123;</span><br><span class=\"line\">        t.Error(<span class=\"string\">`IsPalindrome(&quot;kayak&quot;) = false`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行时，结合<code>-v</code>标记可以打印详细信息，结合<code>-run</code>标识可以只运行符合指定模式的case。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">test</span> -v -run=<span class=\"string\">&quot;French|Canal&quot;</span> </span><br></pre></td></tr></table></figure>\n\n<p>case之间的代码相似性很高，建议用配置的方式批量运行case，减少模板代码书写。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPalindrome</span><span class=\"params\">(t *tesing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tests = []<span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">        input <span class=\"type\">string</span></span><br><span class=\"line\">        want <span class=\"type\">bool</span></span><br><span class=\"line\">    &#125; &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;ab&quot;</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;A man, a plan, a canal: Panama&quot;</span>: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, test := <span class=\"keyword\">range</span> tests &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class=\"line\">            t.Errorf(<span class=\"string\">&quot;IsPalindrome(%q) = %v&quot;</span>, test.input, got)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>go test</code>在运行测试时，每个case的错误不会中断其他case的执行，也不会panic，来保证一次运行能获得所有case的执行结果。对于需要中断的情况，可以使用<code>t.Fatal</code>或者<code>t.Fatalf</code>。</p>\n<h4 id=\"随机化测试\"><a href=\"#随机化测试\" class=\"headerlink\" title=\"随机化测试\"></a>随机化测试</h4><p>不同于上面提到的选择特定case进行测试。随机化测试可以覆盖更广的范围。在验证随机化测试是否符合预期上，有两种思路：</p>\n<ul>\n<li>使用另外一种方式给出结果，对比两种方式的结果是否相同</li>\n<li>使用固定的模式生成随机化case，使其预期结果可以事先推导出来</li>\n</ul>\n<p>另外，在随机化测试时还要考虑能否再次复现问题case的情况。</p>\n<h4 id=\"测试一个命令\"><a href=\"#测试一个命令\" class=\"headerlink\" title=\"测试一个命令\"></a>测试一个命令</h4><p>对于<code>go test</code>而言，<code>main</code>包只是一个库，可以将<code>main</code>函数中需要测试的逻辑抽离成函数，在<code>*_test.go</code>中测试即可。最好将<code>log.Fatal</code>或者<code>os.Exit</code>这种中断程序执行的语句放在<code>main</code>函数中，避免中断测试流程。</p>\n<h4 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h4><p>白盒测试即在对测试对象有清楚认识的情形下进行测试；黑盒测试则相反，更站在客户端的角度去测试包。在白盒测试下，我们可以修改原先包的一些实现方式，使之更易被测试。比如，可以将其中会有副作用的部分，如发邮件、写数据库、发短信的函数覆盖。（类似mock的思路）</p>\n<p>但是，在覆盖后，别忘了还原回去，避免影响后续测试。类似下面这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCheckQuotaNotificationUser</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    saved := notifyUser</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; notifyUser = saved &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    notifyUser = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(user, msg <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">        notifiedUser, notifiedMsg = user, msg</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种覆盖方式正常情况下不会有风险，因为<code>go test</code>通常不会并行运行多个测试。</p>\n<h4 id=\"外部测试包\"><a href=\"#外部测试包\" class=\"headerlink\" title=\"外部测试包\"></a>外部测试包</h4><p>上面提到的都是直接在包下新建<code>*_test.go</code>文件的方式进行测试。有些情况下，如果测试文件内需要引用更高层包，会产生循环引用，这是上一章提到不允许的。这时可以定义为外部包。如：</p>\n<p><code>net/url</code>下的测试文件导入了<code>net/http</code>包，而<code>net/http</code>包中又导入了<code>net/url</code>。这个时候在<code>net/url</code>下的测试文件使用<code>package url_test</code>声明，表示是另一个包<code>net/url_test</code>。然后，通过导入<code>net/url</code>和<code>net/http</code>的方式进行测试。就可以避免循环引用。</p>\n<p>可以通过<code>go list -f</code>指定<code>.GoFiles</code>，<code>.TestGoFiles</code>和<code>.XTestGoFiles</code>分别查看包中的源文件、测试文件和外部测试包文件。</p>\n<p>然而，外部测试包并不能访问到包内对外不可见的变量或函数。这个时候，可以在包内创建一个后门测试文件，用于导出一些内部变量或函数对外部包测试可见，通常命名为<code>export_test.go</code>。这类文件内不包含实际的测试。如<code>fmt</code>包下的<code>export_test.go</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> IsSpace = isSpace</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"写高效的测试\"><a href=\"#写高效的测试\" class=\"headerlink\" title=\"写高效的测试\"></a>写高效的测试</h4><p>Go在设计上和其他很多语言不同，并不包含一个大而全的测试框架，也没有创建、清除操作，和常用的断言、判断方法等。Go认为写case是作者自己的事，而且就像写普通的程序一样，不要有死记硬背和长篇大论，只需简明扼要地表达测试意图。</p>\n<p>在写测试代码时，避免过早抽象，先想着把功能实现，然后再想怎么通过抽象减少重复和复杂度。</p>\n<h4 id=\"避免“脆弱”的测试\"><a href=\"#避免“脆弱”的测试\" class=\"headerlink\" title=\"避免“脆弱”的测试\"></a>避免“脆弱”的测试</h4><p>有两种应用：一种是真正bug很多的（buggy），另一种是合理改动也过不了case的（brittle）。而这里过不了case可能只是因为判断逻辑写的不够宽容，死抠细节导致很容易过时。避免这种情况一个很直接的办法是只检查你关心的特性，使用更简单和时间稳定的方式检查，如不要依赖字符串匹配。去检查本质。</p>\n<h3 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h3><blockquote>\n<p>Testing shows the presence, not the absence of bugs —— Edsger Dijkstra</p>\n</blockquote>\n<p>覆盖率一定程度上能对测试的覆盖程度有启发性的指示作用。使用<code>go test -coverprofile</code>可以指定覆盖率数据输出，如果不需要输出，只看摘要，可以只用<code>go test -cover</code>。使用<code>go tool cover</code>可以显示覆盖率使用介绍。</p>\n<p>最后要说明的是，被覆盖到的代码并不是没有bug，测试是一种<strong>务实</strong>的努力。它是在写测试代价和失败代价的中间的一个折中。</p>\n<h3 id=\"性能测试函数\"><a href=\"#性能测试函数\" class=\"headerlink\" title=\"性能测试函数\"></a>性能测试函数</h3><p>这类函数都以<code>Benchmark</code>开头，和测试函数类似，函数入参是<code>*testing.B</code>类型的变量。默认情况下，不会执行任何性能测试，需要指定<code>-bench</code>值，去匹配对应函数执行，“<code>.</code>”表示匹配所有。如<code>go test -bench=.</code>性能测试函数写法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">BenchmarkIsPalindrome</span><span class=\"params\">(b *testing.B)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; b.N; i++ &#123;</span><br><span class=\"line\">        IsPalindrome(<span class=\"string\">&quot;A man, a plan, a canal: Panama&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之所以需要自己在基准测试函数中写循环，而不集成在测试驱动中，是避免一些一次性操作影响执行时间测量。<code>-benchmem</code>标识会显示内存分配的使用情况。性能测试函数可以用来对比两种策略或算法的相对时间优劣，以及通过调整循环次数，整体上考察代码设计。</p>\n<h3 id=\"性能侧写（Profilling）\"><a href=\"#性能侧写（Profilling）\" class=\"headerlink\" title=\"性能侧写（Profilling）\"></a>性能侧写（Profilling）</h3><p>性能测试函数能帮你发现整体的性能好坏，但不能告诉你哪里做得不够好。</p>\n<p>Knuth曾说过“不要过早优化”，然而结合上下文的原话的意思则是，寻找性能优化点并不那么容易，程序员们在写需求前浪费了大量时间在寻找优化点上，先把事情做出来，不要杞人忧天过早优化。但是优秀的程序员会努力找到优化点并改善之。</p>\n<p>寻找关键点的方式就叫<em>profiling</em>。profile通过采样的方式给出占用时间、资源最多的对象，从而可以对应去优化。Go提供3种profile</p>\n<ul>\n<li>CPU profile，标记占用CPU时间最长的函数</li>\n<li>heap profile，标记分配内存最多的声明</li>\n<li>blocking profile，标记阻塞goroutine时间最久的操作</li>\n</ul>\n<p>对应在<code>go test</code>上的标识为<code>-cpuprofile</code>，<code>-memprofile</code>，<code>-blockprofile</code>。借助<code>go tool pprof</code>可以打印侧写数据，以及可视化数据。</p>\n<h3 id=\"样例函数\"><a href=\"#样例函数\" class=\"headerlink\" title=\"样例函数\"></a>样例函数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ExampleIsPalindrome</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(IsPalindrome(<span class=\"string\">&quot;A man, a plan, a canal: Panama&quot;</span>))</span><br><span class=\"line\">    fmt.Println(IsPalindrome(<span class=\"string\">&quot;palindrome&quot;</span>))</span><br><span class=\"line\">    <span class=\"comment\">// Output:</span></span><br><span class=\"line\">    <span class=\"comment\">// true</span></span><br><span class=\"line\">    <span class=\"comment\">// false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后一种会被<code>go test</code>特殊处理的是样例函数，这类函数以<code>Example</code>开头，并没有入参，也没有返回。它的作用主要有以下3点：</p>\n<ul>\n<li>文档记录，且更能传达意图，同时由于样例函数是实际的Go代码，对比文档，随着代码演化，不会有过期风险。命名单纯叫<code>Example</code>的函数作为整个包的样例函数。</li>\n<li>函数最火包含<code>// Output:</code>注释的话，<code>go test</code>会检查标准输出是否能匹配注释中的输出</li>\n<li>在<code>godoc</code>中可以作为playground，提供给用户动态编辑、运行的功能</li>\n</ul>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><p>反射能在<strong>运行时</strong>不知道变量类型情况下去修改和查询变量值。反射还能让我们将类型作为第一成员的值来使用。类似<code>fmt.Sprintf</code>和<code>text/template</code>中就有用到这个特性</p>\n<h3 id=\"reflect-Type和reflect-Value\"><a href=\"#reflect-Type和reflect-Value\" class=\"headerlink\" title=\"reflect.Type和reflect.Value\"></a><code>reflect.Type</code>和<code>reflect.Value</code></h3><p><code>reflect.Type</code>和<code>reflect.Value</code>分别表示变量的类型和值。其中类型通过<code>reflect.TypeOf</code>得到，得到的<code>reflect.Type</code>可以保存任何类型值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := reflect.TypeOf(<span class=\"number\">3</span>) <span class=\"comment\">// a reflect.Type</span></span><br><span class=\"line\">fmt.Println(t.String()) <span class=\"comment\">// &quot;int&quot;</span></span><br><span class=\"line\">fmt.Println(t) <span class=\"comment\">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>返回的类型总是interface的动态类型，所以总是确切类型。</p>\n<p><code>reflect.ValueOf</code>可以得到任意类型的变量值。返回的<code>reflect.Value</code>满足<code>fmt.Stringer</code>接口，不过打印出来的是变量类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v := reflect.ValueOf(<span class=\"number\">3</span>) <span class=\"comment\">// a reflect.Value</span></span><br><span class=\"line\">fmt.Println(v) <span class=\"comment\">// &quot;3&quot;</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, v) <span class=\"comment\">// &quot;3&quot;</span></span><br><span class=\"line\">fmt.Println(v.String()) <span class=\"comment\">// &quot;&lt;int Value&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>reflect.Value.Interface</code>方法返回一个保存相同值的<code>interface&#123;&#125;</code>类型。它和<code>reflect.Value</code>不同在于，一个<code>interface&#123;&#125;</code>类型的变量掩盖了外部表现和内部实现细节，因此无从对其操作。&#96;&#96;reflect.Value<code>的</code>Kind&#96;方法可以返回类型的底层表示方法，因此使用时，可以只关心Go中定义的类型。</p>\n<h3 id=\"递归值输出函数Display\"><a href=\"#递归值输出函数Display\" class=\"headerlink\" title=\"递归值输出函数Display\"></a>递归值输出函数<code>Display</code></h3><p>利用上面提到的<code>Kind</code>方法，可以实现递归打印任意类型值的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">display</span><span class=\"params\">(path <span class=\"type\">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> v.Kind()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Invalid:</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s = invalid\\n&quot;</span>, path)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Slice, reflect.Array:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class=\"line\">            display(fmt.Sprintf(<span class=\"string\">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Struct:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">            fieldPath := fmt.Sprintf(<span class=\"string\">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)</span><br><span class=\"line\">            display(fieldPath, v.Field(i))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Map:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, key := <span class=\"keyword\">range</span> v.MapKeys() &#123;</span><br><span class=\"line\">            display(fmt.Sprintf(<span class=\"string\">&quot;%s[%s]&quot;</span>, path, formatAtom(key), v.MapIndex(key)))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Ptr:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v.IsNil() &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%s = nil\\n&quot;</span>, path)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            display(fmt.Sprintf(<span class=\"string\">&quot;(*%s)&quot;</span>, path), v.Elem())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> reflect.Interface:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v.IsNil() &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%s = nil\\n&quot;</span>, path)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%s.type = %s\\n&quot;</span>, path, v.Elem().Type())</span><br><span class=\"line\">            display(path+<span class=\"string\">&quot;.value&quot;</span>, v.Elem())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"comment\">// 基础类型、信道、函数</span></span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s = %s\\n&quot;</span>, path, formatAtom(v))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面用到了许多<code>reflect.Value</code>的方法，不是所有的都安全：</p>\n<ul>\n<li><code>v.Index()</code>和<code>v.Len()</code>类似<code>len()</code>和<code>[i]</code>下标取值</li>\n<li><code>v.NumbField()</code>返回结构体中的字段数目，<code>v.Field(i)</code>则返回第i位的<code>reflect.Value</code>类型值</li>\n<li><code>v.MapKeys()</code>返回无序的map key</li>\n<li><code>v.IsNil()</code>和<code>v.Elem()</code>分别判断是否为空和获取值</li>\n</ul>\n<p>上述方法在遇到有环的数据结构时，会无限打印，可以借助下一章里的<code>unsafe</code>包解决。</p>\n<h3 id=\"使用reflect-Value设置变量\"><a href=\"#使用reflect-Value设置变量\" class=\"headerlink\" title=\"使用reflect.Value设置变量\"></a>使用<code>reflect.Value</code>设置变量</h3><p>Go中的变量都是有地址的，可以通过这个地址去修改变量的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">2</span></span><br><span class=\"line\">a := reflect.ValueOf(<span class=\"number\">2</span>)</span><br><span class=\"line\">b := reflect.ValueOf(x)</span><br><span class=\"line\">c := reflect.ValueOf(&amp;x)</span><br><span class=\"line\">d := c.Elem() <span class=\"comment\">// variable</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>d</code>即变量<code>x</code>。借助这个方式我们可以用<code>Addr()</code>获取地址，用<code>Interface()</code>获取<code>interface&#123;&#125;</code>类型的值，再使用类型断言转成具体的变量类型。像下面这样。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">px := d.Addr().Interface().(*<span class=\"type\">int</span>)</span><br><span class=\"line\">*px = <span class=\"number\">3</span></span><br><span class=\"line\">fmt.Println(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>又或者，可以通过<code>Set</code>方法设置一个<code>reflect.Value</code>。针对特定类型，还有<code>SetInt</code>、<code>SetUint</code>、<code>SetString</code>这样的方法。注意，这些方法只使用在特定类型上，对于<code>interface&#123;&#125;</code>或其他类型使用，会引起panic。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d.Set(reflect.ValueOf(<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">ry := reflect.ValueOf(&amp;y).Elem()</span><br><span class=\"line\">ry.SetInt(<span class=\"number\">2</span>) <span class=\"comment\">// panic: SetInt called on interface Value</span></span><br><span class=\"line\">ry.SetInt(reflect.Value(<span class=\"number\">3</span>)) <span class=\"comment\">// OK, y = int(3)</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，反射不能更新那些没有对外导出的结构体字段，尽管这些字段可以在发射中读取到。<code>CanSet()</code>可以判断一个<code>reflect.Value</code>是否可以修改，类似的，<code>CanAddr()</code>可以判断一个<code>reflect.Value</code>是否可以获取到地址。</p>\n<p>利用上面的特性，可以实现encoding&#x2F;json中类似的解析JSON字符串的效果。</p>\n<h3 id=\"访问结构体的field-tag\"><a href=\"#访问结构体的field-tag\" class=\"headerlink\" title=\"访问结构体的field tag\"></a>访问结构体的field tag</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Labels []<span class=\"type\">string</span> <span class=\"string\">`http:&quot;l&quot;`</span></span><br><span class=\"line\">    MaxResults <span class=\"type\">int</span> <span class=\"string\">`http:&quot;max&quot;`</span></span><br><span class=\"line\">    Exact <span class=\"type\">bool</span> <span class=\"string\">`http:&quot;x&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在JSON一节提到，可以在结构体后使用<em>field tag</em>作为JSON解析过程中的metadata。实际上，除了<code>json</code>还可以设置其他tag。这个tag也可以通过反射特性拿到。</p>\n<p><code>reflect.Type</code>的<code>Field()</code>方法可以返回一个<code>reflect.StructField</code>类型，其中包含了字段名、字段类型以及可选的标签。其中<code>Tag</code>字段即field tag对应的字符串，它的<code>Get</code>方法可以返回特定标识后的标签值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unpack</span><span class=\"params\">(req *http.Request, ptr <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := req.ParseForm(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fields := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]reflect.Value)</span><br><span class=\"line\">    v := reflect.ValueOf(ptr).Elem()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">        fieldInfo := v.Type().Field(i) <span class=\"comment\">// reflect.StructField类型</span></span><br><span class=\"line\">        tag := fieldInfo.Tag <span class=\"comment\">// reflect.StructTag类型</span></span><br><span class=\"line\">        name := tag.Get(<span class=\"string\">&quot;http&quot;</span>) <span class=\"comment\">// 获取http标识</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">            name = strings.ToLower(fieldInfo.Name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        field[name] = v.Field(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"展示类型的方法\"><a href=\"#展示类型的方法\" class=\"headerlink\" title=\"展示类型的方法\"></a>展示类型的方法</h3><p><code>reflect.Type</code>和<code>reflect.Value</code>都有一个<code>Method()</code>方法。<code>reflect.Type</code>中的方法返回<code>reflect.Method</code>实例，结构体中包含方法名和方法类型。<code>reflect.Value</code>中的<code>Method()</code>方法则返回一个<code>reflect.Value</code>类型，即一个绑定到receiver上的方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Print</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    v := reflect.ValueOf(x)</span><br><span class=\"line\">    t := v.Type()</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;type %s\\n&quot;</span>, t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">        methType := v.Method(i).Type()</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;func (%s) %s%s\\n&quot;</span>, t, t.Method(i).Name, strings.TrimPrefix(methType.String(), <span class=\"string\">&quot;func&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些忠告-1\"><a href=\"#一些忠告-1\" class=\"headerlink\" title=\"一些忠告\"></a>一些忠告</h3><p>反射在规范的类型系统外，引入了更高自由度和编程的灵活性，但同时也带来了弱类型解释型语言（没错，JS就是你）的弊病：编译期问题会变成运行时问题、代码可读性变差、性能更差。</p>\n<p>反射虽然提供了很强大的功能，但是失去了类型的保护，需要额外处理类型的边界case，否则很容易在运行时出现panic。而这些在使用特定类型时会在编译期就被发现。因此，在使用时，建议将包中使用反射的部分完全封装在内，不对外暴露，同时做一些额外的动态检查。同时，在出错时，给出类型上更友好的提示。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%d %s\\n&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">42</span>) <span class=\"comment\">// &quot;%!d(string=hello) %!s(int=42)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>interface&#123;&#125;</code>类型和大量出现的反射代码会让代码安逸理解，需要辅以更加完善的文档和注释来解释。</p>\n<p>最后，基于反射的函数执行速度比普通基于特定类型的函数慢至少一两个级别。因此，尽量不要在代码执行的关键路径上使用反射实现，类似测试代码这种小数据量和执行覆盖频率的代码就可以使用。</p>\n<h2 id=\"低阶特性\"><a href=\"#低阶特性\" class=\"headerlink\" title=\"低阶特性\"></a>低阶特性</h2><p>Go已经尽量掩盖了它在底层的实现，用来避免出现难以调试的神秘问题。但在有些时候，比如为了追求性能，或者希望和操作系统底层交互，可能希望绕开这个限制。这一章的内容介绍的<code>unsafe</code>包提供了这么一个窗口，<code>cgo</code>工具可以将创建C库和Go的绑定关系。</p>\n<h3 id=\"unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof\"><a href=\"#unsafe-Sizeof，unsafe-Alignof和unsafe-Offsetof\" class=\"headerlink\" title=\"unsafe.Sizeof，unsafe.Alignof和unsafe.Offsetof\"></a><code>unsafe.Sizeof</code>，<code>unsafe.Alignof</code>和<code>unsafe.Offsetof</code></h3><p>这三个API能让你了解一些Go在内存结构上的一些细节。其中</p>\n<ul>\n<li><code>Sizeof</code>返回操作数在内存中占用的大小</li>\n<li><code>Alignof</code>返回操作数“对齐”需要的内存大小</li>\n<li><code>Offsetof</code>返回结构体中字段在结构体内存的偏移量</li>\n</ul>\n<p>这几个API并不像它们名字里写的不安全，对于了解底层的内存表示是有帮助的，比如在需要优化内存性能时。</p>\n<h3 id=\"unsafe-Pointer\"><a href=\"#unsafe-Pointer\" class=\"headerlink\" title=\"unsafe.Pointer\"></a><code>unsafe.Pointer</code></h3><p><code>unsafe.Pointer</code>是一个可以指向任意类型变量的指针，同时<strong>也可以把<code>unsafe.Pointer</code>类型指针转换回特定类型指针</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Float64bits</span><span class=\"params\">(f <span class=\"type\">float64</span>)</span></span> <span class=\"type\">uint64</span> &#123; <span class=\"keyword\">return</span> *(*<span class=\"type\">uint64</span>)(unsafe.Pointer(&amp;f)) &#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#016x\\n&quot;</span>, Float64bits(<span class=\"number\">1.0</span>)) <span class=\"comment\">// &quot;03xff00000000000000&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时<code>unsafe.Pointer</code>可以转换为<code>uintptr</code>类型，这个类型用整数表示了地址。这个整数类型足够大，足以表示任何类型的指针。但在使用时要多加注意，因为Go的垃圾回收机制使得一个变量的地址很可能会在运行过程中改变，从而使之前的<code>uintptr</code>类型变量失去意义。建议尽可能减少<code>unsafe.Pointer</code>到<code>uintptr</code>和对<code>uintptr</code>的使用。如果有包返回了一个<code>uintptr</code>类型，建议立即将其转换为<code>unsafe.Pointer</code>类型，确保指针能指向同一个变量。</p>\n<h3 id=\"cgo\"><a href=\"#cgo\" class=\"headerlink\" title=\"cgo\"></a>cgo</h3><p>使用cgo可以在go中使用C语言，反之亦然，这里从略，具体参考<a href=\"https://golang.org/cmd/cgo%E3%80%82\">https://golang.org/cmd/cgo。</a></p>\n<h3 id=\"再一些忠告\"><a href=\"#再一些忠告\" class=\"headerlink\" title=\"再一些忠告\"></a>再一些忠告</h3><p><code>unsafe</code>包和<code>reflect</code>包很像，提供了一些高级特性，但是更甚。它绕开了语言对不可控因素的隔离，会带来一些风险。所以，在特殊场景下，经过仔细考量和验证证实，使用<code>unsafe</code>确实会带来关键性能提升时，再在代码的关键位置使用<code>unsafe</code>，同时，尽量保证对代码其他地方透明。</p>\n<p>最后，忘掉最后两章吧，先去踏踏实实写一些Go程序，在能用上<code>reflect</code>和<code>unsafe</code>的时候，你自然回想起来的。</p>\n<p>祝，happy Go programming。</p>\n<p><em>-END-</em></p>\n",
            "tags": [
                "golang",
                "语言学习"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/09/10/php-note/",
            "url": "http://shenlvmeng.github.com/blog/2019/09/10/php-note/",
            "title": "（旧文）PHP语言介绍",
            "date_published": "2019-09-10T13:02:17.000Z",
            "content_html": "<blockquote>\n<p><a href=\"//php.net\">php.net</a></p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>PHP来源于工程PHP&#x2F;FI，由Rasmus Lerdorf创建于1995年，起初只是一套简单的Perl脚本，名字叫做“Personal Home Page Tools”，语法也和Perl很像，随着用户的增加，改进为用C语言实现。1997年，Andi Gutmans 和 Zeev Suraski 重写了代码，推出第三版，PHP&#x2F;FI也演变成PHP（PHP: Hypertext Preprocessor）。注意，这是一个递归的缩写。</p>\n<p>1999年，由两人改进的更具模块化的“Zend Engine”引入PHP，在结合了许多新功能后，2000年5月发布官方版PHP 4.0。如今广泛使用的5.x版本从2004年起发布。5.x版本支持完整的面向对象模型。目前的最新版本已经到了7.x版本（直接从稳定的5.6版跃迁）。</p>\n<p>由于丰富的PHP主要用于服务端的脚本程序，就像其他的CGI程序，如收集表单，生成网页，发送&#x2F;接收Cookie等。除此以外，PHP还用于命令行脚本，编写桌面应用程序。这两种开发可能会用到PHP的拓展库。由于解析器的存在，PHP的跨平台能力很好。 </p>\n<p>关于php的绝大多数内容都可以在<a href=\"//php.net\">php.net</a>上找到，上面介绍的历史也是如此。本文的绝大多数内容更是如此。</p>\n<h2 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h2><p>在通常情况下，php用于服务器端脚本，安装配置较之Javascript复杂很多。在Unix环境下，假设服务器环境（如Apache, Nginx等）已经安装完毕，可以通过configure脚本安装配置。Windows环境下，通过MSI文件安装配置PHP和所有内置以及PECL拓展库。此外Mac OS X，云平台等安装各有不同，详见<a href=\"http://php.net/manual/zh/install.php\">官方教程</a>。</p>\n<p>配置文件（<code>php.ini</code>）在PHP启动时被读取，作为服务器模块版本的PHP，仅在服务器启动时读取1次，作为CGI和CLI版本，每次调用都会读取。用户亦可自定义自己的<code>user.ini</code>文件。PHP的有些指令可以在PHP脚本中用<code>ini_set()</code>设定，有些只能在<code>php.ini</code>或<code>httpd.conf</code>中设定。这些是由指令的模式决定的，模式有4种：<code>PHP_INI_USER</code>, <code>PHP_INI_PERDIR</code>, <code>PHP_INI_SYSTEM</code>, <code>PHP_INI_ALL</code>。具体见<a href=\"http://php.net/manual/zh/configuration.changes.modes.php\">文档</a>。</p>\n<p>PHP作为Apache模块运行时，还可以用<code>php_value</code>, <code>php_flag</code>, <code>php_admin_value</code>, <code>php_admin_flag</code>命令设置。</p>\n<h2 id=\"第一段代码\"><a href=\"#第一段代码\" class=\"headerlink\" title=\"第一段代码\"></a>第一段代码</h2><p>与C等语言通过代码输出HTML不同的是，PHP页面本身就是HTML，你也完全可以像通常建立HTML页面那样创建和编辑PHP页面，只不过其中嵌入了<code>&lt;?php</code>和<code>?&gt;</code>包裹的PHP代码。与Javascript不同的是，PHP运行在服务端，用户无从得知脚本是如何运行的。</p>\n<p>值得一提的是，除了上述的开始和结束标记，使用<code>&lt;script language =&quot;php&quot;&gt;&lt;/script&gt;</code>或者asp风格的短标记<code>&lt;?=</code>, <code>&lt;%=</code>也行（<em>不建议</em>）。在这一对标记之外的内容都会被PHP解析器忽略。可以在脚本中通过<code>phpinfo()</code>打印php的整体配置信息。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">phpinfo</span>();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在html语句中嵌入php语句时，尽量做到将业务逻辑和展示语句隔离开对维护php工程有着极大的好处。</p>\n<h2 id=\"特性参考\"><a href=\"#特性参考\" class=\"headerlink\" title=\"特性参考\"></a>特性参考</h2><h3 id=\"PHP标识\"><a href=\"#PHP标识\" class=\"headerlink\" title=\"PHP标识\"></a>PHP标识</h3><p>如上文中提到，PHP通过<code>&lt;?php</code>和<code>?&gt;</code>分隔php脚本，在<code>php.ini</code>激活<code>short_open_tag</code>配置后，支持使用短标记作为分隔符。<strong>如果文件内容为纯PHP代码，最好在文末删除结束标记，以免打印意料之外的空白</strong>。如下示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ... more code</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;Last statement&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// stop here</span></span><br></pre></td></tr></table></figure>\n\n<p>PHP使用<strong>分号</strong>作为分隔符，支持C，C++，Perl风格的注释。即<code>//</code>，<code>/**/</code>和<code>#</code>。</p>\n<h3 id=\"类型-amp-类型转换\"><a href=\"#类型-amp-类型转换\" class=\"headerlink\" title=\"类型 &amp; 类型转换\"></a>类型 &amp; 类型转换</h3><p>PHP的原始数据类型有<strong>boolean，integer，float，string，array，object，resource，NULL</strong>。其中前4种为标量，第5，6中为复合类型。resouce表示资源，<strong>NULL表示无类型</strong>。PHP中<strong>float也称为double</strong>。在确保代码易读性上，还有mixed，number和callback几种伪类型。需要注意的是，PHP和Javascript一样，类型往往根据上下文确定。</p>\n<h4 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h4><p>和JavaScript类似。</p>\n<p>只有TRUE或FALSE，除了false以外，还有下列假值：</p>\n<ul>\n<li>0</li>\n<li>0.0</li>\n<li>‘’</li>\n<li>“0”</li>\n<li>[],</li>\n<li>{}（仅4.0）</li>\n<li>NULL</li>\n</ul>\n<p>其余均为真值（包含任何resource）。和Javascript类似，支持&#x3D;&#x3D;&#x3D;全等。</p>\n<h4 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h4><p>有十进制，十六进制，八进制，二进制表示。除十进制外，分别以<code>0</code>, <code>0x</code>, <code>0b</code>开头。5.0.5后最大值可以用常量<code>PHP_INT_MAX</code>设置。<strong>整数溢出时会被解释为float</strong>。<strong>注意：八进制中传递非法数字后，后面数字会被忽略</strong>。类型转换时，可以使用<code>intval()</code>。在浮点数过大，分数强制转换和其他类型转换时，结果未定义。</p>\n<h4 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h4><p>又称为double和real，支持科学记数法。运算时精度有限，高精度要求下参考任意精度数学函数和gmp函数。在比较大小时需要谨慎，可以采用相减之差和最大容忍度比较的方法作折衷。常量<code>NAN</code>表示浮点计算中不可描述的值，为float类型，不等于任何其他变量，甚至自身。可以用<code>is_nan()</code>检查。</p>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><p>和JavaScript区别较大。</p>\n<ul>\n<li>PHP字符串的字符占1个字节，因此不支持Unicode。字符串最长可达2GB</li>\n<li>表示字符串有4种方法，<strong>单引号，双引号，heredoc和nowdoc</strong>。<ul>\n<li>单引号下，只转义单引号和反斜线，其余字符均为plain text，支持多行；</li>\n<li>双引号下，对换行回车制表符等特殊字符进行转义，还会对变量解析（$xxx）的形式（和Javascript相似）。</li>\n<li>Heredoc结构里，在&lt;&lt;&lt;符号后提供一个标识符然后换行，接下来是字符串本身，字符串后另起一行用前面定义的标识符作为结束标志。中间内容的处理方式同双引号。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"variable\">$str</span> = <span class=\"string\">&lt;&lt;&lt;EOD</span></span><br><span class=\"line\"><span class=\"string\">Example of string</span></span><br><span class=\"line\"><span class=\"string\">spanning multiple lines</span></span><br><span class=\"line\"><span class=\"string\">using heredoc syntax.</span></span><br><span class=\"line\"><span class=\"string\">EOD</span>;</span><br></pre></td></tr></table></figure>\n\n<p>5.3.0以后，可以使用heredoc结构初始化静态变量和类的属性以及常量。nowdoc结构类似于单引号版的heredoc，但是跟在<code>&lt;&lt;&lt;</code>之后的标识符要用单引号括起来，多用在不解析特殊字符的大段文本中。在双引号或heredoc结构中，变量会被解析，简单语法下，PHP解析器会去组合尽量多的标识形成一个合法的<strong>变量名</strong>。复杂语法下，<code>$</code>符号的<strong>外侧或里侧</strong>会紧贴<code>&#123;&#125;</code>，来实现更复杂的变量表达式。</p>\n<p>字符串中的字符可以用<code>[]</code>或者<code>&#123;&#125;</code>（不建议）访问。下标超出字符串长度时，会将<strong>多出的长度用空格填充</strong>。另外，字符串使用<code>.</code>连接。使用<code>strval()</code>转换变量为字符串，boolean会转成<code>&quot;1&quot;</code>或<code>&quot;&quot;</code>。integer和float作字面转换。**array总转换成<code>&quot;Array&quot;</code>**。object总转换成”Object”。NULL总转变成<code>&quot;&quot;</code>。</p>\n<p><code>serialize()</code>可以串行化大部分PHP值。字符串转为数值时，类似Javascript的<code>parseInt()/parseFloat()</code>，试图从头转换直到遇到不合法字符，支持科学记数法。区别在于PHP中失败时返回<code>0</code>而不是<code>NAN</code>。</p>\n<p>关于string的更多介绍，参加<a href=\"https://www.php.net/manual/zh/language.types.string.php#language.types.string\">官方文档String</a>一章。</p>\n<h4 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"variable\">$array</span> = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;foo&quot;</span> =&gt; <span class=\"string\">&quot;bar&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bar&quot;</span> =&gt; <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自 PHP 5.4 起</span></span><br><span class=\"line\"><span class=\"variable\">$array</span> = [</span><br><span class=\"line\">    <span class=\"string\">&quot;foo&quot;</span> =&gt; <span class=\"string\">&quot;bar&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bar&quot;</span> =&gt; <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>与Javascript区别较大，PHP中的数组也是个<strong>有序</strong>映射，描述了keys到values的映射。array使用<code>array()</code>初始化，在5.4版本后支持字面量定义。<strong>key可以是integer或string</strong>（integer时是数组，string时是键值对），value可以是任何类型。使用<code>[]</code>访问和修改数组元素，通过<code>unset()</code>删除某键值对（类似与Javascript的<code>delete</code>）。有趣的是，使用<code>[]</code>不指定键名时，则取当前最大整数索引值（曾经存在即可），新的键名在之上加1。可以使用<code>array_values()</code>重建索引。</p>\n<p>转换为数组时，除object、NULL类型外，其余类型得到只有一个元素的数组。object类型转换时，单元为对象的属性，键名为成员变量名，还有其他特殊情况见文档<a href=\"https://www.php.net/manual/zh/language.types.array.php\">数组</a>部分。NULL会转换为一个空数组。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"variable\">$A</span>; <span class=\"comment\">// This will become &#x27;\\0A\\0A&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"variable\">$A</span>; <span class=\"comment\">// This will become &#x27;\\0B\\0A&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"variable\">$AA</span>; <span class=\"comment\">// This will become &#x27;AA&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">var_dump</span>((<span class=\"keyword\">array</span>) <span class=\"keyword\">new</span> <span class=\"title function_ invoke__\">B</span>());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h4><p>对象，通过new来实例化一个类产生。转换为对象时，PHP会创建一个内置类stdClass的实例，可以通过<code>new stdClass()</code>创建一个空对象。php 7后，还有<code>new class&#123;&#125;</code>和<code>(object) []</code>方法。</p>\n<h4 id=\"resource\"><a href=\"#resource\" class=\"headerlink\" title=\"resource\"></a>resource</h4><p>用于保存到外部资源的一个引用，通过专门的函数建立和使用，由Zend引擎维护资源回收。</p>\n<h4 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h4><p>表示一个变量没有值。可细分为被赋值为<code>NULL</code>，尚未赋值和被<code>unset()</code>。<strong>NULL不区分大小写</strong>。</p>\n<h4 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h4><p>类似Javascript中的function类型，一些函数如<code>call_user_func()</code>可以接收用户定义的回调函数作为参数。传递时，以string类型传递函数名。5.3.0后可以直接传递closure给回调参数。</p>\n<p>其余伪类型多用于代码的说明注释中，如<code>mixed</code>表述多种不确定类型，<code>void</code>表述函数返回值无用或不接受任何参数等。</p>\n<h4 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h4><p>使用<code>var_dump()</code>查看值和类型，<code>gettype()</code>查看类型，<code>is_int</code>&#x2F;<code>is_string</code>&#x2F;…判断类型，<code>(type)</code>或<code>settype()</code>强制类型转换。PHP的强制转换和C非常相似。目前支持<code>(int)</code>, <code>(bool)</code>, <code>(float)</code>, <code>(string)</code>, <code>(array)</code>, <code>(object)</code>, <code>(unset)</code>（转换为<code>NULL</code>）。5.2版本后支持<code>(binary)</code>转换。</p>\n<p>除了强制转换，PHP中会根据需要对变量自动转换，如加法。与Javascript的<code>+</code>不大不同，PHP会优先将操作数转为float，否则会将操作数解释为integer。数组的键名会优先转换为integer（仅十进制），再转换为string。下面就是一个有趣的例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">  <span class=\"variable\">$foo</span> = <span class=\"string\">&quot;0&quot;</span>;  <span class=\"comment\">// $foo is a string</span></span><br><span class=\"line\">  <span class=\"variable\">$foo</span> += <span class=\"number\">2</span>;   <span class=\"comment\">// $foo is an int now</span></span><br><span class=\"line\">  <span class=\"variable\">$foo</span> = <span class=\"variable\">$foo</span> + <span class=\"number\">1.3</span>;  <span class=\"comment\">// $foo is a float now (3.3)</span></span><br><span class=\"line\">  <span class=\"variable\">$foo</span> = <span class=\"number\">5</span> + <span class=\"string\">&quot;10 Little Piggies&quot;</span>; <span class=\"comment\">// $foo is an integer (15)</span></span><br><span class=\"line\">  <span class=\"variable\">$foo</span> = <span class=\"number\">5</span> + <span class=\"string\">&quot;Small Pigs&quot;</span>;     <span class=\"comment\">// $foo is an integer (5)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量-amp-常量\"><a href=\"#变量-amp-常量\" class=\"headerlink\" title=\"变量 &amp; 常量\"></a>变量 &amp; 常量</h3><p>PHP变量以<code>$</code>符号开头，只能包含数字字母（这里说的字母包含ASCII字符）和下划线且不能以数字开头。变量区分大小写。<code>$this</code>是特殊变量不能赋值。可以在<code>$</code>前加<code>&amp;</code>符号<strong>引用赋值</strong>，在改变原变量时，目标变量也会改动。<code>isset()</code>可以检查变量是否已被赋值。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"variable\">$var</span> = <span class=\"string\">&#x27;Bob&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable\">$Var</span> = <span class=\"string\">&#x27;Joe&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;<span class=\"subst\">$var</span>, <span class=\"subst\">$Var</span>&quot;</span>;      <span class=\"comment\">// 输出 &quot;Bob, Joe&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">$<span class=\"number\">4</span>site = <span class=\"string\">&#x27;not yet&#x27;</span>;     <span class=\"comment\">// 非法变量名；以数字开头</span></span><br><span class=\"line\"><span class=\"variable\">$_4site</span> = <span class=\"string\">&#x27;not yet&#x27;</span>;    <span class=\"comment\">// 合法变量名；以下划线开头</span></span><br><span class=\"line\"><span class=\"variable\">$i</span>站点is = <span class=\"string\">&#x27;mansikka&#x27;</span>;  <span class=\"comment\">// 合法变量名；可以用中文</span></span><br></pre></td></tr></table></figure>\n\n<p>用户在为变量命名时，有几点要注意的。function, class, interface, 常量和函数外定义的变量会进入全局命名空间；建议在函数名中用<code>_</code>区分，类名中用驼峰或首字母大写的驼峰命名。注意：很多情况下，PHP会自动将变量名中的点转换成下划线。</p>\n<h4 id=\"可变变量\"><a href=\"#可变变量\" class=\"headerlink\" title=\"可变变量\"></a>可变变量</h4><p>PHP中的变量名可以很方便地改变，而且可变变量可以用在数组或对象中，如下面的例子，。使用可变变量时，注意通过花括号给属性名清晰定界。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// Given these variables ...</span></span><br><span class=\"line\"><span class=\"variable\">$nameTypes</span>    = <span class=\"keyword\">array</span>(<span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;last&quot;</span>, <span class=\"string\">&quot;company&quot;</span>);</span><br><span class=\"line\"><span class=\"variable\">$name_first</span>   = <span class=\"string\">&quot;John&quot;</span>;</span><br><span class=\"line\"><span class=\"variable\">$name_last</span>    = <span class=\"string\">&quot;Doe&quot;</span>;</span><br><span class=\"line\"><span class=\"variable\">$name_company</span> = <span class=\"string\">&quot;PHP.net&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Then this loop is ...</span></span><br><span class=\"line\"><span class=\"keyword\">foreach</span>(<span class=\"variable\">$nameTypes</span> <span class=\"keyword\">as</span> <span class=\"variable\">$type</span>)</span><br><span class=\"line\">  <span class=\"keyword\">print</span> $&#123;<span class=\"string\">&quot;name_<span class=\"subst\">$type</span>&quot;</span>&#125; . <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... equivalent to this print statement.</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">&quot;<span class=\"subst\">$name_first</span>\\n<span class=\"subst\">$name_last</span>\\n<span class=\"subst\">$name_company</span>\\n&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"预定义变量\"><a href=\"#预定义变量\" class=\"headerlink\" title=\"预定义变量\"></a>预定义变量</h4><p>PHP提供许多预定义的变量。PHP中的许多预定义变量都是“超全局的”，这意味着它们在脚本的全部作用域都可见。这种类型在4.1版本中被引入，有<code>$GLOBALS</code>, <code>$_SERVER</code>, <code>$_GET</code>, <code>$_POST</code>, <code>$_FILES</code>, <code>$_COOKIE</code>, <code>$_SESSION</code>, <code>$_REQUEST</code>, <code>$_ENV</code>。它们在5.4版本后不能作为函数的输入参数。通过这些预设的超全局变量，PHP可以轻松地获取请求的各种参数。</p>\n<p>除了上述超全局变量外，还有<code>$php_errormsg</code>, <code>$HTTP_RAW_POST_DATA</code>（使用php:&#x2F;&#x2F;input代替）, <code>$http_response_header</code>(使用HTTP包装其时，该变量会被自动填充)，<code>$argc</code>和<code>$argv</code>分别代表传递给脚本的参数数目和参数数组（运行在命令行下时）。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>变量作用域通常为文件作用域。函数内部的声明的变量被限制在函数作用域内。同时，和Javascript相同，<strong>PHP没有块级作用域</strong>。注意，PHP中定义全局变量需使用<code>global</code>关键字。在函数内部，变量优先视作局部变量。下面的脚本不会有任何输出，因为<code>echo</code>引用了一个局部变量<code>$a</code>，但是在函数作用域内它并没有被赋值。要想$a在函数作用域内可见，需要在引用前声明<code>global</code>。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"variable\">$a</span> = <span class=\"number\">1</span>; <span class=\"comment\">/* global scope */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"variable\">$a</span>; <span class=\"comment\">/* reference to local scope variable */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_ invoke__\">Test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Test2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">global</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_ invoke__\">Test2</span>();</span><br></pre></td></tr></table></figure>\n\n<p>静态变量通过<code>static</code>声明，<strong>仅在局部作用域存在</strong>，程序离开作用域时内容不丢失。静态变量不能使用表达式初始化。在下面的例子中，函数仅在第一次调用时初始化<code>$a</code>变量，之后每次调用都会输出<code>$a</code>，并加一。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"variable\">$a</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\">    <span class=\"variable\">$a</span>++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><p>在类外，常量通过<code>define(name. value)</code>函数定义。在类内使用<code>const</code>定义常量（5.3.0后）。常量的命名规范同C。常量只能是标量。<strong>在访问常量值时，名字前不带<code>$</code><strong>。常量名事先无法确定时，使用<code>constant()</code>获取常量。</strong>常量没有作用域的限制</strong>，可以在任何位置访问。</p>\n<p>PHP定义了大量的魔术常量，都以两个下划线开头和结尾。有<code>__LINE__</code>，<code>__FILE__</code>, <code>__DIR__</code>, <code>__FUNCTION__</code>, <code>__CLASS__</code>, <code>__TRAIT__</code>, <code>METHOD__</code>, <code>__NAMESPACE__</code>。具体解释见<a href=\"http://php.net/manual/zh/language.constants.predefined.php\">官方文档</a>。</p>\n<h3 id=\"表达式-amp-流程\"><a href=\"#表达式-amp-流程\" class=\"headerlink\" title=\"表达式 &amp; 流程\"></a>表达式 &amp; 流程</h3><p>PHP的表达式根据官方的定义表述，是<em>任何有值的东西</em>。表达式的组成类似于其他语言，从略。值得注意的有以下几点：</p>\n<ul>\n<li>PHP的逻辑运算符同时有<code>&amp;&amp;</code>, <code>||</code>以及<code>and</code>, <code>xor</code>, <code>or</code>两套，但是<strong>后一套的优先级最低</strong>。</li>\n<li>PHP提供<code>@</code>作为错误控制运算符，放置在表达式前可以忽略产生的任何错误信息。<strong>强烈不建议使用</strong>。</li>\n<li>反引号``执行其中的shell命令，并将输出结果返回，等同于执行<code>shell_exec()</code>。</li>\n<li><code>+</code>, <code>==</code>, <code>===</code>还可以用于数组间的运算，进行数组的连接，键值对相同的检测。</li>\n<li><code>instanceof</code>用于确定变量是否属于某个类的实例。用法如<code>$a instanceof MyClass</code></li>\n</ul>\n<p>算法流程上，PHP类似C风格。不同点有：</p>\n<ul>\n<li>提供在<code>&lt;?php&gt;</code>闭合标签内使用<code>for endfor</code>这种用法</li>\n<li><code>foreach(array as $key =&gt; $value)</code>便于遍历数组。（注意：在<code>$value</code>前<code>&amp;</code>可以在<code>foreach</code>循环中改变<code>value</code>的值）</li>\n<li><code>break</code>可以接受一个可选的数字决定跳出几层循环</li>\n<li><code>continue</code>接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是<code>1</code></li>\n<li><code>declare</code>设定一段代码的施行指令，目前只支持<code>ticks</code>和<code>encoding</code>。前者控制执行计时的若干条命令后的操作，后者决定代码的运行编码。</li>\n<li><code>require</code>和<code>include</code>效果类似，用法同C，它们也有带后缀<code>_once</code>的操作符</li>\n</ul>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>PHP的函数定义和其他语言类似，定义的函数都具有全局作用域。不同的是</p>\n<ul>\n<li>PHP可以使用<code>create_function(args, code)</code>这样的函数定义函数（类似JS中的<code>new Function()</code>）</li>\n<li>函数需要先定义后使用（这个只是与Javascript不同）</li>\n<li>PHP可以定义有条件的函数，通过用if包裹和放在function定义内</li>\n</ul>\n<p>和C&#x2F;C++风格很像的是：</p>\n<ul>\n<li>PHP函数参数接收的是一个复制，需要传递引用改变原值；</li>\n<li>支持默认参数，需放在最右；</li>\n<li>5.0之后支持对输入参数类型检查，到5.4为止支持class &#x2F; array &#x2F; callable类型，7.0以后支持标量类型。如果给出的值类型不对，那么将会产生一个错误</li>\n<li>7.0之后支持不对输入参数强制类型转换。</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> <span class=\"keyword\">extends</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This doesn&#x27;t extend C.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">C <span class=\"variable\">$c</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"title function_ invoke__\">get_class</span>(<span class=\"variable\">$c</span>).<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">f</span>(<span class=\"keyword\">new</span> C);</span><br><span class=\"line\"><span class=\"title function_ invoke__\">f</span>(<span class=\"keyword\">new</span> D);</span><br><span class=\"line\"><span class=\"title function_ invoke__\">f</span>(<span class=\"keyword\">new</span> E);</span><br></pre></td></tr></table></figure>\n\n<p>和Js相似的一点时，5.6版之后支持使用<code>...</code>符号获取参数列表。</p>\n<p>和可变变量一样，PHP中有可变函数，用法和可变变量一样。在调用对象的静态方法时，函数调用要优于静态属性，下面是一个例子</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"variable\">$variable</span> = <span class=\"string\">&#x27;static property&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Variable</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Method Variable called&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"title class_\">Foo</span>::<span class=\"variable\">$variable</span>; <span class=\"comment\">// This prints &#x27;static property&#x27;. It does need a $variable in this scope.</span></span><br><span class=\"line\"><span class=\"variable\">$variable</span> = <span class=\"string\">&quot;Variable&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>::<span class=\"variable\">$variable</span>();  <span class=\"comment\">// This calls $foo-&gt;Variable() reading $variable in this scope.</span></span><br></pre></td></tr></table></figure>\n\n<p>5.3之后，PHP也支持匿名函数，并可以传递给一个变量储存。实际中，这种表达式会被转换为内置类Closure的对象实例。闭包可以从父作用域继承变量，但是此类变量需要用<em>use结构</em>传递进去，类似于<code>function() use($a)&#123;&#125;</code>这样的形式。</p>\n<h3 id=\"类-amp-对象\"><a href=\"#类-amp-对象\" class=\"headerlink\" title=\"类 &amp; 对象\"></a>类 &amp; 对象</h3><p>PHP承袭着面向对象语言对类和对象的处理。类以<code>class</code>开头，里面包含属性和方法等，可以包含自己的常量。通过<code>new</code>实例化，通过<code>extends</code>实现继承。子类使用<code>parent::</code>访问被覆盖的属性或方法，使用<code>self::</code>自身的静态属性和方法。5.5之后使用<code>ClassName::class</code>可以获取带有命名空间的完整类名。轻量级的类可以通过强制转换关联数组实现。</p>\n<p>类中的静态属性通过<code>::</code>访问，非静态属性通过<code>-&gt;</code>访问。定义常量时使用<code>const</code>，常量的值必须是一个定值（5.6之后可以是数学运算结果）。PHP 5新增了关键字<code>final</code>，修饰方法或者类不可被继承。</p>\n<p>PHP 5中，**<code>__autoload()</code>函数会在使用未定义的类时自动调用**，5.3.0之后通常使用<code>spl_autoload_register()</code>作为<code>autoload</code>的替代。<code>__construct()</code>和<code>__destruct()</code>分别是构造和析构函数，5.3.3之前，在没有<code>__construct()</code>函数也没有父类时，会寻找命名空间中与类名同名的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">spl_autoload_register</span>(function (<span class=\"variable\">$class_name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">require_once</span> <span class=\"variable\">$class_name</span> . <span class=\"string\">&#x27;.php&#x27;</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$obj</span>  = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass1</span>();</span><br><span class=\"line\"><span class=\"variable\">$obj2</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass2</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"trait-amp-匿名类\"><a href=\"#trait-amp-匿名类\" class=\"headerlink\" title=\"trait &amp; 匿名类\"></a>trait &amp; 匿名类</h4><p>在访问控制，继承，抽象类，接口等方面PHP和传统的面向对象语言很像。在5.4.0后，PHP提供了<strong>trait作为类之间代码水平复用的特性（很像mixin）</strong>。在class定义中使用<code>use</code>来获取trait，类似interface，一个类可以插入多个trait，trait会覆盖基类方法而被当前类方法覆盖。在多个trait的同名方法发生冲突时，通过<code>insteadof</code>和<code>as</code>来决定使用哪个，具体见<a href=\"https://www.php.net/manual/zh/language.oop5.traits.php\">trait文档</a>。trait的功能使用依赖注入也可以完成，相关讨论见<a href=\"https://stackoverflow.com/questions/7892749/traits-in-php-any-real-world-examples-best-practices\">stackoverflow trait practives</a>与<a href=\"https://stackoverflow.com/questions/9205083/traits-vs-interfaces\">trait vs interface</a>。trait甚至还支持抽象成员和静态成员。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">smallTalk</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bigTalk</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">smallTalk</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bigTalk</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;B&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Talker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> &#123;</span><br><span class=\"line\">        <span class=\"title\">B</span>::<span class=\"title\">smallTalk</span> <span class=\"title\">insteadof</span> <span class=\"title\">A</span>;</span><br><span class=\"line\">        A::<span class=\"variable constant_\">bigTalk</span> <span class=\"keyword\">insteadof</span> B;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aliased_Talker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> &#123;</span><br><span class=\"line\">        <span class=\"title\">B</span>::<span class=\"title\">smallTalk</span> <span class=\"title\">insteadof</span> <span class=\"title\">A</span>;</span><br><span class=\"line\">        A::<span class=\"variable constant_\">bigTalk</span> <span class=\"keyword\">insteadof</span> B;</span><br><span class=\"line\">        B::<span class=\"variable constant_\">bigTalk</span> <span class=\"keyword\">as</span> talk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PHP7.0之后支持匿名类，用于创建一次性的简单对象。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// PHP 7 之前的代码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"><span class=\"variable\">$msg</span></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"variable\">$msg</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$util</span>-&gt;<span class=\"title function_ invoke__\">setLogger</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用了 PHP 7+ 后的代码</span></span><br><span class=\"line\"><span class=\"variable\">$util</span>-&gt;<span class=\"title function_ invoke__\">setLogger</span>(<span class=\"keyword\">new</span> <span class=\"keyword\">class</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> function <span class=\"title function_ invoke__\">log</span>(<span class=\"variable\">$msg</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"variable\">$msg</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"“重载”\"><a href=\"#“重载”\" class=\"headerlink\" title=\"“重载”\"></a>“重载”</h4><p>PHP提供的<strong>重载（overload）</strong>语义和其他大部分OOP语言不同，指在调用当前环境下未定义或不可见的类属性或方法时调用重载方法。PHP借助<strong>魔术方法</strong>实现重载。读写不可访问属性时，<code>__get()</code>和<code>__set()</code>分别被调用；对不可访问属性调用<code>isset</code>和<code>unset</code>时，<code>__isset()</code>和<code>__unset()</code>分别被调用。<strong>属性重载只能在对象中进行</strong>。调用不可访问的方法和静态方法时，<code>__call()</code>和<code>__callStatic()</code>分别被调用，方法重载用法类似属性重载。重载的示例见文档。（<em>不建议使用这个特性，这会影响ide补全和代码的可读性</em>）。</p>\n<p>PHP5提供foreach方法遍历对象，默认情况可见属性都会被遍历，可以让类实现<code>Iterator</code>接口从而自行决定如何处理遍历。实现<code>IteratorAggregate</code>接口可以代替实现所有的Iterator方法，<code>IteratorAggregate</code>只需实现<code>IteratorAggregate::getIterator()</code>方法即可。</p>\n<h4 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法\"></a>魔术方法</h4><p>PHP将所有<code>__</code>开头的类方法保留为<strong>魔术方法</strong>，<code>__sleep()</code>方法在<code>serialize()</code>函数前调用，应返回一个包含对象中所有应被序列化的变量名称的数组，相对的<code>__wakeup()</code>在反序列化函数前调用。<code>__toString()</code>在把一个类视作字符串时怎样回应时调用。<code>__invoke()</code>在把一个类视作函数调用时调用。更多方法见<a href=\"https://www.php.net/manual/zh/language.oop5.magic.php\">魔术方法页面</a>。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connection</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"variable\">$link</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"variable\">$server</span>, <span class=\"variable\">$username</span>, <span class=\"variable\">$password</span>, <span class=\"variable\">$db</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"><span class=\"variable\">$server</span>, <span class=\"variable\">$username</span>, <span class=\"variable\">$password</span>, <span class=\"variable\">$db</span></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;server = <span class=\"variable\">$server</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;username = <span class=\"variable\">$username</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;password = <span class=\"variable\">$password</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;db = <span class=\"variable\">$db</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;<span class=\"title function_ invoke__\">connect</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connect</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;link = <span class=\"title function_ invoke__\">mysql_connect</span>(<span class=\"variable\">$this</span>-&gt;server, <span class=\"variable\">$this</span>-&gt;username, <span class=\"variable\">$this</span>-&gt;password);</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">mysql_select_db</span>(<span class=\"variable\">$this</span>-&gt;db, <span class=\"variable\">$this</span>-&gt;link);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__sleep</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">array</span>(<span class=\"string\">&#x27;server&#x27;</span>, <span class=\"string\">&#x27;username&#x27;</span>, <span class=\"string\">&#x27;password&#x27;</span>, <span class=\"string\">&#x27;db&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__wakeup</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;<span class=\"title function_ invoke__\">connect</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PHP使用<code>clone</code>创造对象的浅复制（即只创造属性的引用），魔术方法<code>__clone()</code>在clone完成后调用。PHP 5中的对象甚至可以相互比较，使用<code>==</code>判断属性和属性值是否一致，<code>===</code>判断变量是否是同一个实例。</p>\n<p>自5.3.0起，PHP增加了<code>static::</code>关键字和<a href=\"https://www.php.net/manual/zh/language.oop5.late-static-bindings.php\">后期静态绑定</a>的功能，用于在继承范围内引用静态调用的类。静态环境下绑定静态方法可以让子类在<strong>自己的环境</strong>下（自己的this）调用继承自基类的方法。这种方式绑定非静态方法时，会出现不同结果，尽量避免使用。</p>\n<p>对象通过<code>serialize()</code>和<code>unserialize()</code>来序列化和反序列化一个对象，对象的方法和静态成员不会保留。<strong>在解序列的文件域内需要包含类的定义</strong>。</p>\n<h4 id=\"预定义接口\"><a href=\"#预定义接口\" class=\"headerlink\" title=\"预定义接口\"></a>预定义接口</h4><p>PHP预定义了许多接口。<code>Traversal</code>接口监测一个类是否可以使用foreach进行遍历（仅供引擎使用）。<code>Iterator</code>接口用来实现对象的foreach迭代，有<code>rewind</code>, <code>current</code>, <code>key</code>, <code>next</code>, <code>valid</code>等成员方法。除此以外还有聚合迭代，数组式访问，序列化，生成器接口等接口和Closure类。这里从略。</p>\n<h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间是PHP一个比较有特点的特性。在PHP中用命名空间解决<strong>类库和用户代码名字冲突的问题</strong>。实际上命名空间所做的事情就是代码模块化，正如Java的packages和Javascript里CommonJS规范一样。命名空间的命名方法类似变量，不允许使用PHP或php开头的命名空间。下面是一个命名空间的范例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">my</span>\\<span class=\"title class_\">name</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myfunction</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">MYCONST</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$a</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>;</span><br><span class=\"line\"><span class=\"variable\">$c</span> = <span class=\"keyword\">new</span> \\my\\name\\MyClass; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$a</span> = <span class=\"title function_ invoke__\">strlen</span>(<span class=\"string\">&#x27;hi&#x27;</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$d</span> = <span class=\"keyword\">namespace</span>\\<span class=\"title class_\">MYCONST</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$d</span> = <span class=\"keyword\">__NAMESPACE__</span> . <span class=\"string\">&#x27;\\MYCONST&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"title function_ invoke__\">constant</span>(<span class=\"variable\">$d</span>);</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>declare</code>语句以外，<strong>namespace的定义需在文件的最前面</strong>。PHP与其它的语言特征不同，同一个命名空间可以定义在多个文件中，即<strong>允许将同一个命名空间的内容分割存放在不同的文件中</strong>。在命名空间中使用define定义常量时，需要带上<code>__NAMESPACE__</code>，否则意味着定义在全局空间下。</p>\n<p>PHP中的命名空间和文件目录很像，也支持层级化的定义方法，即定义子命名空间，父子间通过反斜线<code>\\</code>隔开。可以在单文件内定义多个namespace（<strong>不提倡</strong>），建议namespace间通过大括号隔离开。PHP命名空间可以和文件系统进行类比，类名非限定时，会在当前空间寻找，以<code>\\</code>开头时从全局空间寻找（相对目录），否则从当前空间起向下寻找（绝对目录）。下面是一个使用了三种方法的样例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Foo</span>\\<span class=\"title class_\">Bar</span>;</span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">&#x27;file1.php&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">FOO</span> = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">staticmethod</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 非限定名称 */</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">foo</span>();     <span class=\"comment\">// 解析为 Foo\\Bar\\foo</span></span><br><span class=\"line\">foo::<span class=\"title function_ invoke__\">staticmethod</span>();     <span class=\"comment\">// 解析为类 Foo\\Bar\\foo的静态方法static method</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> FOO; <span class=\"comment\">// 解析为常量 Foo\\Bar\\FOO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 限定名称 */</span></span><br><span class=\"line\">subnamespace\\<span class=\"title function_ invoke__\">foo</span>(); <span class=\"comment\">// 解析为函数 Foo\\Bar\\subnamespace\\foo</span></span><br><span class=\"line\">subnamespace\\foo::<span class=\"title function_ invoke__\">staticmethod</span>(); <span class=\"comment\">// 解析为类 Foo\\Bar\\subnamespace\\foo, 以及类的方法 staticmethod</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> subnamespace\\FOO; <span class=\"comment\">// 解析为常量 Foo\\Bar\\subnamespace\\FOO</span></span><br><span class=\"line\">                                  </span><br><span class=\"line\"><span class=\"comment\">/* 完全限定名称 */</span></span><br><span class=\"line\">\\Foo\\Bar\\<span class=\"title function_ invoke__\">foo</span>(); <span class=\"comment\">// 解析为函数 Foo\\Bar\\foo</span></span><br><span class=\"line\">\\Foo\\Bar\\foo::<span class=\"title function_ invoke__\">staticmethod</span>(); <span class=\"comment\">// 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethod</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> \\Foo\\Bar\\FOO; <span class=\"comment\">// 解析为常量 Foo\\Bar\\FOO</span></span><br></pre></td></tr></table></figure>\n\n<p>命名空间的装载和名称的解析是在编译期完成的。命名空间有三种定义方法：</p>\n<ul>\n<li>非限定名称：名称中不包含命名空间分割符，即\\，如Foo</li>\n<li>限定名称：名称中包含命名空间分割符，如Foo\\Bar</li>\n<li>完全限定名称：名称中包含命名空间分割符，且以\\开始的标识符，如\\Foo\\Bar</li>\n</ul>\n<p>PHP支持使用<code>namespace</code>关键字或<code>__NAMESPACE__</code>魔术常量获取当前所在命名空间。所有支持命名空间的PHP版本支持三种别名或导入方式：<strong>为类名称使用别名</strong>、<strong>为接口使用别名</strong>、<strong>为命名空间名称使用别名</strong>。这么做类似于在操作系统中创建符号连接。别名通过操作符<code>use as</code>实现。注意：导入命名空间后文件内的类名，接口名等会收到导入的影响。在一个命名空间中，当PHP遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP会退而使用全局空间中的函数或常量。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称。</p>\n<h3 id=\"错误和异常\"><a href=\"#错误和异常\" class=\"headerlink\" title=\"错误和异常\"></a>错误和异常</h3><p>PHP的错误类型有很多，可以见<a href=\"http://php.net/manual/zh/errorfunc.constants.php\">类型列表</a>。PHP对错误的汇报方式由<code>php.ini</code>中的<code>error_reporting</code>命令控制，可以在运行时通过<code>error_reporting()</code>函数动态修改。在开发环境，建议将级别设置到<code>E_ALL</code>，同时在脚本的开头设置级别。<code>php.ini</code>中的<code>display_errors</code>指令控制是否将错误显示在脚本输出中，建议在生产环境中关闭。<code>log_errors</code>指令控制错误记录。</p>\n<p>PHP 5中异常可以被抛出，由try&#x2F;catch语句块获取。<code>catch</code>获得的是一个<code>Exception</code>类的实例。类似Java，可以在catch后加上finally语句块。Exception是一个类，有<code>getMessage</code>，<code>getTraceAsString</code>等方法可以使用和拓展，详见介绍。PHP 7中，大多数错误都被作为Error异常抛出，可以被第一个匹配的try&#x2F;catch语句块捕获，否则交给PHP相应的异常处理函数处理，如果尚未通过<code>set_exception_handler()</code>注册童永刚异常处理函数，则会报告一个Fatal Error。注意：捕获错误或异常时，若在自定义命名空间下，Exception需要用完全限定方式书写。</p>\n<p>7.0以后的版本中，<code>Error</code>和<code>Exception</code>同属于<code>Throwable</code>类型，这一点与5.x版本不同。代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//To catch both exceptions and errors in PHP 5.x and 7, add a catch block for Exception AFTER catching Throwable first.</span></span><br><span class=\"line\"><span class=\"comment\">//Once PHP 5.x support is no longer needed, the block catching Exception can be removed.</span></span><br><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Code that may throw an Exception or Error.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (<span class=\"built_in\">Throwable</span> <span class=\"variable\">$t</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Executed only in PHP 7, will not match in PHP 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (<span class=\"built_in\">Exception</span> <span class=\"variable\">$e</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Executed only in PHP 5, will not be reached in PHP 7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h3><p>PHP中的生成器的概念与Java等高级语言中生成器的概念无二。生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以<code>yield</code>生成许多它所需要的值。当一个生成器被调用的时候，它返回一个可以被遍历的对象。PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态。<strong>生成器不可以返回值</strong>。return语句只会终止生成器继续执行。</p>\n<p><strong>yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数</strong>。可以使用yield返回键值对，引用或<code>NULL</code>等。在PHP 7以后，使用<code>yield from</code>可以从实现了Iterator接口的对象或使用yield的函数中yield值。如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count_to_ten</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayIterator</span>([<span class=\"number\">5</span>, <span class=\"number\">6</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"title function_ invoke__\">seven_eight</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"title function_ invoke__\">nine_ten</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seven_eight</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"title function_ invoke__\">eight</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eight</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nine_ten</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$gen</span> = <span class=\"title function_ invoke__\">count_to_ten</span>();</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"variable\">$gen</span> <span class=\"keyword\">as</span> <span class=\"variable\">$num</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;<span class=\"subst\">$num</span> &quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"variable\">$gen</span>-&gt;<span class=\"title function_ invoke__\">getReturn</span>();</span><br></pre></td></tr></table></figure>\n\n<p>对比生成器和实现Iterator接口的类来看，生成器的代码可读性更高，代码量也更少，缺憾在于不能多次迭代和回退，除非重建或使用clone。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p><strong>PHP的引用意味着不同的名字访问同一个变量内容</strong>，通过在变量前加上<code>&amp;</code>使用。在对一个未定义的变量进行引用参数传递或引用返回时，会自动创建该变量。不使用<code>&amp;</code>符号时，意味着生成一个拷贝。</p>\n<p>在进行引用传递时，只能传递变量，New语句和函数中返回的引用；引用返回时，需要在函数名前加上&amp;符号，同时接受返回值的变量也需写为接收引用的形式。<br>通过<code>unset</code>销毁引用，销毁引用的同时不会销毁原变量（类似于删除符号链接）。<code>global $var</code>实际上就是创建了到<code>$GLOBALS[]</code>的引用。<code>$this</code>也是同理。</p>\n<h3 id=\"支持的协议\"><a href=\"#支持的协议\" class=\"headerlink\" title=\"支持的协议\"></a>支持的协议</h3><p>PHP带有内置URL风格的封装协议，可用于类似<code>fopen()</code>、<code>copy()</code>、<code>file_exists()</code>和<code>filesize()</code>的文件系统函数，如file, http, ftp, php, zlib, data等。其中<code>php://</code>提供的是输入输出流和错误描述符的访问能力。创建数据流前，可以通过<code>stream_context_create()</code>创建上下文选项，定义数据流的选项。</p>\n<h2 id=\"函数参考\"><a href=\"#函数参考\" class=\"headerlink\" title=\"函数参考\"></a>函数参考</h2><p>PHP本身提供了海量的函数。且都可以全局访问到。</p>\n<h3 id=\"内核\"><a href=\"#内核\" class=\"headerlink\" title=\"内核\"></a>内核</h3><p>内核部分的函数，不能通过编译选项去除。PHP这部分的函数和介绍相当多，这里只撷选了常用的部分。</p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>这部分的函数主要用来进行和数组相关的操作，由于PHP中的数组包括了键值对这样类似对象的功能，函数的数量很多，甚至有些冗余。</p>\n<ul>\n<li><code>array_chunk</code> 将数组分割为多个，单元数目由size决定。返回一个多维数组。</li>\n<li><code>array_merge</code> 将多个数组的单元合并在一起，字符串键名相同时，后面的值会覆盖前一个。类似的还有array_merge_recursive。</li>\n<li><code>array_count_values</code> 统计数组中所有的值出现的次数，返回一个关联数组</li>\n<li><code>array_diff</code> 计算数组的差集，返回在array1但不在array2的元素</li>\n<li><code>array_intersect</code> 计算数组的交集，返回一个在array1中出现同时也在其他所有参数数组中出现的值。在差和交的名称前加上u的函数可以自己指定比较方法。</li>\n<li><code>array_fill</code> 用给定的值填充数组的num个条目，start_index为返回数组的第一个索引值。array_fill_keys函数可以填充键值对。<code>array_pad</code> 用值将数组填充到指定长度。键从第一个整型数开始，否则从0开始。</li>\n<li><code>array_flip</code> 返回一个交换键和值的数组。不合法的值将不会反转。类似的<code>array_reverse</code>返回一个单元顺序相反的数组。</li>\n<li><code>array_combine(array $keys , array $values)</code>返回一个由<code>keys</code>数组作键，<code>values</code>数组作值的新数组，两个数组长度不一样时抛出异常。<code>array_keys(array $array [, mixed $search_value [, bool $strict= false ]])</code>返回所有值为<code>search_value</code>的键名，<code>strict</code>表示是否进行严格比较。类似地，<code>array_values(array $input)</code>返回一个由所有值组成的数组，并建立起数字索引。</li>\n<li><code>array_multisort</code>用来一次多多个数组排序，输入数组被当作一个数据表的若干列来排序。常用在对数据库数据的排序。返回值为bool类型。</li>\n<li><code>array_push</code>和<code>array_pop</code>分别在array的末尾弹出或压入一个元素。</li>\n<li><code>array_shift</code>和<code>array_uinshift</code>完成类似于上面的功能，不过是在数组开头。</li>\n<li><code>array_product()</code>和<code>array_sum()</code>分别返回数组的乘积和总和。</li>\n<li><code>array_filter</code>用回调函数过滤数组单元。没有回调函数时将删除input中等值于FALSE的条目。</li>\n<li><code>array_map</code>返回一个arr1所有单元经过callback作用后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。</li>\n<li><code>array_walk</code>使用用户自定义的函数对数组每个函数做回调处理。</li>\n<li><code>array_reduce</code>根据回调将array简化为一个值。function变量可以读取result和item。</li>\n<li><code>array_replace(array $array1 , array $array2 [, array $... ])</code>将前面的数组的键值对覆盖为后面的键值对。多维数组下有recursive版本。</li>\n<li><code>array_key_exists</code>检查键名是否存在于数组中。<code>array_search(mixed $needle , array $haystack [, bool $strict = false ])</code>在数组中搜索给定值。</li>\n<li><code>array_slice</code>根据offset和length从数组中取出一段。</li>\n<li><code>array_splice</code>把input数组中由offset和length指定的单元去掉，如果提供了replacement参数，则用其中的单元取代。</li>\n<li><code>array_unique</code>用于移除数组中重复的值</li>\n</ul>\n<p>除了这些，还有<code>is_array()</code>，<code>explode()</code>，<code>split()</code>等不以array开头的函数和数组相关，大多用来进行一些简单的操作，列表见<a href=\"http://php.net/manual/zh/ref.array.php\">数组参考</a>。和数组排序相关的函数也有很多，它们在排序依据，是否稳定等方面各不相同，更多内容参考对数组进行排序。</p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>和字符串相关的函数也很多，但只有以str开头的是严格意义上的字符串函数。下面列举了部分：</p>\n<ul>\n<li><code>addslashes</code>转义字符串中的单引号，双引号，反斜线和NUL</li>\n<li><code>chr</code>返回ASCII码对应的字符，<code>ord()</code>是其互补函数</li>\n<li><code>chunk_split($body[,int $chunklen = 76 [,string $end = &quot;\\r\\n&quot; ]] )</code>拆分<code>$body</code>为<code>$chunklen</code>的小块，每块后用<code>$end</code>结尾</li>\n<li><code>crypt</code>返回一个单向字符串散列，<code>md5</code>计算字符串的MD5散列值，<code>sha1</code>计算sha1散列值</li>\n<li>echo 输出一组字符串</li>\n<li><code>explode</code>使用一个字符串分割另一个字符串；类似地，<code>implode</code>将一个一维数组的值转为字符串。又写作<code>join</code>。</li>\n<li><code>htmlentites</code>转义所有的特殊字符为HTML实体；<code>html_entity_decode()</code>实现相反的步骤。</li>\n<li><code>htmlspecialchars()</code>和<code>htmlspecialchars_decode()</code>完成的功能和上面相似，但是转义的字符只有<code>&amp;</code>，<code>&quot;</code>，<code>&#39;</code>，<code>&lt;</code>，<code>&gt;</code>。</li>\n<li><code>lcfirst</code>将首字母小写，<code>ucfirst</code>将首字母大写，<code>ucwords</code>将每个单词的首字母大写</li>\n<li><code>ltrim</code>，<code>rtrim</code>和<code>trim</code>删除字符串首部，尾端和两端的空白。</li>\n<li><code>str_getcsv</code>解析csv字符串为一个数组</li>\n<li><code>str_pad</code>使用另一个字符串填充字符串到指定长度</li>\n<li><code>str_repeat</code> 重复一个字符串</li>\n<li><code>str_replace</code> 字符串替换，<code>preg_replace</code>的特殊情况</li>\n<li><code>str_shuffle</code>随机打乱一个字符串</li>\n<li><code>str_split</code>将一个字符串转换为数组</li>\n<li><code>strstr</code>查找字符串的第一次出现。<code>stristr()</code>则不区分大小写地查找</li>\n<li><code>strcmp</code>二进制安全字符串比较大小，<code>strncmp</code>类似，不过允许指定比较的长度，<code>strnatcmp</code>以自然顺序比较字符串</li>\n<li><code>strlen</code>获取字符串长度</li>\n<li><code>strpos</code>查找字符串初次出现位置，<code>strrpos</code>查找最后一次出现，<code>strripos</code>不区分大小写查找最后一次出现</li>\n<li><code>strrev</code>反转字符串</li>\n<li><code>strip_tags</code>去除str中的空字符，HTML标记和PHP标记，和<code>fgetss()</code>机制一样</li>\n<li><code>strtoupper</code>将字符串转化为大写，<code>strtolower</code>将字符串转换为小写</li>\n<li><code>strtr()</code>翻译、转换指定字符</li>\n<li><code>substr</code>返回字符串的子串</li>\n<li><code>substr_count</code>返回子字符串在字符串中出现的次数。</li>\n</ul>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><ul>\n<li><code>boolvar()</code>转换变量为bool类型</li>\n<li><code>empty()</code>判断变量是否为空</li>\n<li><code>isset()</code>检测变量是否已设置</li>\n<li><code>intval()</code>获取变量整数值，<code>floatval()</code>获取变量浮点数值，<code>strval()</code>获取变量的字符串表示</li>\n<li><code>get_resource_type()</code>获取资源类型</li>\n<li><code>gettype()</code>获取变量类型，<code>settype($var, string $type)</code>设置变量类型</li>\n<li><code>is_array</code>, <code>is_bool</code>, <code>is_callable</code>, <code>is_float</code>, <code>is_int</code>, <code>is_null</code>, <code>is_numeric</code>, <code>is_object</code>, <code>is_resource</code>, <code>is_scalar</code>, <code>is_string</code>用来检测各种类型。</li>\n<li><code>print_r()</code>和<code>var_dump()</code>打印变量的相关信息，<code>var_export()</code>以合法PHP代码的形式返回变量的字符串表示</li>\n<li><code>serialize()</code>序列化一个变量，<code>unserialize()</code>反序列化一个变量</li>\n<li><code>unset()</code>销毁指定的变量</li>\n</ul>\n<h4 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h4><ul>\n<li><code>spl_autoload_register()</code>尝试在类名未定义时启动类的自动加载</li>\n<li><code>class_alias</code>为一个类创建别名。</li>\n<li><code>class_exists</code>检查指定的类是否定义</li>\n<li><code>get_class()</code>返回对象实例所属类的名字。类似地还有<code>get_class_vars</code>和<code>get_class_methods</code>函数。</li>\n<li><code>get_declare_classes</code>和<code>get_declare_interfaces</code>以及<code>get_declare_traits</code>获取脚本中已定义的类、接口、trait数组。</li>\n<li><code>method_exists( mixed $object , string $method_name )</code>检查类方法是否存在于指定object中，类似地还有<code>property_exsits</code>，<code>interface_exists</code>和<code>trait_exist</code>等</li>\n</ul>\n<h4 id=\"日期和时间\"><a href=\"#日期和时间\" class=\"headerlink\" title=\"日期和时间\"></a>日期和时间</h4><p>PHP中的时间以64为数字存储。使用时需要配置好<code>php.ini</code>中时区等信息。<code>DateTime</code>，<code>DateTimeZone</code>，<code>DateInterval</code>等对象便于进行相关的操作。PHP同时提供了OOP风格和过程化风格两种方式使用函数。其中<code>DateTime</code>和<code>DateTimeImmutable</code>都继承自<code>DateTimeInterface</code>接口，有着<code>diff</code>，<code>format</code>，<code>getTimestamp</code>，<code>getTimezone</code>等方法。</p>\n<p>DateTime中的部分方法如下：</p>\n<ul>\n<li><code>add(DateInterval $interval)</code>在当前时间上加上一个时间段</li>\n<li><code>sub(DateInterval $interval)</code>在当前时间上减去一个时间段。</li>\n<li><code>__construct()</code>，创建一个对象，过程化风格: <code>date_create()</code></li>\n<li><code>createFromFormat</code>创建一种时间格式format的写法格式见<a href=\"https://www.php.net/manual/zh/datetime.createfromformat.php\">参考</a>。</li>\n<li><code>modify</code>修改当前时间，modify为合法的时间格式。</li>\n<li><code>setDate(int $year, int $month, int $day )</code>设置日期</li>\n<li><code>setTime(int $hour ,int $minute [,int $second = 0 ])</code>设置时间。</li>\n<li><code>setTimestamp()</code>设置时间戳。</li>\n</ul>\n<p>上述方法都有对应的过程化风格的对应函数。</p>\n<p>DatePeriod和DateTimeZone等的介绍从略。除了以上的对象方法过程化的函数外，还有以下一些常用方法：</p>\n<ul>\n<li><code>date($format[, $timestamp)</code>，格式化一个本地时间</li>\n<li><code>getdate()</code>，获得日期时间信息，<code>localtime</code>功能类似，返回一个数组。</li>\n<li><code>mktime</code>获得一个日期的时间戳，默认为当前。类似的还有<code>time</code>，<code>microtime</code>，返回一个时间戳类型</li>\n<li><code>strtotime</code>将英文文本的日期时间解析为Unix时间戳</li>\n<li>有意思的是<code>date_sunset</code>和<code>date_sunrise</code>可以获取指定时间戳的日出日落时间</li>\n</ul>\n<h4 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h4><ul>\n<li><code>basename()</code>返回路径的文件名部分；<code>dirname()</code>返回路径中的目录部分，<code>realpath()</code>返回规范的绝对路径名</li>\n<li><code>chgrp()</code>改变文件所属组，类似的还有<code>chmod</code>和<code>chown</code></li>\n<li><code>copy</code>用于拷贝文件，<code>rename</code>用于移动和重命名文件。注意，这里没有delete函数。<code>unlink</code>用于删除文件</li>\n<li><code>link ()</code>建立一个硬连接，<code>linkinfo</code>, <code>lstat</code>给出连接信息。<code>symlink</code>创建一个符号连接。</li>\n<li><code>mkdir</code>和<code>rmdir</code>用来创建和删除文件夹</li>\n<li><code>file</code>把整个文件都入到一个数组中，一行一个元素，可以使用URL作为文件名。<code>file_exists</code>检查文件或目录是否已存在。<code>tmpfile</code>则会建立一个关闭后自动删除的临时文件。</li>\n<li><code>file_get_contents</code>将文件读入到字符串中，可以使用<code>stream_context_create</code>创建上下文进行更细致的操作。</li>\n<li><code>file_put_contents()</code>写文件，和依次调用<code>fopen()</code>, <code>fwrite()</code>, <code>fclose()</code>效果一样。</li>\n<li><code>fileatime</code>, <code>filectime</code>, <code>filemtime</code>, <code>filegroup</code>, <code>fileowner</code>, <code>fileperms</code>, <code>filesize</code>, <code>filetype</code>, <code>stat</code>等和字面意义一样获取文件的各方面信息。它们接收文件路径作为参数。</li>\n<li><code>is_dir</code>, <code>is_executable</code>, <code>is_file</code>, <code>is_link</code>, <code>is_readable</code>, <code>is_uploaded_file</code>, <code>is_writable</code>检查文件各种属性</li>\n<li><code>fopen</code>打开一个文件，返回一个resource句柄，可以交给<code>fread</code>, <code>fwrite</code>, <code>fscanf</code>, <code>fclose</code>等函数做读写操作。</li>\n<li><code>fgets</code>从当前指针处读取一行，<code>fgetc</code>读取一个字符，<code>fstat</code>返回文件信息，<code>ftruncate</code>将文件阶段到给定长度。</li>\n<li><code>glob()</code>寻找和pattern匹配的文件路径</li>\n</ul>\n<p>Directory类通过<code>dir()</code>创建。Directory实例有<code>close</code>，<code>read</code>，<code>rewind</code>三种方法。分别用来释放句柄，读取条目和倒回开头。初次以外还有下面这些常用的目录相关函数。</p>\n<ul>\n<li><code>chdir(string $directory)</code>用来改变当前目录，</li>\n<li><code>getcwd</code>取得当前工作目录</li>\n<li><code>scandir()</code>返回一个包含目录中所有文件和目录的数组</li>\n<li><code>closedir()</code>关闭通过<code>opendir()</code>打开的目录流。</li>\n<li><code>readdir()</code>返回目录中下一个文件的文件名。文件名以在文件系统中的排序返回。</li>\n</ul>\n<h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>下面这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式：</p>\n<ul>\n<li><code>debug_backtrace()</code>产生一条PHP的回溯跟踪，返回数组类型；<code>debug_print_backtrace()</code>则将回溯打印出来。</li>\n<li><code>error_get_last()</code>获取最后一个发生错误的信息，<code>error_clear_last()</code>清除最后一个错误信息</li>\n<li><code>error_log()</code>发送错误信息到web服务器的错误日志或是一个文件里。</li>\n<li><code>error_reporting()</code>设置应该报告的PHP错误级别。</li>\n<li><code>set_error_handler</code>, <code>set_exception_handler</code>, <code>restore_error_handler</code>, <code>restore_exception_handler</code>分别是设置和重置错误以及异常处理的函数</li>\n<li><code>trigger_error()</code>触发一个用户级别的错误条件，在运行出现异常时，需要产生一个特定响应时很有用。</li>\n</ul>\n<h4 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h4><p>在会话支持下，每个访问网站的用户都有一个唯一的id标识，这个标识可以存储在cookie中，也可以通过URL传递。当一个访问者访问网站时，PHP将自动检查(如果<code>session.auto_start</code>被设置为1）或者在你要求下检查(明确通过<code>session_start()</code>或者隐式通<code> session_register()</code>) 当前会话 id 是否是先前发送的请求创建. 如果是这种情况，那么先前保存的环境将被重建。</p>\n<p>安全方面需要注意以下几点：</p>\n<ul>\n<li><code>session.cookie_lifetime=0</code>, 即浏览器不持久化存储cookie数据</li>\n<li><code>session.use_cookies=On</code> 并且<code>session.use_only_cookies=On</code>，即通过HTTP cookie实现会话ID管理</li>\n<li><code>session.use_strict_mode=On</code>，即禁止使用未初始化会话id的会话，从而防止Javascript进行会话ID的注入</li>\n<li><code>session.cookie_httponly=On</code>，禁止Javascript访问会话ID</li>\n<li><code>session.cookie_secure=On</code>，仅在HTTPS协议下访问session ID，用在仅支持HTTPS的站点</li>\n<li><code>session.hash_function=&quot;sha256&quot;</code>。 高强度的散列函数可以产生高强度的会话ID</li>\n</ul>\n<p>其他注意事项可以在PHP的<a href=\"http://php.net/manual/zh/session.security.php\">会话与安全章节</a>找到，根据实际需要选择。下面是一些session函数的使用:</p>\n<ul>\n<li><code>session_destroy()</code>, 销毁一个会话里的全部数据，但不会重置相关全局变量也不会重置cookie，再次使用时需要重新调用<code>session_start()</code>函数。为彻底删除session，需要调用<code>setcookie()</code>清除cookie中的session ID。</li>\n<li><code>session_cache_expire()</code>设置或读取当前缓存到期时间（这个只和浏览器页面刷新缓存有关）</li>\n<li><code>session_id()</code>获取&#x2F;设置当前会话ID，PHP仅允许会话ID包括a-z A-Z 0-9 ,（逗号） -（减号）.如果不是用cookie来存储session ID，session ID通常附在SID常量中，放在URL里。</li>\n<li><code>session_regenerate_id()</code>在不修改当前session数据的前提下使用新的ID替换原有会话ID。如果启用了<code>session.use_trans_sid</code>选项,那么必须在调用<code>session_regenerate_id()</code>函数之后开始进行输出工作，否则会导致使用原有的会话 ID</li>\n<li><code>session_start()</code>创建新会话或者重用现有会话。 如果通过GET或者POST方式，或者使cookie提交了会话ID，则会重用现有会话。</li>\n<li><code>session_status()</code>返回当前会话状态</li>\n<li><code>session_write_close()</code>写入session数据，然后关闭会话</li>\n<li><code>session_name()</code>设置或返回当前回话名称，名称应短小易懂，且不能由纯数字组成，如<code>website_id</code>。</li>\n<li><code>session_save_path()</code>读取&#x2F;设置当前会话的保存路径</li>\n<li><code>session_unset()</code>释放当前会话注册的所有会话变量</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><p>这部分函数提供执行系统本身命令的能力。注意，<strong>以加锁方式打开的文件，必须在执行后台程序前关闭</strong>。</p>\n<ul>\n<li><code>escapeshellarg(string $arg)</code>和<code>escapeshellcmd(string $command)</code>对参数和命令元字符转义，保证安全。</li>\n<li><code>exec()</code>和<code>passthru()</code>都能执行一个外部程序，区别是前者返回结果的最后一行，后者返回未经处理的全部输出数据。</li>\n<li><code>shell_exec()</code>在shell环境下执行命令，以字符串的形式返回完整的字符串。</li>\n<li><code>system(string $command[, int &amp;$return_var ] )</code>执行 command 参数所指定的命令，并且输出执行结果。</li>\n</ul>\n<h4 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h4><ul>\n<li><code>call_user_func(callable $callback [, mixed $parameter [, mixed $... ]])</code>把第一个参数作为回掉函数调用。在参数很多时，建议使用$callback(…values)的形式传入数组。类似的还有<code>forward_static_call</code>和<code>forward_static_call_array</code>用来调用静态方法。</li>\n<li><code>func_get_arg(int $arg_num)</code>和<code>func_get_arg()</code>返回自定义函数的参数和参数列表，用在函数体内。</li>\n<li><code>function_exists()</code>判断函数是否定义</li>\n<li><code>register_shutdown_function</code>, <code>register_tick_function</code>用来注册<code>exit</code>之后和每个tick后执行的函数</li>\n</ul>\n<h4 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h4><p>这部分函数自5.1.2版本后成为核心的一部分。</p>\n<ul>\n<li><code>hash()</code>根据指定的哈希算法生成哈希值。类似的还有<code>hash_file</code>。</li>\n<li><code>hash_hmac()</code>使用HMAC方法生成带有密钥的哈希值，类似的还有<code>hash_hmac_file</code>。</li>\n<li><code>hash_init()</code>初始化一个哈希运算上下文，返回resource类型</li>\n<li><code>hash_update(resource $context , string $data)</code>向活跃的哈希运算上下文中填充数据。细化的，还有<code>hash_update_file</code>和<code>hash_update_stream</code>两个函数。</li>\n<li><code>hash_final()</code>结束哈希上下文，返回摘要内容。</li>\n<li><code>hash_copy()</code>返回一个哈希运算上下文副本。</li>\n</ul>\n<h4 id=\"PHP自身\"><a href=\"#PHP自身\" class=\"headerlink\" title=\"PHP自身\"></a>PHP自身</h4><p>这些函数允许你获得许多关于PHP本身的参数。</p>\n<ul>\n<li><code>assert()</code>检查一个断言是否为FALSE，并在失败的时候调用<code>assert_options()</code>中指定的回调函数</li>\n<li><code>dl()</code>运行时加载一个PHP扩展</li>\n<li><code>get_cfg_var()</code>获取PHP配置选项的值</li>\n<li><code>get_current_user()</code>获取当前PHP脚本所有者名称</li>\n<li><code>get_included_files()</code>返回被include和require文件名的 array</li>\n<li><code>ini_get()</code>获取一个配置选项的值</li>\n<li><code>ini_set()</code>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复</li>\n<li><code>ini_restore()</code>恢复指定的配置选项到它的原始值</li>\n<li><code>memory_get_usage()</code>返回当前分配给你的 PHP 脚本的内存量，单位是字节（byte）</li>\n<li><code>php_sapi_name()</code>返回web服务器和PHP之间的接口类型</li>\n<li><code>php_uname()</code>返回运行PHP的系统的有关信息</li>\n<li><code>phpinfo([int $what = INFO_ALL])</code>输出关于 PHP 配置的信息。可以通过<code>what</code>筛选输出内容。</li>\n<li><code>phpversion()</code>获取当前的PHP版本</li>\n<li><code>version_compare()</code>对比两个「PHP 规范化」的版本数字字符串</li>\n</ul>\n<h4 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h4><p>这部分函数处理integer和float范围内的计算。预定义常量包括<code>M_PI</code>, <code>M_E</code>, <code>M_LOG2E</code>, <code>M_LN2</code>, <code>M_PI_2</code>, <code>M_1_PI</code>, <code>M_SQRT2</code>, <code>M_SQRT3</code>, <code>INF</code>等诸多数学常量。函数名和其他语言类似。</p>\n<ul>\n<li>三角函数相关：<code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>计算单位为弧度</li>\n<li>双曲函数相关：<code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code>, <code>atan2</code></li>\n<li>对数相关：<code>log</code>, <code>log10</code>, <code>log1p</code></li>\n<li>指数相关：<code>pow</code>, <code>exp</code>, <code>expm</code></li>\n<li>近似相关：<code>round</code>, <code>floor</code>, <code>ceil</code></li>\n<li>随机数相关： <code>rand(int $min , int $max)</code>, <code>mt_rand</code>（用法同<code>rand</code>，性能更好）, <code>srand</code>和<code>mt_srand</code>（现已不需要使用）</li>\n<li>进制转换相关：<code>bindec</code>, <code>octdec</code>, <code>hexdec</code>转为十进制数（读取字符串，输出数字），相对应还有<code>decbin</code>, <code>decbin</code>, <code>dechex</code>。<code>base_convert()</code>可以做任意进制转换</li>\n<li>角度相关：<code>deg2rad</code>角度转弧度</li>\n<li>运算相关：<code>intdiv</code>返回商的整数部分，<code>fmod</code>返回浮点数余数。<code>abs</code>计算绝对值，<code>sqrt</code>计算开根号</li>\n<li>判断相关：<code>is_finite</code>, <code>is_infinite</code>, <code>is_nan</code>,</li>\n<li>其他：<code>max</code>, <code>min</code>（可以输入数组）, <code>pi</code>, <code>hypot</code>（根据直角边计算三角形斜边长）</li>\n</ul>\n<h4 id=\"输出控制\"><a href=\"#输出控制\" class=\"headerlink\" title=\"输出控制\"></a>输出控制</h4><p>PHP脚本有输出时，输出控制函数可以用这些来控制输出。如通过<code>ob_start()</code>将下文的输出放在缓冲区直到调用<code>ob_end_flush()</code>。通常配合<code>header()</code>使用，在真正返回数据前写入header和cookie。</p>\n<p>从略。</p>\n<h4 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h4><ul>\n<li><code>constant()</code>返回一个常量的值</li>\n<li><code>define()</code>定义一个常量</li>\n<li><code>exit()</code>输出一个消息并且退出当前脚本，<code>die</code>是<code>exit</code>的同名函数。</li>\n<li><code>highlight_file()</code>语法高亮一个文件</li>\n<li><code>highlight_string()</code>语法高亮一个字符串，使用方法同上。</li>\n<li><code>sleep()</code>延迟指定秒数执行。类似的还有<code>usleep</code>以指定微秒数暂缓执行，<code>time_sleep_until</code>使脚本睡眠到指定时间</li>\n<li><code>uniqid()</code>返回一个基于当前微秒级时间的带前缀的唯一ID。</li>\n</ul>\n<h3 id=\"绑定拓展库\"><a href=\"#绑定拓展库\" class=\"headerlink\" title=\"绑定拓展库\"></a>绑定拓展库</h3><p>下面的拓展库绑定在PHP发行包中。较之内核部分的函数，更偏向为解决某类问题而设计。这里也只摘选部分常用的介绍。</p>\n<h4 id=\"Ctype\"><a href=\"#Ctype\" class=\"headerlink\" title=\"Ctype\"></a>Ctype</h4><p>用来检测 在当前的区域设定下，一个字符或者字符串 是否仅包含指定类型的字符。根据官方描述，<strong>“如果可以满足需求，请优先考虑使用 ctype 函数， 而不是正则表达式或者对应的 “str_*” 和 “is_*” 函数。 因为 ctype 使用的是原生 C 库，所以会有明显的性能优势”</strong>。在4.2.0版本后，这些函数是默认启动的。</p>\n<ul>\n<li><code>ctype_alpha()</code>纯字符检测</li>\n<li><code>ctype_upper()</code>大写字母检测</li>\n<li><code>ctype_lower()</code>小写字母检测</li>\n<li><code>ctype_digit()</code>纯数字检测</li>\n<li><code>ctype_alnum()</code>检查字符串内的字符否全部为字母或数字</li>\n<li><code>ctype_cntrl()</code>控制字符检测</li>\n<li><code>ctype_print()</code>字符是否都可以打印</li>\n<li><code>ctype_graph()</code>字符输出是否都是可见的</li>\n<li><code>ctype_punct()</code>字符是否都可打印却不是字母数组和空白</li>\n<li><code>ctype_space()</code>空白字符检测</li>\n<li><code>ctype_xdigit()</code>十六进制字符串检测</li>\n</ul>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><p>在PHP5.3版本后，原来的POSIX Regex不再推荐使用。兼容Perl的正则表达式库PCRE仍可以使用，且默认开启。这里仅介绍PCRE相关函数，它们均以<code>preg</code>开头。</p>\n<ul>\n<li><code>preg_match()</code>返回pattern在subject中的匹配次数</li>\n<li><code>preg_match_all()</code>搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以指定顺序输出到matches结果中.</li>\n<li><code>preg_replace()</code>执行一个正则表达式的搜索和替换，当$pattern和$replacement都是数组时，会进行相对应位置的替换。</li>\n<li><code>preg_grep(string $pattern , array $input [, int $flags = 0 ])</code>返回给定数组input中与模式pattern 匹配的元素组成的数组.</li>\n<li><code>preg_split()</code>通过正则表达式分割字符串，返回一个数组。</li>\n</ul>\n<h4 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h4><p>自5.2.0起，JSON拓展默认内置并编译进PHP。</p>\n<ul>\n<li><code>json_encode()</code>JSON编码一个变量。</li>\n<li><code>json_decode()</code>解码一个JSON格式的字符串</li>\n<li><code>json_last_error()</code>返回JSON编码时最后的错误</li>\n</ul>\n<h4 id=\"多字节字符串\"><a href=\"#多字节字符串\" class=\"headerlink\" title=\"多字节字符串\"></a>多字节字符串</h4><p>在汉语中，每个字符通常占用2个字节，在使用string的相关函数时，可能会出现意外问题。多字节字符串即为了解决此问题。这不是一个默认扩展，需要在configure选项中显式激活。详见<a href=\"http://php.net/manual/zh/mbstring.installation.php\">安装</a>。另外，<code>mbstring</code>支持“函数重载”，即使用<code>mb_xxx</code>替代原有的字符串函数。</p>\n<ul>\n<li><code>mb_detect_encoding()</code>检测字符的编码</li>\n<li><code>mb_ereg_xxx</code>打头的与<code>preg_xxx</code>同名的函数为正则匹配多字节版</li>\n<li><code>mb_strlen()</code>获取字符串长度。</li>\n<li><code>mb_split()</code>使用正则表达式分割多字节字符串</li>\n<li><code>mb_substr()</code>执行一个多字节安全的<code>substr()</code>操作</li>\n<li><code>mb_strpos()</code>查找字符串在另一个字符串中首次出现的位置；类似地，<code>mb_strrpos</code>查找最后出现的位置。</li>\n<li><code>mb_strstr ()</code>查找字符串在另一个字符串里的首次出现；类似地，<code>mb_strrchr()</code>查找指定字符在另一个字符串中最后一次的出现</li>\n</ul>\n<h4 id=\"BCMath\"><a href=\"#BCMath\" class=\"headerlink\" title=\"BCMath\"></a>BCMath</h4><p>这部分函数进行任意大小和精度的数字的二进制计算。自4.0.4后随PHP一起发布。Windows版本下是默认支持的。</p>\n<ul>\n<li><code>string bcadd(string $left_operand , string $right_operand [, int $scale ] )</code>加法。scale用来决定小数点位数，输入输出均未string类型，下同。</li>\n<li><code>bcsub()</code>减法</li>\n<li><code>int bccomp()</code>比较</li>\n<li><code>bcmul()</code>乘法</li>\n<li><code>bcdiv()</code>除法</li>\n<li><code>bcmod()</code>取模</li>\n<li><code>bcpow()</code>乘方</li>\n<li><code>bcsqrt()</code>二次方根</li>\n<li><code>bcscale()</code>设置所有bc数学函数的默认小数点位数</li>\n</ul>\n<h4 id=\"图像处理\"><a href=\"#图像处理\" class=\"headerlink\" title=\"图像处理\"></a>图像处理</h4><p>PHP可以处理各种格式的图像，并把它们输出到浏览器。这需要在编译时指定GD库（除了<code>getimagesize()</code>函数）。GD库不仅能处理图像，还能对字体进行处理。使用PHP可以动态修改图像文件，或为图像添加水印信息，甚至创建一个图像。</p>\n<p>下面是和图像信息相关的函数：</p>\n<ul>\n<li><code>gd_info()</code>获取当前安装的GD库信息</li>\n<li><code>getimagesize()</code>获取图像大小，返回数组类型，按顺序分别是宽度，高度，类型，描述宽高的字符串。<code>getimagesizefromstring</code>函数则通过打开的图片信息（字符串格式）中读取图像尺寸信息</li>\n<li><code>image_type_to_extension()</code>获取图像类型的文件后缀</li>\n<li><code>imageistruecolor(resource $image)</code>检查图像是否为真彩色</li>\n<li><code>imagesx()</code>返回image所代表的图像宽度；<code>imagesy()</code>返回所代表的图像高度</li>\n<li><code>imagetypes()</code>返回PHP支持的图像类型，int类型。</li>\n</ul>\n<p>剩下还有众多以<code>image</code>开头的和创建、输出、删除图像，画图、编辑图片、设置颜色、设置字体相关的函数，见<a href=\"https://www.php.net/manual/zh/book.image.php\">参考</a>。</p>\n<h4 id=\"Exif\"><a href=\"#Exif\" class=\"headerlink\" title=\"Exif\"></a>Exif</h4><p>通过Exif拓展，可以操作图像元数据。必须使用<code>--enable-exif</code>选项编译PHP，Windows用户还需要启用mbstring扩展。</p>\n<ul>\n<li><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名</li>\n<li><code>exif_read_data()</code>函数从JPEG或TIFF图像文件中读取EXIF头信息</li>\n<li><code>exif_thumbnail()</code>读取TIFF或JPEG图像中的嵌入缩略图。如果图像不包含缩略图则返回FALSE</li>\n</ul>\n<h4 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h4><p>Socket拓展基于流行的BSD sockets，实现了和socket通讯功能的底层接口。在编译PHP时必须在配置中添加—enable-sockets配置项。利用这部分函数可以很方便地搭建起socket服务器和客户端，示例见<a href=\"http://php.net/manual/zh/sockets.examples.php\">官网</a>。</p>\n<ul>\n<li><code>socket_create(int $domain , int $type , int $protocol)</code>创建并返回一个套接字（resource类型）。其中<code>domain</code>指定使用的网络协议族，<code>type</code>指定建立的套接字类型，<code>protocol</code>指定使用的具体协议。</li>\n<li><code>socket_create_listen()</code>在某端口打开socket以接收连接。</li>\n<li><code>socket_bind()</code>绑定网络地址到套接字的源。</li>\n<li><code>socket_connect()</code>使用address作为目的地址，建立套接字连接。</li>\n<li><code>socket_listen()</code>在创建好socket资源，并绑定了source address后，可以调用此函数监听进入的数据流。</li>\n<li><code>socket_accept()</code>在依次使用socket_create创建套接字，使用<code>socket_bind</code>绑定端口，使用<code>socket_listen</code>监听连接后。该函数允许到此套接字上的连接，返回一个新的socket资源用来通信。</li>\n<li><code>socket_read()</code>从已连接的socket中读取一段长度的数据，返回读出的数据。</li>\n<li><code>socket_recv()</code>功能同上，返回字节数并将数据存放在<code>$buf</code>中。</li>\n<li><code>socket_recvfrom() </code>从已连接和还未连接的socket中读取数据。</li>\n<li><code>socket_write()</code>向socket中写入数据</li>\n<li><code>socket_send()</code>向已连接的socket中写入数据。</li>\n<li><code>socket_sendto()</code>向socket中发送数据而不管是否已连接</li>\n<li><code>socket_getsockname()</code>和<code>socket_getpeername()</code>获取本地和远端socket信息</li>\n<li><code>socket_set_block()</code>和<code>socket_set_nonblock()</code>设置socket是否阻塞</li>\n<li><code>socket_set_option()</code>设置套接字选项</li>\n<li><code>socket_shutdown()</code>停止从socket中读写数据</li>\n<li><code>socket_close()</code>关闭给定的socket资源</li>\n</ul>\n<h3 id=\"外部拓展库\"><a href=\"#外部拓展库\" class=\"headerlink\" title=\"外部拓展库\"></a>外部拓展库</h3><p>这些扩展库已经绑定在PHP发行包中，但是要编译以下扩展库，需要外部的库文件。这里仅介绍常用的cURL库。Mysqli和Mongo等可能会用得到的库介绍从略。</p>\n<h4 id=\"client-URL\"><a href=\"#client-URL\" class=\"headerlink\" title=\"client URL\"></a>client URL</h4><p>PHP支持Daniel Stenberg创建的libcurl库，能够连接通讯各种服务器、使用各种协议。这些curl函数在PHP 4.0.2中引入。需要安装libcurl包才能使用PHP的cURL函数。安装过程从略。curl的使用流程思路和socket，mysql等十分相似，先使用<code>curl_init()</code>初始化会话，再使用<code>curl_setopt()</code>设置选项，然后通过<code>curl_exec()</code>执行会话，最后使用<code>curl_close()</code>关闭。</p>\n<ul>\n<li><code>curl_setopt()</code>设置一个传输选项，常用的设置包括<code>CURLOPT_URL</code>, <code>CURLOPT_HEADER</code>, <code>CURLOPT_RETURNTRANSFER</code>, <code>CURLOPT_TIMEOUT</code>等。类似的，还有<code>curl_setopt_array</code>函数。</li>\n<li><code>curl_reset()</code>重置一个libcurl会话句柄的所有的选项</li>\n<li><code>curl_exec()</code>执行一个cURL会话。返回TRUE或执行的结果，或是FALSE。</li>\n<li><code>curl_close()</code>关闭一个会话，释放所有相关资源</li>\n<li><code>curl_getinfo()</code>获取最后一次传输的相关信息。</li>\n<li><code>curl_error()</code>返回一条最近一次cURL操作明确的文本的错误信息</li>\n<li><code>curl_version()</code>获取cURL版本信息</li>\n</ul>\n<h2 id=\"特色\"><a href=\"#特色\" class=\"headerlink\" title=\"特色\"></a>特色</h2><p>这里列举的特点更多是PHP语言的特殊使用方式与应用特性。如HTTP用户认证（介绍见<a href=\"http://php.net/manual/zh/features.http-auth.php\">官网</a>），cookie等。</p>\n<p>PHP透明地支持HTTP cookie，在PHP的网络函数中可以用<code>setcookie()</code>或<code>setrawcookie()</code>函数来设置cookie。cookie是HTTP标头的一部分，因此<code>setcookie()</code>函数必须在其它信息被输出到浏览器前调用，这和对header()函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的cookie或者其它HTTP标头。</p>\n<p>PHP允许用户使用POST方法上传文本和二进制文件。一个上传文件的HTML表单代码类似如下，其中的<code>MAX_FILE_SIZE</code>隐藏字段在浏览器端限制了文件大小（单位字节，不建议依赖于此）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- The data encoding type, enctype, MUST be specified as below --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&quot;multipart/form-data&quot;</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;__URL__&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- MAX_FILE_SIZE must precede the file input field --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MAX_FILE_SIZE&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;30000&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Name of input element determines name in $_FILES array --&gt;</span></span><br><span class=\"line\">    Send this file: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userfile&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Send File&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>全局变量<code>$_FILES</code>自PHP4.1.0起存在，包含了所有上传的文件信息。<code>$_FILES[&#39;userfile&#39;]</code>数组有<code>name</code>, <code>type</code>, <code>size</code>, <code>tmp_name</code>, <code>error</code>等字段。error字段状态码在0-7间，分别表示上传成功&#x2F;文件过大&#x2F;部分上传&#x2F;没有文件&#x2F;找不到临时文件夹&#x2F;写入失败。文件被上传后，默认地会被储存到服务端的默认临时目录中。</p>\n<p>PHP支持同时上传多个文件并将它们的信息自动以数组的形式组织。要完成这项功能，需要在HTML表单中对文件上传域使用和多选框与复选框相同的数组式提交语法。像下面的代码那样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;file-upload.php&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class=\"line\">  Send these files:<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userfile[]&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userfile[]&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Send files&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，PHP还支持PUT方法上传文件，内容见官方文档。下面是一个允许用户上传图片的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">header</span>(<span class=\"string\">&#x27;Content-Type: text/plain; charset=utf-8&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Undefined | Multiple Files | $_FILES Corruption Attack</span></span><br><span class=\"line\">    <span class=\"comment\">// If this request falls under any of them, treat it invalid.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !<span class=\"keyword\">isset</span>(<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;error&#x27;</span>]) ||</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">is_array</span>(<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;error&#x27;</span>])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Invalid parameters.&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check $_FILES[&#x27;upfile&#x27;][&#x27;error&#x27;] value.</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;error&#x27;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPLOAD_ERR_OK:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPLOAD_ERR_NO_FILE:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;No file sent.&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPLOAD_ERR_INI_SIZE:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPLOAD_ERR_FORM_SIZE:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Exceeded filesize limit.&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Unknown errors.&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// You should also check filesize here. </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;size&#x27;</span>] &gt; <span class=\"number\">1000000</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Exceeded filesize limit.&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// DO NOT TRUST $_FILES[&#x27;upfile&#x27;][&#x27;mime&#x27;] VALUE !!</span></span><br><span class=\"line\">    <span class=\"comment\">// Check MIME Type by yourself.</span></span><br><span class=\"line\">    <span class=\"variable\">$finfo</span> = <span class=\"keyword\">new</span> <span class=\"title function_ invoke__\">finfo</span>(FILEINFO_MIME_TYPE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === <span class=\"variable\">$ext</span> = <span class=\"title function_ invoke__\">array_search</span>(</span><br><span class=\"line\">        <span class=\"variable\">$finfo</span>-&gt;<span class=\"title function_ invoke__\">file</span>(<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]),</span><br><span class=\"line\">        <span class=\"keyword\">array</span>(</span><br><span class=\"line\">            <span class=\"string\">&#x27;jpg&#x27;</span> =&gt; <span class=\"string\">&#x27;image/jpeg&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;png&#x27;</span> =&gt; <span class=\"string\">&#x27;image/png&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;gif&#x27;</span> =&gt; <span class=\"string\">&#x27;image/gif&#x27;</span>,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">    )) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Invalid file format.&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// You should name it uniquely.</span></span><br><span class=\"line\">    <span class=\"comment\">// DO NOT USE $_FILES[&#x27;upfile&#x27;][&#x27;name&#x27;] WITHOUT ANY VALIDATION !!</span></span><br><span class=\"line\">    <span class=\"comment\">// On this example, obtain safe unique name from its binary data.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title function_ invoke__\">move_uploaded_file</span>(</span><br><span class=\"line\">        <span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>],</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">sprintf</span>(<span class=\"string\">&#x27;./uploads/%s.%s&#x27;</span>,</span><br><span class=\"line\">            <span class=\"title function_ invoke__\">sha1_file</span>(<span class=\"variable\">$_FILES</span>[<span class=\"string\">&#x27;upfile&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]),</span><br><span class=\"line\">            <span class=\"variable\">$ext</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    )) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(<span class=\"string\">&#x27;Failed to move uploaded file.&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;File is uploaded successfully.&#x27;</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (<span class=\"built_in\">RuntimeException</span> <span class=\"variable\">$e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"variable\">$e</span>-&gt;<span class=\"title function_ invoke__\">getMessage</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在php.ini文件中激活了<code>allow_url_fopen</code>选项后，可以在大多数需要用文件名作为参数的函数中使用HTTP和FTP的URL来代替文件名。同时，也可以在<code>include</code>、<code>include_once</code>、<code>require</code>及<code>require_once</code>语句中使用URL。如果有合法的访问权限，以一个用户的身份和某FTP服务器建立了链接，还可以向该FTP服务器端的文件进行写操作。</p>\n<p>持久的数据库连接是指在脚本结束运行时不关闭的连接。当收到一个持久连接的请求时。PHP将检查是否已经存在一个（前面已经开启的）相同的持久连接。如果存在，将直接使用这个连接；如果不存在，则建立一个新的连接。所谓“相同”的连接是指用相同的用户名和密码到相同主机的连接。</p>\n<p>PHP 5.3后使用GC作为新的垃圾回收机制。每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。通常，PHP中的垃圾回收机制，仅仅在循环回收算法确实运行时会有时间消耗上的增加。但是在平常的(更小的)脚本中应根本就没有性能影响。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>PHP作为一种强大的语言，无论是以模块还是CGI的方式安装，它的解释器都可以在服务器上访问文件、运行命令以及创建网络连接等。这些功能也许会给服务器添加很多不安全因素，但是只要正确地安装和配置PHP，以及编写安全的代码，那么PHP相对于Perl和C来说，是能创建出更安全的CGI程序的。这部分提出一些原则，在不同环境下尽可能提高安全性。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>以CGI模式安装PHP时，它的设计可以用以避免访问系统文件和服务器的任意目录。在安装时配置一些选项可以有助避免这类攻击。具体见<a href=\"http://php.net/manual/zh/security.cgi-bin.attacks.php\">文档介绍</a>。同理，以Apache模块安装时，权限的注意也请见<a href=\"https://www.php.net/manual/zh/security.apache.php\">官网介绍</a>。</p>\n<h3 id=\"Session安全\"><a href=\"#Session安全\" class=\"headerlink\" title=\"Session安全\"></a>Session安全</h3><p>这部分见<a href=\"####session\">Session部分</a>的安全介绍。</p>\n<h3 id=\"文件系统-1\"><a href=\"#文件系统-1\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h3><p>PHP被设计为以用户级别来访问文件系统，所以完全有可能通过编写一段PHP代码来读取系统文件如<code>/etc/passwd</code>，更改网络连接以及发送大量打印任务等等。因此必须确保PHP代码读取和写入的是合适的文件。</p>\n<p>由于PHP的文件系统操作是基于C语言的函数的，Null字符在C语言中用于标识字符串结束，一个完整的字符串是从其开头到遇见Null字符为止。因此，任何用于操作文件系统的字符串（特别是程序外部输入的字符串）都必须经过适当的检查。</p>\n<p>这种安全问题也会出现在执行来自用户输入的命令。通常有两条路可以选择：1）检查所有来自外部的变量（<strong>黑名单</strong>）；2）后台写死可以执行的文件名或命令有限集（<strong>白名单</strong>）</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>由于敏感数据和机密数据通常存储在数据库中，数据库安全和保护显得尤为重要。<strong>PHP本身并不能保护数据库的安全</strong>。这里只是讲述怎样用PHP脚本对数据库进行基本的访问和操作。</p>\n<p><strong>设计数据库时，永远不要使用数据库所有者或超级用户帐号来连接数据库</strong>，因为这些帐号可以执行任意的操作。应该为程序的每个方面创建不同的数据库帐号，并赋予对数据库对象的极有限的权限。同时，一些功能可以用视图（view）、触发器（trigger）或者规则（rule）在数据库层面完成。</p>\n<p><strong>连接数据库</strong>时，把连接建立在 SSL 加密技术上可以增加客户端和服务器端通信的安全性，或者SSH也可以用于加密客户端和数据库之间的连接。</p>\n<p><strong>存储模型</strong>中，可以散列一些没必要明文显示的数据，建议加盐散列，同时采用新的SHA散列算法（如SHA-2或SHA-3）以增加安全程度。</p>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><p>这部分内容是极为常见的网络安全问题，通过构造特殊的SQL语句，获取数据库信息甚至主机权限，介绍从略。</p>\n<p>在预防措施上，<strong>永远不要信任外部输入的任何数据，包括表单里和cookie的信息</strong>。</p>\n<ul>\n<li>使用权限被严格限制的帐号访问数据库</li>\n<li>检查输入的数据是否具有所期望的数据格式</li>\n<li>减少SQL语句的拼接使用</li>\n<li>使用数据库特定的敏感字符转义函数</li>\n<li>还可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图</li>\n</ul>\n<h3 id=\"错误报告\"><a href=\"#错误报告\" class=\"headerlink\" title=\"错误报告\"></a>错误报告</h3><p>错误报告是一把双刃剑。一方面可以提高安全性，另一方面又有利于攻击者收集服务器的信息以便寻找弱点。PHP的独有的错误提示风格可以说明系统在运行 PHP，一个函数错误可能暴露系统正在使用的数据库，一个文件系统或者PHP的错误就会暴露web服务器具有什么权限，以及文件在服务器上的组织结构等。</p>\n<p>有三个常用的办法处理这些问题。第一个是彻底地检查所有函数，并尝试弥补大多数错误。第二个是对在线系统彻底关闭错误报告。第三个是使用 PHP 自定义的错误处理函数创建自己的错误处理机制</p>\n<p>可以通过<code>error_reporting()</code>帮助找到错误所在并使代码更安全。发布程序前，设置为<code>E_ALL</code>找到所有使用不当的地方；正式发布后，设为0彻底关闭错误报告或设置<code>php.ini</code>中的<code>display_errors</code>为<code>off</code>。</p>\n<h3 id=\"隐藏PHP\"><a href=\"#隐藏PHP\" class=\"headerlink\" title=\"隐藏PHP\"></a>隐藏PHP</h3><p>一些简单的方法可以帮助隐藏 PHP，这样做可以提高攻击者发现系统弱点的难度。在<code>php.ini</code>文件里设置<code>expose_php = off</code>，可以减少他们能获得的有用信息。</p>\n<p>另一个策略就是让web服务器用PHP解析不同扩展名。无论是通过<code>.htaccess</code>文件还是Apache的配置文件，都可以设置能误导攻击者的文件扩展名。</p>\n<p>更多机智的隐藏方法见官网<a href=\"https://www.php.net/manual/zh/security.hiding.php\">隐藏PHP</a>一节。</p>\n<h2 id=\"内核-1\"><a href=\"#内核-1\" class=\"headerlink\" title=\"内核\"></a>内核</h2><p>考虑到重点所在，这部分内容仅简单地介绍一些涉及到PHP内部原理的东西。由于PHP运行在C语言的基础上，以下的内容和C语言编程靠近。</p>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><p>用C语言编程时，开发者要手工地进行内存管理。因为PHP经常用作Web服务器的模块，内存管理与预防内存泄漏紧密关联。此外，Zend引擎要面对一个十分特殊的使用模式：在一段比较短的时间内，许多zval结构大小的内存块和其他的小内存块被请求又再被释放。为了满足以上的需求，Zend引擎提供为了处理请求相关数据提供了一种特殊的内存管理器。请求相关数据是指只需要服务于单个请求，最迟会在请求结束时释放的数据。<em>API介绍从略</em>。</p>\n<p>因为安全原因，在请求结束时，Zend引擎会释放所有由上面提到的API所分配的内存。</p>\n<h3 id=\"变量使用\"><a href=\"#变量使用\" class=\"headerlink\" title=\"变量使用\"></a>变量使用</h3><p>PHP变量，通常来说，由两部分组成：标签（例如，可能是符号表中的一个条目）和实际变量容器。变量容器，在代码中称为zval，掌握了所需处理变量的所有数据。 包括实际值、当前类型、统计指向此容器的标签的数量，和指示这些标签是引用还是副本的标志。在PHP 5.3中，结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> <span class=\"title\">zval</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> _<span class=\"title\">zvalue_value</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">long</span> lval;                 <span class=\"comment\">/* long value */</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dval;               <span class=\"comment\">/* double value */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span>                   <span class=\"comment\">/* string type */</span></span><br><span class=\"line\">        <span class=\"type\">char</span> *val;</span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">    &#125; str;</span><br><span class=\"line\">    HashTable *ht;             <span class=\"comment\">/* hash table value */</span></span><br><span class=\"line\">    zend_object_value obj;</span><br><span class=\"line\">&#125; zvalue_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Variable information */</span></span><br><span class=\"line\">    zvalue_value value;        <span class=\"comment\">/* value */</span></span><br><span class=\"line\">    zend_uint refcount__gc;</span><br><span class=\"line\">    zend_uchar type;           <span class=\"comment\">/* active type */</span></span><br><span class=\"line\">    zend_uchar is_ref__gc;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有关函数，类和对象，流等的介绍从略。</p>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><p>Q: PHP 版本之间有什么联系？<br>A: PHP&#x2F;FI 2.0是最早的PHP版本，已经不再支持。PHP 3是PHP&#x2F;FI 2.0的后继者，要好很多。PHP 5是目前一代的PHP，内部使用了Zend 2引擎，除了很多新功能之外还提供了许多附加的面向对象编程（OOP）特性。<br><br><br>Q: 可以同时运行几个不同版本的PHP吗？<br>A: 可以，请参阅见PHP源程序发行包中的 INSTALL文件。<br><br><br>Q: 应该上哪儿去找我的<code>php.ini</code>文件<br>A: UNIX中默认在<code>/usr/local/lib</code>目录中，也就是<code>&lt;install-path&gt;/lib</code>。可以在编译时通过 <code>--with-config-file-path</code>标记来改变路径。Windows中<code>php.ini</code>文件的默认路径在Windows目录下。如果使用的是Apache服务器，则会首先在Apache的安装目录中寻找<code>php.ini</code>。<br><br><br>Q: PHP是否仅限于处理GET和POST请求方法？<br>A: 不是，PHP有可能处理任何请求方法，例如<code>CONNECT</code>。适当的回应状态可以用<code>header()</code>发送。<br><br><br>Q: 我忘了PHP函数的参数顺序，它们是随机的吗？<br>A: 通常情况下，数组函数的参数里，needle在前，haystack在后；字符串函数中，haystack在前，needle在后。<br><br><br>Q: PHP选项<code>register_globals</code>对我有什么影响？<br>A: 强烈不建议开启此选项，<code>register_globals</code>会自动生成变量。<br><br><br>Q: 我需要直接访问请求报头中的信息，怎么能办到？<br>A: 如果以Apache的模块方式运行PHP，那么函数<code>getallheaders()</code>可以做这件事。<br><br><br>Q: 如果不建议使用常用散列函数保护密码， 那么我应该如何对密码进行散列处理？<br>A: 当进行密码散列处理的时候，有两个必须考虑的因素： 计算量以及“盐”。 散列算法的计算量越大，暴力破解所需的时间就越长。PHP 5.5提供了一个原生密码散列API， 它提供一种安全的方式来完成密码散列和验证。 PHP 5.3.7及后续版本中都提供了一个纯PHP的兼容库。PHP 5.3及后续版本中，还可以使用<code>crypt()</code>函数，它支持多种散列算法。针对每种受支持的散列算法，PHP都提供了对应的原生实现。<br><br><br>Q: “盐”是什么？<br>A: 加解密领域中的“盐”是指在进行散列处理的过程中 加入的一些数据，用来避免从已计算的散列值表（被称作“彩虹表”中对比输出数据从而获取明文密码的风险。<br><br><br>Q: 我在使用<code>&lt;input type=&quot;image&quot;&gt;</code>标记，但是没有<code>$foo.x</code>和<code>$foo.y</code>变量，它们哪去了？<br>A: 当提交表单时，可以用图片代替标准的提交按钮，用类似这样的标记<br><code>&lt;input type=&quot;image&quot; src=&quot;image.gif&quot; name=&quot;foo&quot; /&gt;</code><br>当用户点击了图片的任何部分，该表单会被发送到服务器并加上两个额外的变量：<code>foo.x</code>和<code>foo.y</code>。因为<code>foo.x</code>和 <code>foo.y</code>在PHP中会成为非法的变量名，它们被自动转换成了<code>foo_x</code>和<code>foo_y</code>。也就是用下划线代替了点。<br><br><br>Q: PHP 5中还能用MySQL吗？好像找不到了。<br>A: MySQL依然被支持，唯一区别是PHP 5中默认为不激活。这意味着在PHP的configure一行中不包含有<code>--with-mysql</code>选项，因此必须在编译时手工加入。Windows用户可以编辑<code>php.ini</code>并激活<code>php_mysql.dll</code>。<br><br><br>Q: 在函数定义中，参数旁边的<code>&amp;</code>是什么意思？<br>A: 这表示该参数是引用传递，该函数会修改其值。鼓励使用的方法是在函数定义中指定哪些参数应该用引用传递。在函数调用时通过引用传递参数是不推荐的，因为它影响到了代码的整洁。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://php.net/manual/zh/book.password.php\">php.net</a></li>\n<li><a href=\"https://laravel-china.github.io/php-the-right-way/\">PHP之道中文版</a></li>\n</ul>\n",
            "tags": [
                "PHP",
                "参考"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/07/28/typescript-restudy/",
            "url": "http://shenlvmeng.github.com/blog/2019/07/28/typescript-restudy/",
            "title": "TypeScript再学习",
            "date_published": "2019-07-28T14:23:01.000Z",
            "content_html": "<blockquote>\n<p>尽管项目中已经用上了TypeScript，但是主要场景下对TS的高级特性设计较少，再看过<a href=\"https://github.com/LeetCode-OpenSource/hire/blob/master/typescript_zh.md\">leetcode</a>面试题后，觉得自己的了解程度还远远不够。于是参考<a href=\"https://github.com/basarat/typescript-book/\">《TypeScript Deep Dive》</a>这本开源书（<a href=\"https://jkchao.github.io/typescript-book-chinese/\">中文版</a>）开始再学习</p>\n</blockquote>\n<blockquote>\n<p>TypeScript Playground: <a href=\"http://www.typescriptlang.org/play/\">http://www.typescriptlang.org/play/</a></p>\n</blockquote>\n<h2 id=\"TypeScript项目\"><a href=\"#TypeScript项目\" class=\"headerlink\" title=\"TypeScript项目\"></a>TypeScript项目</h2><h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>TS的编译过程主要通过<code>tsconfig.json</code>文件来配置（当然你也可以通过命令行的方式指定）。TS有些自己的默认配置，你也可以在<code>complierOptions</code>下自定义你的配置。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* 基本选项 */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es5&quot;</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;commonjs&quot;</span><span class=\"punctuation\">,</span>                  <span class=\"comment\">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                             <span class=\"comment\">// 指定要包含在编译中的库文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;allowJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 允许编译 javascript 文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;checkJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 报告 javascript 文件中的错误</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;jsx&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;preserve&quot;</span><span class=\"punctuation\">,</span>                     <span class=\"comment\">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;declaration&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                   <span class=\"comment\">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;sourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                     <span class=\"comment\">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outFile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 将输出文件合并为一个文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                        <span class=\"comment\">// 指定输出目录</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 用来控制输出目录结构 --outDir.</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;removeComments&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                <span class=\"comment\">// 删除编译后的所有的注释</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noEmit&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                        <span class=\"comment\">// 不生成输出文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;importHelpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                 <span class=\"comment\">// 从 tslib 导入辅助工具函数</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isolatedModules&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>               <span class=\"comment\">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 严格的类型检查选项 */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                        <span class=\"comment\">// 启用所有严格类型检查选项</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noImplicitAny&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                 <span class=\"comment\">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strictNullChecks&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>              <span class=\"comment\">// 启用严格的 null 检查</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noImplicitThis&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                <span class=\"comment\">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;alwaysStrict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                  <span class=\"comment\">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 额外的检查 */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noUnusedLocals&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                <span class=\"comment\">// 有未使用的变量时，抛出错误</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noUnusedParameters&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 有未使用的参数时，抛出错误</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noImplicitReturns&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>             <span class=\"comment\">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;noFallthroughCasesInSwitch&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 模块解析选项 */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;moduleResolution&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;node&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;baseUrl&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 用于解析非相对模块名称的基目录</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;paths&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span>                           <span class=\"comment\">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDirs&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                        <span class=\"comment\">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;typeRoots&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 包含类型声明的文件列表</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;types&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                           <span class=\"comment\">// 需要包含的类型声明文件名列表</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;allowSyntheticDefaultImports&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>  <span class=\"comment\">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Source Map Options */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;sourceRoot&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                    <span class=\"comment\">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mapRoot&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;inlineSourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>               <span class=\"comment\">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;inlineSources&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                 <span class=\"comment\">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 其他选项 */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>        <span class=\"comment\">// 启用装饰器</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;emitDecoratorMetadata&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span>          <span class=\"comment\">// 为装饰器提供元数据的支持</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>TS有几种不同的编译方式：</p>\n<ul>\n<li>运行<code>tsc</code>，自动定位当前目录下tsconfig.json</li>\n<li>运行<code>tsc -p [your path]</code>，手动指定config路径</li>\n<li>运行<code>tsc -w</code>进入观测模式，在文件更改时自动重新编译</li>\n</ul>\n<p>你可以通过不同方式指定要编译的文件：</p>\n<ul>\n<li><code>files</code>直接指定要编译的文件</li>\n<li><code>include</code>指定包含的文件</li>\n<li><code>exclude</code>指定排除的文件</li>\n</ul>\n<p>配置值可以是glob格式。</p>\n<h3 id=\"声明空间\"><a href=\"#声明空间\" class=\"headerlink\" title=\"声明空间\"></a>声明空间</h3><p>TypeScript中有两种声明空间：<strong>类型声明空间</strong>和<strong>变量声明空间</strong>。前者只能用作类型注解，后者可以用来当做变量使用。</p>\n<h3 id=\"文件模块\"><a href=\"#文件模块\" class=\"headerlink\" title=\"文件模块\"></a>文件模块</h3><p>TS中有多种模块系统选项：</p>\n<ul>\n<li>AMD：仅在浏览器端使用</li>\n<li>SystemJS：已被ES模块替代</li>\n<li>ES模块：当前的支持有限</li>\n<li>CommonJS：当前比较好的一个选择</li>\n</ul>\n<p>一般在工程中使用ES模块语法，模块选项使用CommonJS。TS中对类型也可以同样适用import和export。</p>\n<h4 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h4><p>通常情况由<code>moduleResolution</code>选项指定。这个选项在<code>tsconfig.json</code>中声明。在声明<code>module: commonjs</code>时，<code>moduleResolution</code>自动指定为<code>node</code>。</p>\n<p>导入路径分两种：</p>\n<ul>\n<li>相对路径，使用<code>./</code>或是<code>../</code>与文件、文件夹名称组成</li>\n<li>动态路径，TS模块解析将会模仿<a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node模块解析规则</a>，即去当前目录、所有父目录的node_modules下寻找对应路径模块</li>\n</ul>\n<p>如果你本身对node下的模块查找很熟悉，那么恭喜，你已经掌握了TS的模块查找。</p>\n<h4 id=\"global-d-ts\"><a href=\"#global-d-ts\" class=\"headerlink\" title=\"global.d.ts\"></a><code>global.d.ts</code></h4><p>在项目中可以通过<code>declare module &#39;somepath&#39; &#123;&#125;</code>的方式声明一个全局模块，这样的一个<code>global.d.ts</code>是声明全局类型的好地方。从js迁移到ts的项目通常需要一个这样的声明</p>\n<h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>TypeScript下可以使用<code>namespace</code>拆分变量的命名空间。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">log</span>(<span class=\"params\">msg</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">error</span>(<span class=\"params\">msg</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// usage</span></span><br><span class=\"line\"><span class=\"title class_\">Logger</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A message&#x27;</span>);</span><br><span class=\"line\"><span class=\"title class_\">Logger</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;An error&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>namespace</code>支持嵌套定义，在<strong>快速演示</strong>和<strong>移植旧的JavaScript</strong></p>\n<h3 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h3><p>在使用ES的动态导入功能时，为了保证TS在转换代码时保留<code>import()</code>语句，<code>tsconfig.json</code>中的<code>module</code>需要是<code>esnext</code>。</p>\n<h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><h4 id=\"基本注解\"><a href=\"#基本注解\" class=\"headerlink\" title=\"基本注解\"></a>基本注解</h4><p>包括JS的<strong>原始类型</strong>：</p>\n<ul>\n<li><code>string</code></li>\n<li><code>number</code></li>\n<li><code>boolean</code></li>\n<li><code>object</code></li>\n<li>其他基本类型</li>\n</ul>\n<p><strong>数组类型</strong>在元素类型后追加<code>[]</code>实现。<strong>键值对</strong>类型使用<code>&#123;[key: string]: any&#125;</code>实现。</p>\n<p>你可以使用<code>interface</code>封装自己的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">school</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        <span class=\"attr\">location</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        <span class=\"attr\">postcode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">tags</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    &#125;[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，对于临时的类型需要。可以直接使用<strong>内联</strong>的方式注解类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125; = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;foo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;CEO&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h4><p>除了上面的基本类型，还有一些常用的特殊类型。</p>\n<p><strong>any</strong>意味着任意类型，<code>any</code>类型可以兼容任何TypeScript中的类型。因此：</p>\n<ul>\n<li>任意类型都可以赋值给<code>any</code></li>\n<li><code>any</code>也可以赋值给任意类型</li>\n</ul>\n<p>初学者在从JavaScript迁移到TypeScript时，通常要借助<code>any</code>的帮助。但实际上使用<code>any</code>就代表告诉TypeScript编译器不要进行任何类型检查。</p>\n<p>在<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-0-rc-2/\">TypeScript 3.0</a>特性中，出现了和<code>any</code>类似的<code>unknown</code>关键字。但是后者是type safe的.</p>\n<ul>\n<li>任何类型都可以赋值给<code>unknown</code></li>\n<li><code>unknown</code>在类型检查后才能赋值给任意类型</li>\n</ul>\n<p>另外在设置编译属性<code>strictNullChecks</code>为<code>false</code>时，字面量<code>null</code>和<code>undefined</code>也可以赋值给任意类型变量。</p>\n<p><code>void</code>用来表示一个函数没有返回值，<code>never</code>表示不会发生的类型。例如抛出错误的函数、死循环函数的返回值类型、以及字面量空数组的元素类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> emptyArr = []; <span class=\"comment\">// never[]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">func</span>: <span class=\"built_in\">never</span> = (<span class=\"function\">() =&gt;</span> <span class=\"keyword\">throw</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Throw an error&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p><code>never</code>类型间可以相互赋值，但不能和其他类型相互赋值。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><p>计算机算法在对封装类型操作时，往往不依赖于元素类型，这种情况下使用泛型描述，TypeScript会帮助推断元素类型，保证类型安全。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> reverse&lt;T&gt;(<span class=\"attr\">items</span>: T[]): T[] &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> res1 = <span class=\"title function_\">reverse</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">res1[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// Error</span></span><br><span class=\"line\">res1[<span class=\"number\">1</span>] = <span class=\"number\">2</span>; <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"高级类型\"><a href=\"#高级类型\" class=\"headerlink\" title=\"高级类型\"></a>高级类型</h4><p><strong>交叉类型</strong>，写作<code>A &amp; B</code>，表示同时具有<code>A</code>和<code>B</code>两种类型的属性，新类型的对象可以使用A或者B的功能。</p>\n<p><strong>联合类型</strong>，写作<code>A | B</code>，表示是<code>A</code>或<code>B</code>其中一种类型，较常用在入参的内联描述中。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> extend&lt;T, U&gt;(<span class=\"attr\">first</span>: T, <span class=\"attr\">second</span>: U): T &amp; U &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">T</span> &amp; <span class=\"attr\">U</span>&gt;</span> = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"language-xml\">    return &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">        ...first,</span></span><br><span class=\"line\"><span class=\"language-xml\">        ...second</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\">function batchOperate(id: string | string[]) &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">    operate([].concat(id));</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>元组类型</strong>，这不是一种新类型，它用来描述不同类型元素的集合，就像宽容的JS数组一样。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> user = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">userInfo</span>: user = [<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"number\">32</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [userName, age] = userInfo;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h4><p>除开interface，还有<code>type</code>可以更快捷地定义类型别名。在结合上述高级属性使用时，类型别名<code>type</code>会是不错的选择。对比<code>interface</code>和<code>type</code>:</p>\n<ul>\n<li>使用<code>interface</code>定义基本的层级结构，它可以和<code>implements</code>以及<code>extends</code>配合使用</li>\n<li>在需要的类型不需要从头构造，而是从已有类型推导出来时，使用<code>type</code>，它更像是给这些computed type一个语义化的名字</li>\n</ul>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举是常见的组织互斥的一组常量的方式。TypeScript中用<code>enum</code>关键字表示。默认的枚举是<strong>数字类型</strong>的，即使用数字作为索引值；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Red</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Green</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Blue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> col = <span class=\"title class_\">Color</span>.<span class=\"property\">Red</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> anotherCol = <span class=\"title class_\">Color</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// &#x27;Red&#x27;</span></span><br><span class=\"line\">col = <span class=\"number\">0</span> <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用数字类型时，枚举值可以用数字代替。默认情况下，枚举值<strong>从0开始</strong>，当然可以用<code> = 1</code>修改默认的枚举值。下面有一个枚举值和标记的组合用法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">AnimalFlags</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">None</span>        = <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">HasClaws</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">CanFly</span>      = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">EatsFish</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Endangered</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">flags</span>: <span class=\"title class_\">AnimalFlags</span>;</span><br><span class=\"line\">  [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不同的<code>Animal</code>的<code>flags</code>做位运算时可以非常方便地完成布尔代数的一些操作。</p>\n<p>另外，枚举类型的值可以通过赋值成为字符串类型。在使用常量枚举时，TypeScript会将所有出现枚举的位置都替换成内联的常量，而不需要查找枚举变量，从而提高性能提升。</p>\n<h3 id=\"从JavaScript中迁移\"><a href=\"#从JavaScript中迁移\" class=\"headerlink\" title=\"从JavaScript中迁移\"></a>从JavaScript中迁移</h3><p>总的来说有下面几步：</p>\n<p>Step1：添加<code>tsconfig.json</code>文件。</p>\n<p>Step2：修改文件拓展名为<code>ts</code>，使用<code>any</code>避免干扰你主要工作的报错，记得在之后规范</p>\n<p>Step3：写新的TypeScript代码，减少<code>any</code>使用</p>\n<p>Step4：回头为你的老代码添加类型</p>\n<p>Step5：为你的第三方库引用类型声明，绝大多数优秀的JS库都已经有人帮忙写好<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">类型声明</a>了</p>\n<p>Step6：对于那些没有声明的第三方库，需要你自己书写类型声明或者<code>declare module yourmodule</code>一劳永逸</p>\n<p>上面提到的类型声明，即DefinitelyTyped通过npm包的方式引入，包有固定前缀<code>@types</code>。</p>\n<p>有些类型声明的引入会带来全局scope的定义，可以通过在<code>tsconfig.json</code>里配置<code>types</code>来限制引入的声明文件</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;types&quot;</span> <span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"string\">&quot;jquery&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型声明文件\"><a href=\"#类型声明文件\" class=\"headerlink\" title=\"类型声明文件\"></a>类型声明文件</h3><p>通过<code>declare</code>关键字告诉TypeScript，你正在表述其他位置已经存在的全局变量。强烈建议把所有的声都放在以<code>.d.ts</code>结尾的文件名的文件内。环境声明不会被编译成代码。</p>\n<p>在这样的模块、变量、类型声明文件里，<code>interface</code>是最常见的。用户代码中可以用类实现这些接口。但是请记住，<code>interface</code>旨在声明JavaScript中可能存在的数据结构。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">z</span>: <span class=\"built_in\">number</span>; <span class=\"comment\">// New member</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPoint</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ERROR : missing member `z`</span></span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lib-d-ts\"><a href=\"#lib-d-ts\" class=\"headerlink\" title=\"lib.d.ts\"></a><code>lib.d.ts</code></h3><p>为了便于你能快速开始书写类型检查的代码，TypeScript自带了BOM的变量声明（包含window、document、math等）位于<code>lib.d.ts</code>中。你可以在你的项目下添加<code>global.d.ts</code>，对已有的全局变量做自己的拓展。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Window</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">foo</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">DateConstructor</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">lastDay</span>(): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title class_\">Date</span>.<span class=\"title function_\">lastDay</span>()</span><br></pre></td></tr></table></figure>\n\n<p>你在自己定义的<code>global.d.ts</code>中可以通过拓展global，修改全局空间内的类型定义。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">global</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">endsWith</span>(<span class=\"attr\">suffix</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译选项\"><a href=\"#编译选项\" class=\"headerlink\" title=\"编译选项\"></a>编译选项</h4><ul>\n<li>指定<code>--noLib</code>可以排除TypeScript自动引入的<code>lib.d.ts</code>，这通常出现在<ul>\n<li>运行JavaScript的环境和标准浏览器相距甚远</li>\n<li>你希望严格控制全局变量的使用</li>\n</ul>\n</li>\n<li>指定<code>--lib</code>可以对编译环境进行细粒度控制引入的包类型<ul>\n<li>tsc中，<code>tsc --target es5 --lib dom,es6</code></li>\n<li>也可以在<code>tsconfig.json</code>中声明<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;dom&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;es6&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>如果没有指定<code>--lib</code>，TypeScript会根据当前编译选项中的<code>target</code>导入默认库。</p>\n<ul>\n<li><code>--target</code>为es5时，导入es5、dom、scriptdom</li>\n<li><code>--target</code>为es6时，导入es6、dom、dom.iterable、scripthost</li>\n</ul>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数注解可以使用内联或<code>interface</code>的方式。通常编译器可以根据代码自动推断函数的返回类型。函数入参的可选参数通过类型注解前的<code>?</code>说明。另外，TypeScript允许你<strong>声明</strong>函数重载，注意，这里只是声明，重载需要自己实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">adult</span>(<span class=\"params\">itself: human</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">adult</span>(<span class=\"params\">itself: human, mate: human, children: human[]</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">adult</span>(<span class=\"params\">itself: human, mate?: human, children?: human[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!mate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; itself &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    itself,</span><br><span class=\"line\">    mate,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: children || []</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">adult</span>(yourself, anotherGuy); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可调用的\"><a href=\"#可调用的\" class=\"headerlink\" title=\"可调用的\"></a>可调用的</h4><p>可以用类型别名或接口表示可调用的类型。函数重载和构造函数定义都可以在其中实现。使用<code>new</code>作为前缀后，需要使用<code>new</code>关键字去调用这个函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Overloaded</span> &#123;</span><br><span class=\"line\">  (<span class=\"attr\">foo</span>: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">foo: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ConstructorFunc</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，还可以使用箭头函数作内联函数注解，但这种时候无法表示重载。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">foo</span>: <span class=\"function\">(<span class=\"params\">bar: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\"><span class=\"params\">bar</span> =&gt;</span> bar.<span class=\"title function_\">toString</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h3><p>字面量 + 联合类型构成TS中常用的字面量类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Seasons</span> = <span class=\"string\">&#x27;spring&#x27;</span> | <span class=\"string\">&#x27;summer&#x27;</span> | <span class=\"string\">&#x27;autumn&#x27;</span> | <span class=\"string\">&#x27;winter&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> binary = <span class=\"number\">0</span> | <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> bools = <span class=\"literal\">true</span> | <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很多时候字面量类型会通过<code>keyof</code>一个键值对的形式来构造。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于创建字符串列表映射至 `K: V` 的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> strEnum&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">o</span>: <span class=\"title class_\">Array</span>&lt;T&gt;): &#123; [K <span class=\"keyword\">in</span> T]: K &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">res, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = key;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;, <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 K: V</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Direction</span> = <span class=\"title function_\">strEnum</span>([<span class=\"string\">&#x27;North&#x27;</span>, <span class=\"string\">&#x27;South&#x27;</span>, <span class=\"string\">&#x27;East&#x27;</span>, <span class=\"string\">&#x27;West&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Direction</span> = keyof <span class=\"keyword\">typeof</span> <span class=\"title class_\">Direction</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>TypeScript有自己的类型推断，但是允许你使用<strong>类型断言</strong>去覆盖。通过<code>as Something</code>或<code>&lt;Something&gt;</code>的方式。但是后者接近JSX语法，所以更多使用前者。</p>\n<p>断言是编译时的，为编译器提供分析代码的方法。TypeScript在进行类型断言时，会判断源类型<code>S</code>是否是目标类型<code>T</code>的子集，若不是则不能成功断言。</p>\n<h3 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h3><p>使用JS中<code>typeof</code>和<code>instanceof</code>可以帮助TypeScript推导出条件语句内的变量类型。使用<code>in</code>操作符，也可以帮助TypeScript判断类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> B &#123;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\">q: A | B</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;x&#x27;</span> <span class=\"keyword\">in</span> q) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// q: A</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// q: B</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在联合类型中，如果有类型使用字面量，TypeScript甚至可以通过判断字面量确定变量类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&#x27;foo&#x27;</span>; <span class=\"comment\">// 字面量类型</span></span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bar</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&#x27;bar&#x27;</span>; <span class=\"comment\">// 字面量类型</span></span><br><span class=\"line\">  <span class=\"attr\">bar</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\">arg: Foo | Bar</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arg.<span class=\"property\">kind</span> === <span class=\"string\">&#x27;foo&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">foo</span>); <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">bar</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一定是 Bar</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">foo</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">bar</span>); <span class=\"comment\">// ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，弥补JS中plain object没有<code>instanceof</code>或<code>typeof</code>自我检查的漏洞。TypeScript提供了<code>is</code>允许自定义类型判断。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 仅仅是一个 interface</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">common</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bar</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">bar</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">common</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户自己定义的类型保护！</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isFoo</span>(<span class=\"params\">arg: Foo | Bar</span>): arg is <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (arg <span class=\"keyword\">as</span> <span class=\"title class_\">Foo</span>).<span class=\"property\">foo</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h3><p>TypeScript可以根据一些规则推断出变量类型：</p>\n<ul>\n<li>定义变量</li>\n<li>函数返回</li>\n<li>赋值</li>\n<li>结构化（数组元素、对象属性）</li>\n<li>解构</li>\n</ul>\n<p>在推断不出类型或使用第三方JS库时，类型会被判定为<code>any</code>。开启编译选项<code>noImplicitAny</code>可以避免这种问题。</p>\n<h3 id=\"类型兼容\"><a href=\"#类型兼容\" class=\"headerlink\" title=\"类型兼容\"></a>类型兼容</h3><ul>\n<li>结构化：只要对象结构匹配，名称无关紧要</li>\n<li>多态性：子类实例可以复制给基类实例，相反则不行</li>\n<li>函数<ul>\n<li>返回类型：数据较多的可以赋值给数据较少的</li>\n<li>入参：入参较少的可以赋值给入参较多的</li>\n<li>可选参数、Rest参数：可以相互赋值（可选和必选仅在<code>strictNullChecks</code>选中时相互兼容）</li>\n<li>入参类型：父类子类相互兼容（牺牲安全性确保便利性）</li>\n</ul>\n</li>\n<li>枚举：和数字类型兼容、不同枚举间不兼容</li>\n<li>类：仅比较<strong>实例成员和实例方法</strong>，不比较构造函数和静态成员，<code>private</code>和<code>protected</code>成员必须来自相同的类</li>\n<li>泛型：泛型对兼容性没有影响（这可能会带来一些潜在问题）</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Poin2D</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">iTakePoint2D</span> = (<span class=\"params\">point: Point2D</span>) =&gt; &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">iTakePoint3D</span> = (<span class=\"params\">point: Point3D</span>) =&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">iTakePoint3D = iTakePoint2D; <span class=\"comment\">// ok, 这是合理的</span></span><br><span class=\"line\">iTakePoint2D = iTakePoint3D; <span class=\"comment\">// also ok，为什么？</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><p>用<code>readonly</code>标记接口属性，表示预期不可修改。获取使用<code>Readonly</code>封装一个泛型<code>T</code>，表示泛型内的属性均不可修改。同样地，你可以为索引签名声明<code>readonly</code>，表示所有索引元素均不可修改。还有些情况下，如果属性配置了<code>getter</code>，但没有<code>setter</code>也会被认为是只读的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> [<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>readonly</code>和<code>const</code>的主要不同在于，前者用来修改属性，后者用于变量。</p>\n<h3 id=\"索引签名\"><a href=\"#索引签名\" class=\"headerlink\" title=\"索引签名\"></a>索引签名</h3><p>索引即数组或键值对的索引。TypeScript中索引类型只能是<code>string</code>或<code>number</code>类型。这意味着，也可以使用字面量类型作为索引类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Index</span> = <span class=\"string\">&#x27;a&#x27;</span> | <span class=\"string\">&#x27;b&#x27;</span> | <span class=\"string\">&#x27;c&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FromIndex</span> = &#123; [k <span class=\"keyword\">in</span> <span class=\"title class_\">Index</span>]?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">good</span>: <span class=\"title class_\">FromIndex</span> = &#123; <span class=\"attr\">b</span>: <span class=\"number\">1</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p>在一些特殊场景下，可以同时支持<code>string</code>和<code>number</code>类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ArrStr</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>; <span class=\"comment\">// 必须包括所用成员类型</span></span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>; <span class=\"comment\">// 字符串索引类型的子级</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流动的类型\"><a href=\"#流动的类型\" class=\"headerlink\" title=\"流动的类型\"></a>流动的类型</h3><p><code>typeof</code>可以捕获变量、类成员类型。使用<code>typeof</code>在捕获一个字符串字面量时，得到的类型是字面量类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">bar</span>: <span class=\"keyword\">typeof</span> foo; <span class=\"comment\">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 捕获字符串的类型与值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> faz = <span class=\"string\">&#x27;Hello World&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用一个捕获的类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">baz</span>: <span class=\"keyword\">typeof</span> faz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bar 仅能被赋值 &#x27;Hello World&#x27;</span></span><br><span class=\"line\">baz = <span class=\"string\">&#x27;Hello World&#x27;</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">baz = <span class=\"string\">&#x27;anything else&#x27;</span>; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>keyof</code>捕获一个类型的键。</p>\n<h3 id=\"ThisType\"><a href=\"#ThisType\" class=\"headerlink\" title=\"ThisType\"></a>ThisType</h3><p>在对象字面量方法的类型定义上声明<code>ThisType()</code>可以修改发放内<code>this</code>的类型，这常被用在<code>this</code>值被重新绑定的情况。</p>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><h3 id=\"bind的隐患\"><a href=\"#bind的隐患\" class=\"headerlink\" title=\"bind的隐患\"></a><code>bind</code>的隐患</h3><p>在<code>lib.d.ts</code>中，对<code>bind</code>的定义如下:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">bind</span>(<span class=\"attr\">thisArg</span>: <span class=\"built_in\">any</span>, ...<span class=\"attr\">argArray</span>: <span class=\"built_in\">any</span>[]): <span class=\"built_in\">any</span></span><br></pre></td></tr></table></figure>\n\n<p>由于返回值是<code>any</code>类型，意味着bind返回的函数将失去类型检查（最新的TS 3.2已经优化了这个问题）。</p>\n<h3 id=\"柯里化函数\"><a href=\"#柯里化函数\" class=\"headerlink\" title=\"柯里化函数\"></a>柯里化函数</h3><p>用一系列箭头表示。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个柯里化函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">add</span> = (<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt; <span class=\"function\">(<span class=\"params\">y: <span class=\"built_in\">number</span></span>) =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单使用</span></span><br><span class=\"line\"><span class=\"title function_\">add</span>(<span class=\"number\">123</span>)(<span class=\"number\">456</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 部分应用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> add123 = <span class=\"title function_\">add</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fully apply the function</span></span><br><span class=\"line\"><span class=\"title function_\">add123</span>(<span class=\"number\">456</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h3><ul>\n<li>使用继承而不是<code>as</code>来实现泛型实例化</li>\n<li>使用<code>as</code>来初始化对象字面量的空对象</li>\n<li>尝试使用类组织代码</li>\n<li>小心使用<code>setter</code>，不要牺牲代码可读性</li>\n<li>在参数名可以很好提高可读性、入参很多时，考虑让函数接受一个对象参数</li>\n</ul>\n<h3 id=\"Reflect-Metadata\"><a href=\"#Reflect-Metadata\" class=\"headerlink\" title=\"Reflect Metadata\"></a>Reflect Metadata</h3><p>Reflect Metadata是ES7的提案，用于在声明时添加和读取元数据。Reflect Metadata的API可以用于类或类属性上，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&#x27;inClass&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&#x27;inMethod&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">hello</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello world&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&#x27;inClass&#x27;</span>, <span class=\"title class_\">Test</span>)); <span class=\"comment\">// &#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&#x27;inMethod&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Test</span>(), <span class=\"string\">&#x27;hello&#x27;</span>)); <span class=\"comment\">// &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此可以通过<code>Reflect.getMetadata</code>的API来获取类相关的元数据。</p>\n<h4 id=\"自定义metadatakey\"><a href=\"#自定义metadatakey\" class=\"headerlink\" title=\"自定义metadatakey\"></a>自定义<code>metadatakey</code></h4><p>可以定义自己的reflect metadata。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">classDecorator</span>(<span class=\"params\"></span>): <span class=\"title class_\">ClassDecorator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">target</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在类上定义元数据，key 为 `classMetaData`，value 为 `a`</span></span><br><span class=\"line\">    <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">defineMetadata</span>(<span class=\"string\">&#x27;classMetaData&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, target);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">methodDecorator</span>(<span class=\"params\"></span>): <span class=\"title class_\">MethodDecorator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, key, descriptor</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在类的原型属性 &#x27;someMethod&#x27; 上定义元数据，key 为 `methodMetaData`，value 为 `b`</span></span><br><span class=\"line\">    <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">defineMetadata</span>(<span class=\"string\">&#x27;methodMetaData&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, target, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@classDecorator</span>()</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SomeClass</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@methodDecorator</span>()</span><br><span class=\"line\">  <span class=\"title function_\">someMethod</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&#x27;classMetaData&#x27;</span>, <span class=\"title class_\">SomeClass</span>); <span class=\"comment\">// &#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&#x27;methodMetaData&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">SomeClass</span>(), <span class=\"string\">&#x27;someMethod&#x27;</span>); <span class=\"comment\">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以借助Reflect Metadata的这个特点，实现诸如控制反转、依赖注入、装饰器等功能。</p>\n<h3 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"keyword\">extends</span> U ? <span class=\"attr\">X</span>: Y</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 2.8的一个<a href=\"https://github.com/Microsoft/TypeScript/pull/21496\">PR</a>里第一次提到条件类型。条件类型主要规则如下：</p>\n<ul>\n<li>上式表示<strong>T如果可以赋值给U</strong>，返回类型<code>X</code>，否则返回<code>Y</code></li>\n<li>在<code>U</code>中出现<code>infer</code>时，TypeScript会去推断<code>infer</code>后的类型变量（假设是<code>V</code>），如果<code>V</code>出在协变位置，则返回<code>V</code>所有可能性的联合类型，如果<code>V</code>出现在逆变位置，则返回<code>V</code>所有可能性的交叉类型（参考：<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98\">协变与逆变</a>）</li>\n</ul>\n<h4 id=\"分布条件类型\"><a href=\"#分布条件类型\" class=\"headerlink\" title=\"分布条件类型\"></a>分布条件类型</h4><p>在检查类型（<code>extends</code>前的类型参数）是原始类型（即没有被泛型等封装）时，称为分布条件类型（Distributive conditional types）。在实例化为实际类型时，联合类型会被拆分开。</p>\n<p>例如，<code>T</code>实例化为<code>A | B | C</code>时，<code>T extends U ? X : Y</code>会被解析成<code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FunctionPropertyNames</span>&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span> ? K : <span class=\"built_in\">never</span> &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FunctionProperties</span>&lt;T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">FunctionPropertyNames</span>&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NonFunctionPropertyNames</span>&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span> ? <span class=\"built_in\">never</span> : K &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NonFunctionProperties</span>&lt;T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">NonFunctionPropertyNames</span>&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Part</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">subparts</span>: <span class=\"title class_\">Part</span>[];</span><br><span class=\"line\">    <span class=\"title function_\">updatePart</span>(<span class=\"attr\">newName</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T40</span> = <span class=\"title class_\">FunctionPropertyNames</span>&lt;<span class=\"title class_\">Part</span>&gt;;  <span class=\"comment\">// &quot;updatePart&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T41</span> = <span class=\"title class_\">NonFunctionPropertyNames</span>&lt;<span class=\"title class_\">Part</span>&gt;;  <span class=\"comment\">// &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T42</span> = <span class=\"title class_\">FunctionProperties</span>&lt;<span class=\"title class_\">Part</span>&gt;;  <span class=\"comment\">// &#123; updatePart(newName: string): void &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T43</span> = <span class=\"title class_\">NonFunctionProperties</span>&lt;<span class=\"title class_\">Part</span>&gt;;  <span class=\"comment\">// &#123; id: number, name: string, subparts: Part[] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a><code>infer</code></h4><p>如上文所说，<code>infer</code>最初出现是用来表示<code>extends</code>条件语句中待推断的类型。下文中若T满足<code>(param: infer P) =&gt; any</code>类型，则推出<code>P</code>类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ParamType</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> (<span class=\"attr\">param</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : T;</span><br></pre></td></tr></table></figure>\n\n<p><code>infer</code>有下面一些常规使用场景。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取返回值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ReturnType</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; infer P ? P : <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取构造函数的入参或实例类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Constructor</span> = <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ConstructorParameters</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span></span><br><span class=\"line\">  ? P</span><br><span class=\"line\">  : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取实例类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">InstanceType</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<p>联合<code>infer</code>和分布条件类型，可以实现一些骚操作，如tuple、intersection、union之间的转换。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tupleToIntersection&lt;T&gt; = T[<span class=\"built_in\">number</span>]；</span><br><span class=\"line\"><span class=\"keyword\">type</span> unionToIntersection&lt;T&gt; = (T <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"function\">(<span class=\"params\">k: T</span>) =&gt;</span> <span class=\"built_in\">void</span> : <span class=\"built_in\">never</span>) <span class=\"keyword\">extends</span> (<span class=\"function\">(<span class=\"params\">k: infer R</span>) =&gt;</span> <span class=\"built_in\">void</span>) ? R : <span class=\"built_in\">never</span></span><br></pre></td></tr></table></figure>\n\n<p>如原文列的<a href=\"https://github.com/LeetCode-OpenSource/hire/blob/master/typescript_zh.md\">LeetCode TypeScript面试题</a>。借助强大的条件类型和<code>infer</code>就能实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Action</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  payload?: T;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 预期的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Result</span> = &#123;</span><br><span class=\"line\">  asyncMethod&lt;T, U&gt;(<span class=\"attr\">input</span>: T): <span class=\"title class_\">Action</span>&lt;U&gt;;</span><br><span class=\"line\">  syncMethod&lt;T, U&gt;(<span class=\"attr\">action</span>: T): <span class=\"title class_\">Action</span>&lt;U&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  asyncMethod&lt;T, U&gt;(<span class=\"attr\">input</span>: <span class=\"title class_\">Promise</span>&lt;T&gt;): <span class=\"title class_\">Promise</span>&lt;<span class=\"title class_\">Action</span>&lt;U&gt;&gt;;</span><br><span class=\"line\">  syncMethod&lt;T, U&gt;(<span class=\"attr\">action</span>: <span class=\"title class_\">Action</span>&lt;T&gt;): <span class=\"title class_\">Action</span>&lt;U&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FuncNames</span>&lt;T&gt; = &#123;</span><br><span class=\"line\">  [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span> ? K : <span class=\"built_in\">never</span></span><br><span class=\"line\">&#125;[keyof T]</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FuncProperties</span>&lt;T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">FuncNames</span>&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UnPackedParams</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"title class_\">Promise</span>&lt;infer R&gt; ? R :</span><br><span class=\"line\">  T <span class=\"keyword\">extends</span> <span class=\"title class_\">Action</span>&lt;infer R&gt; ? R : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UnPackedReturn</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"title class_\">Promise</span>&lt;infer R&gt; ? R : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UnPackedFunction</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> (<span class=\"attr\">params</span>: infer U) =&gt; infer R ? <span class=\"function\">(<span class=\"params\">params: UnPackedParams&lt;U&gt;</span>) =&gt;</span> <span class=\"title class_\">UnPackedReturn</span>&lt;R&gt; : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Resolve</span>&lt;T&gt; = &#123;</span><br><span class=\"line\">  [K <span class=\"keyword\">in</span> keyof T]: <span class=\"title class_\">UnPackedFunction</span>&lt;T[K]&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改 Connect 的类型，让 connected 的类型变成预期的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Connect</span> = <span class=\"function\">(<span class=\"params\"><span class=\"variable language_\">module</span>: Module</span>) =&gt;</span> <span class=\"title class_\">Resolve</span>&lt;<span class=\"title class_\">FuncProperties</span>&lt;<span class=\"title class_\">Module</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TypeScript编译原理\"><a href=\"#TypeScript编译原理\" class=\"headerlink\" title=\"TypeScript编译原理\"></a>TypeScript编译原理</h2><blockquote>\n<p>这部分内容较为简要。</p>\n</blockquote>\n<p>编译器源文件位于<code>src/compiler</code>下，主要由以下部分组成：</p>\n<ul>\n<li>扫描器 Scanner</li>\n<li>解析器 Parser</li>\n<li>绑定器 Binder</li>\n<li>检查器 Checker</li>\n<li>发射器 Emitter</li>\n</ul>\n<p>处理流程分下面几步：</p>\n<ul>\n<li><code>Source --扫描器--&gt; Token流</code></li>\n<li><code>Token流 --解析器--&gt; AST(抽象语法树)</code></li>\n<li><code>AST --绑定器--&gt; Symbols</code></li>\n<li><code>AST + 符号 --检查器--&gt; 类型验证</code></li>\n<li><code>AST + 检查器 --发射器--&gt; JavaScript代码</code></li>\n</ul>\n<h3 id=\"重要文件\"><a href=\"#重要文件\" class=\"headerlink\" title=\"重要文件\"></a>重要文件</h3><ul>\n<li><code>core.ts</code> TypeScript编译器使用的核心工具集</li>\n<li><code>types.ts</code> 包含整个编译器使用的关键数据结构和接口</li>\n<li><code>system.ts</code> 控制编译器和操作系统的所有交互</li>\n</ul>\n<h3 id=\"程序与抽象语法树\"><a href=\"#程序与抽象语法树\" class=\"headerlink\" title=\"程序与抽象语法树\"></a>程序与抽象语法树</h3><p>这里的“程序”指一个“编译上下文”。它包含SourceFile和编译选项。TypeScript有API获取SourceFile列表，每个SourceFile都是一棵抽象语法树的根节点。</p>\n<h4 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h4><p>节点（Node）是AST的基本组成单位。Node有一些关键成员：</p>\n<ul>\n<li><code>TextRange</code> 标识节点在源文件的起止位置</li>\n<li><code>parent?: Node</code> 标识节点在AST中的父节点</li>\n<li>标志（flags）和修饰符（modifier）等有助于节点遍历的成员</li>\n</ul>\n<p>下面有一些常用工具函数的用法：</p>\n<ul>\n<li><code>ts.forEachChild</code> 用来访问任一节点的所有子节点。这个函数会根据每个节点的<code>node.kind</code>判断node类型，然后再在子节点上调用cbNode。</li>\n<li><code>ts.SyntaxKind</code>是一个节点类型的常量枚举，用以表示不同的语法树节点</li>\n<li><code>ts.getLeadingCommentRanges</code>和<code>ts.getTrailingCommentRanges</code>分别获取给定位置第一个换行符到token和之前的注释范围。</li>\n<li><code>ts.getStart</code>和<code>ts.getFullStart</code>分别获取一个token文本开始位置和上一个重要token开始扫描的位置</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">SyntaxKind</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Unknown</span>,</span><br><span class=\"line\">    <span class=\"title class_\">EndOfFileToken</span>,</span><br><span class=\"line\">    <span class=\"title class_\">SingleLineCommentTrivia</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扫描器与解析器\"><a href=\"#扫描器与解析器\" class=\"headerlink\" title=\"扫描器与解析器\"></a>扫描器与解析器</h3><p>扫描器用于读取文本，并转换为Token流。扫描器由解析器（<code>parser.ts</code>）创建，为了避免创建扫描器的开销。<code>parser.ts</code>创建的扫描器是单例。</p>\n<p>扫描器<code>scanner.ts</code>本身提供API给出扫描过程中的各种信息。尽管解析器创建的扫描器是单例，你仍可以使用<code>createScanner</code>创建自己的扫描器，并调用<code>setText</code>、<code>setTextPos</code>随意扫描文件的不同位置。</p>\n<p>解析器由程序经由<code>CompilerHost</code>创建，<code>CompileHost</code>通过<code>getSourceFile</code>准备好待编译文件，再交由解析器处理。解析器根据内部扫描器得到的Token构造一个SourceFile下的语法树。</p>\n<p>解析器使用<code>parseSourceFileWorker</code>和<code>parseStatements</code>创建根节点和其余节点。具体解析每种节点的过程写在<code>parseXxx</code>中。</p>\n<h3 id=\"绑定器\"><a href=\"#绑定器\" class=\"headerlink\" title=\"绑定器\"></a>绑定器</h3><p>绑定器主要职责是创建<em>符号</em>（Symbol）。符号将AST的声明节点和其他声明连接到相同实体上。绑定器会在检查器内被调用，检查器又被程序调用。</p>\n<p>绑定器有几个重要函数：</p>\n<ul>\n<li><code>bindSourceFile</code>，检查<code>file.locals</code>是否定义，没有则交给内部函数<code>bind</code>处理。<code>bindSourceFile</code>内部还定义了许多别的内部变量，通过闭包被其他内部函数使用</li>\n<li><code>bind</code>处理任意节点绑定，先分配<code>node.parent</code>，在交给<code>bindWorker</code>做主要工作，之后调用<code>bindChildren</code>执行子节点的绑定</li>\n<li><code>bindWorker</code>根据节点类型，委托工作给特定的<code>bindXXX</code>函数完成。在<code>bindXXX</code>内最常用的是<code>createSymbol</code>函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createSymbol</span>(<span class=\"params\">flags: SymbolFlags, name: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">Symbol</span> &#123;</span><br><span class=\"line\">  symbolCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Symbol</span>(flags, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>绑定器会调用<code>addDeclarationToSymbol</code>绑定一个节点到符号，并把节点添加成符号的一个声明。声明就是一个有可选名字的节点。</p>\n<h3 id=\"检查器与发射器\"><a href=\"#检查器与发射器\" class=\"headerlink\" title=\"检查器与发射器\"></a>检查器与发射器</h3><p>检查器由程序初始化。在发射器中，类型检查在<code>getDiagnostics</code>中发生，函数被调用时会返回一个<code>EmitResolver</code>。这是一个<code>createTypeChecker</code>的本地函数集合。</p>\n<p>TypeScript有两个发射器，<code>emitter.ts</code>完成TS到JavaScript，<code>declarationEmitter.ts</code>为<code>.ts</code>创建声明文件(<code>.d.ts</code>)。</p>\n<p>程序（Program）通过<code>emit</code>函数，把工作委托给<code>emitter.ts</code>的<code>emitFiles</code>函数。<code>emitFiles</code>中借助<code>emitJavaScript</code>完成主要工作，</p>\n<p><code>emitJavaScript</code>中有大量内部函数，之后借给<code>emitSourceFile</code>发射文本，该函数设置<code>currentSourceFile</code>后交给本地的<code>emit</code>函数处理。在<code>emitJavaScriptWorker</code>中会根据不同符号类型调用不同发射器处理。在<code>emitJavaScript</code>的过程中，<code>initializeEmitterWithSourceMaps</code>使用带有sourceMap的版本覆盖部分本地函数，使大多数发射器代码无需考虑SourceMap。</p>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><h3 id=\"类型系统的行为\"><a href=\"#类型系统的行为\" class=\"headerlink\" title=\"类型系统的行为\"></a>类型系统的行为</h3><p>首先有几个需要格外说明的：</p>\n<ul>\n<li>TypeScript使用<strong>结构化类型</strong>，即类型间的成员类型兼容即类型兼容。</li>\n<li>TypeScript的类型时<em>编译时</em>的，在运行时并没有类型信息，无法从反射或元数据中拿到。</li>\n</ul>\n<p>此外有些常见问题：</p>\n<ul>\n<li><strong>没有setter的getter并没有体现出只读属性</strong>，这在TypeScript2.0+已修复</li>\n<li>更少参数的函数可以赋值给更多参数的函数；返回值更多的函数可以复制给返回值更少的函数</li>\n<li>任何类型都可以等价替代没有属性的interface</li>\n<li>类型别名只是别名而已，进行类型判断时使用的是别名对应的类型</li>\n<li>由于结构化类型，两个不同名但是结构相同的类型，实际上是相互兼容的，有个<a href=\"https://github.com/Microsoft/TypeScript/issues/202\">相关issue</a>，但是尚没有结论</li>\n<li>由于TS的类型只存在于编译时，不能用运行时的<code>typeof</code>或<code>instanceof</code>判断类型。同样地，错误的TS类型转化也不会造成运行时的错误</li>\n<li>重载的最后一个声明签名对签名本身没有影响，所以为了获得重载本身的行为，需要添加额外的重载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLog</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLog</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, message: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLog</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, message?: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些常见的Feature-Request\"><a href=\"#一些常见的Feature-Request\" class=\"headerlink\" title=\"一些常见的Feature Request\"></a>一些常见的Feature Request</h3><ul>\n<li><a href=\"https://github.com/tc39/proposal-optional-chaining\">安全的导航操作符</a>，类似<code>a?.b?.c</code>，目前已在tc39的Stage 3阶段，将并入TS的3.7.0版本</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/issues/8\">代码压缩</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/issues/212\">bind(), call(), apply()返回的函数无类型</a></li>\n</ul>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><h4 id=\"空类的行为很奇怪\"><a href=\"#空类的行为很奇怪\" class=\"headerlink\" title=\"空类的行为很奇怪\"></a>空类的行为很奇怪</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Empty</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"attr\">e</span>: <span class=\"title class_\">Empty</span> = <span class=\"variable language_\">window</span>;</span><br></pre></td></tr></table></figure>\n\n<p>和之前提到的一样，<strong>任何内容都可以赋值给空接口</strong>。所以一般来说，永远不要声明一个没有任何属性的类，对于子类而是如此。</p>\n<h4 id=\"如何比较类\"><a href=\"#如何比较类\" class=\"headerlink\" title=\"如何比较类\"></a>如何比较类</h4><p>TypeScript中，类进行结构上的比较，但是对于<code>private</code>和<code>protected</code>属性除外。类在比较时，如果有成员是<code>private</code>或<code>protected</code>，它们必须来自同一个声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Alpha</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bravo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Charlie</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Delta</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Alpha</span>(),</span><br><span class=\"line\">  b = <span class=\"keyword\">new</span> <span class=\"title class_\">Bravo</span>(),</span><br><span class=\"line\">  c = <span class=\"keyword\">new</span> <span class=\"title class_\">Charlie</span>(),</span><br><span class=\"line\">  d = <span class=\"keyword\">new</span> <span class=\"title class_\">Delta</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">a = b; <span class=\"comment\">// OK</span></span><br><span class=\"line\">c = d; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"class和typeof-class的区别\"><a href=\"#class和typeof-class的区别\" class=\"headerlink\" title=\"class和typeof class的区别\"></a><code>class</code>和<code>typeof class</code>的区别</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">someMethod</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"attr\">x</span>: <span class=\"title class_\">MyClass</span>;</span><br><span class=\"line\"><span class=\"comment\">// Cannot assign &#x27;typeof MyClass&#x27; to MyClass? Huh?</span></span><br><span class=\"line\">x = <span class=\"title class_\">MyClass</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面混用了类型名和类本身，在JavaScript中，类仅仅是一个函数而已。而在TypeScript中，类名表示类实例的类型。</p>\n<h4 id=\"子类的属性在constructor中会被父类同名属性覆盖\"><a href=\"#子类的属性在constructor中会被父类同名属性覆盖\" class=\"headerlink\" title=\"子类的属性在constructor中会被父类同名属性覆盖\"></a>子类的属性在constructor中会被父类同名属性覆盖</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Default value</span></span><br><span class=\"line\">    myColor = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">myColor</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">     myColor = <span class=\"string\">&#x27;red&#x27;</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prints &quot;blue&quot;, expected &quot;red&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br></pre></td></tr></table></figure>\n\n<p>直接原因是在子类constructor中，父类的constructor要先执行。见<a href=\"https://stackoverflow.com/questions/43595943/why-are-derived-class-property-values-not-seen-in-the-base-class-constructor\">Stack Overflow</a>的解释。</p>\n<h4 id=\"interface和declare-class的区别\"><a href=\"#interface和declare-class的区别\" class=\"headerlink\" title=\"interface和declare class的区别\"></a><code>interface</code>和<code>declare class</code>的区别</h4><ul>\n<li><code>interface</code>用来声明一种类型，不会生成实际代码。</li>\n<li><code>declare class</code>用来描述一个已有类的结构</li>\n</ul>\n<h4 id=\"为什么我导入的模块在编译后被删除了\"><a href=\"#为什么我导入的模块在编译后被删除了\" class=\"headerlink\" title=\"为什么我导入的模块在编译后被删除了\"></a>为什么我导入的模块在编译后被删除了</h4><p>TypeScript默认导入的模块不包含副作用，所以会移除不用于任何表达式的模块导入。使用<code>import &#39;xxx&#39;;</code>强制导入有副作用的模块。</p>\n<h4 id=\"tsconfig-json\"><a href=\"#tsconfig-json\" class=\"headerlink\" title=\"tsconfig.json\"></a><code>tsconfig.json</code></h4><ul>\n<li>为什么exclude中的文件仍然会被编译器选中？<ul>\n<li>当exclude的文件被其他include文件依赖时，仍然会被包含进来</li>\n</ul>\n</li>\n<li>除了<code>include</code>外，还有没有指定包含文件的方式<ul>\n<li><code>files</code>指定文件列表</li>\n<li>目录中添加<code>///&lt;reference path=&quot;&quot;&gt;</code>引入</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "typescript",
                "类型系统"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/06/25/dart-best-practice/",
            "url": "http://shenlvmeng.github.com/blog/2019/06/25/dart-best-practice/",
            "title": "Dart快速入门 效率篇",
            "date_published": "2019-06-24T16:51:28.000Z",
            "content_html": "<blockquote>\n<p>参考自<a href=\"https://dart.dev/guides/language/effective-dart\">Effective Dart</a>，截至2019&#x2F;06&#x2F;12</p>\n</blockquote>\n<h2 id=\"通用原则\"><a href=\"#通用原则\" class=\"headerlink\" title=\"通用原则\"></a>通用原则</h2><p>类似其他编程语言，有下面两点注意事项：</p>\n<ul>\n<li>Be consistent, 统一风格</li>\n<li>Be brief, 保持精简，DRY</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><p>指南以下面的关键词开头：</p>\n<ul>\n<li><strong>要</strong>，一定遵守，下面没有前缀的就是以此开头</li>\n<li><strong>不要</strong>，这么做不是个好主意</li>\n<li><strong>推荐</strong>，应该遵守，当不遵守时确保有合理理由</li>\n<li><strong>避免</strong>，和上面相反，除非有足够好的理由，否则不应该这么做</li>\n<li><strong>考虑</strong>，根据实际情况而定</li>\n</ul>\n<p>同时会提到下面这些客体：</p>\n<ul>\n<li><strong>库成员</strong>，顶级变量、getter、setter、函数</li>\n<li><strong>类成员</strong>，类变量、getter、setter、函数</li>\n<li><strong>成员</strong>，库成员或类成员</li>\n<li><strong>变量</strong></li>\n<li><strong>属性</strong>，类中的成员变量、getter、setter，顶级变量、getter、setter</li>\n</ul>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><h4 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h4><ul>\n<li>类名用UpperCamelCase风格</li>\n<li>库和文件名用lowercase_with_underscores风格</li>\n<li>导入前缀用lowercase_with_underscores风格<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:javascript_utils/javascript_utils.dart&#x27;</span> <span class=\"keyword\">as</span> js_utils;</span><br></pre></td></tr></table></figure></li>\n<li>其他标识符使用lowerCamelCase风格</li>\n<li><strong>推荐</strong>使用lowerCamelCase风格命名常量<ul>\n<li>原因：CAPS_STYLE可读性差&#x2F;可能会用于final变量&#x2F;和枚举不搭</li>\n</ul>\n</li>\n<li>把超过2个字母的缩略词当做一般单词来做首字母大写<ul>\n<li>原因：提高可读性</li>\n</ul>\n</li>\n<li><strong>不要</strong>在标识符前加前缀<ul>\n<li>举例：<code>kTimes</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"顺序\"><a href=\"#顺序\" class=\"headerlink\" title=\"顺序\"></a>顺序</h4><ul>\n<li>把”dart:”导入语句放在最前</li>\n<li>把”package:”放在相对导入前</li>\n<li><strong>推荐</strong>把第三方”package:”导入放在其他语句前</li>\n<li>export语句放在最后</li>\n<li>按字母序排序</li>\n</ul>\n<h4 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h4><ul>\n<li>使用dartfmt帮你美化</li>\n<li><strong>考虑</strong>让你的代码更容易美化</li>\n<li><strong>避免</strong>每行超过80字符</li>\n<li>所有控制结构都使用大括号<ul>\n<li>只有if语句写成1行时可以省略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><h4 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h4><ul>\n<li>使用句子的形式表达注释</li>\n<li>用单行注释符表达注释</li>\n</ul>\n<h4 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h4><ul>\n<li>用<code>///</code>表达文档注释</li>\n<li><strong>推荐</strong>为公开API书写注释</li>\n<li><strong>考虑</strong>为私有API书写注释</li>\n<li>用一句话为文档注释开头</li>\n<li>类似git commit message，第一行后空出一行独立成段</li>\n<li>去掉能从上下文直接读出的冗余信息</li>\n<li><strong>推荐</strong>使用第三人称动词开头表示函数、方法注释</li>\n<li><strong>推荐</strong>使用名词短语开头表示变量、成员、getter、setter注释</li>\n<li><strong>推荐</strong>使用名词短语开头表示库、类型注释</li>\n<li><strong>考虑</strong>在注释中添加示例代码</li>\n<li>在注释中用<code>[]</code>方括号引用作用域里的标识符</li>\n<li>使用简短平实的语言描述参数、返回值和异常</li>\n<li>在注解（annotation）前添加注释</li>\n</ul>\n<h4 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h4><p>Dart允许在comment中使用Markdown格式。</p>\n<ul>\n<li><strong>避免</strong>滥用markdown</li>\n<li><strong>避免</strong>使用html格式化文本</li>\n<li><strong>推荐</strong>使用反引号（```）格式化代码</li>\n</ul>\n<h4 id=\"行文\"><a href=\"#行文\" class=\"headerlink\" title=\"行文\"></a>行文</h4><ul>\n<li><strong>推荐</strong>简洁清晰</li>\n<li><strong>避免</strong>使用缩写和首字母缩略词</li>\n<li><strong>推荐</strong>使用“this”而不是“the”来引用实例成员</li>\n</ul>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>下面的规则是书写Dart代码时需要知道的指导原则，尤其是维护你类库的人。</p>\n<h4 id=\"库\"><a href=\"#库\" class=\"headerlink\" title=\"库\"></a>库</h4><ul>\n<li><p>出于历史原因，Dart允许通过<code>part of</code>的方式使用库的一部分文件，使用时通过路径而不是变量名引用</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> my_library;</span><br><span class=\"line\"><span class=\"comment\">// good case</span></span><br><span class=\"line\"><span class=\"keyword\">part</span> of <span class=\"string\">&quot;../../my_library.dart&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bad case</span></span><br><span class=\"line\"><span class=\"keyword\">part</span> of my_library</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不要从库的<code>src</code>文件夹下引用代码</p>\n</li>\n<li><p><strong>推荐</strong>使用相对路径应用库，但是不要跨<code>src</code>文件夹引用</p>\n</li>\n</ul>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><ul>\n<li>在长字符串场景下，使用邻接字符串而不是“+”链接<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// good case</span></span><br><span class=\"line\">raiseAlarm(</span><br><span class=\"line\">    <span class=\"string\">&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27;</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;parts are overrun by martians. Unclear which are which.&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n<li><strong>推荐</strong>使用插值构造字符串</li>\n<li><strong>避免</strong>在插值中使用多余的大括号（对于简单的变量）</li>\n</ul>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><ul>\n<li>尽可能使用字面量形式定义集合，必要时提供泛型类型即可<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// good case</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> points = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> userMap = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bad case</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> points = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> userMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure></li>\n<li>不使用length属性判断集合是否为空，Dart提供了<code>isEmpty</code>和<code>isNotEmpty</code></li>\n<li><strong>考虑</strong>使用高阶函数来明确表达你的意图<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aquaticNames = animals</span><br><span class=\"line\">    .where((animal) =&gt; animal.isAquatic)</span><br><span class=\"line\">    .map((animal) =&gt; animal.name);</span><br></pre></td></tr></table></figure></li>\n<li><strong>避免</strong>在<code>Iterable.forEach()</code>中使用函数声明，Dart里的<code>for-in</code>循环可以很好完成该工作，当然函数本身已经定义好除外。<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// good case</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> person <span class=\"keyword\">in</span> people) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">people.forEach(<span class=\"built_in\">print</span>);</span><br></pre></td></tr></table></figure></li>\n<li>使用<code>iterable.toList</code>替代<code>List.from</code>，只在改变list类型时使用<code>List.from</code><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Creates a List&lt;int&gt;:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iterable = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prints &quot;List&lt;int&gt;&quot;:</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(iterable.toList().runtimeType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prints &quot;List&lt;dynamic&gt;&quot;:</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">List</span>.from(iterable).runtimeType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use it with a type</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2.3</span>, <span class=\"number\">4</span>]; <span class=\"comment\">// List&lt;num&gt;.</span></span><br><span class=\"line\">numbers.removeAt(<span class=\"number\">1</span>); <span class=\"comment\">// Now it only contains integers.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ints = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;.from(numbers);</span><br></pre></td></tr></table></figure></li>\n<li>使用高级的<code>whereType</code>方法从collection中过滤出特定类型元素<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [<span class=\"number\">1</span>, <span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> ints = objects.whereType&lt;<span class=\"built_in\">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>\n<li>有类似用法时，不使用<code>cast()</code>方法<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stuff = &lt;<span class=\"built_in\">dynamic</span>&gt;[<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Good case</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ints = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;.from(stuff);</span><br><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ints = stuff.toList().cast&lt;<span class=\"built_in\">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>\n<li><strong>避免</strong>使用<code>cast()</code>方法，用该方法可能更慢且更有风险，通常情况下有下面一些备选方案<ul>\n<li>创建有正确类型的list</li>\n<li>使用每个集合元素时进行casting操作<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Good case</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> printEvens(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Object</span>&gt; objects) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// We happen to know the list only contains ints.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> objects) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((n <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>).isEven) <span class=\"built_in\">print</span>(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> printEvens(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Object</span>&gt; objects) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// We happen to know the list only contains ints.</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> objects.cast&lt;<span class=\"built_in\">int</span>&gt;()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n.isEven) <span class=\"built_in\">print</span>(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>真正想要强制类型转换时，使用附加类型的<code>List.from</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li>使用函数声明形式命名有名函数（不要使用lambda表达式）</li>\n<li>当有有名函数可以完成任务时，不要创建lambda表达式<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Good case</span></span><br><span class=\"line\">names.forEach(<span class=\"built_in\">print</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\">names.forEach((name) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(name);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li>使用<code>=</code>分隔入参和它的默认值</li>\n<li>不要显式地使用<code>null</code>作为默认值（直接不指定即可）<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> error([<span class=\"built_in\">String</span> message]) &#123;</span><br><span class=\"line\">  stderr.write(message ?? <span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><ul>\n<li>不要显式地使用null初始化变量（语言保证了行为可靠性，不需要再显式设置成null）</li>\n<li>不要存储computed value（即可以推算出的值） ，减少冗余信息，保证数据唯一可信源，使用getter和setter去动态推导出它们</li>\n<li><strong>考虑</strong>忽略局部变量的类型，Dart有强大的静态分析工具帮你推断类型。</li>\n</ul>\n<h4 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h4><ul>\n<li>不要创建没必要的getter和setter</li>\n<li><strong>推荐</strong>使用final限定只读属性</li>\n<li><strong>考虑</strong>使用<code>=&gt;</code>实现只有单一返回语句的函数，对于多行语句建议还是老老实实使用花括号<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span> width =&gt; right - left;</span><br><span class=\"line\"><span class=\"built_in\">bool</span> ready(<span class=\"built_in\">num</span> time) =&gt; minTime == <span class=\"keyword\">null</span> || minTime &lt;= time;</span><br><span class=\"line\">containsValue(<span class=\"built_in\">String</span> value) =&gt; getValues().contains(value);</span><br></pre></td></tr></table></figure></li>\n<li>不要使用<code>this.</code>访问成员，除非遇到变量冲突<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Good case</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> clear() &#123;</span><br><span class=\"line\">    update(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> update(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> clear() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.update(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> update(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>尽可能地在定义变量时初始化该值</li>\n</ul>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><ul>\n<li>尽可能使用更简洁的初始化形式<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>不要在初始化形式中定义类型</li>\n<li>使用<code>;</code>代替<code>&#123;&#125;</code>表示空方法<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>不要使用可选的<code>new</code>来返回一个对象<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Row(</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      RaisedButton(</span><br><span class=\"line\">        child: Text(<span class=\"string\">&#x27;Increment&#x27;</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      Text(<span class=\"string\">&#x27;Click!&#x27;</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>不要无谓地使用<code>const</code>（基本上const可能出现在所有你能使用<code>new</code>的地方），因为有些语境已经隐式包含了const语义<ul>\n<li>字面量集合</li>\n<li>const构造函数调用</li>\n<li>metadata注解</li>\n<li>switch的每一个case</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><ul>\n<li>不要在<code>on</code>以外的语句中丢弃错误，因为在没有<code>on</code>限定时，catch会捕获<em>所有</em>异常</li>\n<li>要只在编程错误时抛出Error的异常</li>\n<li>不要显式地捕获Error及其子类</li>\n<li>使用<code>rethrow</code>重新抛出异常</li>\n</ul>\n<h4 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h4><ul>\n<li><strong>推荐</strong>使用<code>async</code>和<code>await</code>提升你的异步代码可读性</li>\n<li>只在必要的时候使用<code>async</code><ul>\n<li>代码块中使用了<code>await</code></li>\n<li>希望返回一个Future</li>\n<li>希望更方便地处理异步中出现的Error</li>\n<li>异步事件发生具有先后顺序</li>\n</ul>\n</li>\n<li><strong>考虑</strong>使用高阶函数处理stream</li>\n<li><strong>避免</strong>直接使用<code>Completer</code></li>\n<li>用<code>Future&lt;T&gt;</code>而不是<code>T</code>判断<code>FutureOr&lt;T&gt;</code>的具体类型</li>\n</ul>\n<h3 id=\"API设计\"><a href=\"#API设计\" class=\"headerlink\" title=\"API设计\"></a>API设计</h3><h4 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h4><ul>\n<li>使用一致的术语</li>\n<li><strong>避免</strong>缩写，只使用广为人知的缩写</li>\n<li><strong>推荐</strong>把描述中心词放在最后</li>\n<li><strong>考虑</strong>尽量让代码看起来像普通的句子</li>\n<li><strong>推荐</strong>使用名词短语命名非布尔类型的成员或变量</li>\n<li><strong>推荐</strong>使用非命令式短语命名布尔类型成员或变量<ul>\n<li>比如配合be动词的不同时态，<code>isEnabled</code>, <code>hasShown</code>等</li>\n<li>配合助动词，比如<code>hasChildren</code>, <code>canSave</code></li>\n</ul>\n</li>\n<li>有可能的情况下，<strong>考虑</strong>省去上一种情况里的动词</li>\n<li><strong>推荐</strong>使用正向含义的布尔类型变量&#x2F;方法名</li>\n<li><strong>推荐</strong>使用命令式动词命名带有副作用的函数和方法</li>\n<li><strong>考虑</strong>使用名词短语或非命令式动词命名返回数据为主要功能的方法或函数<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.elementAt(<span class=\"number\">3</span>)</span><br><span class=\"line\">string.codeUnitAt(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure></li>\n<li><strong>考虑</strong>使用命令式动词表示你需要对方法所做工作有所关心</li>\n<li><strong>避免</strong>使用<em>get</em>开头的命名，它通常能用getter代替</li>\n<li><strong>推荐</strong>使用<code>to___()</code>来命名类型转换</li>\n<li><strong>推荐</strong>使用<code>as___()</code>来命名类型快照</li>\n<li><strong>避免</strong>在命名中使用方法、函数的入参</li>\n<li>使用助记符命名类型参数<ul>\n<li><code>E</code>代表集合元素</li>\n<li><code>K</code>和<code>V</code>代表key和value</li>\n<li><code>R</code>代表return type</li>\n<li><code>T</code>, <code>S</code>和<code>U</code>命名单一通用且上下文表意清晰的泛型</li>\n<li>除上面情况外，可以使用完整词汇作为泛型类型名</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"库-1\"><a href=\"#库-1\" class=\"headerlink\" title=\"库\"></a>库</h4><p>下划线开头的成员表示成员是私有的，这个特性是内置在Dart语言中的。</p>\n<ul>\n<li><strong>推荐</strong>使用私有声明，未用<code>_</code>开头的库中的公开声明、顶级定义表示其他库可以访问这些成员，同时也会受到库实现契约的约束。</li>\n<li><strong>考虑</strong>在同一个库内定义多个类，这样便于在类之间共享私有变量</li>\n</ul>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><p>Dart是纯OOP的语言，它的所有对象都是类实例。当然不像Java，Dart也允许你定义顶级的变量、函数…</p>\n<ul>\n<li><strong>避免</strong>定义一个函数就可以实现的只有一个实现方法的抽象类<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Predicate&lt;E&gt; = <span class=\"built_in\">bool</span> <span class=\"built_in\">Function</span>(E element);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> test(E element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>避免</strong>定义只有静态成员的类，可以使用顶级变量、函数更方便地实现等价效果。当然，如果变量属于一个组，可以这么实现</li>\n<li><strong>避免</strong>不必要地定义子类</li>\n<li><strong>避免</strong>实现一个不作为接口的类</li>\n<li><strong>避免</strong>mixin不设计用作mixin的类</li>\n<li>在你的类支持拓展时，定义好文档</li>\n<li>在你的类作为接口存在时，定义好文档</li>\n<li>在你的类作为mixin存在时，定义好文档</li>\n</ul>\n<h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><ul>\n<li><strong>考虑</strong>在类支持的情况下，让构造函数成为const</li>\n</ul>\n<h4 id=\"成员-1\"><a href=\"#成员-1\" class=\"headerlink\" title=\"成员\"></a>成员</h4><ul>\n<li><strong>考虑</strong>尽可能地把成员变量和顶级变量定义为final类型</li>\n<li>使用setter和getter定义computed value</li>\n<li>不要使用没有getter的setter</li>\n<li><strong>避免</strong>在返回bool，double，int，num的方法里返回null</li>\n<li><strong>避免</strong>在方法中返回this，只为了串联调用函数</li>\n</ul>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>Dart中的类型可以帮助使用者理解你API中的静态类型设计，它分两种：类型注解和类型参数。前一种放在变量名前注解变量类型，后一种作为泛型参数传入。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isEmpty(<span class=\"built_in\">String</span> parameter) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> result = parameter.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; ints = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n\n<p>在未指定类型时，Dart会从上下文自动推断或者使用缺省的<code>dynamic</code>类型。</p>\n<p>简言之，Dart提供了强大的类型推导简化了你声明类型的负担，但同时不声明类型会降低API的可读性，下面一些guideline帮你在两点间找到一个平衡。</p>\n<ul>\n<li><strong>推荐</strong>对于类型表意不清晰的public属性和顶级变量使用类型注解<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;<span class=\"built_in\">bool</span>&gt; install(PackageId id, <span class=\"built_in\">String</span> destination) =&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> screenWidth = <span class=\"number\">640</span>; <span class=\"comment\">// Inferred as int.</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>考虑</strong>对于类型表意不清晰的private属性添加类型注解</li>\n<li><strong>避免</strong>为局部变量添加类型注解，如果你需要静态类型提供的便利，可以借助<code>is</code>限制变量类型</li>\n<li><strong>避免</strong>在方法表达式上使用类型，考虑到方法表达式通常作为方法入参，类型可以自动推断，不需要类型注解</li>\n<li><strong>避免</strong>冗余的泛型和类型注解<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Good case</span></span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; things = <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; things = <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br></pre></td></tr></table></figure></li>\n<li>在不希望使用Dart推断的类型时，使用类型注解</li>\n<li><strong>推荐</strong>使用显示的dynamic代替Dart推断失败回退的dynamic</li>\n<li><strong>推荐</strong>在Function类型注解中添加函数类型签名</li>\n<li>不要为setter指定返回值</li>\n<li>使用新式的typeof判断类型<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Comparison&lt;T&gt; = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(T, T);</span><br></pre></td></tr></table></figure></li>\n<li>使用<code>Object</code>代替<code>dynamic</code>表示可以接受任何对象</li>\n<li>使用<code>Future&lt;void&gt;</code>作为无返回值的异步函数返回类型</li>\n<li>不使用<code>FutureOr&lt;T&gt;</code>作为返回值</li>\n</ul>\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><strong>避免</strong>位置参数作为可选布尔参数，这样可读性比较差<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Task(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> Task(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> ListBox(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> Button(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Good case</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>避免</strong>将用户想忽略的参数放在位置可选参数的前列</li>\n<li><strong>避免</strong>使用强制的无意义的参数<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bad case</span></span><br><span class=\"line\">string.substring(start, <span class=\"keyword\">null</span>)</span><br></pre></td></tr></table></figure></li>\n<li>使用<strong>左闭右开</strong>区间表示两个参数代表的范围</li>\n</ul>\n<h4 id=\"相同判断\"><a href=\"#相同判断\" class=\"headerlink\" title=\"相同判断\"></a>相同判断</h4><ul>\n<li>覆写<code>==</code>的同时覆写<code>hashCode</code>，默认的哈希函数实现了恒等式哈希。<strong>任何两个相等的两个对象必须具有相同的哈希值</strong>。</li>\n<li><code>==</code>需要遵循数学的相等规则<ul>\n<li>自反，a &#x3D;&#x3D; a</li>\n<li>对称，a &#x3D;&#x3D; b &#x3D;&gt; b &#x3D;&#x3D; a</li>\n<li>传递，a &#x3D;&#x3D; b &amp;&amp; b &#x3D;&#x3D; c &#x3D;&gt; a &#x3D;&#x3D; c</li>\n</ul>\n</li>\n<li><strong>避免</strong>为可变对象自定义相等函数，<code>hashCode</code>函数会增加你的工作量</li>\n<li>不要在自定义<code>==</code>中判断null，Dart也已经替你做了这部分工作</li>\n</ul>\n",
            "tags": [
                "Dart",
                "最佳实践"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2019/06/16/dart-lang-intro/",
            "url": "http://shenlvmeng.github.com/blog/2019/06/16/dart-lang-intro/",
            "title": "Dart快速入门 语法篇",
            "date_published": "2019-06-15T16:13:19.000Z",
            "content_html": "<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义个方法。</span></span><br><span class=\"line\">printNumber(<span class=\"built_in\">num</span> aNumber) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The number is <span class=\"subst\">$aNumber</span>.&#x27;</span>); <span class=\"comment\">// 在控制台打印内容。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这是程序执行的入口。</span></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number = <span class=\"number\">42</span>; <span class=\"comment\">// 定义并初始化一个变量。</span></span><br><span class=\"line\">  printNumber(number); <span class=\"comment\">// 调用一个方法。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注释：<code>//</code>或<code>/* ... */</code>，同其他主流语言</li>\n<li>类型：num、String、int、bool等</li>\n<li>字面量：42，’Hello world!’</li>\n<li>函数：类似<code>print()</code>的形式</li>\n<li>字符串插值</li>\n<li>入口方法：<code>main</code></li>\n</ul>\n<h2 id=\"基本理念\"><a href=\"#基本理念\" class=\"headerlink\" title=\"基本理念\"></a>基本理念</h2><ul>\n<li><strong>所有可以用变量引用的都是对象，每个对象都是一个类的实例</strong>，例如数字、方法、null，<strong>所有对象都继承Object类</strong></li>\n<li>Dart是<strong>强类型语言</strong>。但是不强制使用类型标注，因为它可以通过推导得到变量类型。在你明确不希望有类型时，使用<code>dynamic</code>关键字表示动态类型</li>\n<li>Dart支持泛型，比如<code>List&lt;int&gt;</code></li>\n<li>Dart支持顶级方法<code>main()</code>，支持类的静态方法、实例方法，也可以在函数内使用函数</li>\n<li>类似地，Dart支持全局变量、局部变量和在类中定义的成员变量</li>\n<li>Dart<strong>没有</strong>public、protected、private的区分，如果标识符以<code>_</code>开头，那么该标识符就是私有的</li>\n<li>Dart的变量名只能以<strong>下划线和字母</strong>开头，后跟<strong>字符或数字</strong></li>\n<li>Dart区分语句块和表达式，只有表达式有值。</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p>分为三类：</p>\n<ul>\n<li>对于只在特定上下文环境下生效的<strong>上下文关键字</strong>，可以用作标识符</li>\n<li>对于<strong>内置标识符</strong>，为了便于移植JavaScript代码到Dart，这些关键字不可用作类或类型名或import的前缀</li>\n<li>其他关键字为保留字</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;Dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> name = <span class=\"string\">&#x27;Dart&#x27;</span>;</span><br><span class=\"line\">Dynamic name = <span class=\"string\">&#x27;Dart&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>根据<em>基本理念</em>，变量都是存储值的引用。使用<code>var</code>修饰时，变量类型会自动推导；也可以显示声明变量类型，或者使用<code>dynamic</code>关键字表示变量可能有多种类型。</p>\n<p>任何没有初始化的变量默认值都为null。</p>\n<p>常量使用<code>final</code>或<code>const</code>（实例变量只能用<code>final</code>）。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> name = <span class=\"string\">&#x27;foo&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"built_in\">String</span> title = <span class=\"string\">&#x27;FE&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"number\">10000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">double</span> percent = <span class=\"number\">0.314</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> bar = <span class=\"keyword\">const</span>[];</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = []; <span class=\"comment\">// 和上面一个效果</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>final变量只能赋值一次，const变量是编译时常量。</li>\n<li><code>const</code>除了用来定义不变量，还可以用来创建不变的值，以及定义创建常量的构造函数。在这么用时可以省略构造过程，像上面的baz变量一样</li>\n</ul>\n<h2 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h2><ul>\n<li>numbers</li>\n<li>strings</li>\n<li>booleans</li>\n<li>lists (也被称之为 arrays)</li>\n<li>maps</li>\n<li>runes (用于在字符串中表示 Unicode 字符)</li>\n<li>symbols</li>\n</ul>\n<p>再次重申，Dart中变量都是一个对象，所以你都可以使用构造函数来初始化。</p>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h3><p>有<code>int</code>和<code>double</code>两种类型。提供了原生操作符和<code>abs()</code>等常用函数，整数和浮点数的字面量初始化类似js。</p>\n<p>字符串和数字互转：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String -&gt; int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"built_in\">int</span>.parse(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(one == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String -&gt; double</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> onePointOne = <span class=\"built_in\">double</span>.parse(<span class=\"string\">&#x27;1.1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(onePointOne == <span class=\"number\">1.1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// int -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> oneAsString = <span class=\"number\">1.</span>toString();</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(oneAsString == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> piAsString = <span class=\"number\">3.14159</span>.toStringAsFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(piAsString == <span class=\"string\">&#x27;3.14&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>Dart的字符串是UTF-16编码的字符序列。可以使用单引号或双引号创建。字符串中用<code>$&#123;expr&#125;</code>的语法使用表达式，**如果表达式是一个标识符，可以省去<code>&#123;&#125;</code>**，对<code>&#123;&#125;</code>内的表达式，Dart使用<code>toString()</code>方法转成字符串使用。</p>\n<p>使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>表示多行字符串。使用<code>r&#39;&#39;</code>表示纯字符串。</p>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>布尔类型有两个字面量值，<code>true</code>和<code>false</code>。和JavaScript不同的是，在<code>if</code>语句等使用bool类型的地方，<strong>只有<code>true</code>被认为是true，其余所有值都是false</strong>。这也是为了避免JavaScript中判断true、false时坑爹的地方。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;JS prints this line.&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Dart in production mode prints this line.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// However, in checked mode, if (1) throws an</span></span><br><span class=\"line\">  <span class=\"comment\">// exception because 1 is not boolean.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>List的字面量写法和JavaScript一样。Dart会做类型推导，在元素类型不一致时报错。你可以使用const语句定义一个不变的List对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>2.3后，Dart支持<code>...</code>解构操作符，以及对空列表兼容的<code>...?</code>。同时支持collection if和collection for语法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nav = [</span><br><span class=\"line\">  <span class=\"string\">&#x27;Home&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;Furniture&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;Plants&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promoActive) <span class=\"string\">&#x27;Outlet&#x27;</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> listOfInts = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> listOfStrings = [</span><br><span class=\"line\">  <span class=\"string\">&#x27;#0&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> listOfInts) <span class=\"string\">&#x27;#<span class=\"subst\">$i</span>&#x27;</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><blockquote>\n<p>2.2版本后支持</p>\n</blockquote>\n<p>一组元素唯一的无序列表。字面量写法类似数学中集合的定义方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> halogens = &#123;<span class=\"string\">&#x27;fluorine&#x27;</span>, <span class=\"string\">&#x27;chlorine&#x27;</span>, <span class=\"string\">&#x27;bromine&#x27;</span>, <span class=\"string\">&#x27;iodine&#x27;</span>, <span class=\"string\">&#x27;astatine&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用构造函数的方式创建。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elements = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\">elements.add(<span class=\"string\">&#x27;fluorine&#x27;</span>);</span><br><span class=\"line\">elements.addAll(halogens);</span><br></pre></td></tr></table></figure>\n\n<p>类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>表达键值对数据，每个键只出现一次，且<strong>可以是任意类型</strong>。类似Set，可以使用字面量和构造函数两种方式构造。使用字面量时，Dart会做类型推导。</p>\n<p>Map的设置和JavaScript类似，另外类似List，2.3之后有<code>...</code>和<code>...?</code>的语法支持。</p>\n<h3 id=\"Rune\"><a href=\"#Rune\" class=\"headerlink\" title=\"Rune\"></a>Rune</h3><p>Dart用Rune类型表示UTF-32的字符，如emoji等。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>用来代表Dart中声明的操作符或标识符，可以在标识符前添加<code>#</code>获取标识符的Symbol对象。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>类似JavaScript，Dart中的Function也是对象并具有Function类型。推荐使用显式类型声明方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isNoble(<span class=\"built_in\">int</span> atomicNumber) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart支持箭头函数。</p>\n<h3 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h3><p>可选参数分两种：命名参数、位置参数。</p>\n<p>命名参数使用<code>param: value</code>指定，在调用时使用<code>&#123;param1, param2&#125;</code>的形式传递参数。支持在参数前添加<code>@required</code>表示参数必选。</p>\n<p>位置参数使用<code>[]</code>包裹方法参数，使用时不传参数即可。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enableFlags(bold: <span class=\"keyword\">true</span>, hidden: <span class=\"keyword\">false</span>);</span><br><span class=\"line\">enableFlags(&#123;<span class=\"built_in\">bool</span> bold, <span class=\"built_in\">bool</span> hidden&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg, [<span class=\"built_in\">String</span> device]) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Howdy&#x27;</span>) == <span class=\"string\">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>定义方法时，可以使用<code>=</code>定义可选参数的默认值。否则默认值为null。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg,</span><br><span class=\"line\">    [<span class=\"built_in\">String</span> device = <span class=\"string\">&#x27;carrier pigeon&#x27;</span>, <span class=\"built_in\">String</span> mood]) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"string\">&#x27;<span class=\"subst\">$from</span> says <span class=\"subst\">$msg</span>&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (device != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">&#x27;<span class=\"subst\">$result</span> with a <span class=\"subst\">$device</span>&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mood != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">&#x27;<span class=\"subst\">$result</span> (in a <span class=\"subst\">$mood</span> mood)&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Howdy&#x27;</span>) ==</span><br><span class=\"line\">    <span class=\"string\">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><p>每个应用都需要有顶级的<code>main()</code>函数作为入口，返回值void类型，并且有可选的<code>List&lt;String&gt;</code>参数（用于解析命令行输入的参数数据）。如</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">querySelector</span>(<span class=\"string\">&quot;#sample_text_id&quot;</span>)</span><br><span class=\"line\">    ..text = <span class=\"string\">&quot;Click me!&quot;</span></span><br><span class=\"line\">    ..onClick.listen(reverseText);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的<code>..</code>语法为级联调用，表示在一个对象上执行多个操作。</p>\n</blockquote>\n<h3 id=\"第一公民\"><a href=\"#第一公民\" class=\"headerlink\" title=\"第一公民\"></a>第一公民</h3><p>类似JavaScript，Dart中Function可以作为参数、返回值、变量、对象使用。同样也有匿名函数可以使用，区别是箭头后是语句块时，不使用箭头，只在之后是表达式时使用箭头。</p>\n<h3 id=\"作用域与闭包\"><a href=\"#作用域与闭包\" class=\"headerlink\" title=\"作用域与闭包\"></a>作用域与闭包</h3><p>Dart是静态作用域，即变量的作用域在写代码时就确定了，作用域层级即大括号的层级。</p>\n<p>类似JavaScript，Dart的闭包意味着方法可以封闭其作用域内的变量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Returns a function that adds [addBy] to the</span></span></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">function&#x27;s argument.</span></span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> addBy) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; addBy + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 2.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 4.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add4 = makeAdder(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add2(<span class=\"number\">3</span>) == <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add4(<span class=\"number\">3</span>) == <span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>所有函数<strong>必须返回一个值</strong>，否则默认<code>return null</code>。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ul>\n<li><code>~/</code>返回取整截断的商</li>\n<li>使用<code>==</code>判断相等性<ul>\n<li>会调用左侧对象的<code>==</code>方法，和后面的对象对比</li>\n</ul>\n</li>\n<li>类型转换：<ul>\n<li><code>as</code>，类型转换，类似typescript中的as</li>\n<li><code>is</code> 判断对象是否是指定类型</li>\n<li><code>is!</code> 判断对象是否不是指定类型</li>\n</ul>\n</li>\n<li><code>??=</code>在value不是null时赋值给变量</li>\n<li><code>expr1 ?? expr2</code>表示如果expr1是非null则返回其值，否则执行expr2并返回</li>\n<li><code>..</code> 级联操作符，表示在一个对象上连续调用多个函数以及访问成员变量，可以嵌套</li>\n<li><code>?.</code>和<code>.</code>类似，但是在左侧操作对象为null时返回null<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> addressBook = (<span class=\"keyword\">new</span> AddressBookBuilder()</span><br><span class=\"line\">      ..name = <span class=\"string\">&#x27;jenny&#x27;</span></span><br><span class=\"line\">      ..email = <span class=\"string\">&#x27;jenny@example.com&#x27;</span></span><br><span class=\"line\">      ..phone = (<span class=\"keyword\">new</span> PhoneNumberBuilder()</span><br><span class=\"line\">            ..number = <span class=\"string\">&#x27;415-555-0100&#x27;</span></span><br><span class=\"line\">            ..label = <span class=\"string\">&#x27;home&#x27;</span>)</span><br><span class=\"line\">          .build())</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><ul>\n<li>for循环中，Dart会自动捕获当时的index索引值，避免JavaScript中问题。对interable的对象可以使用<code>forEach()</code>方法遍历，对List、Set还支持<code>for-in</code>形式的遍历</li>\n<li><code>switch</code>中的每个case（除了空case）都必须有<code>break</code></li>\n<li><code>assert</code>在检查模式下会被跳过</li>\n</ul>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>和JavaScript中的异常类似。</p>\n<p>不一样的是，可以使用<code>on</code>或<code>catch</code>捕获异常，可以通过<code>rethrow</code>在其中重新抛出异常。</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><ul>\n<li>构造方式类似ES6中引入JavaScript Class。</li>\n<li>用成员方式声明的类变量在定义时初始化，也就是在构造函数前</li>\n<li>可以使用Object的runtimeType属性来判断实例的类型</li>\n<li>使用const关键字结合构造函数可以构造出不可变的对象实例</li>\n</ul>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>使用和类名同名的方法作为构造函数（或者使用<em>命名构造函数</em>）。因为把构造函数参数赋值给实例变量的场景太常见了，Dart提供了下面的语法糖。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Syntactic sugar for setting x and y</span></span><br><span class=\"line\">  <span class=\"comment\">// before the constructor body runs.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用命名构造函数实现多个构造函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Named constructor</span></span><br><span class=\"line\">  Point.fromJson(<span class=\"built_in\">Map</span> json) &#123;</span><br><span class=\"line\">    x = json[<span class=\"string\">&#x27;x&#x27;</span>];</span><br><span class=\"line\">    y = json[<span class=\"string\">&#x27;y&#x27;</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>子类不会从父类继承构造函数</strong>，在未定义构造函数时，会有一个默认构造函数，这个函数没有参数，且会调起父类的没有参数的构造函数。</p>\n<p>在有初始化参数列表（initializer list）的情况下，初始化参数列表在父类构造函数前执行。</p>\n<ol>\n<li>初始化参数列表</li>\n<li>父类无参构造函数</li>\n<li>子类无参构造函数</li>\n</ol>\n<p>父类没有无参构造函数时，需要手动调用父类的其他构造函数。</p>\n<h4 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h4><p>在执行父类构造函数前，可以初始化实例参数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Initializer list sets instance variables before</span></span><br><span class=\"line\">  <span class=\"comment\">// the constructor body runs.</span></span><br><span class=\"line\">  Point.fromJson(<span class=\"built_in\">Map</span> jsonMap)</span><br><span class=\"line\">      : x = jsonMap[<span class=\"string\">&#x27;x&#x27;</span>],</span><br><span class=\"line\">        y = jsonMap[<span class=\"string\">&#x27;y&#x27;</span>] &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;In Point.fromJson(): (<span class=\"subst\">$x</span>, <span class=\"subst\">$y</span>)&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在冒号右边用逗号隔开初始化表达式。注意：等号右边无法访问<code>this</code>。</p>\n<h4 id=\"重定向构造函数\"><a href=\"#重定向构造函数\" class=\"headerlink\" title=\"重定向构造函数\"></a>重定向构造函数</h4><p>重定向构造函数没有代码，<strong>在构造函数声明后</strong>，用冒号调用其他构造函数</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The main constructor for this class.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Delegates to the main constructor.</span></span><br><span class=\"line\">  Point.alongXAxis(<span class=\"built_in\">num</span> x) : <span class=\"keyword\">this</span>(x, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常量构造函数\"><a href=\"#常量构造函数\" class=\"headerlink\" title=\"常量构造函数\"></a>常量构造函数</h4><p>如果类支持提供状态不变的对象，需要定义一个<code>const</code>构造函数，且所有类变量都要是<code>final</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin =</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂构造函数\"><a href=\"#工厂构造函数\" class=\"headerlink\" title=\"工厂构造函数\"></a>工厂构造函数</h4><p>当你的构造函数不需要返回新对象，而从其他地方获取时（如缓存），使用工厂构造函数。**工厂构造函数内无法访问<code>this</code>**。调用时方式和普通构造函数等同。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to the _ in front</span></span><br><span class=\"line\">  <span class=\"comment\">// of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = <span class=\"keyword\">new</span> Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> logger = <span class=\"keyword\">new</span> Logger(<span class=\"string\">&#x27;UI&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>类方法可以访问<code>this</code>，另外对于类对象的每个属性都有隐含的getter和setter（final除外）。也可以显式使用<code>get</code>和<code>set</code>定义getter和setter的行为。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> left;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> top;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\">  Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Define two calculated properties: right and bottom.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right             =&gt; left + width;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value)  =&gt; left = value - width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom            =&gt; top + height;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Dart使用<code>extends</code>继承，用<code>super</code>指代父类，用<code>@overide</code>注解重载操作。</li>\n<li>Dart中有抽象类&#x2F;抽象方法，设计和使用类似Java的抽象类&#x2F;抽象方法。如果你希望抽象类可实例化，可以定义一个工厂工造函数。</li>\n<li>每个类都隐式的定义了一个包含所有实例成员的接口，通过使用<code>implement</code>实现若干其他类的API（不包括构造函数）</li>\n<li>可以重载一些操作符，如<code>+</code>, <code>-</code>, <code>[]</code>, <code>&gt;&gt;</code>等，实现在特定类上的特定表现</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Vector(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">Overrides + (a + b).</span></span></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> +(Vector v) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vector(x + v.x, y + v.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">Overrides - (a - b).</span></span></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> -(Vector v) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vector(x - v.x, y - v.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有意思的是，Dart提供<code>noSuchMethod()</code>方法，在访问不存在的类实例或方法时被调用。如果没有填写，默认使用Object的同名方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@proxy</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">  void noSuchMethod(Invocation inv) &#123;</span><br><span class=\"line\">     print(&#x27;You tried to use a non-existent member: &#x27; +</span><br><span class=\"line\">        &#x27;$&#123;inv.memberName&#125;&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举是特殊的类，使用<code>enum</code>关键字定义。每个枚举值都有index属性的<code>getter</code>函数，枚举的<code>values</code>常量可以返回所有枚举值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; red, green, blue &#125;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(Color.red.index == <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(colors[<span class=\"number\">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h3><p>Dart中提供了<strong>多类继承</strong>中重用类代码的mixin，用<code>with</code>结合mixin类实现，这种类没有构造函数。除非你想像正常类一样使用mixin，否则使用<code>mixin</code>关键字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mixin</span> Musical &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canPlayPiano = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canCompose = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canConduct = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> entertainMe() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canPlayPiano) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Playing piano&#x27;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (canConduct) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Waving hands&#x27;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Humming to self&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当限制mixin只在特定类中使用时，结合<code>on</code>让mixin也能调用父类方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mixin</span> MusicalPerformer <span class=\"keyword\">on</span> Musician &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类变量、函数\"><a href=\"#类变量、函数\" class=\"headerlink\" title=\"类变量、函数\"></a>类变量、函数</h3><p>使用<code>static</code>前缀修饰，表示类级别的变量、函数。类变量只在第一次使用时初始化。静态方法无法访问this。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>使用泛型的两个动机：</p>\n<ul>\n<li>有助于IDE、环境、同事帮你定位问题和代码自动生成</li>\n<li>减少重复代码</li>\n</ul>\n<p>List和Map的泛型定义类似C++风格。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = &lt;<span class=\"built_in\">String</span>&gt;[<span class=\"string\">&#x27;Seth&#x27;</span>, <span class=\"string\">&#x27;Kathy&#x27;</span>, <span class=\"string\">&#x27;Lars&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> pages = &lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;index.html&#x27;</span>: <span class=\"string\">&#x27;Homepage&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;robots.txt&#x27;</span>: <span class=\"string\">&#x27;Hints for web robots&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;humans.txt&#x27;</span>: <span class=\"string\">&#x27;We are people, not machines&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\"><span class=\"keyword\">var</span> views = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, View&gt;();</span><br><span class=\"line\"><span class=\"built_in\">print</span>(names <span class=\"keyword\">is</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>在泛型中使用<code>extends</code>可以限制泛型的具体类型。在1.21之后，Dart支持泛型函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first&lt;T&gt;(<span class=\"built_in\">List</span>&lt;T&gt; ts) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...Do some initial work or error checking, then...</span></span><br><span class=\"line\">  T tmp ?= ts[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// ...Do some additional checking or processing...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h2><p>使用<code>import</code>和<code>library</code>引入和导出模块。<code>_</code>开头的标识符只在库内部可见。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;dart:html&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;dart:io&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:mylib/mylib.dart&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:utils/utils.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:lib2/lib2.dart&#x27;</span> <span class=\"keyword\">as</span> lib2;  <span class=\"comment\">// 指定库前缀，避免重名</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:lib1/lib1.dart&#x27;</span> <span class=\"keyword\">show</span> foo; <span class=\"comment\">// 部分导入</span></span><br></pre></td></tr></table></figure>\n\n<p><code>dart:</code>开头代表内置库，<code>package:</code>开头代表外部库。外部库使用<code>pub</code>包管理器管理。</p>\n<h3 id=\"懒加载库\"><a href=\"#懒加载库\" class=\"headerlink\" title=\"懒加载库\"></a>懒加载库</h3><p>懒加载即在使用时再加载库，如优化app启动时间，加载很可能用不到的功能。</p>\n<p>加载时使用<code>deferred as</code>导入，使用<code>loadLibrary()</code>方法加载。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:deferred/hello.dart&#x27;</span> <span class=\"keyword\">deferred</span> <span class=\"keyword\">as</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\">greet() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异步支持\"><a href=\"#异步支持\" class=\"headerlink\" title=\"异步支持\"></a>异步支持</h2><p>Dart中返回<code>Future</code>和<code>Stream</code>的方法都是异步的，意味着设置好耗时操作（I&#x2F;O）后就返回。类似ES7中的<code>await</code>和<code>async</code>，你也可以像组织同步代码一样组织你的异步代码。</p>\n<p>Dart中声明异步方法是<strong>在函数名后加入async</strong>，这类方法返回一个<code>Future</code>对象，了解JS中<code>Promise</code>的同学可以很快理解Future是做什么的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkVersion() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version == expectedVersion) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something.</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something else.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在返回值是Stream时，使用<code>await for</code>的形式接收Stream中的数据。另外别忘了用<code>async</code>修饰外界函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> request <span class=\"keyword\">in</span> requestServer) &#123;</span><br><span class=\"line\">    handleRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成器函数\"><a href=\"#生成器函数\" class=\"headerlink\" title=\"生成器函数\"></a>生成器函数</h2><p>惰性生产数据，类似ES6中的<code>function*</code>。Dart提供两种类型：</p>\n<ul>\n<li>同步：返回Iterator</li>\n<li>异步：返回Stream</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;<span class=\"built_in\">int</span>&gt; naturalsDownFrom(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* naturalsDownFrom(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Stream&lt;<span class=\"built_in\">int</span>&gt; asynchronousNaturalsTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可调用的类\"><a href=\"#可调用的类\" class=\"headerlink\" title=\"可调用的类\"></a>可调用的类</h2><p>类中实现了<code>call()</code>方法时，类实例可以当做方法调用。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">wf(<span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><p>类似typescript中的interface定义，Dart可以借助<code>typedef</code>进行一些更复杂的类型判断。typedef只是类型别名的一种说法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">int</span> Compare(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(sort <span class=\"keyword\">is</span> Compare); <span class=\"comment\">// True!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h2><p>使用元数据给代码添加额外信息，也能便于文档自动生成。</p>\n<ul>\n<li><code>@deprecated</code></li>\n<li><code>@override</code></li>\n<li><code>@proxy</code></li>\n</ul>\n<p>你还可以自定义自己的元数据注解：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">todo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> who;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> what;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> todo(<span class=\"keyword\">this</span>.who, <span class=\"keyword\">this</span>.what);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// another file</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;todo.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@todo</span>(<span class=\"string\">&#x27;seth&#x27;</span>, <span class=\"string\">&#x27;make this do something&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;do something&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>单行，<code>//</code></li>\n<li>多行，<code>/**/</code></li>\n<li>文档注释， <code>///</code>开头，或<code>/**</code>开头，<code>*/</code>结束</li>\n</ul>\n<p>遵守规范的注释风格会有助于文档自动生成。</p>\n",
            "tags": [
                "Dart"
            ]
        },
        {
            "id": "http://shenlvmeng.github.com/blog/2017/10/13/css-definitive-guide-content/",
            "url": "http://shenlvmeng.github.com/blog/2017/10/13/css-definitive-guide-content/",
            "title": "《CSS权威指南》脉络",
            "date_published": "2017-10-13T05:56:33.000Z",
            "content_html": "<h3 id=\"CSS和文档\"><a href=\"#CSS和文档\" class=\"headerlink\" title=\"CSS和文档\"></a>CSS和文档</h3><ul>\n<li><p>CSS的出现和特点</p>\n</li>\n<li><p><code>&lt;link&gt;</code>、<code>&lt;style&gt;</code>和<code>@import</code></p>\n</li>\n<li><p>CSS注释</p>\n</li>\n<li><p>内联样式</p>\n</li>\n<li><p><code>@import</code>必须写在CSS文档的开头</p>\n</li>\n</ul>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><ul>\n<li><p>基本结构</p>\n</li>\n<li><p>元素选择器（分组选择器、通配选择器）</p>\n</li>\n<li><p>类选择器&#x2F;ID选择器</p>\n</li>\n<li><p>属性选择器（具体属性、部分属性）</p>\n</li>\n<li><p>后代选择器、兄弟选择器（<code>&gt;</code>, <code>+</code>）</p>\n</li>\n<li><p>伪类&#x2F;伪元素选择器</p>\n</li>\n<li><p><code>^=</code>, <code>$=</code>, <code>~=</code>, <code>*=</code>, <code>|=</code>用在属性选择中的部分匹配里，eg：<code>span[class~=&quot;bar&quot;]</code>，<br>其中<code>~=</code>匹配空格隔开的字符，<code>*=</code>匹配部分字符串，<code>|=</code>匹配完整字符串或以字符串开头</p>\n</li>\n<li><p>常用的伪类选择器有</p>\n<ul>\n<li><code>:link</code> 拥有<code>href</code>属性的<strong>未访问</strong>地址</li>\n<li><code>:visited</code></li>\n<li><code>:focus</code> 当前获得输入焦点的元素</li>\n<li><code>:hover</code></li>\n<li><code>:active</code> 被用户激活的元素</li>\n<li><code>:first-child</code> 第一个子元素，类似地还有<code>:last-child</code>和<code>nth-child()</code></li>\n<li><code>:lang()</code> 根据语言选择</li>\n<li><code>:first-letter</code>和<code>first-line</code>针对元素第一个字母和第一行文本</li>\n<li><code>:before</code>和<code>:after</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"层叠关系\"><a href=\"#层叠关系\" class=\"headerlink\" title=\"层叠关系\"></a>层叠关系</h3><ul>\n<li><p>优先级顺序（ID &gt; 类、属性、伪类 &gt; 元素、伪元素 &gt; 通配或结合符<code>,</code> &gt; 继承的属性）</p>\n</li>\n<li><p>内联样式和<code>!important</code>的特殊性</p>\n</li>\n<li><p>继承</p>\n</li>\n<li><p>层叠规则</p>\n</li>\n<li><p>来源权重关系（读者重要声明 &gt; 创作者的重要声明 &gt; 创作者正常声明 &gt; 读者正常声明 &gt; 用户代理声明）</p>\n</li>\n<li><p>LVHA（<code>:link</code> - <code>:visited</code> - <code>:hover</code> - <code>:active</code>的声明顺序）</p>\n</li>\n<li><p>一个声明出现的越后，它的权重越大</p>\n</li>\n</ul>\n<h3 id=\"值和单位\"><a href=\"#值和单位\" class=\"headerlink\" title=\"值和单位\"></a>值和单位</h3><ul>\n<li><p>数字</p>\n</li>\n<li><p>百分数</p>\n</li>\n<li><p>颜色（具名、rgb&#x2F;rgba、十六进制）、Web安全颜色</p>\n</li>\n<li><p>长度单位（in&#x2F;cm&#x2F;mm&#x2F;pt&#x2F;pc&#x2F;px，em&#x2F;ex&#x2F;rem&#x2F;vw&#x2F;vh&#x2F;vmin&#x2F;vmax）</p>\n</li>\n<li><p>URL（<code>url(protocol://server/pathname)</code>或<code>url(pathname)</code>）</p>\n</li>\n<li><p>关键字</p>\n</li>\n<li><p>角度&#x2F;时间&#x2F;频率</p>\n</li>\n<li><p>CSS2.1中有一个所有属性共有的关键字：<code>inherit</code></p>\n</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><ul>\n<li><p>通用字体（serif&#x2F;sans-serif&#x2F;monospace&#x2F;cursive&#x2F;fantasy）</p>\n</li>\n<li><p>指定字体</p>\n</li>\n<li><p>字体加粗（100~900，lighter&#x2F;bolder）</p>\n</li>\n<li><p>字体大小（xx-small ~ xx-large；绝对大小；百分数）</p>\n</li>\n<li><p>字体风格和变形（font-style，font-variant）</p>\n</li>\n<li><p><code>font</code>属性（<code>[&lt;font-style&gt; || &lt;font-variant&gt; || &lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;</code>）</p>\n</li>\n<li><p><code>font-face</code>规则（<code>font-family</code>，<code>font-style</code>，<code>src</code>等）</p>\n</li>\n<li><p>衬线字体包括Times，Georgia；非衬线字体包括Helvetiva，Geneva，Verdana，Arial；Monospace字体包括Courier，Courier New</p>\n</li>\n<li><p>字体名称中包含空格或特殊字符时，建议用引号包裹</p>\n</li>\n<li><p>一般地，400对应normal，700对应bold</p>\n</li>\n<li><p>字体大小是可以继承的，不过继承的是计算值而不是百分数</p>\n</li>\n<li><p><code>italic</code>是单独的字体风格，<code>oblique</code>则是正常文本的倾斜版本</p>\n</li>\n<li><p><code>small-caps</code>表示小型大写字母</p>\n</li>\n</ul>\n<h3 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h3><ul>\n<li><p>缩进（<code>text-indent</code>）</p>\n</li>\n<li><p>水平对齐（<code>text-align</code>）</p>\n</li>\n<li><p>垂直对齐（<code>line-height</code>和<code>vertical-align</code>）</p>\n</li>\n<li><p>字间隔和字母间隔（<code>word-spacing</code>和<code>letter-spacing</code>）</p>\n</li>\n<li><p>文本转换（<code>text-transfrom</code>）</p>\n</li>\n<li><p>文本装饰（<code>text-decoration</code>）</p>\n</li>\n<li><p>文本阴影（<code>text-shadow</code>）</p>\n</li>\n<li><p>空白符处理（<code>white-space</code>）</p>\n</li>\n<li><p>文本方向（<code>direction</code>和<code>unicode-bidi</code>）</p>\n</li>\n<li><p><code>text-indent</code>为负值时表示悬挂缩进效果</p>\n</li>\n<li><p><code>line-height</code>有继承性，表示文本基线（baseline）间的距离，继承的仍然是计算值</p>\n</li>\n<li><p>行内元素的行框由行间距和内容区组成</p>\n</li>\n<li><p><code>vertical-align</code>只应用于行内元素、替换元素和单元格，且不能继承。它可以取百分数和长度值，相对于自身line-height计算。</p>\n<ul>\n<li>在基线对齐时，将元素的<strong>底部</strong>和行框的基线对齐</li>\n<li>取值为<code>sub</code>或<code>super</code>时，元素的基线（或底端）将升高或降低</li>\n<li>取值<code>bottom</code>或<code>top</code>时，相对行框的顶端和底端</li>\n<li>取值为<code>middle</code>时，会把行内元素的中点与行框基线上方0.5ex（约为0.25em，因x-height而异）处对齐</li>\n<li>取值为数值时，会相对于父元素行框基线升高<br>最后，父元素的行框的行高会因此做调整</li>\n</ul>\n</li>\n<li><p><code>text-transform</code>有<code>uppercase</code>, <code>lowercase</code>, <code>capitalize</code>等几种选择，有继承性</p>\n</li>\n<li><p><code>text-decoration</code>有<code>underline</code>, <code>overline</code>, <code>line-through</code>, <code>blink</code>等几种选择，没有继承性</p>\n</li>\n<li><p><code>text-shadow</code>先确定阴影颜色，前两个长度值确定偏移距离，第三个值确定模糊半径，可以同时设置多个阴影效果</p>\n</li>\n<li><p><code>white-space</code>行为如下表</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>空白符</th>\n<th>换行符</th>\n<th>自动换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pre-line</td>\n<td>合并</td>\n<td>保留</td>\n<td>允许</td>\n</tr>\n<tr>\n<td>normal</td>\n<td>合并</td>\n<td>忽略</td>\n<td>允许</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>忽略</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>允许</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><ul>\n<li><p>基本框与包含块</p>\n</li>\n<li><p>正常流&#x2F;非替换元素&#x2F;替换元素&#x2F;块级元素&#x2F;行内元素</p>\n</li>\n<li><p>水平属性（<code>width</code>，<code>margin/border/padding-left/right</code>）</p>\n</li>\n<li><p>垂直属性（<code>height</code>，<code>margin/border/padding-top/bottom</code>）</p>\n</li>\n<li><p>行内元素（em框、内容区、行间距、行内框、行框）</p>\n</li>\n<li><p>元素的显示方式（<code>display</code>，<code>inline-block</code>和<code>run-in</code>）</p>\n</li>\n<li><p>在水平属性中只有<code>width</code>和外边距可以设置为<code>auto</code>，其余属性必须设置为特定的值或默认为0。使用<code>auto</code>将会弥补实际值和所需总和的差距，当格式化属性过度受限时，会强制把<code>margin-right</code>设置为<code>auto</code>。相反，不止一个<code>auto</code>出现时，若<code>width</code>不为<code>auto</code>，则会将元素居中，出现三个<code>auto</code>时，外边距都会设置为0。</p>\n</li>\n<li><p>垂直属性类似上面，不一样的是，元素间的外边距会合并，留下较大的外边距。</p>\n</li>\n<li><p>对于非替换元素，元素行内框高度等于<code>line-height</code>的值；对于替换元素，则由内容区高度决定</p>\n</li>\n<li><p>行内元素的边框边界由<code>font-size</code>决定，与<code>line-height</code>无关。类似，内外边距不会影响行框的形成和布局。</p>\n</li>\n<li><p>行内替换元素并没有自己的基线，所以说相对较好的方案是将其行内框底部和基线对齐。</p>\n</li>\n<li><p><code>inline-block</code>元素的<code>width</code>未定义或声明为<code>auto</code>时，元素会收缩来适应到框宽度刚好足够包含该内容</p>\n</li>\n</ul>\n<h3 id=\"边距和边框\"><a href=\"#边距和边框\" class=\"headerlink\" title=\"边距和边框\"></a>边距和边框</h3><ul>\n<li><p>基本元素框</p>\n</li>\n<li><p>外边距（负外边距和垂直外边距合并）</p>\n</li>\n<li><p>行内元素的外边距</p>\n</li>\n<li><p>边框</p>\n</li>\n<li><p>内边距</p>\n</li>\n<li><p>行内元素的内边距</p>\n</li>\n<li><p>外边距的空白不能放置其他元素</p>\n</li>\n<li><p>内外边距设置为百分数时，相对于父元素的<strong>宽度</strong>计算，这样做是为了避免高度上导致无限循环</p>\n</li>\n<li><p>对于行内元素，只有<code>line-height</code>，<code>font-size</code>和<code>vertical-align</code>可以改变元素行高，为替换元素设置的外边距会影响行高</p>\n</li>\n<li><p>边框的默认属性为<code>none medium &lt;color&gt;</code></p>\n</li>\n<li><p>元素的背景会延伸到内边距</p>\n</li>\n<li><p>左内&#x2F;外边距应用到行内元素开始处，右内&#x2F;外边距应用到行内元素结束处</p>\n</li>\n</ul>\n<h3 id=\"背景与颜色\"><a href=\"#背景与颜色\" class=\"headerlink\" title=\"背景与颜色\"></a>背景与颜色</h3><ul>\n<li><p>前景色（<code>color</code>）</p>\n</li>\n<li><p>背景色</p>\n</li>\n<li><p>背景图片</p>\n</li>\n<li><p>背景重复、背景定位（<code>background-position</code>）</p>\n</li>\n<li><p>背景大小（<code>background-size</code>，CSS3新增）</p>\n</li>\n<li><p>一般来说，前景包括元素的<strong>文本和边框</strong></p>\n</li>\n<li><p>前景色属性可以继承</p>\n</li>\n<li><p><strong>所有背景属性都不可继承</strong></p>\n</li>\n<li><p>背景图像放在指定的背景色之上</p>\n</li>\n<li><p><code>background</code>简写属性为<code>background-color || background-image || background-repeat || background-attachment || background-position</code></p>\n</li>\n</ul>\n<h3 id=\"浮动和定位\"><a href=\"#浮动和定位\" class=\"headerlink\" title=\"浮动和定位\"></a>浮动和定位</h3><ul>\n<li><p>浮动元素</p>\n</li>\n<li><p>浮动定位规则</p>\n</li>\n<li><p>浮动行为和浮动内容的的重叠</p>\n</li>\n<li><p>清除（<code>clear</code>）</p>\n</li>\n<li><p>定位类型（<code>position</code>）</p>\n</li>\n<li><p>宽高限制（<code>max/min-width</code>和<code>max/min-height</code>）</p>\n</li>\n<li><p>内容溢出（<code>overflow</code>和<code>clip</code>）</p>\n</li>\n<li><p>元素可见性（<code>visibility</code>）</p>\n</li>\n<li><p>绝对定位、固定定位、相对定位</p>\n</li>\n<li><p><code>z-index</code></p>\n</li>\n<li><p>浮动元素的外边距不会合并</p>\n</li>\n<li><p>浮动的非替换元素需要指定<code>width</code>，否则宽度将趋于0</p>\n</li>\n<li><p>浮动元素的包含块为距离最近的块级祖先元素</p>\n</li>\n<li><p>行内框和浮动元素重叠时，边框和内容都在浮动内容之上；块级元素重叠时，内容在之上，边框和背景在之下显示</p>\n</li>\n<li><p><code>clear</code>只应用于块级元素，清除区域不允许浮动元素进入</p>\n</li>\n<li><p><code>absolute</code>元素会形成一个块级框</p>\n</li>\n<li><p><code>top</code>等属性应用在<code>absolute</code>元素时，描述其距离<strong>外边距边界</strong>的距离</p>\n</li>\n<li><p>可以通过<code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code>这样的定位信息确定绝对定位元素的内容区大小</p>\n</li>\n<li><p><code>clip</code>通过<code>rect(top,right,bottom,left)</code>确定绝对定位元素的剪裁区域</p>\n</li>\n<li><p>绝对定位元素的静态位置为其<code>position</code>为<code>static</code>时的位置</p>\n</li>\n<li><p>对于绝对定位元素，垂直方向或水平方向设置<code>auto</code>可以垂直或水平居中</p>\n</li>\n<li><p>对于相对定位，如遇到过度受限的情况，一个值会设置为另一个的相反数，保证自洽。</p>\n</li>\n</ul>\n<h3 id=\"表布局\"><a href=\"#表布局\" class=\"headerlink\" title=\"表布局\"></a>表布局</h3><ul>\n<li><p>表显示值（即相关<code>display</code>）</p>\n</li>\n<li><p>以行为主</p>\n</li>\n<li><p>匿名表对象插入法则</p>\n</li>\n<li><p>表标题</p>\n</li>\n<li><p>表单元格（<code>border-collapse</code>, <code>border-spacing</code>, <code>empty-cells</code>）</p>\n</li>\n<li><p>单元格边框合并</p>\n</li>\n<li><p>表大小（<code>table-layout</code>, 高度, 对齐）</p>\n</li>\n<li><p>CSS的列和列组只能接受<code>border</code>，<code>background</code>，<code>width</code>，<code>visibility</code>四种属性</p>\n</li>\n<li><p>单元格垂直对齐有4种可选值，<code>top</code>, <code>bottom</code>, <code>middle</code>, <code>baseline</code></p>\n</li>\n</ul>\n<h3 id=\"列表和生成内容\"><a href=\"#列表和生成内容\" class=\"headerlink\" title=\"列表和生成内容\"></a>列表和生成内容</h3><ul>\n<li><p>列表类型、列表项图像、列表标志位置</p>\n</li>\n<li><p>插入生成内容（<code>content</code>，<code>attr(xxx)</code>, <code>quote</code>）</p>\n</li>\n<li><p>计数器（<code>counter-reset</code>, <code>counter-increment</code>）</p>\n</li>\n<li><p>列表样式可以简写为<code>&lt;list-style-type&gt; | &lt;list-style-image&gt; | &lt;list-style-position&gt;</code></p>\n</li>\n<li><p>在<code>quote</code>属性里指定开闭字符串后，可以通过content，结合<code>:before</code>，<code>:after</code>伪类插入开闭quote的标记</p>\n</li>\n</ul>\n<h3 id=\"用户界面样式\"><a href=\"#用户界面样式\" class=\"headerlink\" title=\"用户界面样式\"></a>用户界面样式</h3><ul>\n<li><p>系统字体（如<code>caption</code>等）</p>\n</li>\n<li><p>系统颜色（已废弃）</p>\n</li>\n<li><p>光标（<code>cursor</code>）</p>\n</li>\n<li><p>轮廓（<code>outline</code>）</p>\n</li>\n<li><p><code>cursor</code>有下面一些常见的值</p>\n<ul>\n<li><code>pointer</code> 用在超链接上</li>\n<li><code>text</code> 用来纯文本上</li>\n<li><code>move</code> 用来指示目标可以被拖动，相关的还有<code>e-resize</code>, <code>ne-resize</code>, <code>se-resize</code>等边缘的拖动标记</li>\n<li><code>crosshair</code> 用来指示可以选取范围，类似截屏的光标效果</li>\n<li><code>wait</code> 显示等待标记</li>\n<li><code>progress</code> 指示等待的状态，同时表示可以进行其他操作</li>\n<li><code>help</code> 显示帮助光标</li>\n<li><code>url()</code> 自定义光标图像，建议设置缺省值</li>\n</ul>\n</li>\n<li><p><code>outline</code>的设置类似<code>border</code>，由<code>outline-color</code>, <code>outline-style</code>, <code>outline-width</code>组成</p>\n</li>\n</ul>\n<h3 id=\"非屏幕媒体\"><a href=\"#非屏幕媒体\" class=\"headerlink\" title=\"非屏幕媒体\"></a>非屏幕媒体</h3><ul>\n<li><p>分页媒体（<code>size</code>和<code>page</code>等）</p>\n</li>\n<li><p>投影样式</p>\n</li>\n<li><p>声音样式（<code>speak</code>，<code>stress</code>，<code>richness</code>等）</p>\n</li>\n<li><p>可以在<code>&lt;link&gt;</code>标签的<code>media</code>属性里指定媒体类型，或是在CSS文件中通过<code>@media xxx &#123;&#125;</code>的形式指定</p>\n</li>\n</ul>\n",
            "tags": [
                "读书笔记",
                "CSS",
                "盒模型",
                "浮动"
            ]
        }
    ]
}